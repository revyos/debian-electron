--- a/third_party/ffmpeg/CREDITS.chromium
+++ b/third_party/ffmpeg/CREDITS.chromium
@@ -336,74 +336,6 @@
 
 ********************************************************************************
 
-libswresample/swresample.h
-
-Copyright (C) 2011-2013 Michael Niedermayer (michaelni@gmx.at)
-
-This file is part of libswresample
-
-libswresample is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-libswresample is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with libswresample; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
-
-********************************************************************************
-
-libswresample/version.h
-
-Version macros.
-
-This file is part of libswresample
-
-libswresample is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-libswresample is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with libswresample; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
-
-********************************************************************************
-
-libswresample/version_major.h
-
-Version macros.
-
-This file is part of libswresample
-
-libswresample is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-libswresample is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with libswresample; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
-
-********************************************************************************
-
-libavcodec/jfdctfst.c
-libavcodec/jfdctint_template.c
 libavcodec/jrevdct.c
 
 This file is part of the Independent JPEG Group's software.
--- a/third_party/ffmpeg/Changelog
+++ b/third_party/ffmpeg/Changelog
@@ -14,6 +14,10 @@
 - bonk decoder and demuxer
 - Micronas SC-4 audio decoder
 - LAF demuxer
+- APAC decoder and demuxer
+- Media 100i decoders
+- DTS to PTS reorder bsf
+- ViewQuest VQC decoder
 
 
 version 5.1:
--- a/third_party/ffmpeg/MAINTAINERS
+++ b/third_party/ffmpeg/MAINTAINERS
@@ -11,17 +11,11 @@
 patches and related discussions.
 
 
-Project Leader
-==============
-
-  final design decisions
-
-
 Applications
 ============
 
 ffmpeg:
-  ffmpeg.c                              Michael Niedermayer
+  ffmpeg.c                              Michael Niedermayer, Anton Khirnov
 
 ffplay:
   ffplay.c                              Marton Balint
--- a/third_party/ffmpeg/Makefile
+++ b/third_party/ffmpeg/Makefile
@@ -91,7 +91,7 @@
 SUBDIR_VARS := CLEANFILES FFLIBS HOSTPROGS TESTPROGS TOOLS               \
                HEADERS ARCH_HEADERS BUILT_HEADERS SKIPHEADERS            \
                ARMV5TE-OBJS ARMV6-OBJS ARMV8-OBJS VFP-OBJS NEON-OBJS     \
-               ALTIVEC-OBJS VSX-OBJS MMX-OBJS X86ASM-OBJS                \
+               ALTIVEC-OBJS VSX-OBJS RVV-OBJS MMX-OBJS X86ASM-OBJS       \
                MIPSFPU-OBJS MIPSDSPR2-OBJS MIPSDSP-OBJS MSA-OBJS         \
                MMI-OBJS LSX-OBJS LASX-OBJS OBJS SLIBOBJS SHLIBOBJS       \
                STLIBOBJS HOSTOBJS TESTOBJS
--- a/third_party/ffmpeg/README.chromium
+++ b/third_party/ffmpeg/README.chromium
@@ -3,7 +3,7 @@
 License: LGPL 2.1
 License File: CREDITS.chromium
 Upstream Git: git://source.ffmpeg.org/ffmpeg.git
-Last Upstream Merge: 48615f0a7861fd1c24195f74856f68e06c7ca73c, Sep 22 2022
+Last Upstream Merge: cb803a0072cb98945dcd3f1660bd2a975650ce42, Oct 27 2022
 This file documents the layout of the Chromium copy of FFmpeg, some common
 tasks, and how to create the build files and related configurations.
 
--- a/third_party/ffmpeg/chromium/config/Chrome/android/arm-neon/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/arm-neon/config.h
@@ -1,7 +1,7 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/arm-linux-androideabi --extra-cflags='--target=arm-linux-androideabi23' --extra-ldflags='--target=arm-linux-androideabi23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/arm-linux-androideabi --extra-ldflags='--gcc-toolchain=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-neon --extra-cflags='-mtune=generic-armv7-a' --extra-cflags='-mfloat-abi=softfp' --extra-cflags='-mfpu=neon' --enable-demuxer=aac --enable-parser=aac --enable-decoder=aac" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/arm-linux-androideabi --extra-cflags='--target=arm-linux-androideabi23' --extra-ldflags='--target=arm-linux-androideabi23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/arm-linux-androideabi --extra-ldflags='--gcc-toolchain=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-neon --extra-cflags='-mtune=generic-armv7-a' --extra-cflags='-mfloat-abi=softfp' --extra-cflags='-mfpu=neon' --enable-demuxer=aac --enable-parser=aac --enable-decoder=aac" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 0 /* #define HAVE_POSIX_MEMALIGN 1 -- forced to 0. See https://crbug.com/604451 */
+#define HAVE_PRCTL 1
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/android/arm-neon/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/arm-neon/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/android/arm-neon/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/arm-neon/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/android/arm64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/arm64/config.h
@@ -1,7 +1,7 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/aarch64-linux-android --extra-cflags='--target=aarch64-linux-android23' --extra-ldflags='--target=aarch64-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/aarch64-linux-android --extra-ldflags='--gcc-toolchain=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a' --enable-demuxer=aac --enable-parser=aac --enable-decoder=aac" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/aarch64-linux-android --extra-cflags='--target=aarch64-linux-android23' --extra-ldflags='--target=aarch64-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/aarch64-linux-android --extra-ldflags='--gcc-toolchain=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a' --enable-demuxer=aac --enable-parser=aac --enable-decoder=aac" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 0 /* #define HAVE_POSIX_MEMALIGN 1 -- forced to 0. See https://crbug.com/604451 */
+#define HAVE_PRCTL 1
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/android/arm64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/arm64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/android/arm64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/arm64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/android/ia32/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/ia32/config.h
@@ -1,7 +1,7 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/i686-linux-android --extra-cflags='--target=i686-linux-android23' --extra-ldflags='--target=i686-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/i686-linux-android --extra-ldflags='--gcc-toolchain=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --disable-x86asm --enable-demuxer=aac --enable-parser=aac --enable-decoder=aac" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/i686-linux-android --extra-cflags='--target=i686-linux-android23' --extra-ldflags='--target=i686-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/i686-linux-android --extra-ldflags='--gcc-toolchain=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --disable-x86asm --enable-demuxer=aac --enable-parser=aac --enable-decoder=aac" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 0 /* #define HAVE_POSIX_MEMALIGN 1 -- forced to 0. See https://crbug.com/604451 */
+#define HAVE_PRCTL 1
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/android/ia32/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/ia32/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/android/ia32/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/ia32/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/android/x64/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/x64/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 1
 %define HAVE_PTHREAD_CANCEL 0
 %define HAVE_SCHED_GETAFFINITY 1
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/android/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/x64/config.h
@@ -1,7 +1,7 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/x86_64-linux-android --extra-cflags='--target=x86_64-linux-android23' --extra-ldflags='--target=x86_64-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/x86_64-linux-android --extra-ldflags='--gcc-toolchain=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=x86_64 --enable-demuxer=aac --enable-parser=aac --enable-decoder=aac" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/x86_64-linux-android --extra-cflags='--target=x86_64-linux-android23' --extra-ldflags='--target=x86_64-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/x86_64-linux-android --extra-ldflags='--gcc-toolchain=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=x86_64 --enable-demuxer=aac --enable-parser=aac --enable-decoder=aac" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 0 /* #define HAVE_POSIX_MEMALIGN 1 -- forced to 0. See https://crbug.com/604451 */
+#define HAVE_PRCTL 1
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/android/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/android/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/android/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/linux-noasm/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux-noasm/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --disable-asm --disable-inline-asm --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --arch=x86_64 --target-os=linux --disable-asm --disable-inline-asm --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux-noasm/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux-noasm/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux-noasm/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux-noasm/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/arm-neon/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/arm-neon/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/chromium/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --enable-neon --extra-cflags='-mfpu=neon' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --enable-neon --extra-cflags='-mfpu=neon' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/arm-neon/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/arm-neon/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/arm-neon/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/arm-neon/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/chromium/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --disable-neon --extra-cflags='-mfpu=vfpv3-d16' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --disable-neon --extra-cflags='-mfpu=vfpv3-d16' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/arm/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/arm/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/arm64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/arm64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-cross-compile --cross-prefix=/usr/bin/aarch64-linux-gnu- --target-os=linux --extra-cflags='--target=aarch64-linux-gnu' --extra-ldflags='--target=aarch64-linux-gnu' --sysroot=/chromium/src/build/linux/debian_bullseye_arm64-sysroot --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-cross-compile --cross-prefix=/usr/bin/aarch64-linux-gnu- --extra-cflags='--target=aarch64-linux-gnu' --extra-ldflags='--target=aarch64-linux-gnu' --target-os=linux --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/build/linux/debian_bullseye_arm64-sysroot --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/arm64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/arm64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/arm64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/arm64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/ia32/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/ia32/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 1
 %define HAVE_PTHREAD_CANCEL 1
 %define HAVE_SCHED_GETAFFINITY 1
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/ia32/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/ia32/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/ia32/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/ia32/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/ia32/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/ia32/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/x64/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/x64/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 1
 %define HAVE_PTHREAD_CANCEL 1
 %define HAVE_SCHED_GETAFFINITY 1
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --arch=x86_64 --target-os=linux --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/linux/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/mac/arm64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/mac/arm64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-cross-compile --cc=clang --ld=ld64.lld --nm=llvm-nm --ar=llvm-ar --target-os=darwin --extra-cflags='--target=arm64-apple-macosx' --extra-cflags=-F/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks --extra-cflags='-mmacosx-version-min=10.10' --extra-cflags=-fblocks --extra-cflags=-nostdinc --extra-cflags=-isystem/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include --extra-cflags=-isystem/chromium/src/third_party/llvm-build/Release+Asserts/lib/clang/16.0.0/include --extra-ldflags=-syslibroot --extra-ldflags=/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk --extra-ldflags=-L/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib --extra-ldflags=-lSystem --extra-ldflags=-macosx_version_min --extra-ldflags=10.10 --extra-ldflags=-sdk_version --extra-ldflags=10.10 --extra-ldflags=-platform_version --extra-ldflags=macos --extra-ldflags=10.10 --extra-ldflags=10.10 --arch=arm64 --extra-cflags='-arch arm64' --extra-ldflags='-arch arm64' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-cross-compile --cc=clang --ld=ld64.lld --nm=llvm-nm --ar=llvm-ar --target-os=darwin --extra-cflags='--target=arm64-apple-macosx' --extra-cflags=-F/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks --extra-cflags='-mmacosx-version-min=10.10' --extra-cflags=-fblocks --extra-cflags=-nostdinc --extra-cflags=-isystem/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include --extra-cflags=-isystem/usr/local/google/home/liberato/src/release_chrome/src/third_party/llvm-build/Release+Asserts/lib/clang/16.0.0/include --extra-ldflags=-syslibroot --extra-ldflags=/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib --extra-ldflags=-lSystem --extra-ldflags=-macosx_version_min --extra-ldflags=10.10 --extra-ldflags=-sdk_version --extra-ldflags=10.10 --extra-ldflags=-platform_version --extra-ldflags=macos --extra-ldflags=10.10 --extra-ldflags=10.10 --arch=arm64 --extra-cflags='-arch arm64' --extra-ldflags='-arch arm64' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME darwin
 #define av_restrict restrict
 #define EXTERN_PREFIX "_"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/mac/arm64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/mac/arm64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/mac/arm64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/mac/arm64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/mac/x64/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chrome/mac/x64/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 0
 %define HAVE_PTHREAD_CANCEL 1
 %define HAVE_SCHED_GETAFFINITY 0
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/mac/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/mac/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-cross-compile --cc=clang --ld=ld64.lld --nm=llvm-nm --ar=llvm-ar --target-os=darwin --extra-cflags='--target=x86_64-apple-macosx' --extra-cflags=-F/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks --extra-cflags='-mmacosx-version-min=10.10' --extra-cflags=-fblocks --extra-cflags=-nostdinc --extra-cflags=-isystem/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include --extra-cflags=-isystem/chromium/src/third_party/llvm-build/Release+Asserts/lib/clang/16.0.0/include --extra-ldflags=-syslibroot --extra-ldflags=/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk --extra-ldflags=-L/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib --extra-ldflags=-lSystem --extra-ldflags=-macosx_version_min --extra-ldflags=10.10 --extra-ldflags=-sdk_version --extra-ldflags=10.10 --extra-ldflags=-platform_version --extra-ldflags=macos --extra-ldflags=10.10 --extra-ldflags=10.10 --arch=x86_64 --extra-cflags=-m64 --extra-ldflags='-arch x86_64' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-cross-compile --cc=clang --ld=ld64.lld --nm=llvm-nm --ar=llvm-ar --target-os=darwin --extra-cflags='--target=x86_64-apple-macosx' --extra-cflags=-F/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks --extra-cflags='-mmacosx-version-min=10.10' --extra-cflags=-fblocks --extra-cflags=-nostdinc --extra-cflags=-isystem/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include --extra-cflags=-isystem/usr/local/google/home/liberato/src/release_chrome/src/third_party/llvm-build/Release+Asserts/lib/clang/16.0.0/include --extra-ldflags=-syslibroot --extra-ldflags=/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib --extra-ldflags=-lSystem --extra-ldflags=-macosx_version_min --extra-ldflags=10.10 --extra-ldflags=-sdk_version --extra-ldflags=10.10 --extra-ldflags=-platform_version --extra-ldflags=macos --extra-ldflags=10.10 --extra-ldflags=10.10 --arch=x86_64 --extra-cflags=-m64 --extra-ldflags='-arch x86_64' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME darwin
 #define av_restrict restrict
 #define EXTERN_PREFIX "_"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/mac/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/mac/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/mac/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/mac/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/win/arm64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/arm64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/chromium/src/third_party/ffmpeg/chromium/include/win --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --arch=aarch64 --as=clang-cl --extra-cflags='--target=arm64-windows' --extra-cflags=/winsysroot/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/ffmpeg/chromium/include/win --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --arch=aarch64 --as=clang-cl --extra-cflags='--target=arm64-windows' --extra-cflags=/winsysroot/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME win32
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 0
 #define HAVE_PEEKNAMEDPIPE 1
 #define HAVE_POSIX_MEMALIGN 0
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/win/arm64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/arm64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/win/arm64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/arm64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/win/ia32/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/ia32/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 0
 %define HAVE_PEEKNAMEDPIPE 1
 %define HAVE_POSIX_MEMALIGN 0
+%define HAVE_PRCTL 0
 %define HAVE_PTHREAD_CANCEL 0
 %define HAVE_SCHED_GETAFFINITY 0
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/win/ia32/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/ia32/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/chromium/src/third_party/ffmpeg/chromium/include/win --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --extra-cflags=-m32 --extra-cflags=/winsysroot/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/ffmpeg/chromium/include/win --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --extra-cflags=-m32 --extra-cflags=/winsysroot/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME win32
 #define av_restrict restrict
 #define EXTERN_PREFIX "_"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 0
 #define HAVE_PEEKNAMEDPIPE 1
 #define HAVE_POSIX_MEMALIGN 0
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/win/ia32/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/ia32/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/win/ia32/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/ia32/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chrome/win/x64/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/x64/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 0
 %define HAVE_PEEKNAMEDPIPE 1
 %define HAVE_POSIX_MEMALIGN 0
+%define HAVE_PRCTL 0
 %define HAVE_PTHREAD_CANCEL 0
 %define HAVE_SCHED_GETAFFINITY 0
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/win/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/chromium/src/third_party/ffmpeg/chromium/include/win --target-os=win64 --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --extra-cflags=/winsysroot/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/ffmpeg/chromium/include/win --target-os=win64 --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --extra-cflags=/winsysroot/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME win64
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 0
 #define HAVE_PEEKNAMEDPIPE 1
 #define HAVE_POSIX_MEMALIGN 0
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chrome/win/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chrome/win/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chrome/win/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux-noasm/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux-noasm/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --disable-asm --disable-inline-asm --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --arch=x86_64 --target-os=linux --disable-asm --disable-inline-asm --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
@@ -669,7 +673,7 @@
 #define CONFIG_EXIF 1
 #define CONFIG_FAANDCT 0
 #define CONFIG_FAANIDCT 0
-#define CONFIG_FDCTDSP 1
+#define CONFIG_FDCTDSP 0
 #define CONFIG_FMTCONVERT 0
 #define CONFIG_FRAME_THREAD_ENCODER 0
 #define CONFIG_G722DSP 0
@@ -713,7 +717,7 @@
 #define CONFIG_MSMPEG4DEC 0
 #define CONFIG_MSMPEG4ENC 0
 #define CONFIG_MSS34DSP 0
-#define CONFIG_PIXBLOCKDSP 1
+#define CONFIG_PIXBLOCKDSP 0
 #define CONFIG_QPELDSP 1
 #define CONFIG_QSV 0
 #define CONFIG_QSVDEC 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux-noasm/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux-noasm/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 1
 #define CONFIG_AMRWB_DECODER 1
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux-noasm/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux-noasm/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm-neon/config.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm-neon/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/chromium/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --enable-neon --extra-cflags='-mfpu=neon' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --enable-neon --extra-cflags='-mfpu=neon' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
@@ -669,7 +673,7 @@
 #define CONFIG_EXIF 1
 #define CONFIG_FAANDCT 0
 #define CONFIG_FAANIDCT 0
-#define CONFIG_FDCTDSP 1
+#define CONFIG_FDCTDSP 0
 #define CONFIG_FMTCONVERT 0
 #define CONFIG_FRAME_THREAD_ENCODER 0
 #define CONFIG_G722DSP 0
@@ -713,7 +717,7 @@
 #define CONFIG_MSMPEG4DEC 0
 #define CONFIG_MSMPEG4ENC 0
 #define CONFIG_MSS34DSP 0
-#define CONFIG_PIXBLOCKDSP 1
+#define CONFIG_PIXBLOCKDSP 0
 #define CONFIG_QPELDSP 1
 #define CONFIG_QSV 0
 #define CONFIG_QSVDEC 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm-neon/config_components.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm-neon/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 1
 #define CONFIG_AMRWB_DECODER 1
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm-neon/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm-neon/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm/config.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/chromium/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --disable-neon --extra-cflags='-mfpu=vfpv3-d16' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --disable-neon --extra-cflags='-mfpu=vfpv3-d16' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
@@ -669,7 +673,7 @@
 #define CONFIG_EXIF 1
 #define CONFIG_FAANDCT 0
 #define CONFIG_FAANIDCT 0
-#define CONFIG_FDCTDSP 1
+#define CONFIG_FDCTDSP 0
 #define CONFIG_FMTCONVERT 0
 #define CONFIG_FRAME_THREAD_ENCODER 0
 #define CONFIG_G722DSP 0
@@ -713,7 +717,7 @@
 #define CONFIG_MSMPEG4DEC 0
 #define CONFIG_MSMPEG4ENC 0
 #define CONFIG_MSS34DSP 0
-#define CONFIG_PIXBLOCKDSP 1
+#define CONFIG_PIXBLOCKDSP 0
 #define CONFIG_QPELDSP 1
 #define CONFIG_QSV 0
 #define CONFIG_QSVDEC 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm/config_components.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 1
 #define CONFIG_AMRWB_DECODER 1
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm64/config.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-cross-compile --cross-prefix=/usr/bin/aarch64-linux-gnu- --target-os=linux --extra-cflags='--target=aarch64-linux-gnu' --extra-ldflags='--target=aarch64-linux-gnu' --sysroot=/chromium/src/build/linux/debian_bullseye_arm64-sysroot --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-cross-compile --cross-prefix=/usr/bin/aarch64-linux-gnu- --extra-cflags='--target=aarch64-linux-gnu' --extra-ldflags='--target=aarch64-linux-gnu' --target-os=linux --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/build/linux/debian_bullseye_arm64-sysroot --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
@@ -669,7 +673,7 @@
 #define CONFIG_EXIF 1
 #define CONFIG_FAANDCT 0
 #define CONFIG_FAANIDCT 0
-#define CONFIG_FDCTDSP 1
+#define CONFIG_FDCTDSP 0
 #define CONFIG_FMTCONVERT 0
 #define CONFIG_FRAME_THREAD_ENCODER 0
 #define CONFIG_G722DSP 0
@@ -713,7 +717,7 @@
 #define CONFIG_MSMPEG4DEC 0
 #define CONFIG_MSMPEG4ENC 0
 #define CONFIG_MSS34DSP 0
-#define CONFIG_PIXBLOCKDSP 1
+#define CONFIG_PIXBLOCKDSP 0
 #define CONFIG_QPELDSP 1
 #define CONFIG_QSV 0
 #define CONFIG_QSVDEC 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 1
 #define CONFIG_AMRWB_DECODER 1
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/arm64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/ia32/config.asm
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/ia32/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 1
 %define HAVE_PTHREAD_CANCEL 1
 %define HAVE_SCHED_GETAFFINITY 1
 %define HAVE_SECITEMIMPORT 0
@@ -653,7 +657,7 @@
 %define CONFIG_EXIF 1
 %define CONFIG_FAANDCT 0
 %define CONFIG_FAANIDCT 0
-%define CONFIG_FDCTDSP 1
+%define CONFIG_FDCTDSP 0
 %define CONFIG_FMTCONVERT 0
 %define CONFIG_FRAME_THREAD_ENCODER 0
 %define CONFIG_G722DSP 0
@@ -697,7 +701,7 @@
 %define CONFIG_MSMPEG4DEC 0
 %define CONFIG_MSMPEG4ENC 0
 %define CONFIG_MSS34DSP 0
-%define CONFIG_PIXBLOCKDSP 1
+%define CONFIG_PIXBLOCKDSP 0
 %define CONFIG_QPELDSP 1
 %define CONFIG_QSV 0
 %define CONFIG_QSVDEC 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/ia32/config.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/ia32/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
@@ -669,7 +673,7 @@
 #define CONFIG_EXIF 1
 #define CONFIG_FAANDCT 0
 #define CONFIG_FAANIDCT 0
-#define CONFIG_FDCTDSP 1
+#define CONFIG_FDCTDSP 0
 #define CONFIG_FMTCONVERT 0
 #define CONFIG_FRAME_THREAD_ENCODER 0
 #define CONFIG_G722DSP 0
@@ -713,7 +717,7 @@
 #define CONFIG_MSMPEG4DEC 0
 #define CONFIG_MSMPEG4ENC 0
 #define CONFIG_MSS34DSP 0
-#define CONFIG_PIXBLOCKDSP 1
+#define CONFIG_PIXBLOCKDSP 0
 #define CONFIG_QPELDSP 1
 #define CONFIG_QSV 0
 #define CONFIG_QSVDEC 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/ia32/config_components.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/ia32/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 1
 #define CONFIG_AMRWB_DECODER 1
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/ia32/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/ia32/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/x64/config.asm
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/x64/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 1
 %define HAVE_PTHREAD_CANCEL 1
 %define HAVE_SCHED_GETAFFINITY 1
 %define HAVE_SECITEMIMPORT 0
@@ -653,7 +657,7 @@
 %define CONFIG_EXIF 1
 %define CONFIG_FAANDCT 0
 %define CONFIG_FAANIDCT 0
-%define CONFIG_FDCTDSP 1
+%define CONFIG_FDCTDSP 0
 %define CONFIG_FMTCONVERT 0
 %define CONFIG_FRAME_THREAD_ENCODER 0
 %define CONFIG_G722DSP 0
@@ -697,7 +701,7 @@
 %define CONFIG_MSMPEG4DEC 0
 %define CONFIG_MSMPEG4ENC 0
 %define CONFIG_MSS34DSP 0
-%define CONFIG_PIXBLOCKDSP 1
+%define CONFIG_PIXBLOCKDSP 0
 %define CONFIG_QPELDSP 1
 %define CONFIG_QSV 0
 %define CONFIG_QSVDEC 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --arch=x86_64 --target-os=linux --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264' --enable-decoder=mpeg4 --enable-parser='h263,mpeg4video' --enable-demuxer=avi --enable-demuxer=amr --enable-decoder='amrnb,amrwb' --enable-decoder=gsm_ms --enable-parser=gsm" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
@@ -669,7 +673,7 @@
 #define CONFIG_EXIF 1
 #define CONFIG_FAANDCT 0
 #define CONFIG_FAANIDCT 0
-#define CONFIG_FDCTDSP 1
+#define CONFIG_FDCTDSP 0
 #define CONFIG_FMTCONVERT 0
 #define CONFIG_FRAME_THREAD_ENCODER 0
 #define CONFIG_G722DSP 0
@@ -713,7 +717,7 @@
 #define CONFIG_MSMPEG4DEC 0
 #define CONFIG_MSMPEG4ENC 0
 #define CONFIG_MSS34DSP 0
-#define CONFIG_PIXBLOCKDSP 1
+#define CONFIG_PIXBLOCKDSP 0
 #define CONFIG_QPELDSP 1
 #define CONFIG_QSV 0
 #define CONFIG_QSVDEC 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 1
 #define CONFIG_AMRWB_DECODER 1
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/ChromeOS/linux/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/ChromeOS/linux/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/android/arm-neon/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/arm-neon/config.h
@@ -1,7 +1,7 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/arm-linux-androideabi --extra-cflags='--target=arm-linux-androideabi23' --extra-ldflags='--target=arm-linux-androideabi23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/arm-linux-androideabi --extra-ldflags='--gcc-toolchain=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-neon --extra-cflags='-mtune=generic-armv7-a' --extra-cflags='-mfloat-abi=softfp' --extra-cflags='-mfpu=neon'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/arm-linux-androideabi --extra-cflags='--target=arm-linux-androideabi23' --extra-ldflags='--target=arm-linux-androideabi23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/arm-linux-androideabi --extra-ldflags='--gcc-toolchain=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-neon --extra-cflags='-mtune=generic-armv7-a' --extra-cflags='-mfloat-abi=softfp' --extra-cflags='-mfpu=neon'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 0 /* #define HAVE_POSIX_MEMALIGN 1 -- forced to 0. See https://crbug.com/604451 */
+#define HAVE_PRCTL 1
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/android/arm-neon/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/arm-neon/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/android/arm-neon/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/arm-neon/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/android/arm64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/arm64/config.h
@@ -1,7 +1,7 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/aarch64-linux-android --extra-cflags='--target=aarch64-linux-android23' --extra-ldflags='--target=aarch64-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/aarch64-linux-android --extra-ldflags='--gcc-toolchain=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/aarch64-linux-android --extra-cflags='--target=aarch64-linux-android23' --extra-ldflags='--target=aarch64-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/aarch64-linux-android --extra-ldflags='--gcc-toolchain=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 0 /* #define HAVE_POSIX_MEMALIGN 1 -- forced to 0. See https://crbug.com/604451 */
+#define HAVE_PRCTL 1
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/android/arm64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/arm64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/android/arm64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/arm64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/android/ia32/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/ia32/config.h
@@ -1,7 +1,7 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/i686-linux-android --extra-cflags='--target=i686-linux-android23' --extra-ldflags='--target=i686-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/i686-linux-android --extra-ldflags='--gcc-toolchain=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --disable-x86asm" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/i686-linux-android --extra-cflags='--target=i686-linux-android23' --extra-ldflags='--target=i686-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/i686-linux-android --extra-ldflags='--gcc-toolchain=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --disable-x86asm" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 0 /* #define HAVE_POSIX_MEMALIGN 1 -- forced to 0. See https://crbug.com/604451 */
+#define HAVE_PRCTL 1
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/android/ia32/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/ia32/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/android/ia32/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/ia32/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/android/x64/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/x64/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 1
 %define HAVE_PTHREAD_CANCEL 0
 %define HAVE_SCHED_GETAFFINITY 1
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/android/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/x64/config.h
@@ -1,7 +1,7 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/x86_64-linux-android --extra-cflags='--target=x86_64-linux-android23' --extra-ldflags='--target=x86_64-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/x86_64-linux-android --extra-ldflags='--gcc-toolchain=/chromium/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=x86_64" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --enable-small --enable-pic --cc=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --cxx=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ --ld=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --enable-cross-compile --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/x86_64-linux-android --extra-cflags='--target=x86_64-linux-android23' --extra-ldflags='--target=x86_64-linux-android23' --extra-ldflags=-L/tmp/fakelinkerscripts --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/x86_64-linux-android --extra-ldflags='--gcc-toolchain=/usr/local/google/home/liberato/src/release_chrome/src/third_party/android_ndk/toolchains/llvm/prebuilt/linux-x86_64/' --target-os=android --arch=x86_64" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 0 /* #define HAVE_POSIX_MEMALIGN 1 -- forced to 0. See https://crbug.com/604451 */
+#define HAVE_PRCTL 1
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/android/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/android/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/android/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/linux-noasm/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux-noasm/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --disable-asm --disable-inline-asm --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --arch=x86_64 --target-os=linux --disable-asm --disable-inline-asm --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux-noasm/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux-noasm/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux-noasm/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux-noasm/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/arm-neon/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/arm-neon/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/chromium/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --enable-neon --extra-cflags='-mfpu=neon' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --enable-neon --extra-cflags='-mfpu=neon' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/arm-neon/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/arm-neon/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/arm-neon/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/arm-neon/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/arm/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/arm/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/chromium/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --disable-neon --extra-cflags='-mfpu=vfpv3-d16' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=arm --enable-armv6 --enable-armv6t2 --enable-vfp --enable-thumb --extra-cflags='-march=armv7-a' --enable-cross-compile --target-os=linux --extra-cflags='--target=arm-linux-gnueabihf' --extra-ldflags='--target=arm-linux-gnueabihf' --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/build/linux/debian_bullseye_arm-sysroot --extra-cflags='-mtune=cortex-a8' --extra-cflags='-mfloat-abi=hard' --extra-cflags=-O2 --disable-neon --extra-cflags='-mfpu=vfpv3-d16' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/arm/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/arm/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/arm/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/arm/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/arm64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/arm64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-cross-compile --cross-prefix=/usr/bin/aarch64-linux-gnu- --target-os=linux --extra-cflags='--target=aarch64-linux-gnu' --extra-ldflags='--target=aarch64-linux-gnu' --sysroot=/chromium/src/build/linux/debian_bullseye_arm64-sysroot --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-cross-compile --cross-prefix=/usr/bin/aarch64-linux-gnu- --extra-cflags='--target=aarch64-linux-gnu' --extra-ldflags='--target=aarch64-linux-gnu' --target-os=linux --sysroot=/usr/local/google/home/liberato/src/release_chrome/src/build/linux/debian_bullseye_arm64-sysroot --arch=aarch64 --enable-armv8 --extra-cflags='-march=armv8-a' --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/arm64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/arm64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/arm64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/arm64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/ia32/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/ia32/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 1
 %define HAVE_PTHREAD_CANCEL 1
 %define HAVE_SCHED_GETAFFINITY 1
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/ia32/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/ia32/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --enable-pic --cc=clang --cxx=clang++ --ld=clang" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --arch=i686 --extra-cflags='\"-m32\"' --extra-ldflags='\"-m32\"' --enable-pic --cc=clang --cxx=clang++ --ld=clang" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/ia32/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/ia32/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/ia32/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/ia32/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/x64/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/x64/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 1
 %define HAVE_PTHREAD_CANCEL 1
 %define HAVE_SCHED_GETAFFINITY 1
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-lto --arch=x86_64 --target-os=linux --enable-pic --cc=clang --cxx=clang++ --ld=clang --extra-ldflags='-fuse-ld=lld'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/linux/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/linux/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/mac/arm64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/mac/arm64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-cross-compile --cc=clang --ld=ld64.lld --nm=llvm-nm --ar=llvm-ar --target-os=darwin --extra-cflags='--target=arm64-apple-macosx' --extra-cflags=-F/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks --extra-cflags='-mmacosx-version-min=10.10' --extra-cflags=-fblocks --extra-cflags=-nostdinc --extra-cflags=-isystem/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include --extra-cflags=-isystem/chromium/src/third_party/llvm-build/Release+Asserts/lib/clang/16.0.0/include --extra-ldflags=-syslibroot --extra-ldflags=/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk --extra-ldflags=-L/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib --extra-ldflags=-lSystem --extra-ldflags=-macosx_version_min --extra-ldflags=10.10 --extra-ldflags=-sdk_version --extra-ldflags=10.10 --extra-ldflags=-platform_version --extra-ldflags=macos --extra-ldflags=10.10 --extra-ldflags=10.10 --arch=arm64 --extra-cflags='-arch arm64' --extra-ldflags='-arch arm64'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-cross-compile --cc=clang --ld=ld64.lld --nm=llvm-nm --ar=llvm-ar --target-os=darwin --extra-cflags='--target=arm64-apple-macosx' --extra-cflags=-F/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks --extra-cflags='-mmacosx-version-min=10.10' --extra-cflags=-fblocks --extra-cflags=-nostdinc --extra-cflags=-isystem/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include --extra-cflags=-isystem/usr/local/google/home/liberato/src/release_chrome/src/third_party/llvm-build/Release+Asserts/lib/clang/16.0.0/include --extra-ldflags=-syslibroot --extra-ldflags=/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib --extra-ldflags=-lSystem --extra-ldflags=-macosx_version_min --extra-ldflags=10.10 --extra-ldflags=-sdk_version --extra-ldflags=10.10 --extra-ldflags=-platform_version --extra-ldflags=macos --extra-ldflags=10.10 --extra-ldflags=10.10 --arch=arm64 --extra-cflags='-arch arm64' --extra-ldflags='-arch arm64'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME darwin
 #define av_restrict restrict
 #define EXTERN_PREFIX "_"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/mac/arm64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/mac/arm64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/mac/arm64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/mac/arm64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/mac/x64/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chromium/mac/x64/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
 %define HAVE_POSIX_MEMALIGN 1
+%define HAVE_PRCTL 0
 %define HAVE_PTHREAD_CANCEL 1
 %define HAVE_SCHED_GETAFFINITY 0
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/mac/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/mac/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-cross-compile --cc=clang --ld=ld64.lld --nm=llvm-nm --ar=llvm-ar --target-os=darwin --extra-cflags='--target=x86_64-apple-macosx' --extra-cflags=-F/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks --extra-cflags='-mmacosx-version-min=10.10' --extra-cflags=-fblocks --extra-cflags=-nostdinc --extra-cflags=-isystem/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include --extra-cflags=-isystem/chromium/src/third_party/llvm-build/Release+Asserts/lib/clang/16.0.0/include --extra-ldflags=-syslibroot --extra-ldflags=/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk --extra-ldflags=-L/chromium/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib --extra-ldflags=-lSystem --extra-ldflags=-macosx_version_min --extra-ldflags=10.10 --extra-ldflags=-sdk_version --extra-ldflags=10.10 --extra-ldflags=-platform_version --extra-ldflags=macos --extra-ldflags=10.10 --extra-ldflags=10.10 --arch=x86_64 --extra-cflags=-m64 --extra-ldflags='-arch x86_64'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-pic --cc=clang --cxx=clang++ --ld=clang --enable-cross-compile --cc=clang --ld=ld64.lld --nm=llvm-nm --ar=llvm-ar --target-os=darwin --extra-cflags='--target=x86_64-apple-macosx' --extra-cflags=-F/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks --extra-cflags='-mmacosx-version-min=10.10' --extra-cflags=-fblocks --extra-cflags=-nostdinc --extra-cflags=-isystem/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include --extra-cflags=-isystem/usr/local/google/home/liberato/src/release_chrome/src/third_party/llvm-build/Release+Asserts/lib/clang/16.0.0/include --extra-ldflags=-syslibroot --extra-ldflags=/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk --extra-ldflags=-L/usr/local/google/home/liberato/src/release_chrome/src/build/mac_files/xcode_binaries/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib --extra-ldflags=-lSystem --extra-ldflags=-macosx_version_min --extra-ldflags=10.10 --extra-ldflags=-sdk_version --extra-ldflags=10.10 --extra-ldflags=-platform_version --extra-ldflags=macos --extra-ldflags=10.10 --extra-ldflags=10.10 --arch=x86_64 --extra-cflags=-m64 --extra-ldflags='-arch x86_64'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME darwin
 #define av_restrict restrict
 #define EXTERN_PREFIX "_"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 1
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/mac/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/mac/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/mac/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/mac/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/win/arm64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/arm64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/chromium/src/third_party/ffmpeg/chromium/include/win --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --arch=aarch64 --as=clang-cl --extra-cflags='--target=arm64-windows' --extra-cflags=/winsysroot/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/ffmpeg/chromium/include/win --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --arch=aarch64 --as=clang-cl --extra-cflags='--target=arm64-windows' --extra-cflags=/winsysroot/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME win32
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 0
 #define HAVE_AMD3DNOW 0
 #define HAVE_AMD3DNOWEXT 0
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 0
 #define HAVE_AMD3DNOW_EXTERNAL 0
 #define HAVE_AMD3DNOWEXT_EXTERNAL 0
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 0
 #define HAVE_AMD3DNOW_INLINE 0
 #define HAVE_AMD3DNOWEXT_INLINE 0
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 0
 #define HAVE_PEEKNAMEDPIPE 1
 #define HAVE_POSIX_MEMALIGN 0
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/win/arm64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/arm64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/win/arm64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/arm64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/win/ia32/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/ia32/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 0
 %define HAVE_PEEKNAMEDPIPE 1
 %define HAVE_POSIX_MEMALIGN 0
+%define HAVE_PRCTL 0
 %define HAVE_PTHREAD_CANCEL 0
 %define HAVE_SCHED_GETAFFINITY 0
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/win/ia32/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/ia32/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/chromium/src/third_party/ffmpeg/chromium/include/win --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --extra-cflags=-m32 --extra-cflags=/winsysroot/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/ffmpeg/chromium/include/win --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --extra-cflags=-m32 --extra-cflags=/winsysroot/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME win32
 #define av_restrict restrict
 #define EXTERN_PREFIX "_"
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 0
 #define HAVE_PEEKNAMEDPIPE 1
 #define HAVE_POSIX_MEMALIGN 0
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/win/ia32/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/ia32/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/win/ia32/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/ia32/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/config/Chromium/win/x64/config.asm
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/x64/config.asm
@@ -41,6 +41,7 @@
 %define HAVE_POWER8 0
 %define HAVE_PPC4XX 0
 %define HAVE_VSX 0
+%define HAVE_RVV 0
 %define HAVE_AESNI 1
 %define HAVE_AMD3DNOW 1
 %define HAVE_AMD3DNOWEXT 1
@@ -89,6 +90,7 @@
 %define HAVE_POWER8_EXTERNAL 0
 %define HAVE_PPC4XX_EXTERNAL 0
 %define HAVE_VSX_EXTERNAL 0
+%define HAVE_RVV_EXTERNAL 0
 %define HAVE_AESNI_EXTERNAL 1
 %define HAVE_AMD3DNOW_EXTERNAL 1
 %define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -137,6 +139,7 @@
 %define HAVE_POWER8_INLINE 0
 %define HAVE_PPC4XX_INLINE 0
 %define HAVE_VSX_INLINE 0
+%define HAVE_RVV_INLINE 0
 %define HAVE_AESNI_INLINE 1
 %define HAVE_AMD3DNOW_INLINE 1
 %define HAVE_AMD3DNOWEXT_INLINE 1
@@ -308,6 +311,7 @@
 %define HAVE_NANOSLEEP 0
 %define HAVE_PEEKNAMEDPIPE 1
 %define HAVE_POSIX_MEMALIGN 0
+%define HAVE_PRCTL 0
 %define HAVE_PTHREAD_CANCEL 0
 %define HAVE_SCHED_GETAFFINITY 0
 %define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/win/x64/config.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/x64/config.h
@@ -1,12 +1,12 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/chromium/src/third_party/ffmpeg/chromium/include/win --target-os=win64 --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --extra-cflags=/winsysroot/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/chromium/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82'" -- elide long configuration string from binary */
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --toolchain=msvc --extra-cflags=-I/usr/local/google/home/liberato/src/release_chrome/src/third_party/ffmpeg/chromium/include/win --target-os=win64 --enable-cross-compile --cc=clang-cl --ld=lld-link --nm=llvm-nm --ar=llvm-ar --extra-cflags=-O2 --extra-cflags=/winsysroot/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82 --extra-ldflags='/winsysroot:/usr/local/google/home/liberato/src/release_chrome/src/third_party/depot_tools/win_toolchain/vs_files/1023ce2e82'" -- elide long configuration string from binary */
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
 #define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project 8ace9ea258c9ddc2e1e1c50cabde328ea10e34cf)"
+#define CC_IDENT "clang version 16.0.0 (https://chromium.googlesource.com/a/external/github.com/llvm/llvm-project deb82d4a20150b4c983ed02adcfd2ca84691b74b)"
 #define OS_NAME win64
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
@@ -57,6 +57,7 @@
 #define HAVE_POWER8 0
 #define HAVE_PPC4XX 0
 #define HAVE_VSX 0
+#define HAVE_RVV 0
 #define HAVE_AESNI 1
 #define HAVE_AMD3DNOW 1
 #define HAVE_AMD3DNOWEXT 1
@@ -105,6 +106,7 @@
 #define HAVE_POWER8_EXTERNAL 0
 #define HAVE_PPC4XX_EXTERNAL 0
 #define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
 #define HAVE_AESNI_EXTERNAL 1
 #define HAVE_AMD3DNOW_EXTERNAL 1
 #define HAVE_AMD3DNOWEXT_EXTERNAL 1
@@ -153,6 +155,7 @@
 #define HAVE_POWER8_INLINE 0
 #define HAVE_PPC4XX_INLINE 0
 #define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
 #define HAVE_AESNI_INLINE 1
 #define HAVE_AMD3DNOW_INLINE 1
 #define HAVE_AMD3DNOWEXT_INLINE 1
@@ -324,6 +327,7 @@
 #define HAVE_NANOSLEEP 0
 #define HAVE_PEEKNAMEDPIPE 1
 #define HAVE_POSIX_MEMALIGN 0
+#define HAVE_PRCTL 0
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 0
 #define HAVE_SECITEMIMPORT 0
--- a/third_party/ffmpeg/chromium/config/Chromium/win/x64/config_components.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/x64/config_components.h
@@ -8,6 +8,7 @@
 #define CONFIG_CHOMP_BSF 0
 #define CONFIG_DUMP_EXTRADATA_BSF 0
 #define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
 #define CONFIG_DV_ERROR_MARKER_BSF 0
 #define CONFIG_EAC3_CORE_BSF 0
 #define CONFIG_EXTRACT_EXTRADATA_BSF 0
@@ -162,6 +163,7 @@
 #define CONFIG_M101_DECODER 0
 #define CONFIG_MAGICYUV_DECODER 0
 #define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
 #define CONFIG_MIMIC_DECODER 0
 #define CONFIG_MJPEG_DECODER 0
 #define CONFIG_MJPEGB_DECODER 0
@@ -304,6 +306,7 @@
 #define CONFIG_VP9_RKMPP_DECODER 0
 #define CONFIG_VP9_V4L2M2M_DECODER 0
 #define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
 #define CONFIG_WBMP_DECODER 0
 #define CONFIG_WEBP_DECODER 0
 #define CONFIG_WCMV_DECODER 0
@@ -339,6 +342,7 @@
 #define CONFIG_ALS_DECODER 0
 #define CONFIG_AMRNB_DECODER 0
 #define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_APTX_DECODER 0
 #define CONFIG_APTX_HD_DECODER 0
@@ -368,6 +372,7 @@
 #define CONFIG_FASTAUDIO_DECODER 0
 #define CONFIG_FFWAVESYNTH_DECODER 0
 #define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
 #define CONFIG_G723_1_DECODER 0
 #define CONFIG_G729_DECODER 0
 #define CONFIG_GSM_DECODER 0
@@ -818,6 +823,7 @@
 #define CONFIG_AAC_MF_ENCODER 0
 #define CONFIG_AC3_MF_ENCODER 0
 #define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
 #define CONFIG_LIBOPENH264_ENCODER 0
 #define CONFIG_H264_AMF_ENCODER 0
 #define CONFIG_H264_MF_ENCODER 0
@@ -929,6 +935,7 @@
 #define CONFIG_DVDSUB_PARSER 0
 #define CONFIG_DVD_NAV_PARSER 0
 #define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
 #define CONFIG_G723_1_PARSER 0
 #define CONFIG_G729_PARSER 0
 #define CONFIG_GIF_PARSER 0
@@ -1559,6 +1566,7 @@
 #define CONFIG_AMRNB_DEMUXER 0
 #define CONFIG_AMRWB_DEMUXER 0
 #define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
 #define CONFIG_APC_DEMUXER 0
 #define CONFIG_APE_DEMUXER 0
 #define CONFIG_APM_DEMUXER 0
--- a/third_party/ffmpeg/chromium/config/Chromium/win/x64/libavutil/ffversion.h
+++ b/third_party/ffmpeg/chromium/config/Chromium/win/x64/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-109438-gdf92f7d9c7"
+#define FFMPEG_VERSION "N-110035-gcb4fb69337"
 #endif /* AVUTIL_FFVERSION_H */
--- a/third_party/ffmpeg/chromium/patches/README
+++ b/third_party/ffmpeg/chromium/patches/README
@@ -902,3 +902,13 @@
 Affects:
     libavutil/hwcontext_stub.c
 
+------------------------------------------------------------------
+commit 68994b791ea432cbb1ff551ffbe4f40b1b8f93f2
+Author: Frank Liberato <liberato@chromium.org>
+Date:   Fri Oct 28 03:26:22 2022 +0000
+
+    moved ff_ac3_find_syncword out of CONFIG_AC3_PARSER
+
+Affects:
+    libavcodec/ac3_parser.c
+
--- a/third_party/ffmpeg/chromium/patches/config_flag_changes.txt
+++ b/third_party/ffmpeg/chromium/patches/config_flag_changes.txt
@@ -1,11 +1 @@
-+ CONFIG_BONK_DECODER 0
-+ CONFIG_BONK_DEMUXER 0
-+ CONFIG_COLORSPACE_CUDA_FILTER 0
-+ CONFIG_LAF_DEMUXER 0
-+ CONFIG_MISC4_DECODER 0
-+ CONFIG_MISC4_PARSER 0
-+ CONFIG_XWD_PARSER 0
-+ HAVE_MAKEINFO 0
-+ HAVE_MAKEINFO_HTML 0
-- HAVE_MAKEINFO 1
-- HAVE_MAKEINFO_HTML 1
+- HAVE_PRCTL 1
--- a/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
+++ b/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
@@ -491,10 +491,13 @@
   # isn't actually used, so it's safe to set HAVE_SYSCTL to 0. Linux is also
   # removing <sys/sysctl.h> soon, so this is needed to silence a deprecation
   # #warning which will be converted to an error via -Werror.
+  # There is also no prctl.h
   if target_os in ['linux', 'linux-noasm']:
     pre_make_rewrites += [
         (r'(#define HAVE_SYSCTL [01])',
-         r'#define HAVE_SYSCTL 0 /* \1 -- forced to 0 for Fuchsia */')
+         r'#define HAVE_SYSCTL 0 /* \1 -- forced to 0 for Fuchsia */'),
+        (r'(#define HAVE_PRCTL [01])',
+         r'#define HAVE_PRCTL 0 /* \1 -- forced to 0 for Fuchsia */')
     ]
 
   # Turn off bcrypt, since we don't have it on Windows builders, but it does
@@ -738,9 +741,20 @@
         configure_flags['Common'].extend([
             '--arch=x86_64',
         ])
-      if target_os != 'android':
-        configure_flags['Common'].extend(['--enable-lto'])
-      pass
+      else:
+        configure_flags['Common'].extend([
+          '--enable-lto',
+          '--arch=x86_64',
+          '--target-os=linux',
+        ])
+
+        if host_arch != 'x64':
+          configure_flags['Common'].extend([
+            '--enable-cross-compile',
+            '--cross-prefix=/usr/bin/x86_64-linux-gnu-',
+            '--extra-cflags=--target=x86_64-linux-gnu',
+            '--extra-ldflags=--target=x86_64-linux-gnu',
+          ])
     elif target_arch == 'ia32':
       configure_flags['Common'].extend([
           '--arch=i686',
@@ -823,12 +837,16 @@
           ])
     elif target_arch == 'arm64':
       if target_os != 'android':
-        configure_flags['Common'].extend([
+        if host_arch != 'arm64':
+          configure_flags['Common'].extend([
             '--enable-cross-compile',
             '--cross-prefix=/usr/bin/aarch64-linux-gnu-',
-            '--target-os=linux',
             '--extra-cflags=--target=aarch64-linux-gnu',
             '--extra-ldflags=--target=aarch64-linux-gnu',
+          ])
+
+        configure_flags['Common'].extend([
+            '--target-os=linux',
             '--sysroot=' + os.path.join(CHROMIUM_ROOT_DIR,
                                         'build/linux/debian_bullseye_arm64-sysroot'),
         ])
--- a/third_party/ffmpeg/chromium/scripts/robo_lib/packages.py
+++ b/third_party/ffmpeg/chromium/scripts/robo_lib/packages.py
@@ -25,4 +25,10 @@
 GccAarch64LinuxGNU = Library('gcc-aarch64-linux-gnu', {
   OsFlavor.Debian: 'gcc-aarch64-linux-gnu',
   OsFlavor.Arch: 'aarch64-linux-gnu-binutils',
-})
\ No newline at end of file
+})
+
+
+GccMultilib = Library('gcc-multilib', {
+  OsFlavor.Debian: 'gcc-multilib',
+  OsFlavor.Arch: 'gcc',
+})
--- a/third_party/ffmpeg/chromium/scripts/robo_setup.py
+++ b/third_party/ffmpeg/chromium/scripts/robo_setup.py
@@ -38,6 +38,7 @@
   if robo_configuration.host_operating_system() == "linux":
     packages.Nasm.Install(robo_configuration)
     packages.GccAarch64LinuxGNU.Install(robo_configuration)
+    packages.GccMultilib.Install(robo_configuration)
   else:
     raise Exception("I don't know how to install deps for host os %s" %
                     robo_configuration.host_operating_system())
--- a/third_party/ffmpeg/ffbuild/arch.mak
+++ b/third_party/ffmpeg/ffbuild/arch.mak
@@ -15,5 +15,7 @@
 OBJS-$(HAVE_ALTIVEC) += $(ALTIVEC-OBJS) $(ALTIVEC-OBJS-yes)
 OBJS-$(HAVE_VSX)     += $(VSX-OBJS) $(VSX-OBJS-yes)
 
+OBJS-$(HAVE_RVV)     += $(RVV-OBJS)     $(RVV-OBJS-yes)
+
 OBJS-$(HAVE_MMX)     += $(MMX-OBJS)     $(MMX-OBJS-yes)
 OBJS-$(HAVE_X86ASM)  += $(X86ASM-OBJS)  $(X86ASM-OBJS-yes)
--- a/third_party/ffmpeg/ffmpeg_generated.gni
+++ b/third_party/ffmpeg/ffmpeg_generated.gni
@@ -71,10 +71,8 @@
     "libavcodec/mpegaudiodsp_float.c",
     "libavcodec/mpegaudiotabs.c",
     "libavcodec/options.c",
-    "libavcodec/opus.c",
+    "libavcodec/opus_parse.c",
     "libavcodec/opus_parser.c",
-    "libavcodec/opus_rc.c",
-    "libavcodec/opustab.c",
     "libavcodec/parser.c",
     "libavcodec/parsers.c",
     "libavcodec/pcm.c",
@@ -223,9 +221,8 @@
     "libavcodec/autorename_libavcodec_blockdsp.c",
     "libavcodec/autorename_libavcodec_idctdsp.c",
     "libavcodec/autorename_libavcodec_me_cmp.c",
+    "libavcodec/autorename_libavcodec_mpeg4videodsp.c",
     "libavcodec/autorename_libavcodec_mpegvideo.c",
-    "libavcodec/autorename_libavcodec_mpegvideodsp.c",
-    "libavcodec/autorename_libavcodec_pixblockdsp.c",
     "libavcodec/autorename_libavcodec_qpeldsp.c",
     "libavcodec/autorename_libavcodec_simple_idct.c",
     "libavcodec/autorename_libavcodec_xvididct.c",
@@ -233,7 +230,6 @@
     "libavcodec/celp_math.c",
     "libavcodec/error_resilience.c",
     "libavcodec/exif.c",
-    "libavcodec/fdctdsp.c",
     "libavcodec/gsm_parser.c",
     "libavcodec/gsmdec.c",
     "libavcodec/gsmdec_data.c",
@@ -243,8 +239,6 @@
     "libavcodec/h263dec.c",
     "libavcodec/h263dsp.c",
     "libavcodec/ituh263dec.c",
-    "libavcodec/jfdctfst.c",
-    "libavcodec/jfdctint.c",
     "libavcodec/jrevdct.c",
     "libavcodec/lsp.c",
     "libavcodec/mpeg4video.c",
@@ -292,33 +286,6 @@
   ]
 }
 
-if ((use_linux_config && current_cpu == "x64" && ffmpeg_branding == "ChromeOS") || (use_linux_config && current_cpu == "x86" && ffmpeg_branding == "ChromeOS")) {
-  ffmpeg_c_sources += [
-    "libavcodec/x86/autorename_libavcodec_x86_mpegvideo.c",
-    "libavcodec/x86/blockdsp_init.c",
-    "libavcodec/x86/fdct.c",
-    "libavcodec/x86/fdctdsp_init.c",
-    "libavcodec/x86/h263dsp_init.c",
-    "libavcodec/x86/idctdsp_init.c",
-    "libavcodec/x86/me_cmp_init.c",
-    "libavcodec/x86/mpegvideodsp.c",
-    "libavcodec/x86/pixblockdsp_init.c",
-    "libavcodec/x86/qpeldsp_init.c",
-    "libavcodec/x86/xvididct_init.c",
-  ]
-  ffmpeg_asm_sources += [
-    "libavcodec/x86/blockdsp.asm",
-    "libavcodec/x86/h263_loopfilter.asm",
-    "libavcodec/x86/idctdsp.asm",
-    "libavcodec/x86/me_cmp.asm",
-    "libavcodec/x86/pixblockdsp.asm",
-    "libavcodec/x86/qpeldsp.asm",
-    "libavcodec/x86/simple_idct.asm",
-    "libavcodec/x86/simple_idct10.asm",
-    "libavcodec/x86/xvididct.asm",
-  ]
-}
-
 if ((current_cpu == "arm64" && ffmpeg_branding == "Chrome") || (current_cpu == "x64" && ffmpeg_branding == "Chrome") || (is_android && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (is_android && current_cpu == "x86" && ffmpeg_branding == "Chrome") || (is_mac && ffmpeg_branding == "Chrome") || (is_win && ffmpeg_branding == "Chrome") || (use_linux_config && ffmpeg_branding == "Chrome") || (use_linux_config && ffmpeg_branding == "ChromeOS")) {
   ffmpeg_c_sources += [
     "libavcodec/aac_ac3_parser.c",
@@ -341,27 +308,26 @@
   ]
 }
 
-if ((use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "ChromeOS") || (use_linux_config && current_cpu == "arm" && ffmpeg_branding == "ChromeOS")) {
+if ((use_linux_config && current_cpu == "x64" && ffmpeg_branding == "ChromeOS") || (use_linux_config && current_cpu == "x86" && ffmpeg_branding == "ChromeOS")) {
   ffmpeg_c_sources += [
-    "libavcodec/arm/blockdsp_init_arm.c",
-    "libavcodec/arm/idctdsp_init_arm.c",
-    "libavcodec/arm/idctdsp_init_armv5te.c",
-    "libavcodec/arm/idctdsp_init_armv6.c",
-    "libavcodec/arm/me_cmp_init_arm.c",
-    "libavcodec/arm/mpegvideo_arm.c",
-    "libavcodec/arm/mpegvideo_armv5te.c",
-    "libavcodec/arm/pixblockdsp_init_arm.c",
+    "libavcodec/x86/autorename_libavcodec_x86_mpegvideo.c",
+    "libavcodec/x86/blockdsp_init.c",
+    "libavcodec/x86/h263dsp_init.c",
+    "libavcodec/x86/idctdsp_init.c",
+    "libavcodec/x86/me_cmp_init.c",
+    "libavcodec/x86/mpeg4videodsp.c",
+    "libavcodec/x86/qpeldsp_init.c",
+    "libavcodec/x86/xvididct_init.c",
   ]
-  ffmpeg_gas_sources += [
-    "libavcodec/arm/idctdsp_arm.S",
-    "libavcodec/arm/idctdsp_armv6.S",
-    "libavcodec/arm/jrevdct_arm.S",
-    "libavcodec/arm/me_cmp_armv6.S",
-    "libavcodec/arm/mpegvideo_armv5te_s.S",
-    "libavcodec/arm/pixblockdsp_armv6.S",
-    "libavcodec/arm/simple_idct_arm.S",
-    "libavcodec/arm/simple_idct_armv5te.S",
-    "libavcodec/arm/simple_idct_armv6.S",
+  ffmpeg_asm_sources += [
+    "libavcodec/x86/blockdsp.asm",
+    "libavcodec/x86/h263_loopfilter.asm",
+    "libavcodec/x86/idctdsp.asm",
+    "libavcodec/x86/me_cmp.asm",
+    "libavcodec/x86/qpeldsp.asm",
+    "libavcodec/x86/simple_idct.asm",
+    "libavcodec/x86/simple_idct10.asm",
+    "libavcodec/x86/xvididct.asm",
   ]
 }
 
@@ -387,6 +353,28 @@
   ]
 }
 
+if ((use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "ChromeOS") || (use_linux_config && current_cpu == "arm" && ffmpeg_branding == "ChromeOS")) {
+  ffmpeg_c_sources += [
+    "libavcodec/arm/blockdsp_init_arm.c",
+    "libavcodec/arm/idctdsp_init_arm.c",
+    "libavcodec/arm/idctdsp_init_armv5te.c",
+    "libavcodec/arm/idctdsp_init_armv6.c",
+    "libavcodec/arm/me_cmp_init_arm.c",
+    "libavcodec/arm/mpegvideo_arm.c",
+    "libavcodec/arm/mpegvideo_armv5te.c",
+  ]
+  ffmpeg_gas_sources += [
+    "libavcodec/arm/idctdsp_arm.S",
+    "libavcodec/arm/idctdsp_armv6.S",
+    "libavcodec/arm/jrevdct_arm.S",
+    "libavcodec/arm/me_cmp_armv6.S",
+    "libavcodec/arm/mpegvideo_armv5te_s.S",
+    "libavcodec/arm/simple_idct_arm.S",
+    "libavcodec/arm/simple_idct_armv5te.S",
+    "libavcodec/arm/simple_idct_armv6.S",
+  ]
+}
+
 if ((is_mac && current_cpu == "x64" && ffmpeg_branding == "Chrome") || (is_win && current_cpu == "x64" && ffmpeg_branding == "Chrome") || (is_win && current_cpu == "x86" && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "x64" && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "x64" && ffmpeg_branding == "ChromeOS") || (use_linux_config && current_cpu == "x86" && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "x86" && ffmpeg_branding == "ChromeOS")) {
   ffmpeg_c_sources += [
     "libavcodec/x86/h264_qpel.c",
@@ -507,6 +495,7 @@
     "libavcodec/autorename_libavcodec_videodsp.c",
     "libavcodec/h264pred.c",
     "libavcodec/hpeldsp.c",
+    "libavcodec/jpegquanttables.c",
     "libavcodec/vp3.c",
     "libavcodec/vp3_parser.c",
     "libavcodec/vp3dsp.c",
@@ -546,34 +535,6 @@
   ]
 }
 
-if (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "ChromeOS") {
-  ffmpeg_c_sources += [
-    "libavcodec/arm/blockdsp_init_neon.c",
-    "libavcodec/arm/idctdsp_init_neon.c",
-  ]
-  ffmpeg_gas_sources += [
-    "libavcodec/arm/autorename_libavcodec_arm_idctdsp_neon.S",
-    "libavcodec/arm/autorename_libavcodec_arm_pixblockdsp_neon.S",
-    "libavcodec/arm/autorename_libavcodec_arm_simple_idct_neon.S",
-    "libavcodec/arm/blockdsp_neon.S",
-    "libavcodec/arm/mpegvideo_neon.S",
-  ]
-}
-
-if (use_linux_config && current_cpu == "arm64" && ffmpeg_branding == "ChromeOS") {
-  ffmpeg_c_sources += [
-    "libavcodec/aarch64/idctdsp_init_aarch64.c",
-    "libavcodec/aarch64/me_cmp_init_aarch64.c",
-    "libavcodec/aarch64/pixblockdsp_init_aarch64.c",
-  ]
-  ffmpeg_gas_sources += [
-    "libavcodec/aarch64/idctdsp_neon.S",
-    "libavcodec/aarch64/me_cmp_neon.S",
-    "libavcodec/aarch64/pixblockdsp_neon.S",
-    "libavcodec/aarch64/simple_idct_neon.S",
-  ]
-}
-
 if ((is_android && current_cpu == "arm" && arm_use_neon) || (use_linux_config && current_cpu == "arm" && arm_use_neon)) {
   ffmpeg_c_sources += [
     "libavutil/arm/float_dsp_init_neon.c",
@@ -587,6 +548,19 @@
   ]
 }
 
+if (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "ChromeOS") {
+  ffmpeg_c_sources += [
+    "libavcodec/arm/blockdsp_init_neon.c",
+    "libavcodec/arm/idctdsp_init_neon.c",
+  ]
+  ffmpeg_gas_sources += [
+    "libavcodec/arm/autorename_libavcodec_arm_idctdsp_neon.S",
+    "libavcodec/arm/autorename_libavcodec_arm_simple_idct_neon.S",
+    "libavcodec/arm/blockdsp_neon.S",
+    "libavcodec/arm/mpegvideo_neon.S",
+  ]
+}
+
 if (use_linux_config && current_cpu == "arm" && arm_use_neon) {
   ffmpeg_c_sources += [
     "libavcodec/arm/hpeldsp_init_neon.c",
@@ -600,6 +574,18 @@
   ]
 }
 
+if (use_linux_config && current_cpu == "arm64" && ffmpeg_branding == "ChromeOS") {
+  ffmpeg_c_sources += [
+    "libavcodec/aarch64/idctdsp_init_aarch64.c",
+    "libavcodec/aarch64/me_cmp_init_aarch64.c",
+  ]
+  ffmpeg_gas_sources += [
+    "libavcodec/aarch64/idctdsp_neon.S",
+    "libavcodec/aarch64/me_cmp_neon.S",
+    "libavcodec/aarch64/simple_idct_neon.S",
+  ]
+}
+
 if ((use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && arm_use_neon && ffmpeg_branding == "ChromeOS") || (use_linux_config && current_cpu == "arm" && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "arm" && ffmpeg_branding == "ChromeOS")) {
   ffmpeg_c_sources += [
     "libavcodec/arm/h264chroma_init_arm.c",
--- a/third_party/ffmpeg/libavcodec/Makefile
+++ b/third_party/ffmpeg/libavcodec/Makefile
@@ -132,7 +132,7 @@
                                           mpegaudiodsp_float.o
 OBJS-$(CONFIG_MPEGAUDIOHEADER)         += mpegaudiodecheader.o mpegaudiotabs.o
 OBJS-$(CONFIG_MPEG4AUDIO)              += mpeg4audio.o mpeg4audio_sample_rates.o
-OBJS-$(CONFIG_MPEGVIDEO)               += mpegvideo.o mpegvideodsp.o rl.o \
+OBJS-$(CONFIG_MPEGVIDEO)               += mpegvideo.o rl.o \
                                           mpegvideo_motion.o \
                                           mpegvideodata.o mpegpicture.o  \
                                           to_upper4.o
@@ -142,7 +142,7 @@
                                           mpegvideoencdsp.o
 OBJS-$(CONFIG_MSMPEG4DEC)              += msmpeg4dec.o msmpeg4.o msmpeg4data.o
 OBJS-$(CONFIG_MSMPEG4ENC)              += msmpeg4enc.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_MSS34DSP)                += mss34dsp.o
+OBJS-$(CONFIG_MSS34DSP)                += mss34dsp.o jpegquanttables.o
 OBJS-$(CONFIG_PIXBLOCKDSP)             += pixblockdsp.o
 OBJS-$(CONFIG_QPELDSP)                 += qpeldsp.o
 OBJS-$(CONFIG_QSV)                     += qsv.o
@@ -196,7 +196,7 @@
 OBJS-$(CONFIG_AC3_FIXED_ENCODER)       += ac3enc_fixed.o ac3enc.o ac3tab.o ac3.o kbdwin.o
 OBJS-$(CONFIG_AC3_MF_ENCODER)          += mfenc.o mf_utils.o
 OBJS-$(CONFIG_ACELP_KELVIN_DECODER)    += g729dec.o lsp.o celp_math.o celp_filters.o acelp_filters.o acelp_pitch_delay.o acelp_vectors.o g729postfilter.o
-OBJS-$(CONFIG_AGM_DECODER)             += agm.o
+OBJS-$(CONFIG_AGM_DECODER)             += agm.o jpegquanttables.o
 OBJS-$(CONFIG_AIC_DECODER)             += aic.o
 OBJS-$(CONFIG_ALAC_DECODER)            += alac.o alac_data.o alacdsp.o
 OBJS-$(CONFIG_ALAC_ENCODER)            += alacenc.o alac_data.o
@@ -214,6 +214,7 @@
 OBJS-$(CONFIG_AMV_ENCODER)             += mjpegenc.o mjpegenc_common.o
 OBJS-$(CONFIG_ANM_DECODER)             += anm.o
 OBJS-$(CONFIG_ANSI_DECODER)            += ansi.o cga_data.o
+OBJS-$(CONFIG_APAC_DECODER)            += apac.o
 OBJS-$(CONFIG_APE_DECODER)             += apedec.o
 OBJS-$(CONFIG_APTX_DECODER)            += aptxdec.o aptx.o
 OBJS-$(CONFIG_APTX_ENCODER)            += aptxenc.o aptx.o
@@ -243,6 +244,7 @@
 OBJS-$(CONFIG_AURA2_DECODER)           += aura.o
 OBJS-$(CONFIG_AV1_DECODER)             += av1dec.o
 OBJS-$(CONFIG_AV1_CUVID_DECODER)       += cuviddec.o
+OBJS-$(CONFIG_AV1_QSV_ENCODER)         += qsvenc_av1.o
 OBJS-$(CONFIG_AVRN_DECODER)            += avrndec.o
 OBJS-$(CONFIG_AVRP_DECODER)            += r210dec.o
 OBJS-$(CONFIG_AVRP_ENCODER)            += r210enc.o
@@ -331,7 +333,7 @@
 OBJS-$(CONFIG_EATGQ_DECODER)           += eatgq.o eaidct.o
 OBJS-$(CONFIG_EATGV_DECODER)           += eatgv.o
 OBJS-$(CONFIG_EATQI_DECODER)           += eatqi.o eaidct.o mpeg12.o \
-                                          mpeg12data.o mpegvideodata.o
+                                          mpeg12data.o
 OBJS-$(CONFIG_EIGHTBPS_DECODER)        += 8bps.o
 OBJS-$(CONFIG_EIGHTSVX_EXP_DECODER)    += 8svx.o
 OBJS-$(CONFIG_EIGHTSVX_FIB_DECODER)    += 8svx.o
@@ -360,6 +362,7 @@
 OBJS-$(CONFIG_FOURXM_DECODER)          += 4xm.o
 OBJS-$(CONFIG_FRAPS_DECODER)           += fraps.o
 OBJS-$(CONFIG_FRWU_DECODER)            += frwu.o
+OBJS-$(CONFIG_FTR_DECODER)             += ftr.o
 OBJS-$(CONFIG_G2M_DECODER)             += g2meet.o elsdec.o mjpegdec_common.o
 OBJS-$(CONFIG_G723_1_DECODER)          += g723_1dec.o g723_1.o \
                                           acelp_vectors.o celp_filters.o celp_math.o
@@ -467,6 +470,7 @@
 OBJS-$(CONFIG_MAGICYUV_DECODER)        += magicyuv.o
 OBJS-$(CONFIG_MAGICYUV_ENCODER)        += magicyuvenc.o
 OBJS-$(CONFIG_MDEC_DECODER)            += mdec.o mpeg12.o mpeg12data.o
+OBJS-$(CONFIG_MEDIA100_DECODER)        += media100.o
 OBJS-$(CONFIG_METASOUND_DECODER)       += metasound.o metasound_data.o \
                                           twinvq.o
 OBJS-$(CONFIG_MICRODVD_DECODER)        += microdvddec.o ass.o
@@ -520,7 +524,7 @@
 OBJS-$(CONFIG_MPEG2_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG2_VAAPI_ENCODER)     += vaapi_encode_mpeg2.o
 OBJS-$(CONFIG_MPEG2_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
-OBJS-$(CONFIG_MPEG4_DECODER)           += xvididct.o
+OBJS-$(CONFIG_MPEG4_DECODER)           += mpeg4videodsp.o xvididct.o
 OBJS-$(CONFIG_MPEG4_ENCODER)           += mpeg4videoenc.o
 OBJS-$(CONFIG_MPEG4_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG4_MEDIACODEC_DECODER) += mediacodecdec.o
@@ -549,13 +553,13 @@
 OBJS-$(CONFIG_NELLYMOSER_DECODER)      += nellymoserdec.o nellymoser.o
 OBJS-$(CONFIG_NELLYMOSER_ENCODER)      += nellymoserenc.o nellymoser.o
 OBJS-$(CONFIG_NOTCHLC_DECODER)         += notchlc.o
-OBJS-$(CONFIG_NUV_DECODER)             += nuv.o rtjpeg.o
+OBJS-$(CONFIG_NUV_DECODER)             += nuv.o rtjpeg.o jpegquanttables.o
 OBJS-$(CONFIG_ON2AVC_DECODER)          += on2avc.o on2avcdata.o
-OBJS-$(CONFIG_OPUS_DECODER)            += opusdec.o opus.o opus_celt.o opus_rc.o \
+OBJS-$(CONFIG_OPUS_DECODER)            += opusdec.o opusdec_celt.o opus_celt.o \
                                           opus_pvq.o opus_silk.o opustab.o vorbis_data.o \
-                                          opusdsp.o
-OBJS-$(CONFIG_OPUS_ENCODER)            += opusenc.o opus.o opus_rc.o opustab.o opus_pvq.o \
-                                          opusenc_psy.o vorbis_data.o
+                                          opusdsp.o opus_parse.o opus_rc.o
+OBJS-$(CONFIG_OPUS_ENCODER)            += opusenc.o opusenc_psy.o opus_celt.o \
+                                          opus_pvq.o opus_rc.o opustab.o
 OBJS-$(CONFIG_PAF_AUDIO_DECODER)       += pafaudio.o
 OBJS-$(CONFIG_PAF_VIDEO_DECODER)       += pafvideo.o
 OBJS-$(CONFIG_PAM_DECODER)             += pnmdec.o pnm.o
@@ -657,7 +661,8 @@
 OBJS-$(CONFIG_SONIC_DECODER)           += sonic.o
 OBJS-$(CONFIG_SONIC_ENCODER)           += sonic.o
 OBJS-$(CONFIG_SONIC_LS_ENCODER)        += sonic.o
-OBJS-$(CONFIG_SPEEDHQ_DECODER)         += speedhq.o mpeg12.o mpeg12data.o simple_idct.o
+OBJS-$(CONFIG_SPEEDHQ_DECODER)         += speedhqdec.o speedhq.o mpeg12.o \
+                                          mpeg12data.o
 OBJS-$(CONFIG_SPEEDHQ_ENCODER)         += speedhq.o mpeg12data.o mpeg12enc.o speedhqenc.o
 OBJS-$(CONFIG_SPEEX_DECODER)           += speexdec.o
 OBJS-$(CONFIG_SP5X_DECODER)            += sp5xdec.o
@@ -734,7 +739,7 @@
                                           vorbis_data.o
 OBJS-$(CONFIG_VORBIS_ENCODER)          += vorbisenc.o vorbis.o \
                                           vorbis_data.o
-OBJS-$(CONFIG_VP3_DECODER)             += vp3.o
+OBJS-$(CONFIG_VP3_DECODER)             += vp3.o jpegquanttables.o
 OBJS-$(CONFIG_VP5_DECODER)             += vp5.o vp56.o vp56data.o vpx_rac.o
 OBJS-$(CONFIG_VP6_DECODER)             += vp6.o vp56.o vp56data.o \
                                           vp6dsp.o vpx_rac.o
@@ -758,6 +763,7 @@
 OBJS-$(CONFIG_VPLAYER_DECODER)         += textdec.o ass.o
 OBJS-$(CONFIG_VP9_V4L2M2M_DECODER)     += v4l2_m2m_dec.o
 OBJS-$(CONFIG_VQA_DECODER)             += vqavideo.o
+OBJS-$(CONFIG_VQC_DECODER)             += vqcdec.o
 OBJS-$(CONFIG_WAVPACK_DECODER)         += wavpack.o wavpackdata.o dsd.o
 OBJS-$(CONFIG_WAVPACK_ENCODER)         += wavpackdata.o wavpackenc.o
 OBJS-$(CONFIG_WBMP_DECODER)            += wbmpdec.o
@@ -1132,6 +1138,7 @@
 OBJS-$(CONFIG_DVD_NAV_PARSER)          += dvd_nav_parser.o
 OBJS-$(CONFIG_DVDSUB_PARSER)           += dvdsub_parser.o
 OBJS-$(CONFIG_FLAC_PARSER)             += flac_parser.o flacdata.o flac.o
+OBJS-$(CONFIG_FTR_PARSER)              += ftr_parser.o
 OBJS-$(CONFIG_G723_1_PARSER)           += g723_1_parser.o
 OBJS-$(CONFIG_G729_PARSER)             += g729_parser.o
 OBJS-$(CONFIG_GIF_PARSER)              += gif_parser.o
@@ -1152,8 +1159,8 @@
 OBJS-$(CONFIG_MPEGAUDIO_PARSER)        += mpegaudio_parser.o
 OBJS-$(CONFIG_MPEGVIDEO_PARSER)        += mpegvideo_parser.o    \
                                           mpeg12.o mpeg12data.o
-OBJS-$(CONFIG_OPUS_PARSER)             += opus_parser.o opus.o opustab.o \
-                                          opus_rc.o vorbis_data.o
+OBJS-$(CONFIG_OPUS_PARSER)             += opus_parser.o opus_parse.o \
+                                          vorbis_data.o
 OBJS-$(CONFIG_PNG_PARSER)              += png_parser.o
 OBJS-$(CONFIG_PNM_PARSER)              += pnm_parser.o pnm.o
 OBJS-$(CONFIG_QOI_PARSER)              += qoi_parser.o
@@ -1180,6 +1187,7 @@
 OBJS-$(CONFIG_CHOMP_BSF)                  += chomp_bsf.o
 OBJS-$(CONFIG_DUMP_EXTRADATA_BSF)         += dump_extradata_bsf.o
 OBJS-$(CONFIG_DCA_CORE_BSF)               += dca_core_bsf.o
+OBJS-$(CONFIG_DTS2PTS_BSF)                += dts2pts_bsf.o
 OBJS-$(CONFIG_DV_ERROR_MARKER_BSF)        += dv_error_marker_bsf.o
 OBJS-$(CONFIG_EAC3_CORE_BSF)              += eac3_core_bsf.o
 OBJS-$(CONFIG_EXTRACT_EXTRADATA_BSF)      += extract_extradata_bsf.o    \
--- a/third_party/ffmpeg/libavcodec/aac_ac3_parser.c
+++ b/third_party/ffmpeg/libavcodec/aac_ac3_parser.c
@@ -26,6 +26,8 @@
 #include "libavutil/common.h"
 #include "parser.h"
 #include "aac_ac3_parser.h"
+#include "ac3_parser_internal.h"
+#include "adts_header.h"
 
 int ff_aac_ac3_parse(AVCodecParserContext *s1,
                      AVCodecContext *avctx,
@@ -38,83 +40,127 @@
     int new_frame_start;
     int got_frame = 0;
 
+    if (s1->flags & PARSER_FLAG_COMPLETE_FRAMES) {
+        i = buf_size;
+        got_frame = 1;
+    } else {
 get_next:
-    i=END_NOT_FOUND;
-    if(s->remaining_size <= buf_size){
-        if(s->remaining_size && !s->need_next_header){
-            i= s->remaining_size;
-            s->remaining_size = 0;
-        }else{ //we need a header first
-            len=0;
-            for(i=s->remaining_size; i<buf_size; i++){
-                s->state = (s->state<<8) + buf[i];
-                if((len=s->sync(s->state, s, &s->need_next_header, &new_frame_start)))
-                    break;
-            }
-            if(len<=0){
-                i=END_NOT_FOUND;
-            }else{
-                got_frame = 1;
-                s->state=0;
-                i-= s->header_size -1;
-                s->remaining_size = len;
-                if(!new_frame_start || pc->index+i<=0){
-                    s->remaining_size += i;
-                    goto get_next;
+        i=END_NOT_FOUND;
+        if(s->remaining_size <= buf_size){
+            if(s->remaining_size && !s->need_next_header){
+                i= s->remaining_size;
+                s->remaining_size = 0;
+            }else{ //we need a header first
+                len=0;
+                for(i=s->remaining_size; i<buf_size; i++){
+                    s->state = (s->state<<8) + buf[i];
+                    if((len=s->sync(s->state, &s->need_next_header, &new_frame_start)))
+                        break;
                 }
-                else if (i < 0) {
-                    s->remaining_size += i;
+                if(len<=0){
+                    i=END_NOT_FOUND;
+                }else{
+                    got_frame = 1;
+                    s->state=0;
+                    i-= s->header_size -1;
+                    s->remaining_size = len;
+                    if(!new_frame_start || pc->index+i<=0){
+                        s->remaining_size += i;
+                        goto get_next;
+                    }
+                    else if (i < 0) {
+                        s->remaining_size += i;
+                    }
                 }
             }
         }
-    }
 
-    if(ff_combine_frame(pc, i, &buf, &buf_size)<0){
-        s->remaining_size -= FFMIN(s->remaining_size, buf_size);
-        *poutbuf = NULL;
-        *poutbuf_size = 0;
-        return buf_size;
+        if(ff_combine_frame(pc, i, &buf, &buf_size)<0){
+            s->remaining_size -= FFMIN(s->remaining_size, buf_size);
+            *poutbuf = NULL;
+            *poutbuf_size = 0;
+            return buf_size;
+        }
     }
 
     *poutbuf = buf;
     *poutbuf_size = buf_size;
 
-    /* update codec info */
-    if(s->codec_id)
-        avctx->codec_id = s->codec_id;
-
     if (got_frame) {
+        int bit_rate;
+
         /* Due to backwards compatible HE-AAC the sample rate, channel count,
            and total number of samples found in an AAC ADTS header are not
            reliable. Bit rate is still accurate because the total frame
            duration in seconds is still correct (as is the number of bits in
            the frame). */
         if (avctx->codec_id != AV_CODEC_ID_AAC) {
-            avctx->sample_rate = s->sample_rate;
+            AC3HeaderInfo hdr, *phrd = &hdr;
+            int offset = ff_ac3_find_syncword(buf, buf_size);
+
+            if (offset < 0)
+                return i;
+
+            buf += offset;
+            buf_size -= offset;
+            while (buf_size > 0) {
+                int ret = avpriv_ac3_parse_header(&phrd, buf, buf_size);
+
+                if (ret < 0 || hdr.frame_size > buf_size)
+                    return i;
+
+                if (buf_size > hdr.frame_size) {
+                    buf += hdr.frame_size;
+                    buf_size -= hdr.frame_size;
+                    continue;
+                }
+                /* Check for false positives since the syncword is not enough.
+                   See section 6.1.2 of A/52. */
+                if (av_crc(s->crc_ctx, 0, buf + 2, hdr.frame_size - 2))
+                    return i;
+                break;
+            }
+
+            avctx->sample_rate = hdr.sample_rate;
+
+            if (hdr.bitstream_id > 10)
+                avctx->codec_id = AV_CODEC_ID_EAC3;
+
             if (!CONFIG_EAC3_DECODER || avctx->codec_id != AV_CODEC_ID_EAC3) {
                 av_channel_layout_uninit(&avctx->ch_layout);
-                if (s->channel_layout) {
-                    av_channel_layout_from_mask(&avctx->ch_layout, s->channel_layout);
+                if (hdr.channel_layout) {
+                    av_channel_layout_from_mask(&avctx->ch_layout, hdr.channel_layout);
                 } else {
                     avctx->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
-                    avctx->ch_layout.nb_channels = s->channels;
+                    avctx->ch_layout.nb_channels = hdr.channels;
                 }
 #if FF_API_OLD_CHANNEL_LAYOUT
 FF_DISABLE_DEPRECATION_WARNINGS
                 avctx->channels = avctx->ch_layout.nb_channels;
-                avctx->channel_layout = s->channel_layout;
+                avctx->channel_layout = hdr.channel_layout;
 FF_ENABLE_DEPRECATION_WARNINGS
 #endif
             }
-            s1->duration = s->samples;
-            avctx->audio_service_type = s->service_type;
+            s1->duration = hdr.num_blocks * 256;
+            avctx->audio_service_type = hdr.bitstream_mode;
+            if (hdr.bitstream_mode == 0x7 && hdr.channels > 1)
+                avctx->audio_service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE;
+            bit_rate = hdr.bit_rate;
+        } else {
+            AACADTSHeaderInfo hdr, *phrd = &hdr;
+            int ret = avpriv_adts_header_parse(&phrd, buf, buf_size);
+
+            if (ret < 0)
+                return i;
+
+            bit_rate = hdr.bit_rate;
         }
 
         /* Calculate the average bit rate */
         s->frame_number++;
         if (!CONFIG_EAC3_DECODER || avctx->codec_id != AV_CODEC_ID_EAC3) {
             avctx->bit_rate +=
-                (s->bit_rate - avctx->bit_rate) / s->frame_number;
+                (bit_rate - avctx->bit_rate) / s->frame_number;
         }
     }
 
--- a/third_party/ffmpeg/libavcodec/aac_ac3_parser.h
+++ b/third_party/ffmpeg/libavcodec/aac_ac3_parser.h
@@ -24,6 +24,7 @@
 #define AVCODEC_AAC_AC3_PARSER_H
 
 #include <stdint.h>
+#include "libavutil/crc.h"
 #include "avcodec.h"
 #include "parser.h"
 
@@ -39,24 +40,15 @@
 
 typedef struct AACAC3ParseContext {
     ParseContext pc;
-    int frame_size;
     int header_size;
-    int (*sync)(uint64_t state, struct AACAC3ParseContext *hdr_info,
-            int *need_next_header, int *new_frame_start);
-
-    int channels;
-    int sample_rate;
-    int bit_rate;
-    int samples;
-    uint64_t channel_layout;
-    int service_type;
+    int (*sync)(uint64_t state, int *need_next_header, int *new_frame_start);
 
+    const AVCRC *crc_ctx;
     int remaining_size;
     uint64_t state;
 
     int need_next_header;
     int frame_number;
-    enum AVCodecID codec_id;
 } AACAC3ParseContext;
 
 int ff_aac_ac3_parse(AVCodecParserContext *s1,
--- a/third_party/ffmpeg/libavcodec/aac_adtstoasc_bsf.c
+++ b/third_party/ffmpeg/libavcodec/aac_adtstoasc_bsf.c
@@ -26,6 +26,7 @@
 #include "put_bits.h"
 #include "get_bits.h"
 #include "mpeg4audio.h"
+#include "mpeg4audio_copy_pce.h"
 
 typedef struct AACBSFContext {
     int first_frame_done;
--- a/third_party/ffmpeg/libavcodec/aac_parser.c
+++ b/third_party/ffmpeg/libavcodec/aac_parser.c
@@ -27,8 +27,7 @@
 #include "get_bits.h"
 #include "mpeg4audio.h"
 
-static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,
-        int *need_next_header, int *new_frame_start)
+static int aac_sync(uint64_t state, int *need_next_header, int *new_frame_start)
 {
     GetBitContext bits;
     AACADTSHeaderInfo hdr;
@@ -46,10 +45,6 @@
         return 0;
     *need_next_header = 0;
     *new_frame_start  = 1;
-    hdr_info->sample_rate = hdr.sample_rate;
-    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];
-    hdr_info->samples     = hdr.samples;
-    hdr_info->bit_rate    = hdr.bit_rate;
     return size;
 }
 
--- a/third_party/ffmpeg/libavcodec/aacdec.c
+++ b/third_party/ffmpeg/libavcodec/aacdec.c
@@ -566,9 +566,7 @@
     },
     .p.capabilities  = AV_CODEC_CAP_CHANNEL_CONF | AV_CODEC_CAP_DR1,
     .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = aac_channel_layout,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(aac_channel_layout)
     .p.ch_layouts    = aac_ch_layout,
     .flush = flush,
     .p.priv_class    = &aac_decoder_class,
@@ -594,9 +592,7 @@
     },
     .p.capabilities  = AV_CODEC_CAP_CHANNEL_CONF | AV_CODEC_CAP_DR1,
     .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = aac_channel_layout,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(aac_channel_layout)
     .p.ch_layouts    = aac_ch_layout,
     .flush = flush,
     .p.profiles      = NULL_IF_CONFIG_SMALL(ff_aac_profiles),
--- a/third_party/ffmpeg/libavcodec/aacdec_fixed.c
+++ b/third_party/ffmpeg/libavcodec/aacdec_fixed.c
@@ -464,9 +464,7 @@
     },
     .p.capabilities  = AV_CODEC_CAP_CHANNEL_CONF | AV_CODEC_CAP_DR1,
     .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = aac_channel_layout,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(aac_channel_layout)
     .p.ch_layouts    = aac_ch_layout,
     .p.priv_class    = &aac_decoder_class,
     .p.profiles      = NULL_IF_CONFIG_SMALL(ff_aac_profiles),
--- a/third_party/ffmpeg/libavcodec/aacdectab.h
+++ b/third_party/ffmpeg/libavcodec/aacdectab.h
@@ -73,7 +73,7 @@
 };
 
 #if FF_API_OLD_CHANNEL_LAYOUT
-static const uint64_t aac_channel_layout[16] = {
+static const uint64_t aac_channel_layout[] = {
     AV_CH_LAYOUT_MONO,
     AV_CH_LAYOUT_STEREO,
     AV_CH_LAYOUT_SURROUND,
@@ -81,9 +81,6 @@
     AV_CH_LAYOUT_5POINT0_BACK,
     AV_CH_LAYOUT_5POINT1_BACK,
     AV_CH_LAYOUT_7POINT1_WIDE_BACK,
-    0,
-    0,
-    0,
     AV_CH_LAYOUT_6POINT1,
     AV_CH_LAYOUT_7POINT1,
     AV_CH_LAYOUT_22POINT2,
@@ -92,7 +89,7 @@
 };
 #endif
 
-static const AVChannelLayout aac_ch_layout[16] = {
+static const AVChannelLayout aac_ch_layout[] = {
     AV_CHANNEL_LAYOUT_MONO,
     AV_CHANNEL_LAYOUT_STEREO,
     AV_CHANNEL_LAYOUT_SURROUND,
@@ -100,9 +97,6 @@
     AV_CHANNEL_LAYOUT_5POINT0_BACK,
     AV_CHANNEL_LAYOUT_5POINT1_BACK,
     AV_CHANNEL_LAYOUT_7POINT1_WIDE_BACK,
-    { 0 },
-    { 0 },
-    { 0 },
     AV_CHANNEL_LAYOUT_6POINT1,
     AV_CHANNEL_LAYOUT_7POINT1,
     AV_CHANNEL_LAYOUT_22POINT2,
--- a/third_party/ffmpeg/libavcodec/aacpsdsp.h
+++ b/third_party/ffmpeg/libavcodec/aacpsdsp.h
@@ -55,6 +55,7 @@
 void ff_psdsp_init_arm(PSDSPContext *s);
 void ff_psdsp_init_aarch64(PSDSPContext *s);
 void ff_psdsp_init_mips(PSDSPContext *s);
+void ff_psdsp_init_riscv(PSDSPContext *s);
 void ff_psdsp_init_x86(PSDSPContext *s);
 
 #endif /* AVCODEC_AACPSDSP_H */
--- a/third_party/ffmpeg/libavcodec/aacpsdsp_template.c
+++ b/third_party/ffmpeg/libavcodec/aacpsdsp_template.c
@@ -230,6 +230,8 @@
     ff_psdsp_init_aarch64(s);
 #elif ARCH_MIPS
     ff_psdsp_init_mips(s);
+#elif ARCH_RISCV
+    ff_psdsp_init_riscv(s);
 #elif ARCH_X86
     ff_psdsp_init_x86(s);
 #endif
--- a/third_party/ffmpeg/libavcodec/aarch64/Makefile
+++ b/third_party/ffmpeg/libavcodec/aarch64/Makefile
@@ -67,4 +67,5 @@
                                            aarch64/vp9mc_neon.o
 NEON-OBJS-$(CONFIG_HEVC_DECODER)        += aarch64/hevcdsp_idct_neon.o         \
                                            aarch64/hevcdsp_init_aarch64.o      \
+                                           aarch64/hevcdsp_qpel_neon.o         \
                                            aarch64/hevcdsp_sao_neon.o
--- a/third_party/ffmpeg/libavcodec/aarch64/fft_neon.S
+++ b/third_party/ffmpeg/libavcodec/aarch64/fft_neon.S
@@ -342,8 +342,7 @@
 function fft\n\()_neon, align=6
         AARCH64_VALID_JUMP_TARGET
         AARCH64_SIGN_LINK_REGISTER
-        sub             sp,  sp,  #16
-        stp             x28, x30, [sp]
+        stp             x28, x30, [sp, #-16]!
         add             x28, x0,  #\n4*2*8
         bl              fft\n2\()_neon
         mov             x0,  x28
--- a/third_party/ffmpeg/libavcodec/aarch64/h264idct_neon.S
+++ b/third_party/ffmpeg/libavcodec/aarch64/h264idct_neon.S
@@ -157,8 +157,7 @@
 endfunc
 
 function ff_h264_idct_add8_neon, export=1
-        sub             sp,  sp, #0x40
-        stp             x19, x20, [sp]
+        stp             x19, x20, [sp, #-0x40]!
         mov             x12, x30
         ldp             x6,  x15, [x0]          // dest[0], dest[1]
         add             x5,  x1,  #16*4         // block_offset
@@ -187,8 +186,7 @@
         csel            x6,  x15, x6,  eq
         cmp             x10, #20
         b.lt            1b
-        ldp             x19, x20, [sp]
-        add             sp,  sp,  #0x40
+        ldp             x19, x20, [sp], #0x40
         ret             x12
 endfunc
 
--- a/third_party/ffmpeg/libavcodec/aarch64/hevcdsp_init_aarch64.c
+++ b/third_party/ffmpeg/libavcodec/aarch64/hevcdsp_init_aarch64.c
@@ -69,6 +69,46 @@
                                           const int16_t *sao_offset_val, int eo, int width, int height);
 void ff_hevc_sao_edge_filter_8x8_8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride_dst,
                                         const int16_t *sao_offset_val, int eo, int width, int height);
+void ff_hevc_put_hevc_qpel_h4_8_neon(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height,
+                                     intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_h6_8_neon(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height,
+                                     intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_h8_8_neon(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height,
+                                     intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_h12_8_neon(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height,
+                                      intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_h16_8_neon(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height,
+                                      intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_uni_h4_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                         ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,
+                                         int width);
+void ff_hevc_put_hevc_qpel_uni_h6_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                         ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,
+                                         int width);
+void ff_hevc_put_hevc_qpel_uni_h8_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                         ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,
+                                         int width);
+void ff_hevc_put_hevc_qpel_uni_h12_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                          ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t
+                                          my, int width);
+void ff_hevc_put_hevc_qpel_uni_h16_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                          ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t
+                                          my, int width);
+void ff_hevc_put_hevc_qpel_bi_h4_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                        ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t
+                                        mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_bi_h6_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                        ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t
+                                        mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_bi_h8_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                        ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t
+                                        mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_bi_h12_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                         ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t
+                                         mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_bi_h16_8_neon(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src,
+                                         ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t
+                                         mx, intptr_t my, int width);
 
 av_cold void ff_hevc_dsp_init_aarch64(HEVCDSPContext *c, const int bit_depth)
 {
@@ -95,6 +135,33 @@
         c->sao_edge_filter[2]          =
         c->sao_edge_filter[3]          =
         c->sao_edge_filter[4]          = ff_hevc_sao_edge_filter_16x16_8_neon;
+        c->put_hevc_qpel[1][0][1]      = ff_hevc_put_hevc_qpel_h4_8_neon;
+        c->put_hevc_qpel[2][0][1]      = ff_hevc_put_hevc_qpel_h6_8_neon;
+        c->put_hevc_qpel[3][0][1]      = ff_hevc_put_hevc_qpel_h8_8_neon;
+        c->put_hevc_qpel[4][0][1]      =
+        c->put_hevc_qpel[6][0][1]      = ff_hevc_put_hevc_qpel_h12_8_neon;
+        c->put_hevc_qpel[5][0][1]      =
+        c->put_hevc_qpel[7][0][1]      =
+        c->put_hevc_qpel[8][0][1]      =
+        c->put_hevc_qpel[9][0][1]      = ff_hevc_put_hevc_qpel_h16_8_neon;
+        c->put_hevc_qpel_uni[1][0][1]  = ff_hevc_put_hevc_qpel_uni_h4_8_neon;
+        c->put_hevc_qpel_uni[2][0][1]  = ff_hevc_put_hevc_qpel_uni_h6_8_neon;
+        c->put_hevc_qpel_uni[3][0][1]  = ff_hevc_put_hevc_qpel_uni_h8_8_neon;
+        c->put_hevc_qpel_uni[4][0][1]  =
+        c->put_hevc_qpel_uni[6][0][1]  = ff_hevc_put_hevc_qpel_uni_h12_8_neon;
+        c->put_hevc_qpel_uni[5][0][1]  =
+        c->put_hevc_qpel_uni[7][0][1]  =
+        c->put_hevc_qpel_uni[8][0][1]  =
+        c->put_hevc_qpel_uni[9][0][1]  = ff_hevc_put_hevc_qpel_uni_h16_8_neon;
+        c->put_hevc_qpel_bi[1][0][1]   = ff_hevc_put_hevc_qpel_bi_h4_8_neon;
+        c->put_hevc_qpel_bi[2][0][1]   = ff_hevc_put_hevc_qpel_bi_h6_8_neon;
+        c->put_hevc_qpel_bi[3][0][1]   = ff_hevc_put_hevc_qpel_bi_h8_8_neon;
+        c->put_hevc_qpel_bi[4][0][1]   =
+        c->put_hevc_qpel_bi[6][0][1]   = ff_hevc_put_hevc_qpel_bi_h12_8_neon;
+        c->put_hevc_qpel_bi[5][0][1]   =
+        c->put_hevc_qpel_bi[7][0][1]   =
+        c->put_hevc_qpel_bi[8][0][1]   =
+        c->put_hevc_qpel_bi[9][0][1]   = ff_hevc_put_hevc_qpel_bi_h16_8_neon;
     }
     if (bit_depth == 10) {
         c->add_residual[0]             = ff_hevc_add_residual_4x4_10_neon;
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/aarch64/hevcdsp_qpel_neon.S
@@ -0,0 +1,484 @@
+/* -*-arm64-*-
+ * vim: syntax=arm64asm
+ *
+ * Copyright (c) 2022 J. Dekker <jdek@itanimul.li>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/aarch64/asm.S"
+#define MAX_PB_SIZE 64
+
+const qpel_filters, align=4
+        .byte           0,  0,  0,  0,  0,  0, 0,  0
+        .byte           -1, 4,-10, 58, 17, -5, 1,  0
+        .byte           -1, 4,-11, 40, 40,-11, 4, -1
+        .byte           0,  1, -5, 17, 58,-10, 4, -1
+endconst
+
+.macro load_filter m
+        movrel          x15, qpel_filters
+        add             x15, x15, \m, lsl #3
+        ld1             {v0.8b}, [x15]
+        sxtl            v0.8h, v0.8b
+.endm
+
+.macro put_hevc type
+.ifc \type, qpel
+        // void put_hevc_qpel_h(int16_t *dst,
+        //                      uint8_t *_src, ptrdiff_t _srcstride,
+        //                      int height, intptr_t mx, intptr_t my, int width)
+        dst        .req x0
+        dststride  .req x7
+        src        .req x1
+        srcstride  .req x2
+        height     .req x3
+        heightw    .req w3
+        mx         .req x4
+        width      .req w6
+.endif
+.ifc \type, qpel_uni
+        // void put_hevc_qpel_uni_h(uint8_t *_dst,  ptrdiff_t _dststride,
+        //                          uint8_t *_src, ptrdiff_t _srcstride,
+        //                          int height, intptr_t mx, intptr_t my, int width)
+        dst        .req x0
+        dststride  .req x1
+        src        .req x2
+        srcstride  .req x3
+        height     .req x4
+        heightw    .req w4
+        mx         .req x5
+        width      .req w7
+.endif
+.ifc \type, qpel_bi
+        // void put_hevc_qpel_bi_h(uint8_t *_dst, ptrdiff_t _dststride,
+        //                         uint8_t *_src, ptrdiff_t _srcstride,
+        //                         int16_t *src2, int height, intptr_t mx,
+        //                         intptr_t my, int width)
+        dst        .req x0
+        dststride  .req x1
+        src        .req x2
+        srcstride  .req x3
+        height     .req x5
+        heightw    .req w5
+        mx         .req x6
+        width      .req w8
+.endif
+
+.ifc \type, qpel
+function ff_hevc_put_hevc_h4_8_neon, export=0
+        uxtl            v16.8h,  v16.8b
+        uxtl            v17.8h,  v17.8b
+        uxtl            v18.8h,  v18.8b
+        uxtl            v19.8h,  v19.8b
+
+        mul             v23.4h,  v16.4h, v0.h[0]
+        mul             v24.4h,  v18.4h, v0.h[0]
+
+.irpc i, 1234567
+        ext             v20.16b, v16.16b, v17.16b, #(2*\i)
+        ext             v21.16b, v18.16b, v19.16b, #(2*\i)
+        mla             v23.4h,  v20.4h, v0.h[\i]
+        mla             v24.4h,  v21.4h, v0.h[\i]
+.endr
+        ret
+endfunc
+.endif
+
+function ff_hevc_put_hevc_\type\()_h4_8_neon, export=1
+        load_filter     mx
+.ifc \type, qpel_bi
+        mov             x16, #(MAX_PB_SIZE << 2) // src2bstridel
+        add             x15, x4, #(MAX_PB_SIZE << 1) // src2b
+.endif
+        sub             src, src, #3
+        mov             mx, x30
+.ifc \type, qpel
+        mov             dststride, #(MAX_PB_SIZE << 1)
+        lsl             x13, srcstride, #1 // srcstridel
+        mov             x14, #(MAX_PB_SIZE << 2)
+.else
+        lsl             x14, dststride, #1 // dststridel
+        lsl             x13, srcstride, #1 // srcstridel
+.endif
+        add             x10, dst, dststride // dstb
+        add             x12, src, srcstride // srcb
+0:      ld1             {v16.8b, v17.8b}, [src], x13
+        ld1             {v18.8b, v19.8b}, [x12], x13
+.ifc \type, qpel_bi
+        ld1             {v25.8h}, [ x4], x16
+        ld1             {v26.8h}, [x15], x16
+.endif
+
+        bl              ff_hevc_put_hevc_h4_8_neon
+        subs            heightw, heightw, #2
+
+.ifc \type, qpel
+        st1             {v23.4h}, [dst], x14
+        st1             {v24.4h}, [x10], x14
+.else
+.ifc \type, qpel_bi
+        sqadd           v23.4h, v23.4h, v25.4h
+        sqadd           v24.4h, v24.4h, v26.4h
+        sqrshrun        v23.8b, v23.8h, #7
+        sqrshrun        v24.8b, v24.8h, #7
+.else
+        sqrshrun        v23.8b, v23.8h, #6
+        sqrshrun        v24.8b, v24.8h, #6
+.endif
+        st1             {v23.s}[0], [dst], x14
+        st1             {v24.s}[0], [x10], x14
+.endif
+        b.gt            0b // double line
+        ret             mx
+endfunc
+
+.ifc \type, qpel
+function ff_hevc_put_hevc_h8_8_neon, export=0
+        uxtl            v16.8h,  v16.8b
+        uxtl            v17.8h,  v17.8b
+        uxtl            v18.8h,  v18.8b
+        uxtl            v19.8h,  v19.8b
+
+        mul             v23.8h,  v16.8h, v0.h[0]
+        mul             v24.8h,  v18.8h, v0.h[0]
+
+.irpc i, 1234567
+        ext             v20.16b, v16.16b, v17.16b, #(2*\i)
+        ext             v21.16b, v18.16b, v19.16b, #(2*\i)
+        mla             v23.8h,  v20.8h, v0.h[\i]
+        mla             v24.8h,  v21.8h, v0.h[\i]
+.endr
+        ret
+endfunc
+.endif
+
+function ff_hevc_put_hevc_\type\()_h6_8_neon, export=1
+        load_filter     mx
+.ifc \type, qpel_bi
+        mov             x16, #(MAX_PB_SIZE << 2) // src2bstridel
+        add             x15, x4, #(MAX_PB_SIZE << 1) // src2b
+.endif
+        sub             src, src, #3
+        mov             mx, x30
+.ifc \type, qpel
+        mov             dststride, #(MAX_PB_SIZE << 1)
+        lsl             x13, srcstride, #1 // srcstridel
+        mov             x14, #((MAX_PB_SIZE << 2) - 8)
+.else
+        lsl             x14, dststride, #1 // dststridel
+        lsl             x13, srcstride, #1 // srcstridel
+        sub             x14, x14, #4
+.endif
+        add             x10, dst, dststride // dstb
+        add             x12, src, srcstride // srcb
+0:      ld1             {v16.8b, v17.8b}, [src], x13
+        ld1             {v18.8b, v19.8b}, [x12], x13
+.ifc \type, qpel_bi
+        ld1             {v25.8h}, [ x4], x16
+        ld1             {v26.8h}, [x15], x16
+.endif
+
+        bl              ff_hevc_put_hevc_h8_8_neon
+        subs            heightw, heightw, #2
+
+.ifc \type, qpel
+        st1             {v23.4h},   [dst], #8
+        st1             {v24.4h},   [x10], #8
+        st1             {v23.s}[2], [dst], x14
+        st1             {v24.s}[2], [x10], x14
+.else
+.ifc \type, qpel_bi
+        sqadd           v23.8h, v23.8h, v25.8h
+        sqadd           v24.8h, v24.8h, v26.8h
+        sqrshrun        v23.8b, v23.8h, #7
+        sqrshrun        v24.8b, v24.8h, #7
+.else
+        sqrshrun        v23.8b, v23.8h, #6
+        sqrshrun        v24.8b, v24.8h, #6
+.endif
+        st1             {v23.s}[0], [dst], #4
+        st1             {v24.s}[0], [x10], #4
+        st1             {v23.h}[2], [dst], x14
+        st1             {v24.h}[2], [x10], x14
+.endif
+        b.gt            0b // double line
+        ret             mx
+endfunc
+
+function ff_hevc_put_hevc_\type\()_h8_8_neon, export=1
+        load_filter     mx
+.ifc \type, qpel_bi
+        mov             x16, #(MAX_PB_SIZE << 2) // src2bstridel
+        add             x15, x4, #(MAX_PB_SIZE << 1) // src2b
+.endif
+        sub             src, src, #3
+        mov             mx, x30
+.ifc \type, qpel
+        mov             dststride, #(MAX_PB_SIZE << 1)
+        lsl             x13, srcstride, #1 // srcstridel
+        mov             x14, #(MAX_PB_SIZE << 2)
+.else
+        lsl             x14, dststride, #1 // dststridel
+        lsl             x13, srcstride, #1 // srcstridel
+.endif
+        add             x10, dst, dststride // dstb
+        add             x12, src, srcstride // srcb
+0:      ld1             {v16.8b, v17.8b}, [src], x13
+        ld1             {v18.8b, v19.8b}, [x12], x13
+.ifc \type, qpel_bi
+        ld1             {v25.8h}, [ x4], x16
+        ld1             {v26.8h}, [x15], x16
+.endif
+
+        bl              ff_hevc_put_hevc_h8_8_neon
+        subs            heightw, heightw, #2
+
+.ifc \type, qpel
+        st1             {v23.8h}, [dst], x14
+        st1             {v24.8h}, [x10], x14
+.else
+.ifc \type, qpel_bi
+        sqadd           v23.8h, v23.8h, v25.8h
+        sqadd           v24.8h, v24.8h, v26.8h
+        sqrshrun        v23.8b, v23.8h, #7
+        sqrshrun        v24.8b, v24.8h, #7
+.else
+        sqrshrun        v23.8b, v23.8h, #6
+        sqrshrun        v24.8b, v24.8h, #6
+.endif
+        st1             {v23.8b}, [dst], x14
+        st1             {v24.8b}, [x10], x14
+.endif
+        b.gt            0b // double line
+        ret             mx
+endfunc
+
+.ifc \type, qpel
+function ff_hevc_put_hevc_h16_8_neon, export=0
+        uxtl            v16.8h,  v16.8b
+        uxtl            v17.8h,  v17.8b
+        uxtl            v18.8h,  v18.8b
+
+        uxtl            v19.8h,  v19.8b
+        uxtl            v20.8h,  v20.8b
+        uxtl            v21.8h,  v21.8b
+
+        mul             v26.8h,  v16.8h, v0.h[0]
+        mul             v27.8h,  v17.8h, v0.h[0]
+        mul             v28.8h,  v19.8h, v0.h[0]
+        mul             v29.8h,  v20.8h, v0.h[0]
+.irpc i, 1234567
+        ext             v22.16b, v16.16b, v17.16b, #(2*\i)
+        ext             v23.16b, v17.16b, v18.16b, #(2*\i)
+
+        ext             v24.16b, v19.16b, v20.16b, #(2*\i)
+        ext             v25.16b, v20.16b, v21.16b, #(2*\i)
+
+        mla             v26.8h,  v22.8h, v0.h[\i]
+        mla             v27.8h,  v23.8h, v0.h[\i]
+
+        mla             v28.8h,  v24.8h, v0.h[\i]
+        mla             v29.8h,  v25.8h, v0.h[\i]
+.endr
+        subs            x9, x9, #2
+        ret
+endfunc
+.endif
+
+function ff_hevc_put_hevc_\type\()_h12_8_neon, export=1
+        load_filter     mx
+        sxtw            height, heightw
+.ifc \type, qpel_bi
+        ldrh            w8, [sp] // width
+        mov             x16, #(MAX_PB_SIZE << 2) // src2bstridel
+        lsl             x17, height, #7 // src2b reset (height * (MAX_PB_SIZE << 1))
+        add             x15, x4, #(MAX_PB_SIZE << 1) // src2b
+.endif
+        sub             src, src, #3
+        mov             mx, x30
+.ifc \type, qpel
+        mov             dststride, #(MAX_PB_SIZE << 1)
+        lsl             x13, srcstride, #1 // srcstridel
+        mov             x14, #((MAX_PB_SIZE << 2) - 16)
+.else
+        lsl             x14, dststride, #1 // dststridel
+        lsl             x13, srcstride, #1 // srcstridel
+        sub             x14, x14, #8
+.endif
+        add             x10, dst, dststride // dstb
+        add             x12, src, srcstride // srcb
+0:      mov             x9, height
+1:      ld1             {v16.8b-v18.8b}, [src], x13
+        ld1             {v19.8b-v21.8b}, [x12], x13
+
+        bl              ff_hevc_put_hevc_h16_8_neon
+
+.ifc \type, qpel
+        st1             {v26.8h}, [dst], #16
+        st1             {v28.8h}, [x10], #16
+        st1             {v27.4h}, [dst], x14
+        st1             {v29.4h}, [x10], x14
+.else
+.ifc \type, qpel_bi
+        ld1             {v16.8h, v17.8h}, [ x4], x16
+        ld1             {v18.8h, v19.8h}, [x15], x16
+        sqadd           v26.8h, v26.8h, v16.8h
+        sqadd           v27.8h, v27.8h, v17.8h
+        sqadd           v28.8h, v28.8h, v18.8h
+        sqadd           v29.8h, v29.8h, v19.8h
+        sqrshrun        v26.8b, v26.8h, #7
+        sqrshrun        v27.8b, v27.8h, #7
+        sqrshrun        v28.8b, v28.8h, #7
+        sqrshrun        v29.8b, v29.8h, #7
+.else
+        sqrshrun        v26.8b, v26.8h, #6
+        sqrshrun        v27.8b, v27.8h, #6
+        sqrshrun        v28.8b, v28.8h, #6
+        sqrshrun        v29.8b, v29.8h, #6
+.endif
+        st1             {v26.8b},   [dst], #8
+        st1             {v28.8b},   [x10], #8
+        st1             {v27.s}[0], [dst], x14
+        st1             {v29.s}[0], [x10], x14
+.endif
+        b.gt            1b // double line
+        subs            width, width, #12
+        // reset src
+        msub            src, srcstride, height, src
+        msub            x12, srcstride, height, x12
+        // reset dst
+        msub            dst, dststride, height, dst
+        msub            x10, dststride, height, x10
+.ifc \type, qpel_bi
+        // reset xsrc
+        sub             x4,  x4,  x17
+        sub             x15, x15, x17
+        add             x4,  x4,  #24
+        add             x15, x15, #24
+.endif
+        add             src, src, #12
+        add             x12, x12, #12
+.ifc \type, qpel
+        add             dst, dst, #24
+        add             x10, x10, #24
+.else
+        add             dst, dst, #12
+        add             x10, x10, #12
+.endif
+        b.gt            0b
+        ret             mx
+endfunc
+
+function ff_hevc_put_hevc_\type\()_h16_8_neon, export=1
+        load_filter     mx
+        sxtw            height, heightw
+        mov             mx, x30
+.ifc \type, qpel_bi
+        ldrh            w8, [sp] // width
+        mov             x16, #(MAX_PB_SIZE << 2) // src2bstridel
+        lsl             x17, x5, #7 // src2b reset
+        add             x15, x4, #(MAX_PB_SIZE << 1) // src2b
+.endif
+        sub             src, src, #3
+        mov             mx, x30
+.ifc \type, qpel
+        mov             dststride, #(MAX_PB_SIZE << 1)
+        lsl             x13, srcstride, #1 // srcstridel
+        mov             x14, #((MAX_PB_SIZE << 2) - 16)
+.else
+        lsl             x14, dststride, #1 // dststridel
+        lsl             x13, srcstride, #1 // srcstridel
+        sub             x14, x14, #8
+.endif
+        add             x10, dst, dststride // dstb
+        add             x12, src, srcstride // srcb
+0:      mov             x9, height
+1:      ld1             {v16.8b-v18.8b}, [src], x13
+        ld1             {v19.8b-v21.8b}, [x12], x13
+
+        bl              ff_hevc_put_hevc_h16_8_neon
+
+.ifc \type, qpel
+        st1             {v26.8h}, [dst], #16
+        st1             {v28.8h}, [x10], #16
+        st1             {v27.8h}, [dst], x14
+        st1             {v29.8h}, [x10], x14
+.else
+.ifc \type, qpel_bi
+        ld1             {v16.8h, v17.8h}, [ x4], x16
+        ld1             {v18.8h, v19.8h}, [x15], x16
+        sqadd           v26.8h, v26.8h, v16.8h
+        sqadd           v27.8h, v27.8h, v17.8h
+        sqadd           v28.8h, v28.8h, v18.8h
+        sqadd           v29.8h, v29.8h, v19.8h
+        sqrshrun        v26.8b, v26.8h, #7
+        sqrshrun        v27.8b, v27.8h, #7
+        sqrshrun        v28.8b, v28.8h, #7
+        sqrshrun        v29.8b, v29.8h, #7
+.else
+        sqrshrun        v26.8b, v26.8h, #6
+        sqrshrun        v27.8b, v27.8h, #6
+        sqrshrun        v28.8b, v28.8h, #6
+        sqrshrun        v29.8b, v29.8h, #6
+.endif
+        st1             {v26.8b}, [dst], #8
+        st1             {v28.8b}, [x10], #8
+        st1             {v27.8b}, [dst], x14
+        st1             {v29.8b}, [x10], x14
+.endif
+        b.gt            1b // double line
+        subs            width, width, #16
+        // reset src
+        msub            src, srcstride, height, src
+        msub            x12, srcstride, height, x12
+        // reset dst
+        msub            dst, dststride, height, dst
+        msub            x10, dststride, height, x10
+.ifc \type, qpel_bi
+        // reset xsrc
+        sub             x4,  x4,  x17
+        sub             x15, x15, x17
+        add             x4,  x4,  #32
+        add             x15, x15, #32
+.endif
+        add             src, src, #16
+        add             x12, x12, #16
+.ifc \type, qpel
+        add             dst, dst, #32
+        add             x10, x10, #32
+.else
+        add             dst, dst, #16
+        add             x10, x10, #16
+.endif
+        b.gt            0b
+        ret             mx
+endfunc
+
+.unreq height
+.unreq heightw
+.unreq width
+.unreq src
+.unreq dst
+.unreq srcstride
+.unreq dststride
+.unreq mx
+.endm
+
+put_hevc qpel
+put_hevc qpel_uni
+put_hevc qpel_bi
--- a/third_party/ffmpeg/libavcodec/aarch64/hevcdsp_sao_neon.S
+++ b/third_party/ffmpeg/libavcodec/aarch64/hevcdsp_sao_neon.S
@@ -33,8 +33,7 @@
 //                      int16_t *sao_offset_val, int sao_left_class,
 //                      int width, int height)
 function ff_hevc_sao_band_filter_8x8_8_neon, export=1
-        sub             sp,  sp, #64
-        stp             xzr, xzr, [sp]
+        stp             xzr, xzr, [sp, #-64]!
         stp             xzr, xzr, [sp, #16]
         stp             xzr, xzr, [sp, #32]
         stp             xzr, xzr, [sp, #48]
--- a/third_party/ffmpeg/libavcodec/aarch64/mdct_neon.S
+++ b/third_party/ffmpeg/libavcodec/aarch64/mdct_neon.S
@@ -23,8 +23,7 @@
 #include "libavutil/aarch64/asm.S"
 
 function ff_imdct_half_neon, export=1
-        sub             sp,  sp,  #32
-        stp             x19, x20, [sp]
+        stp             x19, x20, [sp, #-32]!
         AARCH64_SIGN_LINK_REGISTER
         str             x30, [sp, #16]
         mov             x12, #1
@@ -120,17 +119,15 @@
         st2             {v4.2s,v5.2s},  [x0]
         st2             {v6.2s,v7.2s},  [x8]
 
-        ldp             x19, x20, [sp]
         ldr             x30, [sp, #16]
         AARCH64_VALIDATE_LINK_REGISTER
-        add             sp,  sp,  #32
+        ldp             x19, x20, [sp], #32
 
         ret
 endfunc
 
 function ff_imdct_calc_neon, export=1
-        sub             sp,  sp,  #32
-        stp             x19, x20, [sp]
+        stp             x19, x20, [sp, #-32]!
         AARCH64_SIGN_LINK_REGISTER
         str             x30, [sp, #16]
         ldr             w3,  [x0, #28]          // mdct_bits
@@ -163,18 +160,16 @@
         subs            x19, x19,  #16
         b.gt            1b
 
-        ldp             x19, x20, [sp]
         ldr             x30, [sp, #16]
         AARCH64_VALIDATE_LINK_REGISTER
-        add             sp,  sp,  #32
+        ldp             x19, x20, [sp], #32
 
         ret
 endfunc
 
 
 function ff_mdct_calc_neon, export=1
-        sub             sp,  sp,  #32
-        stp             x19, x20, [sp]
+        stp             x19, x20, [sp, #-32]!
         AARCH64_SIGN_LINK_REGISTER
         str             x30, [sp, #16]
 
@@ -323,10 +318,9 @@
         st2             {v4.2s,v5.2s},  [x0]
         st2             {v6.2s,v7.2s},  [x8]
 
-        ldp             x19, x20, [sp]
         ldr             x30, [sp, #16]
         AARCH64_VALIDATE_LINK_REGISTER
-        add             sp,  sp,  #32
+        ldp             x19, x20, [sp], #32
 
         ret
 endfunc
--- a/third_party/ffmpeg/libavcodec/aarch64/me_cmp_init_aarch64.c
+++ b/third_party/ffmpeg/libavcodec/aarch64/me_cmp_init_aarch64.c
@@ -59,6 +59,23 @@
                           ptrdiff_t stride, int h);
 int pix_median_abs8_neon(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                          ptrdiff_t stride, int h);
+int ff_pix_abs8_x2_neon(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
+                        ptrdiff_t stride, int h);
+int ff_pix_abs8_y2_neon(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
+                        ptrdiff_t stride, int h);
+int ff_pix_abs8_xy2_neon(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
+                         ptrdiff_t stride, int h);
+
+int nsse8_neon(int multiplier, const uint8_t *s, const uint8_t *s2,
+               ptrdiff_t stride, int h);
+int nsse8_neon_wrapper(MpegEncContext *c, const uint8_t *s1, const uint8_t *s2,
+                       ptrdiff_t stride, int h);
+
+int vsse8_neon(MpegEncContext *c, const uint8_t *s1, const uint8_t *s2,
+               ptrdiff_t stride, int h);
+
+int vsse_intra8_neon(MpegEncContext *c, const uint8_t *s, const uint8_t *dummy,
+                     ptrdiff_t stride, int h);
 
 av_cold void ff_me_cmp_init_aarch64(MECmpContext *c, AVCodecContext *avctx)
 {
@@ -70,6 +87,9 @@
         c->pix_abs[0][2] = ff_pix_abs16_y2_neon;
         c->pix_abs[0][3] = ff_pix_abs16_xy2_neon;
         c->pix_abs[1][0] = ff_pix_abs8_neon;
+        c->pix_abs[1][1] = ff_pix_abs8_x2_neon;
+        c->pix_abs[1][2] = ff_pix_abs8_y2_neon;
+        c->pix_abs[1][3] = ff_pix_abs8_xy2_neon;
 
         c->sad[0] = ff_pix_abs16_neon;
         c->sad[1] = ff_pix_abs8_neon;
@@ -82,9 +102,13 @@
         c->vsad[5] = vsad_intra8_neon;
 
         c->vsse[0] = vsse16_neon;
+        c->vsse[1] = vsse8_neon;
+
         c->vsse[4] = vsse_intra16_neon;
+        c->vsse[5] = vsse_intra8_neon;
 
         c->nsse[0] = nsse16_neon_wrapper;
+        c->nsse[1] = nsse8_neon_wrapper;
 
         c->median_sad[0] = pix_median_abs16_neon;
         c->median_sad[1] = pix_median_abs8_neon;
@@ -99,3 +123,12 @@
     else
         return nsse16_neon(8, s1, s2, stride, h);
 }
+
+int nsse8_neon_wrapper(MpegEncContext *c, const uint8_t *s1, const uint8_t *s2,
+                       ptrdiff_t stride, int h)
+{
+    if (c)
+        return nsse8_neon(c->avctx->nsse_weight, s1, s2, stride, h);
+    else
+        return nsse8_neon(8, s1, s2, stride, h);
+}
--- a/third_party/ffmpeg/libavcodec/aarch64/me_cmp_neon.S
+++ b/third_party/ffmpeg/libavcodec/aarch64/me_cmp_neon.S
@@ -119,6 +119,198 @@
         ret
 endfunc
 
+function ff_pix_abs8_x2_neon, export=1
+        // x0           unused
+        // x1           uint8_t *pix1
+        // x2           uint8_t *pix2
+        // x3           ptrdiff_t stride
+        // w4           int h
+
+        cmp             w4, #4
+        movi            v26.8h, #0
+        add             x5, x2, #1 // pix2 + 1
+        b.lt            2f
+
+// make 4 iterations at once
+1:
+        ld1             {v1.8b}, [x2], x3
+        ld1             {v2.8b}, [x5], x3
+        ld1             {v0.8b}, [x1], x3
+        ld1             {v4.8b}, [x2], x3
+        urhadd          v30.8b, v1.8b, v2.8b
+        ld1             {v5.8b}, [x5], x3
+        uabal           v26.8h, v0.8b, v30.8b
+        ld1             {v6.8b}, [x1], x3
+        urhadd          v29.8b, v4.8b, v5.8b
+        ld1             {v7.8b}, [x2], x3
+        ld1             {v20.8b}, [x5], x3
+        uabal           v26.8h, v6.8b, v29.8b
+        ld1             {v21.8b}, [x1], x3
+        urhadd          v28.8b, v7.8b, v20.8b
+        ld1             {v22.8b}, [x2], x3
+        ld1             {v23.8b}, [x5], x3
+        uabal           v26.8h, v21.8b, v28.8b
+        sub             w4, w4, #4
+        ld1             {v24.8b}, [x1], x3
+        urhadd          v27.8b, v22.8b, v23.8b
+        cmp             w4, #4
+        uabal           v26.8h, v24.8b, v27.8b
+
+        b.ge            1b
+        cbz             w4, 3f
+
+// iterate by one
+2:
+        ld1             {v1.8b}, [x2], x3
+        ld1             {v2.8b}, [x5], x3
+        ld1             {v0.8b}, [x1], x3
+        urhadd          v30.8b, v1.8b, v2.8b
+        subs            w4, w4, #1
+        uabal           v26.8h, v0.8b, v30.8b
+
+        b.ne            2b
+3:
+        uaddlv          s20, v26.8h
+        fmov            w0, s20
+
+        ret
+
+endfunc
+
+function ff_pix_abs8_y2_neon, export=1
+        // x0           unused
+        // x1           uint8_t *pix1
+        // x2           uint8_t *pix2
+        // x3           ptrdiff_t stride
+        // w4           int h
+
+        cmp             w4, #4
+        movi            v26.8h, #0
+        ld1             {v1.8b}, [x2], x3
+        b.lt            2f
+
+// make 4 iterations at once
+1:
+        ld1             {v2.8b}, [x2], x3
+        ld1             {v0.8b}, [x1], x3
+        urhadd          v30.8b, v1.8b, v2.8b
+        ld1             {v5.8b}, [x2], x3
+        ld1             {v6.8b}, [x1], x3
+        uabal           v26.8h, v0.8b, v30.8b
+        urhadd          v29.8b, v2.8b, v5.8b
+        ld1             {v20.8b}, [x2], x3
+        ld1             {v21.8b}, [x1], x3
+        uabal           v26.8h, v6.8b, v29.8b
+        urhadd          v28.8b, v5.8b, v20.8b
+        ld1             {v1.8b},  [x2], x3
+        ld1             {v24.8b}, [x1], x3
+        urhadd          v27.8b, v20.8b, v1.8b
+        sub             w4, w4, #4
+        uabal           v26.8h, v21.8b, v28.8b
+        cmp             w4, #4
+        uabal           v26.8h, v24.8b, v27.8b
+
+        b.ge            1b
+        cbz             w4, 3f
+
+// iterate by one
+2:
+        ld1             {v0.8b}, [x1], x3
+        ld1             {v2.8b}, [x2], x3
+        urhadd          v30.8b, v1.8b, v2.8b
+        subs            w4, w4, #1
+        uabal           v26.8h, v0.8b, v30.8b
+        mov             v1.8b, v2.8b
+
+        b.ne            2b
+3:
+        uaddlv          s20, v26.8h
+        fmov            w0, s20
+
+        ret
+
+endfunc
+
+function ff_pix_abs8_xy2_neon, export=1
+        // x0           unused
+        // x1           uint8_t *pix1
+        // x2           uint8_t *pix2
+        // x3           ptrdiff_t stride
+        // w4           int h
+
+        movi            v31.8h, #0
+        add             x0, x2, 1  // pix2 + 1
+
+        add             x5, x2, x3 // pix2 + stride = pix3
+        cmp             w4, #4
+        add             x6, x5, 1 // pix3 + stride + 1
+
+        ld1             {v0.8b}, [x2], x3
+        ld1             {v1.8b}, [x0], x3
+        uaddl           v2.8h, v0.8b, v1.8b
+
+        b.lt            2f
+
+// make 4 iterations at once
+1:
+        ld1             {v4.8b}, [x5], x3
+        ld1             {v5.8b}, [x6], x3
+        ld1             {v7.8b}, [x5], x3
+        uaddl           v0.8h, v4.8b, v5.8b
+        ld1             {v16.8b}, [x6], x3
+        add             v4.8h, v0.8h, v2.8h
+        ld1             {v5.8b}, [x1], x3
+        rshrn           v4.8b, v4.8h, #2
+        uaddl           v7.8h, v7.8b, v16.8b
+        uabal           v31.8h, v5.8b, v4.8b
+        add             v2.8h, v0.8h, v7.8h
+        ld1             {v17.8b}, [x1], x3
+        rshrn           v2.8b, v2.8h, #2
+        ld1             {v20.8b}, [x5], x3
+        uabal           v31.8h, v17.8b, v2.8b
+        ld1             {v21.8b}, [x6], x3
+        ld1             {v25.8b}, [x5], x3
+        uaddl           v20.8h, v20.8b, v21.8b
+        ld1             {v26.8b}, [x6], x3
+        add             v7.8h, v7.8h, v20.8h
+        uaddl           v25.8h, v25.8b, v26.8b
+        rshrn           v7.8b, v7.8h, #2
+        ld1             {v22.8b}, [x1], x3
+        mov             v2.16b, v25.16b
+        uabal           v31.8h, v22.8b, v7.8b
+        add             v20.8h, v20.8h, v25.8h
+        ld1             {v27.8b}, [x1], x3
+        sub             w4, w4, #4
+        rshrn           v20.8b, v20.8h, #2
+        cmp             w4, #4
+        uabal           v31.8h, v27.8b, v20.8b
+
+        b.ge            1b
+
+        cbz             w4, 3f
+
+// iterate by one
+2:
+        ld1             {v0.8b}, [x5], x3
+        ld1             {v1.8b}, [x6], x3
+        ld1             {v4.8b}, [x1], x3
+        uaddl           v21.8h, v0.8b, v1.8b
+        subs            w4, w4, #1
+        add             v3.8h, v2.8h, v21.8h
+        mov             v2.16b, v21.16b
+        rshrn           v3.8b, v3.8h, #2
+        uabal           v31.8h, v4.8b, v3.8b
+        b.ne            2b
+
+3:
+        uaddlv          s18, v31.8h
+        fmov            w0, s18
+
+        ret
+
+endfunc
+
+
 function ff_pix_abs16_xy2_neon, export=1
         // x0           unused
         // x1           uint8_t *pix1
@@ -326,9 +518,9 @@
         // w4           int h
 
         // initialize buffers
+        ld1             {v1.16b}, [x2], x3              // Load pix2
         movi            v29.8h, #0                      // clear the accumulator
         movi            v28.8h, #0                      // clear the accumulator
-        add             x5, x2, x3                      // pix2 + stride
         cmp             w4, #4
         b.lt            2f
 
@@ -339,29 +531,25 @@
         // avg2(a, b) = (((a) + (b) + 1) >> 1)
         // abs(x) = (x < 0 ? (-x) : (x))
 
-        ld1             {v1.16b}, [x2], x3              // Load pix2 for first iteration
-        ld1             {v2.16b}, [x5], x3              // Load pix3 for first iteration
+        ld1             {v2.16b}, [x2], x3              // Load pix3 for first iteration
         ld1             {v0.16b}, [x1], x3              // Load pix1 for first iteration
         urhadd          v30.16b, v1.16b, v2.16b         // Rounding halving add, first iteration
-        ld1             {v4.16b}, [x2], x3              // Load pix2 for second iteration
-        ld1             {v5.16b}, [x5], x3              // Load pix3 for second iteartion
+        ld1             {v5.16b}, [x2], x3              // Load pix3 for second iteartion
         uabal           v29.8h, v0.8b, v30.8b           // Absolute difference of lower half, first iteration
         uabal2          v28.8h, v0.16b, v30.16b         // Absolute difference of upper half, first iteration
         ld1             {v3.16b}, [x1], x3              // Load pix1 for second iteration
-        urhadd          v27.16b, v4.16b, v5.16b         // Rounding halving add, second iteration
-        ld1             {v7.16b}, [x2], x3              // Load pix2 for third iteration
-        ld1             {v20.16b}, [x5], x3             // Load pix3 for third iteration
+        urhadd          v27.16b, v2.16b, v5.16b         // Rounding halving add, second iteration
+        ld1             {v20.16b}, [x2], x3             // Load pix3 for third iteration
         uabal           v29.8h, v3.8b, v27.8b           // Absolute difference of lower half for second iteration
         uabal2          v28.8h, v3.16b, v27.16b         // Absolute difference of upper half for second iteration
         ld1             {v6.16b}, [x1], x3              // Load pix1 for third iteration
-        urhadd          v26.16b, v7.16b, v20.16b        // Rounding halving add, third iteration
-        ld1             {v22.16b}, [x2], x3             // Load pix2 for fourth iteration
-        ld1             {v23.16b}, [x5], x3             // Load pix3 for fourth iteration
+        urhadd          v26.16b, v5.16b, v20.16b        // Rounding halving add, third iteration
+        ld1             {v1.16b}, [x2], x3              // Load pix3 for fourth iteration
         uabal           v29.8h, v6.8b, v26.8b           // Absolute difference of lower half for third iteration
         uabal2          v28.8h, v6.16b, v26.16b         // Absolute difference of upper half for third iteration
         ld1             {v21.16b}, [x1], x3             // Load pix1 for fourth iteration
         sub             w4, w4, #4                      // h-= 4
-        urhadd          v25.16b, v22.16b, v23.16b       // Rounding halving add
+        urhadd          v25.16b, v20.16b, v1.16b        // Rounding halving add
         cmp             w4, #4
         uabal           v29.8h, v21.8b, v25.8b          // Absolute difference of lower half for fourth iteration
         uabal2          v28.8h, v21.16b, v25.16b        // Absolute difference of upper half for fourth iteration
@@ -372,11 +560,11 @@
 // iterate by one
 2:
 
-        ld1             {v1.16b}, [x2], x3              // Load pix2
-        ld1             {v2.16b}, [x5], x3              // Load pix3
+        ld1             {v2.16b}, [x2], x3              // Load pix3
         subs            w4, w4, #1
         ld1             {v0.16b}, [x1], x3              // Load pix1
         urhadd          v30.16b, v1.16b, v2.16b         // Rounding halving add
+        mov             v1.16b, v2.16b                  // Shift pix3->pix2
         uabal           v29.8h, v30.8b, v0.8b
         uabal2          v28.8h, v30.16b, v0.16b
 
@@ -475,7 +663,7 @@
         movi            v21.4s, #0
         movi            v20.4s, #0
         cmp             w4, #4
-        b.le            2f
+        b.lt            2f
 
 // make 4 iterations at once
 1:
@@ -538,7 +726,7 @@
 
         movi            v16.4s, #0                      // clear the result accumulator
         cmp             w4, #4
-        b.le            2f
+        b.lt            2f
 
 // make 4 iterations at once
 1:
@@ -650,6 +838,76 @@
         ret
 endfunc
 
+function vsse8_neon, export=1
+        // x0           unused
+        // x1           uint8_t *pix1
+        // x2           uint8_t *pix2
+        // x3           ptrdiff_t stride
+        // w4           int h
+
+        ld1             {v0.8b}, [x1], x3              // Load pix1[0], first iteration
+        ld1             {v1.8b}, [x2], x3              // Load pix2[0], first iteration
+
+        sub             w4, w4, #1                      // we need to make h-1 iterations
+        movi            v16.4s, #0
+        movi            v17.4s, #0
+
+        cmp             w4, #3                          // check if we can make 3 iterations at once
+        usubl           v31.8h, v0.8b, v1.8b            // Signed difference of pix1[0] - pix2[0], first iteration
+        b.lt            2f
+
+
+1:
+        // x = abs(pix1[0] - pix2[0] - pix1[0 + stride] + pix2[0 + stride])
+        // res = (x) * (x)
+        ld1             {v0.8b}, [x1], x3              // Load pix1[0 + stride], first iteration
+        ld1             {v1.8b}, [x2], x3              // Load pix2[0 + stride], first iteration
+        ld1             {v2.8b}, [x1], x3              // Load pix1[0 + stride], second iteration
+        ld1             {v3.8b}, [x2], x3              // Load pix2[0 + stride], second iteration
+        usubl           v29.8h, v0.8b, v1.8b
+        usubl2          v28.8h, v0.16b, v1.16b
+        ld1             {v4.8b}, [x1], x3              // Load pix1[0 + stride], third iteration
+        ld1             {v5.8b}, [x2], x3              // Load pix1[0 + stride], third iteration
+        sabd            v31.8h, v31.8h, v29.8h
+        usubl           v27.8h, v2.8b, v3.8b
+        usubl           v25.8h, v4.8b, v5.8b
+        sabd            v29.8h, v29.8h, v27.8h
+        sabd            v27.8h, v27.8h, v25.8h
+        umlal           v16.4s, v31.4h, v31.4h
+        umlal2          v17.4s, v31.8h, v31.8h
+        mov             v31.16b, v25.16b
+        umlal           v16.4s, v29.4h, v29.4h
+        umlal2          v17.4s, v29.8h, v29.8h
+        sub             w4, w4, #3
+        umlal           v16.4s, v27.4h, v27.4h
+        umlal2          v17.4s, v27.8h, v27.8h
+        cmp             w4, #3
+
+        b.ge            1b
+
+        cbz             w4, 3f
+
+// iterate by once
+2:
+        ld1             {v0.8b}, [x1], x3
+        ld1             {v1.8b}, [x2], x3
+        subs            w4, w4, #1
+        usubl           v29.8h, v0.8b, v1.8b
+        sabd            v31.8h, v31.8h, v29.8h
+        umlal           v16.4s, v31.4h, v31.4h
+        umlal2          v17.4s, v31.8h, v31.8h
+        mov             v31.16b, v29.16b
+        b.ne            2b
+
+3:
+        add             v16.4s, v16.4s, v17.4s
+        uaddlv          d17, v16.4s
+        fmov            w0, s17
+
+        ret
+endfunc
+
+
 function vsse16_neon, export=1
         // x0           unused
         // x1           uint8_t *pix1
@@ -667,7 +925,7 @@
         cmp             w4, #3                          // check if we can make 3 iterations at once
         usubl           v31.8h, v0.8b, v1.8b            // Signed difference of pix1[0] - pix2[0], first iteration
         usubl2          v30.8h, v0.16b, v1.16b          // Signed difference of pix1[0] - pix2[0], first iteration
-        b.le            2f
+        b.lt            2f
 
 
 1:
@@ -848,6 +1106,59 @@
         ret
 endfunc
 
+function vsse_intra8_neon, export=1
+        // x0           unused
+        // x1           uint8_t *pix1
+        // x2           uint8_t *dummy
+        // x3           ptrdiff_t stride
+        // w4           int h
+
+        sub             w4, w4, #1 // we need to make h-1 iterations
+        ld1             {v0.8b}, [x1], x3
+        cmp             w4, #3
+        movi            v16.4s, #0
+
+        b.lt            2f
+
+1:
+        // v = abs( pix1[0] - pix1[0 + stride] )
+        // score = sum( v * v )
+        ld1             {v1.8b}, [x1], x3
+        ld1             {v2.8b}, [x1], x3
+        uabd            v30.8b, v0.8b, v1.8b
+        ld1             {v3.8b}, [x1], x3
+        uabd            v27.8b, v1.8b, v2.8b
+        umull           v29.8h, v30.8b, v30.8b
+        uabd            v25.8b, v2.8b, v3.8b
+        umull           v26.8h, v27.8b, v27.8b
+        uadalp          v16.4s, v29.8h
+        umull           v24.8h, v25.8b, v25.8b
+        uadalp          v16.4s, v26.8h
+        sub             w4, w4, #3
+        uadalp          v16.4s, v24.8h
+        cmp             w4, #3
+        mov             v0.8b, v3.8b
+
+        b.ge            1b
+        cbz             w4, 3f
+
+// iterate by one
+2:
+        ld1             {v1.8b}, [x1], x3
+        subs            w4, w4, #1
+        uabd            v30.8b, v0.8b, v1.8b
+        mov             v0.8b, v1.8b
+        umull           v29.8h, v30.8b, v30.8b
+        uadalp          v16.4s, v29.8h
+        cbnz            w4, 2b
+
+3:
+        uaddlv          d17, v16.4s
+        fmov            w0, s17
+
+        ret
+endfunc
+
 function nsse16_neon, export=1
         // x0           multiplier
         // x1           uint8_t *pix1
@@ -862,10 +1173,9 @@
         bl              X(sse16_neon)
         ldr             x30, [sp, #0x30]
         mov             w9, w0                                  // here we store score1
-        ldr             x5, [sp]
         ldp             x1, x2, [sp, #0x10]
         ldp             x3, x4, [sp, #0x20]
-        add             sp, sp, #0x40
+        ldr             x5, [sp], #0x40
 
         movi            v16.8h, #0
         movi            v17.8h, #0
@@ -963,6 +1273,104 @@
         saddlv          s16, v16.8h
         sqabs           s16, s16
         fmov            w0, s16
+
+        mul             w0, w0, w5
+        add             w0, w0, w9
+
+        ret
+endfunc
+
+function nsse8_neon, export=1
+        // x0           multiplier
+        // x1           uint8_t *pix1
+        // x2           uint8_t *pix2
+        // x3           ptrdiff_t stride
+        // w4           int h
+
+        str             x0, [sp, #-0x40]!
+        stp             x1, x2, [sp, #0x10]
+        stp             x3, x4, [sp, #0x20]
+        str             x30, [sp, #0x30]
+        bl              X(sse8_neon)
+        ldr             x30, [sp, #0x30]
+        mov             w9, w0                                  // here we store score1
+        ldp             x1, x2, [sp, #0x10]
+        ldp             x3, x4, [sp, #0x20]
+        ldr             x5, [sp], #0x40
+
+        movi            v16.8h, #0
+        movi            v17.8h, #0
+        movi            v18.8h, #0
+        movi            v19.8h, #0
+
+        ld1             {v0.8b}, [x1], x3
+        subs            w4, w4, #1                              // we need to make h-1 iterations
+        ext             v1.8b, v0.8b, v0.8b, #1                 // x1 + 1
+        ld1             {v2.8b}, [x2], x3
+        cmp             w4, #2
+        ext             v3.8b, v2.8b, v2.8b, #1                 // x2 + 1
+
+        b.lt            2f
+
+// make 2 iterations at once
+1:
+        ld1             {v4.8b}, [x1], x3
+        ld1             {v20.8b}, [x1], x3
+        ld1             {v6.8b}, [x2], x3
+        ext             v5.8b, v4.8b, v4.8b, #1                 // x1 + stride + 1
+        ext             v21.8b, v20.8b, v20.8b, #1
+        ld1             {v22.8b}, [x2], x3
+        ext             v7.8b, v6.8b, v6.8b, #1                 // x2 + stride + 1
+        usubl           v31.8h, v0.8b, v4.8b
+        ext             v23.8b, v22.8b, v22.8b, #1
+        usubl           v29.8h, v1.8b, v5.8b
+        usubl           v27.8h, v2.8b, v6.8b
+        usubl           v25.8h, v3.8b, v7.8b
+        saba            v16.8h, v31.8h, v29.8h
+        usubl           v31.8h, v4.8b, v20.8b
+        saba            v18.8h, v27.8h, v25.8h
+        sub             w4, w4, #2
+        usubl           v29.8h, v5.8b, v21.8b
+        mov             v0.16b, v20.16b
+        mov             v1.16b, v21.16b
+        saba            v16.8h, v31.8h, v29.8h
+        usubl           v27.8h, v6.8b, v22.8b
+        usubl           v25.8h, v7.8b, v23.8b
+        mov             v2.16b, v22.16b
+        mov             v3.16b, v23.16b
+        cmp             w4, #2
+        saba            v18.8h, v27.8h, v25.8h
+        b.ge            1b
+        cbz             w4, 3f
+
+// iterate by one
+2:
+        ld1             {v4.8b}, [x1], x3
+        subs            w4, w4, #1
+        ext             v5.8b, v4.8b, v4.8b, #1                 // x1 + stride + 1
+        ld1             {v6.8b}, [x2], x3
+        usubl           v31.8h, v0.8b, v4.8b
+        ext             v7.8b, v6.8b, v6.8b, #1                 // x2 + stride + 1
+
+        usubl           v29.8h, v1.8b, v5.8b
+        saba            v16.8h, v31.8h, v29.8h
+        usubl           v27.8h, v2.8b, v6.8b
+        usubl           v25.8h, v3.8b, v7.8b
+        saba            v18.8h, v27.8h, v25.8h
+
+        mov             v0.16b, v4.16b
+        mov             v1.16b, v5.16b
+        mov             v2.16b, v6.16b
+        mov             v3.16b, v7.16b
+
+        cbnz            w4, 2b
+
+3:
+        sqsub           v16.8h, v16.8h, v18.8h
+        ins             v16.h[7], wzr
+        saddlv          s16, v16.8h
+        sqabs           s16, s16
+        fmov            w0, s16
 
         mul             w0, w0, w5
         add             w0, w0, w9
--- a/third_party/ffmpeg/libavcodec/aarch64/synth_filter_neon.S
+++ b/third_party/ffmpeg/libavcodec/aarch64/synth_filter_neon.S
@@ -61,11 +61,11 @@
 
         blr             x9
 
-        ldp             x2,  x4,  [sp]          // synct_buf_2, window
         ldp             x13, x9,  [sp, #16]     // out, synth_buf
         ldp             x0,  x30, [sp, #32]     // *synth_buf_offset
         AARCH64_VALIDATE_LINK_REGISTER
         ldr             s0,  [sp, #48]
+        ldp             x2,  x4,  [sp], #64     // synct_buf_2, window
 
         add             x3,  x2,  #16*4         // synct_buf_2 + 16
         add             x14, x13, #16*4         // out + 16
@@ -116,6 +116,5 @@
         b               1b
 
 10:
-        add             sp,  sp,  #64
         ret
 endfunc
--- a/third_party/ffmpeg/libavcodec/aarch64/vp9itxfm_neon.S
+++ b/third_party/ffmpeg/libavcodec/aarch64/vp9itxfm_neon.S
@@ -850,10 +850,10 @@
         mov             x15, x30
         // iadst16 requires clobbering v8-v15, but idct16 doesn't need to.
 .ifnc \txfm1\()_\txfm2,idct_idct
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
 .endif
 
         sub             sp,  sp,  #512
@@ -920,10 +920,10 @@
 
         add             sp,  sp,  #512
 .ifnc \txfm1\()_\txfm2,idct_idct
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
 .endif
         ret             x15
 endfunc
@@ -1486,8 +1486,8 @@
 
         mov             x15, x30
 
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x20]!
+        stp             d10, d11, [sp, #0x10]
 
         sub             sp,  sp,  #2048
 
@@ -1544,8 +1544,8 @@
 
         add             sp,  sp,  #2048
 
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d8,  d9,  [sp], #0x20
 
         ret             x15
 endfunc
@@ -1569,8 +1569,8 @@
 
         add             sp,  sp,  #2048
 
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d8,  d9,  [sp], #0x20
 
         ret             x15
 endfunc
--- a/third_party/ffmpeg/libavcodec/aarch64/vp9lpf_16bpp_neon.S
+++ b/third_party/ffmpeg/libavcodec/aarch64/vp9lpf_16bpp_neon.S
@@ -417,10 +417,10 @@
 function ff_\func\()_\bpp\()_neon, export=1
 .if \push
         mov             x16, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
 .endif
         lsl             w2,  w2,  #\bpp - 8
         lsl             w3,  w3,  #\bpp - 8
@@ -430,10 +430,10 @@
         mov             x7,  #((1 << \bpp) - 1)
 .if \push
         bl              \func\()_16_neon
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
         ret             x16
 .else
         b               \func\()_16_neon
@@ -450,10 +450,10 @@
 function ff_\func\()_\suffix\()_\bpp\()_neon, export=1
         mov             x16, x30
 .if \push
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
 .endif
         lsl             w2,  w2,  #\bpp - 8
         lsl             w3,  w3,  #\bpp - 8
@@ -469,10 +469,10 @@
 .endif
         bl              \func\()_\int_suffix\()_16_neon
 .if \push
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], 0x40
 .endif
         ret             x16
 endfunc
--- a/third_party/ffmpeg/libavcodec/aarch64/vp9lpf_neon.S
+++ b/third_party/ffmpeg/libavcodec/aarch64/vp9lpf_neon.S
@@ -564,10 +564,10 @@
         loop_filter     16, .8b,  0,    v8,  v9,  v10, v11, v12, v13, v14, v15
         ret
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
         ret             x10
 endfunc
 
@@ -575,10 +575,10 @@
         loop_filter     16, .16b, 0,    v8,  v9,  v10, v11, v12, v13, v14, v15
         ret
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
         ret             x10
 endfunc
 
@@ -973,10 +973,10 @@
 
 function ff_vp9_loop_filter_v_16_8_neon, export=1
         mov             x10, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
         sub             x9,  x0,  x1, lsl #3
         ld1             {v16.8b}, [x9], x1 // p7
         ld1             {v24.8b}, [x0], x1 // q0
@@ -1018,10 +1018,10 @@
         st1             {v9.8b},  [x9], x1
         st1             {v17.8b}, [x0], x1
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
         ret             x10
 8:
         add             x9,  x9,  x1, lsl #2
@@ -1045,10 +1045,10 @@
 
 function ff_vp9_loop_filter_v_16_16_neon, export=1
         mov             x10, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
         sub             x9,  x0,  x1, lsl #3
         ld1             {v16.16b}, [x9], x1 // p7
         ld1             {v24.16b}, [x0], x1 // q0
@@ -1087,10 +1087,10 @@
         st1             {v9.16b},  [x9], x1
         st1             {v17.16b}, [x0], x1
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
         ret             x10
 8:
         add             x9,  x9,  x1, lsl #2
@@ -1112,10 +1112,10 @@
 
 function ff_vp9_loop_filter_h_16_8_neon, export=1
         mov             x10, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
         sub             x9,  x0,  #8
         ld1             {v16.8b}, [x9], x1
         ld1             {v24.8b}, [x0], x1
@@ -1164,10 +1164,10 @@
         st1             {v9.8b},  [x9], x1
         st1             {v31.8b}, [x0], x1
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
         ret             x10
 8:
         // The same writeback as in loop_filter_h_8_8
@@ -1202,10 +1202,10 @@
 
 function ff_vp9_loop_filter_h_16_16_neon, export=1
         mov             x10, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
         sub             x9,  x0,  #8
         ld1             {v16.8b},   [x9], x1
         ld1             {v24.8b},   [x0], x1
@@ -1283,10 +1283,10 @@
         st1             {v9.d}[1],  [x9], x1
         st1             {v31.d}[1], [x0], x1
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
         ret             x10
 8:
         sub             x9,  x0,  #4
--- a/third_party/ffmpeg/libavcodec/ac3_parser.c
+++ b/third_party/ffmpeg/libavcodec/ac3_parser.c
@@ -53,6 +53,33 @@
  */
 static const uint8_t surround_levels[4] = { 4, 6, 7, 6 };
 
+/*** Chromium: vvv end #if CONFIG_AC3_PARSER */
+#endif
+/*** Chromium: ^^^ end #if CONFIG_AC3_PARSER */
+
+int ff_ac3_find_syncword(const uint8_t *buf, int buf_size)
+{
+    int i;
+
+    for (i = 1; i < buf_size; i += 2) {
+        if (buf[i] == 0x77 || buf[i] == 0x0B) {
+            if ((buf[i] ^ buf[i-1]) == (0x77 ^ 0x0B)) {
+                i--;
+                break;
+            } else if ((buf[i] ^ buf[i+1]) == (0x77 ^ 0x0B)) {
+                break;
+            }
+        }
+    }
+    if (i >= buf_size)
+        return AVERROR_INVALIDDATA;
+
+    return i;
+}
+
+/*** Chromium: vvv restart #if CONFIG_AC3_PARSER */
+#if CONFIG_AC3_PARSER
+/*** Chromium: ^^^ restart #if CONFIG_AC3_PARSER */
 
 int ff_ac3_parse_header(GetBitContext *gbc, AC3HeaderInfo *hdr)
 {
@@ -196,8 +223,7 @@
     return 0;
 }
 
-static int ac3_sync(uint64_t state, AACAC3ParseContext *hdr_info,
-        int *need_next_header, int *new_frame_start)
+static int ac3_sync(uint64_t state, int *need_next_header, int *new_frame_start)
 {
     int err;
     union {
@@ -219,19 +245,6 @@
     if(err < 0)
         return 0;
 
-    hdr_info->sample_rate = hdr.sample_rate;
-    hdr_info->bit_rate = hdr.bit_rate;
-    hdr_info->channels = hdr.channels;
-    hdr_info->channel_layout = hdr.channel_layout;
-    hdr_info->samples = hdr.num_blocks * 256;
-    hdr_info->service_type = hdr.bitstream_mode;
-    if (hdr.bitstream_mode == 0x7 && hdr.channels > 1)
-        hdr_info->service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE;
-    if(hdr.bitstream_id>10)
-        hdr_info->codec_id = AV_CODEC_ID_EAC3;
-    else if (hdr_info->codec_id == AV_CODEC_ID_NONE)
-        hdr_info->codec_id = AV_CODEC_ID_AC3;
-
     *new_frame_start  = (hdr.frame_type != EAC3_FRAME_TYPE_DEPENDENT);
     *need_next_header = *new_frame_start || (hdr.frame_type != EAC3_FRAME_TYPE_AC3_CONVERT);
     return hdr.frame_size;
@@ -241,6 +254,7 @@
 {
     AACAC3ParseContext *s = s1->priv_data;
     s->header_size = AC3_HEADER_SIZE;
+    s->crc_ctx = av_crc_get_table(AV_CRC_16_ANSI);
     s->sync = ac3_sync;
     return 0;
 }
--- a/third_party/ffmpeg/libavcodec/ac3_parser_internal.h
+++ b/third_party/ffmpeg/libavcodec/ac3_parser_internal.h
@@ -79,4 +79,6 @@
 int avpriv_ac3_parse_header(AC3HeaderInfo **hdr, const uint8_t *buf,
                             size_t size);
 
+int ff_ac3_find_syncword(const uint8_t *buf, int buf_size);
+
 #endif /* AVCODEC_AC3_PARSER_INTERNAL_H */
--- a/third_party/ffmpeg/libavcodec/ac3dec.c
+++ b/third_party/ffmpeg/libavcodec/ac3dec.c
@@ -236,7 +236,7 @@
     if (!s->fdsp)
         return AVERROR(ENOMEM);
 
-    ff_ac3dsp_init(&s->ac3dsp, avctx->flags & AV_CODEC_FLAG_BITEXACT);
+    ff_ac3dsp_init(&s->ac3dsp);
     av_lfg_init(&s->dith_state, 0);
 
     if (USE_FIXED)
@@ -1508,19 +1508,8 @@
     s->superframe_size = 0;
 
     buf_size = full_buf_size;
-    for (i = 1; i < buf_size; i += 2) {
-        if (buf[i] == 0x77 || buf[i] == 0x0B) {
-            if ((buf[i] ^ buf[i-1]) == (0x77 ^ 0x0B)) {
-                i--;
-                break;
-            } else if ((buf[i] ^ buf[i+1]) == (0x77 ^ 0x0B)) {
-                break;
-            }
-        }
-    }
-    if (i >= buf_size)
-        return AVERROR_INVALIDDATA;
-    if (i > 10)
+    i = ff_ac3_find_syncword(buf, buf_size);
+    if (i < 0 || i > 10)
         return i;
     buf += i;
     buf_size -= i;
--- a/third_party/ffmpeg/libavcodec/ac3dsp.c
+++ b/third_party/ffmpeg/libavcodec/ac3dsp.c
@@ -374,7 +374,7 @@
         ac3_downmix_c(samples, matrix, out_ch, in_ch, len);
 }
 
-av_cold void ff_ac3dsp_init(AC3DSPContext *c, int bit_exact)
+av_cold void ff_ac3dsp_init(AC3DSPContext *c)
 {
     c->ac3_exponent_min = ac3_exponent_min_c;
     c->float_to_fixed24 = float_to_fixed24_c;
@@ -390,10 +390,10 @@
     c->downmix_fixed         = NULL;
 
 #if ARCH_ARM
-    ff_ac3dsp_init_arm(c, bit_exact);
+    ff_ac3dsp_init_arm(c);
 #elif ARCH_X86
-    ff_ac3dsp_init_x86(c, bit_exact);
+    ff_ac3dsp_init_x86(c);
 #elif ARCH_MIPS
-    ff_ac3dsp_init_mips(c, bit_exact);
+    ff_ac3dsp_init_mips(c);
 #endif
 }
--- a/third_party/ffmpeg/libavcodec/ac3dsp.h
+++ b/third_party/ffmpeg/libavcodec/ac3dsp.h
@@ -105,10 +105,10 @@
     void (*downmix_fixed)(int32_t **samples, int16_t **matrix, int len);
 } AC3DSPContext;
 
-void ff_ac3dsp_init    (AC3DSPContext *c, int bit_exact);
-void ff_ac3dsp_init_arm(AC3DSPContext *c, int bit_exact);
-void ff_ac3dsp_init_x86(AC3DSPContext *c, int bit_exact);
-void ff_ac3dsp_init_mips(AC3DSPContext *c, int bit_exact);
+void ff_ac3dsp_init    (AC3DSPContext *c);
+void ff_ac3dsp_init_arm(AC3DSPContext *c);
+void ff_ac3dsp_init_x86(AC3DSPContext *c);
+void ff_ac3dsp_init_mips(AC3DSPContext *c);
 
 void ff_ac3dsp_downmix(AC3DSPContext *c, float **samples, float **matrix,
                        int out_ch, int in_ch, int len);
--- a/third_party/ffmpeg/libavcodec/ac3enc.c
+++ b/third_party/ffmpeg/libavcodec/ac3enc.c
@@ -2613,7 +2613,7 @@
 
     ff_audiodsp_init(&s->adsp);
     ff_me_cmp_init(&s->mecc, avctx);
-    ff_ac3dsp_init(&s->ac3dsp, avctx->flags & AV_CODEC_FLAG_BITEXACT);
+    ff_ac3dsp_init(&s->ac3dsp);
 
     dprint_options(s);
 
--- a/third_party/ffmpeg/libavcodec/ac3enc_fixed.c
+++ b/third_party/ffmpeg/libavcodec/ac3enc_fixed.c
@@ -119,7 +119,6 @@
 }
 
 
-FF_DISABLE_DEPRECATION_WARNINGS
 const FFCodec ff_ac3_fixed_encoder = {
     .p.name          = "ac3_fixed",
     CODEC_LONG_NAME("ATSC A/52A (AC-3)"),
@@ -135,10 +134,7 @@
     .p.priv_class    = &ff_ac3enc_class,
     .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
     .p.supported_samplerates = ff_ac3_sample_rate_tab,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = ff_ac3_channel_layouts,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(ff_ac3_channel_layouts)
     .p.ch_layouts    = ff_ac3_ch_layouts,
     .defaults        = ff_ac3_enc_defaults,
 };
-FF_ENABLE_DEPRECATION_WARNINGS
--- a/third_party/ffmpeg/libavcodec/ac3enc_float.c
+++ b/third_party/ffmpeg/libavcodec/ac3enc_float.c
@@ -123,7 +123,6 @@
     return ff_ac3_encode_init(avctx);
 }
 
-FF_DISABLE_DEPRECATION_WARNINGS
 const FFCodec ff_ac3_encoder = {
     .p.name          = "ac3",
     CODEC_LONG_NAME("ATSC A/52A (AC-3)"),
@@ -138,11 +137,8 @@
                                                       AV_SAMPLE_FMT_NONE },
     .p.priv_class    = &ff_ac3enc_class,
     .p.supported_samplerates = ff_ac3_sample_rate_tab,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = ff_ac3_channel_layouts,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(ff_ac3_channel_layouts)
     .p.ch_layouts    = ff_ac3_ch_layouts,
     .defaults        = ff_ac3_enc_defaults,
     .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 };
-FF_ENABLE_DEPRECATION_WARNINGS
--- a/third_party/ffmpeg/libavcodec/adts_header.c
+++ b/third_party/ffmpeg/libavcodec/adts_header.c
@@ -32,6 +32,8 @@
     int size, rdb, ch, sr;
     int aot, crc_abs;
 
+    memset(hdr, 0, sizeof(*hdr));
+
     if (get_bits(gbc, 12) != 0xfff)
         return AAC_AC3_PARSE_ERROR_SYNC;
 
--- a/third_party/ffmpeg/libavcodec/adts_parser.c
+++ b/third_party/ffmpeg/libavcodec/adts_parser.c
@@ -47,24 +47,30 @@
 {
 #if CONFIG_ADTS_HEADER
     int ret = 0;
+    int allocated = 0;
     GetBitContext gb;
 
     if (!phdr || !buf || size < AV_AAC_ADTS_HEADER_SIZE)
         return AVERROR_INVALIDDATA;
 
-    *phdr = av_mallocz(sizeof(AACADTSHeaderInfo));
+    if (!*phdr) {
+        allocated = 1;
+        *phdr = av_mallocz(sizeof(AACADTSHeaderInfo));
+    }
     if (!*phdr)
         return AVERROR(ENOMEM);
 
     ret = init_get_bits8(&gb, buf, AV_AAC_ADTS_HEADER_SIZE);
     if (ret < 0) {
-        av_freep(phdr);
+        if (allocated)
+            av_freep(phdr);
         return ret;
     }
 
     ret = ff_adts_header_parse(&gb, *phdr);
     if (ret < 0) {
-        av_freep(phdr);
+        if (allocated)
+            av_freep(phdr);
         return ret;
     }
 
--- a/third_party/ffmpeg/libavcodec/agm.c
+++ b/third_party/ffmpeg/libavcodec/agm.c
@@ -33,24 +33,7 @@
 #include "decode.h"
 #include "get_bits.h"
 #include "idctdsp.h"
-
-static const uint8_t unscaled_luma[64] = {
-    16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19,
-    26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56,
-    14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56,
-    68,109,103, 77, 24, 35, 55, 64, 81,104,113, 92,
-    49, 64, 78, 87,103,121,120,101, 72, 92, 95, 98,
-    112,100,103,99
-};
-
-static const uint8_t unscaled_chroma[64] = {
-    17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66,
-    99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99,
-    47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99
-};
+#include "jpegquanttables.h"
 
 typedef struct MotionVector {
     int16_t x, y;
@@ -88,7 +71,7 @@
     int luma_quant_matrix[64];
     int chroma_quant_matrix[64];
 
-    ScanTable scantable;
+    uint8_t permutated_scantable[64];
     DECLARE_ALIGNED(32, int16_t, block)[64];
 
     int16_t *wblocks;
@@ -195,7 +178,7 @@
 static int decode_intra_blocks(AGMContext *s, GetBitContext *gb,
                                const int *quant_matrix, int *skip, int *dc_level)
 {
-    const uint8_t *scantable = s->scantable.permutated;
+    const uint8_t *scantable = s->permutated_scantable;
     int level, ret, map = 0;
 
     memset(s->wblocks, 0, s->wblocks_size);
@@ -237,7 +220,7 @@
                                const int *quant_matrix, int *skip,
                                int *map)
 {
-    const uint8_t *scantable = s->scantable.permutated;
+    const uint8_t *scantable = s->permutated_scantable;
     int level, ret;
 
     memset(s->wblocks, 0, s->wblocks_size);
@@ -272,7 +255,7 @@
 static int decode_intra_block(AGMContext *s, GetBitContext *gb,
                               const int *quant_matrix, int *skip, int *dc_level)
 {
-    const uint8_t *scantable = s->scantable.permutated;
+    const uint8_t *scantable = s->permutated_scantable;
     const int offset = s->plus ? 0 : 1024;
     int16_t *block = s->block;
     int level, ret, map = 0;
@@ -362,7 +345,7 @@
                               const int *quant_matrix, int *skip,
                               int *map)
 {
-    const uint8_t *scantable = s->scantable.permutated;
+    const uint8_t *scantable = s->permutated_scantable;
     int16_t *block = s->block;
     int level, ret;
 
@@ -550,13 +533,13 @@
     } else {
         if (qscale >= 0.0) {
             for (int i = 0; i < 64; i++) {
-                luma[i]   = FFMAX(1, unscaled_luma  [(i & 7) * 8 + (i >> 3)] * f);
-                chroma[i] = FFMAX(1, unscaled_chroma[(i & 7) * 8 + (i >> 3)] * f);
+                luma[i]   = FFMAX(1, ff_mjpeg_std_luminance_quant_tbl  [(i & 7) * 8 + (i >> 3)] * f);
+                chroma[i] = FFMAX(1, ff_mjpeg_std_chrominance_quant_tbl[(i & 7) * 8 + (i >> 3)] * f);
             }
         } else {
             for (int i = 0; i < 64; i++) {
-                luma[i]   = FFMAX(1, 255.0 - (255 - unscaled_luma  [(i & 7) * 8 + (i >> 3)]) * f);
-                chroma[i] = FFMAX(1, 255.0 - (255 - unscaled_chroma[(i & 7) * 8 + (i >> 3)]) * f);
+                luma[i]   = FFMAX(1, 255.0 - (255 - ff_mjpeg_std_luminance_quant_tbl  [(i & 7) * 8 + (i >> 3)]) * f);
+                chroma[i] = FFMAX(1, 255.0 - (255 - ff_mjpeg_std_chrominance_quant_tbl[(i & 7) * 8 + (i >> 3)]) * f);
             }
         }
     }
@@ -1249,7 +1232,8 @@
 
     avctx->idct_algo = FF_IDCT_SIMPLE;
     ff_idctdsp_init(&s->idsp, avctx);
-    ff_init_scantable(s->idsp.idct_permutation, &s->scantable, ff_zigzag_direct);
+    ff_permute_scantable(s->permutated_scantable, ff_zigzag_direct,
+                         s->idsp.idct_permutation);
 
     s->prev_frame = av_frame_alloc();
     if (!s->prev_frame)
--- a/third_party/ffmpeg/libavcodec/aic.c
+++ b/third_party/ffmpeg/libavcodec/aic.c
@@ -143,7 +143,6 @@
     AVCodecContext *avctx;
     AVFrame        *frame;
     IDCTDSPContext idsp;
-    ScanTable      scantable;
 
     int            num_x_slices;
     int            slice_width;
@@ -348,10 +347,10 @@
     for (mb = 0; mb < slice_width; mb++) {
         for (blk = 0; blk < 4; blk++) {
             if (!ctx->interlaced)
-                recombine_block(ctx->block, ctx->scantable.permutated,
+                recombine_block(ctx->block, ctx->idsp.idct_permutation,
                                 &base_y, &ext_y);
             else
-                recombine_block_il(ctx->block, ctx->scantable.permutated,
+                recombine_block_il(ctx->block, ctx->idsp.idct_permutation,
                                    &base_y, &ext_y, blk);
             unquant_block(ctx->block, ctx->quant, ctx->quant_matrix);
             ctx->idsp.idct(ctx->block);
@@ -368,7 +367,7 @@
         Y += 16;
 
         for (blk = 0; blk < 2; blk++) {
-            recombine_block(ctx->block, ctx->scantable.permutated,
+            recombine_block(ctx->block, ctx->idsp.idct_permutation,
                             &base_c, &ext_c);
             unquant_block(ctx->block, ctx->quant, ctx->quant_matrix);
             ctx->idsp.idct(ctx->block);
@@ -444,7 +443,6 @@
 {
     AICContext *ctx = avctx->priv_data;
     int i;
-    uint8_t scan[64];
 
     ctx->avctx = avctx;
 
@@ -453,9 +451,6 @@
     ff_idctdsp_init(&ctx->idsp, avctx);
 
     for (i = 0; i < 64; i++)
-        scan[i] = i;
-    ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable, scan);
-    for (i = 0; i < 64; i++)
         ctx->quant_matrix[ctx->idsp.idct_permutation[i]] = aic_quant_matrix[i];
 
     ctx->mb_width  = FFALIGN(avctx->width,  16) >> 4;
--- a/third_party/ffmpeg/libavcodec/alacdsp.c
+++ b/third_party/ffmpeg/libavcodec/alacdsp.c
@@ -58,7 +58,9 @@
     c->append_extra_bits[0] =
     c->append_extra_bits[1] = append_extra_bits;
 
-#if ARCH_X86
+#if ARCH_RISCV
+    ff_alacdsp_init_riscv(c);
+#elif ARCH_X86
     ff_alacdsp_init_x86(c);
 #endif
 }
--- a/third_party/ffmpeg/libavcodec/alacdsp.h
+++ b/third_party/ffmpeg/libavcodec/alacdsp.h
@@ -29,6 +29,7 @@
 } ALACDSPContext;
 
 void ff_alacdsp_init(ALACDSPContext *c);
+void ff_alacdsp_init_riscv(ALACDSPContext *c);
 void ff_alacdsp_init_x86(ALACDSPContext *c);
 
 #endif /* AVCODEC_ALACDSP_H */
--- a/third_party/ffmpeg/libavcodec/alacenc.c
+++ b/third_party/ffmpeg/libavcodec/alacenc.c
@@ -648,7 +648,6 @@
     .version    = LIBAVUTIL_VERSION_INT,
 };
 
-FF_DISABLE_DEPRECATION_WARNINGS
 const FFCodec ff_alac_encoder = {
     .p.name         = "alac",
     CODEC_LONG_NAME("ALAC (Apple Lossless Audio Codec)"),
@@ -660,12 +659,9 @@
     .init           = alac_encode_init,
     FF_CODEC_ENCODE_CB(alac_encode_frame),
     .close          = alac_encode_close,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = alac_channel_layouts,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(alac_channel_layouts)
     .p.ch_layouts   = ff_alac_ch_layouts,
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S32P,
                                                      AV_SAMPLE_FMT_S16P,
                                                      AV_SAMPLE_FMT_NONE },
 };
-FF_ENABLE_DEPRECATION_WARNINGS
--- a/third_party/ffmpeg/libavcodec/allcodecs.c
+++ b/third_party/ffmpeg/libavcodec/allcodecs.c
@@ -194,6 +194,7 @@
 extern const FFCodec ff_magicyuv_encoder;
 extern const FFCodec ff_magicyuv_decoder;
 extern const FFCodec ff_mdec_decoder;
+extern const FFCodec ff_media100_decoder;
 extern const FFCodec ff_mimic_decoder;
 extern const FFCodec ff_mjpeg_encoder;
 extern const FFCodec ff_mjpeg_decoder;
@@ -380,6 +381,7 @@
 extern const FFCodec ff_vp9_rkmpp_decoder;
 extern const FFCodec ff_vp9_v4l2m2m_decoder;
 extern const FFCodec ff_vqa_decoder;
+extern const FFCodec ff_vqc_decoder;
 extern const FFCodec ff_wbmp_decoder;
 extern const FFCodec ff_wbmp_encoder;
 extern const FFCodec ff_webp_decoder;
@@ -432,6 +434,7 @@
 extern const FFCodec ff_als_decoder;
 extern const FFCodec ff_amrnb_decoder;
 extern const FFCodec ff_amrwb_decoder;
+extern const FFCodec ff_apac_decoder;
 extern const FFCodec ff_ape_decoder;
 extern const FFCodec ff_aptx_encoder;
 extern const FFCodec ff_aptx_decoder;
@@ -467,6 +470,7 @@
 extern const FFCodec ff_ffwavesynth_decoder;
 extern const FFCodec ff_flac_encoder;
 extern const FFCodec ff_flac_decoder;
+extern const FFCodec ff_ftr_decoder;
 extern const FFCodec ff_g723_1_encoder;
 extern const FFCodec ff_g723_1_decoder;
 extern const FFCodec ff_g729_decoder;
@@ -824,6 +828,7 @@
 extern const FFCodec ff_av1_decoder;
 extern const FFCodec ff_av1_cuvid_decoder;
 extern const FFCodec ff_av1_qsv_decoder;
+extern const FFCodec ff_av1_qsv_encoder;
 extern const FFCodec ff_libopenh264_encoder;
 extern const FFCodec ff_libopenh264_decoder;
 extern const FFCodec ff_h264_amf_encoder;
--- a/third_party/ffmpeg/libavcodec/amrwbdec.c
+++ b/third_party/ffmpeg/libavcodec/amrwbdec.c
@@ -24,6 +24,8 @@
  * AMR wideband decoder
  */
 
+#include "config.h"
+
 #include "libavutil/channel_layout.h"
 #include "libavutil/common.h"
 #include "libavutil/lfg.h"
@@ -42,7 +44,9 @@
 #include "amr.h"
 
 #include "amrwbdata.h"
+#if ARCH_MIPS
 #include "mips/amrwbdec_mips.h"
+#endif /* ARCH_MIPS */
 
 typedef struct AMRWBContext {
     AMRWBFrame                             frame; ///< AMRWB parameters decoded from bitstream
--- a/third_party/ffmpeg/libavcodec/aptxdec.c
+++ b/third_party/ffmpeg/libavcodec/aptxdec.c
@@ -183,9 +183,7 @@
     .init                  = ff_aptx_init,
     FF_CODEC_DECODE_CB(aptx_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_STEREO, 0},
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_STEREO, { 0 } },
     .p.sample_fmts         = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S32P,
                                                              AV_SAMPLE_FMT_NONE },
@@ -202,9 +200,7 @@
     .init                  = ff_aptx_init,
     FF_CODEC_DECODE_CB(aptx_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_STEREO, 0},
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_STEREO, { 0 } },
     .p.sample_fmts         = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S32P,
                                                              AV_SAMPLE_FMT_NONE },
--- a/third_party/ffmpeg/libavcodec/aptxenc.c
+++ b/third_party/ffmpeg/libavcodec/aptxenc.c
@@ -276,9 +276,7 @@
     .init                  = aptx_encode_init,
     FF_CODEC_ENCODE_CB(aptx_encode_frame),
     .close                 = aptx_close,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_STEREO, 0},
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_STEREO, { 0 } },
     .p.sample_fmts         = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S32P,
                                                              AV_SAMPLE_FMT_NONE },
@@ -297,9 +295,7 @@
     .init                  = aptx_encode_init,
     FF_CODEC_ENCODE_CB(aptx_encode_frame),
     .close                 = aptx_close,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_STEREO, 0},
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_STEREO, { 0 } },
     .p.sample_fmts         = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S32P,
                                                              AV_SAMPLE_FMT_NONE },
--- a/third_party/ffmpeg/libavcodec/arm/ac3dsp_init_arm.c
+++ b/third_party/ffmpeg/libavcodec/arm/ac3dsp_init_arm.c
@@ -44,7 +44,7 @@
 
 void ff_ac3_update_bap_counts_arm(uint16_t mant_cnt[16], uint8_t *bap, int len);
 
-av_cold void ff_ac3dsp_init_arm(AC3DSPContext *c, int bit_exact)
+av_cold void ff_ac3dsp_init_arm(AC3DSPContext *c)
 {
     int cpu_flags = av_get_cpu_flags();
 
--- a/third_party/ffmpeg/libavcodec/arm/autorename_libavcodec_arm_pixblockdsp_neon.S
+++ /dev/null
@@ -1,2 +0,0 @@
-// File automatically generated. See crbug.com/495833.
-#include "pixblockdsp_neon.S"
--- a/third_party/ffmpeg/libavcodec/arm/vc1dsp_neon.S
+++ b/third_party/ffmpeg/libavcodec/arm/vc1dsp_neon.S
@@ -1310,17 +1310,17 @@
 function ff_vc1_v_loop_filter8_neon, export=1
         sub             r3, r0, r1, lsl #2
         vldr            d0, .Lcoeffs
-        vld1.32         {d1}, [r0 :64], r1      @ P5
-        vld1.32         {d2}, [r3 :64], r1      @ P1
-        vld1.32         {d3}, [r3 :64], r1      @ P2
-        vld1.32         {d4}, [r0 :64], r1      @ P6
-        vld1.32         {d5}, [r3 :64], r1      @ P3
-        vld1.32         {d6}, [r0 :64], r1      @ P7
+        vld1.32         {d1}, [r0, :64], r1     @ P5
+        vld1.32         {d2}, [r3, :64], r1     @ P1
+        vld1.32         {d3}, [r3, :64], r1     @ P2
+        vld1.32         {d4}, [r0, :64], r1     @ P6
+        vld1.32         {d5}, [r3, :64], r1     @ P3
+        vld1.32         {d6}, [r0, :64], r1     @ P7
         vshll.u8        q8, d1, #1              @ 2*P5
         vshll.u8        q9, d2, #1              @ 2*P1
-        vld1.32         {d7}, [r3 :64]          @ P4
+        vld1.32         {d7}, [r3, :64]         @ P4
         vmovl.u8        q1, d3                  @ P2
-        vld1.32         {d20}, [r0 :64]         @ P8
+        vld1.32         {d20}, [r0, :64]        @ P8
         vmovl.u8        q11, d4                 @ P6
         vdup.16         q12, r2                 @ pq
         vmovl.u8        q13, d5                 @ P3
@@ -1375,8 +1375,8 @@
         vmla.i16        q1, q0, q2              @ invert d depending on clip_sign & a0_sign, or zero it if they match, and accumulate into P5
         vqmovun.s16     d0, q3
         vqmovun.s16     d1, q1
-        vst1.32         {d0}, [r3 :64], r1
-        vst1.32         {d1}, [r3 :64]
+        vst1.32         {d0}, [r3, :64], r1
+        vst1.32         {d1}, [r3, :64]
 1:      bx              lr
 endfunc
 
@@ -1491,17 +1491,17 @@
         vpush           {d8-d15}
         sub             r3, r0, r1, lsl #2
         vldr            d0, .Lcoeffs
-        vld1.64         {q1}, [r0 :128], r1     @ P5
-        vld1.64         {q2}, [r3 :128], r1     @ P1
-        vld1.64         {q3}, [r3 :128], r1     @ P2
-        vld1.64         {q4}, [r0 :128], r1     @ P6
-        vld1.64         {q5}, [r3 :128], r1     @ P3
-        vld1.64         {q6}, [r0 :128], r1     @ P7
+        vld1.64         {q1}, [r0, :128], r1    @ P5
+        vld1.64         {q2}, [r3, :128], r1    @ P1
+        vld1.64         {q3}, [r3, :128], r1    @ P2
+        vld1.64         {q4}, [r0, :128], r1    @ P6
+        vld1.64         {q5}, [r3, :128], r1    @ P3
+        vld1.64         {q6}, [r0, :128], r1    @ P7
         vshll.u8        q7, d2, #1              @ 2*P5[0..7]
         vshll.u8        q8, d4, #1              @ 2*P1[0..7]
-        vld1.64         {q9}, [r3 :128]         @ P4
+        vld1.64         {q9}, [r3, :128]        @ P4
         vmovl.u8        q10, d6                 @ P2[0..7]
-        vld1.64         {q11}, [r0 :128]        @ P8
+        vld1.64         {q11}, [r0, :128]       @ P8
         vmovl.u8        q12, d8                 @ P6[0..7]
         vdup.16         q13, r2                 @ pq
         vshll.u8        q2, d5, #1              @ 2*P1[8..15]
@@ -1611,8 +1611,8 @@
         vqmovun.s16     d0, q6
         vqmovun.s16     d5, q9
         vqmovun.s16     d1, q1
-        vst1.64         {q2}, [r3 :128], r1
-        vst1.64         {q0}, [r3 :128]
+        vst1.64         {q2}, [r3, :128], r1
+        vst1.64         {q0}, [r3, :128]
 1:      vpop            {d8-d15}
         bx              lr
 endfunc
--- a/third_party/ffmpeg/libavcodec/asv.c
+++ b/third_party/ffmpeg/libavcodec/asv.c
@@ -25,6 +25,8 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes.h"
+
 #include "asv.h"
 #include "avcodec.h"
 #include "bswapdsp.h"
@@ -88,7 +90,7 @@
 
 av_cold void ff_asv_common_init(AVCodecContext *avctx)
 {
-    ASV1Context *const a = avctx->priv_data;
+    ASVCommonContext *const a = avctx->priv_data;
 
     ff_bswapdsp_init(&a->bbdsp);
 
--- a/third_party/ffmpeg/libavcodec/asv.h
+++ b/third_party/ffmpeg/libavcodec/asv.h
@@ -28,38 +28,17 @@
 
 #include <stdint.h>
 
-#include "libavutil/mem_internal.h"
-
 #include "avcodec.h"
-#include "blockdsp.h"
 #include "bswapdsp.h"
-#include "fdctdsp.h"
-#include "idctdsp.h"
-#include "get_bits.h"
-#include "pixblockdsp.h"
-#include "put_bits.h"
 
-typedef struct ASV1Context {
+typedef struct ASVCommonContext {
     AVCodecContext *avctx;
-    BlockDSPContext bdsp;
     BswapDSPContext bbdsp;
-    FDCTDSPContext fdsp;
-    IDCTDSPContext idsp;
-    PixblockDSPContext pdsp;
-    PutBitContext pb;
-    GetBitContext gb;
-    ScanTable scantable;
-    int inv_qscale;
     int mb_width;
     int mb_height;
     int mb_width2;
     int mb_height2;
-    DECLARE_ALIGNED(32, int16_t, block)[6][64];
-    uint16_t intra_matrix[64];
-    int q_intra_matrix[64];
-    uint8_t *bitstream_buffer;
-    unsigned int bitstream_buffer_size;
-} ASV1Context;
+} ASVCommonContext;
 
 extern const uint8_t ff_asv_scantab[64];
 extern const uint8_t ff_asv_ccp_tab[17][2];
--- a/third_party/ffmpeg/libavcodec/asvdec.c
+++ b/third_party/ffmpeg/libavcodec/asvdec.c
@@ -25,6 +25,7 @@
 
 #include "libavutil/attributes.h"
 #include "libavutil/mem.h"
+#include "libavutil/mem_internal.h"
 #include "libavutil/thread.h"
 
 #include "asv.h"
@@ -33,8 +34,10 @@
 #include "codec_internal.h"
 #include "config_components.h"
 #include "decode.h"
+#include "get_bits.h"
 #include "idctdsp.h"
 #include "mpeg12data.h"
+#include "vlc.h"
 
 #define CCP_VLC_BITS         5
 #define DC_CCP_VLC_BITS      4
@@ -48,6 +51,20 @@
 static VLC ac_ccp_vlc;
 static VLC asv2_level_vlc;
 
+typedef struct ASVDecContext {
+    ASVCommonContext c;
+
+    GetBitContext gb;
+
+    BlockDSPContext bdsp;
+    IDCTDSPContext idsp;
+    uint8_t permutated_scantable[64];
+    DECLARE_ALIGNED(32, int16_t, block)[6][64];
+    uint16_t intra_matrix[64];
+    uint8_t *bitstream_buffer;
+    unsigned int bitstream_buffer_size;
+} ASVDecContext;
+
 static av_cold void init_vlcs(void)
 {
     INIT_VLC_STATIC(&ccp_vlc, CCP_VLC_BITS, 17,
@@ -106,7 +123,7 @@
         return code - 31;
 }
 
-static inline int asv1_decode_block(ASV1Context *a, int16_t block[64])
+static inline int asv1_decode_block(ASVDecContext *a, int16_t block[64])
 {
     int i;
 
@@ -119,25 +136,25 @@
             if (ccp == 16)
                 break;
             if (ccp < 0 || i >= 10) {
-                av_log(a->avctx, AV_LOG_ERROR, "coded coeff pattern damaged\n");
+                av_log(a->c.avctx, AV_LOG_ERROR, "coded coeff pattern damaged\n");
                 return AVERROR_INVALIDDATA;
             }
 
             if (ccp & 8)
-                block[a->scantable.permutated[4 * i + 0]] = (asv1_get_level(&a->gb) * a->intra_matrix[4 * i + 0]) >> 4;
+                block[a->permutated_scantable[4 * i + 0]] = (asv1_get_level(&a->gb) * a->intra_matrix[4 * i + 0]) >> 4;
             if (ccp & 4)
-                block[a->scantable.permutated[4 * i + 1]] = (asv1_get_level(&a->gb) * a->intra_matrix[4 * i + 1]) >> 4;
+                block[a->permutated_scantable[4 * i + 1]] = (asv1_get_level(&a->gb) * a->intra_matrix[4 * i + 1]) >> 4;
             if (ccp & 2)
-                block[a->scantable.permutated[4 * i + 2]] = (asv1_get_level(&a->gb) * a->intra_matrix[4 * i + 2]) >> 4;
+                block[a->permutated_scantable[4 * i + 2]] = (asv1_get_level(&a->gb) * a->intra_matrix[4 * i + 2]) >> 4;
             if (ccp & 1)
-                block[a->scantable.permutated[4 * i + 3]] = (asv1_get_level(&a->gb) * a->intra_matrix[4 * i + 3]) >> 4;
+                block[a->permutated_scantable[4 * i + 3]] = (asv1_get_level(&a->gb) * a->intra_matrix[4 * i + 3]) >> 4;
         }
     }
 
     return 0;
 }
 
-static inline int asv2_decode_block(ASV1Context *a, int16_t block[64])
+static inline int asv2_decode_block(ASVDecContext *a, int16_t block[64])
 {
     int i, count, ccp;
 
@@ -148,11 +165,11 @@
     ccp = asv2_get_vlc2(&a->gb, dc_ccp_vlc.table, DC_CCP_VLC_BITS);
     if (ccp) {
         if (ccp & 4)
-            block[a->scantable.permutated[1]] = (asv2_get_level(&a->gb) * a->intra_matrix[1]) >> 4;
+            block[a->permutated_scantable[1]] = (asv2_get_level(&a->gb) * a->intra_matrix[1]) >> 4;
         if (ccp & 2)
-            block[a->scantable.permutated[2]] = (asv2_get_level(&a->gb) * a->intra_matrix[2]) >> 4;
+            block[a->permutated_scantable[2]] = (asv2_get_level(&a->gb) * a->intra_matrix[2]) >> 4;
         if (ccp & 1)
-            block[a->scantable.permutated[3]] = (asv2_get_level(&a->gb) * a->intra_matrix[3]) >> 4;
+            block[a->permutated_scantable[3]] = (asv2_get_level(&a->gb) * a->intra_matrix[3]) >> 4;
     }
 
     for (i = 1; i < count + 1; i++) {
@@ -160,26 +177,26 @@
 
         if (ccp) {
             if (ccp & 8)
-                block[a->scantable.permutated[4 * i + 0]] = (asv2_get_level(&a->gb) * a->intra_matrix[4 * i + 0]) >> 4;
+                block[a->permutated_scantable[4 * i + 0]] = (asv2_get_level(&a->gb) * a->intra_matrix[4 * i + 0]) >> 4;
             if (ccp & 4)
-                block[a->scantable.permutated[4 * i + 1]] = (asv2_get_level(&a->gb) * a->intra_matrix[4 * i + 1]) >> 4;
+                block[a->permutated_scantable[4 * i + 1]] = (asv2_get_level(&a->gb) * a->intra_matrix[4 * i + 1]) >> 4;
             if (ccp & 2)
-                block[a->scantable.permutated[4 * i + 2]] = (asv2_get_level(&a->gb) * a->intra_matrix[4 * i + 2]) >> 4;
+                block[a->permutated_scantable[4 * i + 2]] = (asv2_get_level(&a->gb) * a->intra_matrix[4 * i + 2]) >> 4;
             if (ccp & 1)
-                block[a->scantable.permutated[4 * i + 3]] = (asv2_get_level(&a->gb) * a->intra_matrix[4 * i + 3]) >> 4;
+                block[a->permutated_scantable[4 * i + 3]] = (asv2_get_level(&a->gb) * a->intra_matrix[4 * i + 3]) >> 4;
         }
     }
 
     return 0;
 }
 
-static inline int decode_mb(ASV1Context *a, int16_t block[6][64])
+static inline int decode_mb(ASVDecContext *a, int16_t block[6][64])
 {
     int i, ret;
 
     a->bdsp.clear_blocks(block[0]);
 
-    if (a->avctx->codec_id == AV_CODEC_ID_ASV1) {
+    if (a->c.avctx->codec_id == AV_CODEC_ID_ASV1) {
         for (i = 0; i < 6; i++) {
             if ((ret = asv1_decode_block(a, block[i])) < 0)
                 return ret;
@@ -193,7 +210,7 @@
     return 0;
 }
 
-static inline void idct_put(ASV1Context *a, AVFrame *frame, int mb_x, int mb_y)
+static inline void idct_put(ASVDecContext *a, AVFrame *frame, int mb_x, int mb_y)
 {
     int16_t(*block)[64] = a->block;
     int linesize = frame->linesize[0];
@@ -207,7 +224,7 @@
     a->idsp.idct_put(dest_y + 8 * linesize,     linesize, block[2]);
     a->idsp.idct_put(dest_y + 8 * linesize + 8, linesize, block[3]);
 
-    if (!(a->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+    if (!(a->c.avctx->flags & AV_CODEC_FLAG_GRAY)) {
         a->idsp.idct_put(dest_cb, frame->linesize[1], block[4]);
         a->idsp.idct_put(dest_cr, frame->linesize[2], block[5]);
     }
@@ -216,12 +233,13 @@
 static int decode_frame(AVCodecContext *avctx, AVFrame *p,
                         int *got_frame, AVPacket *avpkt)
 {
-    ASV1Context *const a = avctx->priv_data;
+    ASVDecContext *const a = avctx->priv_data;
+    const ASVCommonContext *const c = &a->c;
     const uint8_t *buf = avpkt->data;
     int buf_size       = avpkt->size;
-    int mb_x, mb_y, ret;
+    int ret;
 
-    if (buf_size * 8LL < a->mb_height * a->mb_width * 13LL)
+    if (buf_size * 8LL < c->mb_height * c->mb_width * 13LL)
         return AVERROR_INVALIDDATA;
 
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
@@ -235,7 +253,7 @@
         if (!a->bitstream_buffer)
             return AVERROR(ENOMEM);
 
-        a->bbdsp.bswap_buf((uint32_t *) a->bitstream_buffer,
+        c->bbdsp.bswap_buf((uint32_t *) a->bitstream_buffer,
                            (const uint32_t *) buf, buf_size / 4);
         ret = init_get_bits8(&a->gb, a->bitstream_buffer, buf_size);
     } else {
@@ -244,8 +262,8 @@
     if (ret < 0)
         return ret;
 
-    for (mb_y = 0; mb_y < a->mb_height2; mb_y++) {
-        for (mb_x = 0; mb_x < a->mb_width2; mb_x++) {
+    for (int mb_y = 0; mb_y < c->mb_height2; mb_y++) {
+        for (int mb_x = 0; mb_x < c->mb_width2; mb_x++) {
             if ((ret = decode_mb(a, a->block)) < 0)
                 return ret;
 
@@ -253,9 +271,9 @@
         }
     }
 
-    if (a->mb_width2 != a->mb_width) {
-        mb_x = a->mb_width2;
-        for (mb_y = 0; mb_y < a->mb_height2; mb_y++) {
+    if (c->mb_width2 != c->mb_width) {
+        int mb_x = c->mb_width2;
+        for (int mb_y = 0; mb_y < c->mb_height2; mb_y++) {
             if ((ret = decode_mb(a, a->block)) < 0)
                 return ret;
 
@@ -263,9 +281,9 @@
         }
     }
 
-    if (a->mb_height2 != a->mb_height) {
-        mb_y = a->mb_height2;
-        for (mb_x = 0; mb_x < a->mb_width; mb_x++) {
+    if (c->mb_height2 != c->mb_height) {
+        int mb_y = c->mb_height2;
+        for (int mb_x = 0; mb_x < c->mb_width; mb_x++) {
             if ((ret = decode_mb(a, a->block)) < 0)
                 return ret;
 
@@ -275,16 +293,15 @@
 
     *got_frame = 1;
 
-    emms_c();
-
     return (get_bits_count(&a->gb) + 31) / 32 * 4;
 }
 
 static av_cold int decode_init(AVCodecContext *avctx)
 {
     static AVOnce init_static_once = AV_ONCE_INIT;
-    ASV1Context *const a = avctx->priv_data;
+    ASVDecContext *const a = avctx->priv_data;
     const int scale      = avctx->codec_id == AV_CODEC_ID_ASV1 ? 1 : 2;
+    int inv_qscale;
     int i;
 
     if (avctx->extradata_size < 1) {
@@ -294,22 +311,23 @@
     ff_asv_common_init(avctx);
     ff_blockdsp_init(&a->bdsp);
     ff_idctdsp_init(&a->idsp, avctx);
-    ff_init_scantable(a->idsp.idct_permutation, &a->scantable, ff_asv_scantab);
+    ff_permute_scantable(a->permutated_scantable, ff_asv_scantab,
+                         a->idsp.idct_permutation);
     avctx->pix_fmt = AV_PIX_FMT_YUV420P;
 
-    if (avctx->extradata_size < 1 || (a->inv_qscale = avctx->extradata[0]) == 0) {
+    if (avctx->extradata_size < 1 || (inv_qscale = avctx->extradata[0]) == 0) {
         av_log(avctx, AV_LOG_ERROR, "illegal qscale 0\n");
         if (avctx->codec_id == AV_CODEC_ID_ASV1)
-            a->inv_qscale = 6;
+            inv_qscale = 6;
         else
-            a->inv_qscale = 10;
+            inv_qscale = 10;
     }
 
     for (i = 0; i < 64; i++) {
         int index = ff_asv_scantab[i];
 
         a->intra_matrix[i] = 64 * scale * ff_mpeg1_default_intra_matrix[index] /
-                             a->inv_qscale;
+                             inv_qscale;
     }
 
     ff_thread_once(&init_static_once, init_vlcs);
@@ -319,7 +337,7 @@
 
 static av_cold int decode_end(AVCodecContext *avctx)
 {
-    ASV1Context *const a = avctx->priv_data;
+    ASVDecContext *const a = avctx->priv_data;
 
     av_freep(&a->bitstream_buffer);
     a->bitstream_buffer_size = 0;
@@ -333,7 +351,7 @@
     CODEC_LONG_NAME("ASUS V1"),
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_ASV1,
-    .priv_data_size = sizeof(ASV1Context),
+    .priv_data_size = sizeof(ASVDecContext),
     .init           = decode_init,
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
@@ -347,7 +365,7 @@
     CODEC_LONG_NAME("ASUS V2"),
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_ASV2,
-    .priv_data_size = sizeof(ASV1Context),
+    .priv_data_size = sizeof(ASVDecContext),
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
--- a/third_party/ffmpeg/libavcodec/asvenc.c
+++ b/third_party/ffmpeg/libavcodec/asvenc.c
@@ -27,6 +27,7 @@
 
 #include "libavutil/attributes.h"
 #include "libavutil/mem.h"
+#include "libavutil/mem_internal.h"
 
 #include "aandcttab.h"
 #include "asv.h"
@@ -36,6 +37,19 @@
 #include "encode.h"
 #include "fdctdsp.h"
 #include "mpeg12data.h"
+#include "pixblockdsp.h"
+#include "put_bits.h"
+
+typedef struct ASVEncContext {
+    ASVCommonContext c;
+
+    PutBitContext pb;
+
+    PixblockDSPContext pdsp;
+    FDCTDSPContext fdsp;
+    DECLARE_ALIGNED(32, int16_t, block)[6][64];
+    int q_intra_matrix[64];
+} ASVEncContext;
 
 static inline void asv1_put_level(PutBitContext *pb, int level)
 {
@@ -49,7 +63,7 @@
     }
 }
 
-static inline void asv2_put_level(ASV1Context *a, PutBitContext *pb, int level)
+static inline void asv2_put_level(ASVEncContext *a, PutBitContext *pb, int level)
 {
     unsigned int index = level + 31;
 
@@ -58,14 +72,14 @@
     } else {
         put_bits_le(pb, 5, 0); /* Escape code */
         if (level < -128 || level > 127) {
-            av_log(a->avctx, AV_LOG_WARNING, "Clipping level %d, increase qscale\n", level);
+            av_log(a->c.avctx, AV_LOG_WARNING, "Clipping level %d, increase qscale\n", level);
             level = av_clip_int8(level);
         }
         put_bits_le(pb, 8, level & 0xFF);
     }
 }
 
-static inline void asv1_encode_block(ASV1Context *a, int16_t block[64])
+static inline void asv1_encode_block(ASVEncContext *a, int16_t block[64])
 {
     int i;
     int nc_count = 0;
@@ -111,7 +125,7 @@
     put_bits(&a->pb, 5, 0xF); /* End of block */
 }
 
-static inline void asv2_encode_block(ASV1Context *a, int16_t block[64])
+static inline void asv2_encode_block(ASVEncContext *a, int16_t block[64])
 {
     int i;
     int count = 0;
@@ -166,13 +180,13 @@
 
 #define MAX_MB_SIZE (30 * 16 * 16 * 3 / 2 / 8)
 
-static inline int encode_mb(ASV1Context *a, int16_t block[6][64])
+static inline int encode_mb(ASVEncContext *a, int16_t block[6][64])
 {
     int i;
 
     av_assert0(put_bytes_left(&a->pb, 0) >= MAX_MB_SIZE);
 
-    if (a->avctx->codec_id == AV_CODEC_ID_ASV1) {
+    if (a->c.avctx->codec_id == AV_CODEC_ID_ASV1) {
         for (i = 0; i < 6; i++)
             asv1_encode_block(a, block[i]);
     } else {
@@ -183,7 +197,7 @@
     return 0;
 }
 
-static inline void dct_get(ASV1Context *a, const AVFrame *frame,
+static inline void dct_get(ASVEncContext *a, const AVFrame *frame,
                            int mb_x, int mb_y)
 {
     int16_t (*block)[64] = a->block;
@@ -201,7 +215,7 @@
     for (i = 0; i < 4; i++)
         a->fdsp.fdct(block[i]);
 
-    if (!(a->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+    if (!(a->c.avctx->flags & AV_CODEC_FLAG_GRAY)) {
         a->pdsp.get_pixels(block[4], ptr_cb, frame->linesize[1]);
         a->pdsp.get_pixels(block[5], ptr_cr, frame->linesize[2]);
         for (i = 4; i < 6; i++)
@@ -212,9 +226,9 @@
 static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                         const AVFrame *pict, int *got_packet)
 {
-    ASV1Context *const a = avctx->priv_data;
+    ASVEncContext *const a = avctx->priv_data;
+    const ASVCommonContext *const c = &a->c;
     int size, ret;
-    int mb_x, mb_y;
 
     if (pict->width % 16 || pict->height % 16) {
         AVFrame *clone = av_frame_alloc();
@@ -258,35 +272,34 @@
         return ret;
     }
 
-    if ((ret = ff_alloc_packet(avctx, pkt, a->mb_height * a->mb_width * MAX_MB_SIZE +
+    if ((ret = ff_alloc_packet(avctx, pkt, c->mb_height * c->mb_width * MAX_MB_SIZE +
                                AV_INPUT_BUFFER_MIN_SIZE)) < 0)
         return ret;
 
     init_put_bits(&a->pb, pkt->data, pkt->size);
 
-    for (mb_y = 0; mb_y < a->mb_height2; mb_y++) {
-        for (mb_x = 0; mb_x < a->mb_width2; mb_x++) {
+    for (int mb_y = 0; mb_y < c->mb_height2; mb_y++) {
+        for (int mb_x = 0; mb_x < c->mb_width2; mb_x++) {
             dct_get(a, pict, mb_x, mb_y);
             encode_mb(a, a->block);
         }
     }
 
-    if (a->mb_width2 != a->mb_width) {
-        mb_x = a->mb_width2;
-        for (mb_y = 0; mb_y < a->mb_height2; mb_y++) {
+    if (c->mb_width2 != c->mb_width) {
+        int mb_x = c->mb_width2;
+        for (int mb_y = 0; mb_y < c->mb_height2; mb_y++) {
             dct_get(a, pict, mb_x, mb_y);
             encode_mb(a, a->block);
         }
     }
 
-    if (a->mb_height2 != a->mb_height) {
-        mb_y = a->mb_height2;
-        for (mb_x = 0; mb_x < a->mb_width; mb_x++) {
+    if (c->mb_height2 != c->mb_height) {
+        int mb_y = c->mb_height2;
+        for (int mb_x = 0; mb_x < c->mb_width; mb_x++) {
             dct_get(a, pict, mb_x, mb_y);
             encode_mb(a, a->block);
         }
     }
-    emms_c();
 
     if (avctx->codec_id == AV_CODEC_ID_ASV1)
         flush_put_bits(&a->pb);
@@ -296,7 +309,7 @@
     size = (put_bytes_output(&a->pb) + 3) / 4;
 
     if (avctx->codec_id == AV_CODEC_ID_ASV1) {
-        a->bbdsp.bswap_buf((uint32_t *) pkt->data,
+        c->bbdsp.bswap_buf((uint32_t *) pkt->data,
                            (uint32_t *) pkt->data, size);
     }
 
@@ -308,9 +321,10 @@
 
 static av_cold int encode_init(AVCodecContext *avctx)
 {
-    ASV1Context *const a = avctx->priv_data;
+    ASVEncContext *const a = avctx->priv_data;
     int i;
     const int scale = avctx->codec_id == AV_CODEC_ID_ASV1 ? 1 : 2;
+    int inv_qscale;
 
     ff_asv_common_init(avctx);
     ff_fdctdsp_init(&a->fdsp, avctx);
@@ -319,23 +333,23 @@
     if (avctx->global_quality <= 0)
         avctx->global_quality = 4 * FF_QUALITY_SCALE;
 
-    a->inv_qscale = (32 * scale * FF_QUALITY_SCALE +
+    inv_qscale = (32 * scale * FF_QUALITY_SCALE +
                      avctx->global_quality / 2) / avctx->global_quality;
 
     avctx->extradata                   = av_mallocz(8);
     if (!avctx->extradata)
         return AVERROR(ENOMEM);
     avctx->extradata_size              = 8;
-    ((uint32_t *) avctx->extradata)[0] = av_le2ne32(a->inv_qscale);
+    AV_WLA(32, avctx->extradata, inv_qscale);
     ((uint32_t *) avctx->extradata)[1] = av_le2ne32(AV_RL32("ASUS"));
 
     for (i = 0; i < 64; i++) {
         if (a->fdsp.fdct == ff_fdct_ifast) {
             int q = 32LL * scale * ff_mpeg1_default_intra_matrix[i] * ff_aanscales[i];
-            a->q_intra_matrix[i] = (((int64_t)a->inv_qscale << 30) + q / 2) / q;
+            a->q_intra_matrix[i] = (((int64_t)inv_qscale << 30) + q / 2) / q;
         } else {
             int q = 32 * scale * ff_mpeg1_default_intra_matrix[i];
-            a->q_intra_matrix[i] = ((a->inv_qscale << 16) + q / 2) / q;
+            a->q_intra_matrix[i] = ((inv_qscale << 16) + q / 2) / q;
         }
     }
 
@@ -349,7 +363,7 @@
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_ASV1,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .priv_data_size = sizeof(ASV1Context),
+    .priv_data_size = sizeof(ASVEncContext),
     .init           = encode_init,
     FF_CODEC_ENCODE_CB(encode_frame),
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
@@ -364,7 +378,7 @@
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_ASV2,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .priv_data_size = sizeof(ASV1Context),
+    .priv_data_size = sizeof(ASVEncContext),
     .init           = encode_init,
     FF_CODEC_ENCODE_CB(encode_frame),
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
--- a/third_party/ffmpeg/libavcodec/audiodsp.c
+++ b/third_party/ffmpeg/libavcodec/audiodsp.c
@@ -113,6 +113,8 @@
     ff_audiodsp_init_arm(c);
 #elif ARCH_PPC
     ff_audiodsp_init_ppc(c);
+#elif ARCH_RISCV
+    ff_audiodsp_init_riscv(c);
 #elif ARCH_X86
     ff_audiodsp_init_x86(c);
 #endif
--- a/third_party/ffmpeg/libavcodec/audiodsp.h
+++ b/third_party/ffmpeg/libavcodec/audiodsp.h
@@ -55,6 +55,7 @@
 void ff_audiodsp_init(AudioDSPContext *c);
 void ff_audiodsp_init_arm(AudioDSPContext *c);
 void ff_audiodsp_init_ppc(AudioDSPContext *c);
+void ff_audiodsp_init_riscv(AudioDSPContext *c);
 void ff_audiodsp_init_x86(AudioDSPContext *c);
 
 #endif /* AVCODEC_AUDIODSP_H */
--- a/third_party/ffmpeg/libavcodec/audiotoolboxenc.c
+++ b/third_party/ffmpeg/libavcodec/audiotoolboxenc.c
@@ -627,7 +627,7 @@
         .p.priv_class   = &ffat_##NAME##_enc_class, \
         .p.capabilities = AV_CODEC_CAP_DELAY | \
                           AV_CODEC_CAP_ENCODER_FLUSH CAPS, \
-        .p.channel_layouts = CHANNEL_LAYOUTS, \
+        CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(CHANNEL_LAYOUTS) \
         .p.ch_layouts   = CH_LAYOUTS, \
         .p.sample_fmts  = (const enum AVSampleFormat[]) { \
             AV_SAMPLE_FMT_S16, \
--- a/third_party/ffmpeg/libavcodec/autorename_libavcodec_mpegvideodsp.c
+++ /dev/null
@@ -1,2 +0,0 @@
-// File automatically generated. See crbug.com/495833.
-#include "mpegvideodsp.c"
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/autorename_libavcodec_mpeg4videodsp.c
@@ -0,0 +1,2 @@
+// File automatically generated. See crbug.com/495833.
+#include "mpeg4videodsp.c"
--- a/third_party/ffmpeg/libavcodec/autorename_libavcodec_pixblockdsp.c
+++ /dev/null
@@ -1,2 +0,0 @@
-// File automatically generated. See crbug.com/495833.
-#include "pixblockdsp.c"
--- a/third_party/ffmpeg/libavcodec/avcodec.h
+++ b/third_party/ffmpeg/libavcodec/avcodec.h
@@ -1305,13 +1305,9 @@
      * unofficial and experimental (that is, they always try to decode things
      * when they can) unless they are explicitly asked to behave stupidly
      * (=strictly conform to the specs)
+     * This may only be set to one of the FF_COMPLIANCE_* values in defs.h.
      */
     int strict_std_compliance;
-#define FF_COMPLIANCE_VERY_STRICT   2 ///< Strictly conform to an older more strict version of the spec or reference software.
-#define FF_COMPLIANCE_STRICT        1 ///< Strictly conform to all the things in the spec no matter what consequences.
-#define FF_COMPLIANCE_NORMAL        0
-#define FF_COMPLIANCE_UNOFFICIAL   -1 ///< Allow unofficial extensions
-#define FF_COMPLIANCE_EXPERIMENTAL -2 ///< Allow nonstandardized experimental things.
 
     /**
      * error concealment flags
@@ -1347,28 +1343,13 @@
 
     /**
      * Error recognition; may misdetect some more or less valid parts as errors.
+     * This is a bitfield of the AV_EF_* values defined in defs.h.
+     *
      * - encoding: Set by user.
      * - decoding: Set by user.
      */
     int err_recognition;
 
-/**
- * Verify checksums embedded in the bitstream (could be of either encoded or
- * decoded data, depending on the codec) and print an error message on mismatch.
- * If AV_EF_EXPLODE is also set, a mismatching checksum will result in the
- * decoder returning an error.
- */
-#define AV_EF_CRCCHECK  (1<<0)
-#define AV_EF_BITSTREAM (1<<1)          ///< detect bitstream specification deviations
-#define AV_EF_BUFFER    (1<<2)          ///< detect improper bitstream length
-#define AV_EF_EXPLODE   (1<<3)          ///< abort decoding on minor error detection
-
-#define AV_EF_IGNORE_ERR (1<<15)        ///< ignore errors and continue
-#define AV_EF_CAREFUL    (1<<16)        ///< consider things that violate the spec, are fast to calculate and have not been seen in the wild as errors
-#define AV_EF_COMPLIANT  (1<<17)        ///< consider all spec non compliances as errors
-#define AV_EF_AGGRESSIVE (1<<18)        ///< consider things that a sane encoder should not do as an error
-
-
     /**
      * opaque 64-bit number (generally a PTS) that will be reordered and
      * output in AVFrame.reordered_opaque
@@ -1518,7 +1499,7 @@
      *   libavcodec will behave as if this field was always set to 1.
      *   Callers that want to be forward compatible with future libavcodec
      *   versions should wrap access to this field in
-     *     #if LIBAVCODEC_VERSION_MAJOR < 60
+     *     `#if LIBAVCODEC_VERSION_MAJOR < 60`
      */
     attribute_deprecated
     int thread_safe_callbacks;
@@ -2515,6 +2496,7 @@
 void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
                                int linesize_align[AV_NUM_DATA_POINTERS]);
 
+#ifdef FF_API_AVCODEC_CHROMA_POS
 /**
  * Converts AVChromaLocation to swscale x/y chroma position.
  *
@@ -2523,7 +2505,9 @@
  *
  * @param xpos  horizontal chroma sample position
  * @param ypos  vertical   chroma sample position
+ * @deprecated Use av_chroma_location_enum_to_pos() instead.
  */
+ attribute_deprecated
 int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos);
 
 /**
@@ -2534,8 +2518,11 @@
  *
  * @param xpos  horizontal chroma sample position
  * @param ypos  vertical   chroma sample position
+ * @deprecated Use av_chroma_location_pos_to_enum() instead.
  */
+ attribute_deprecated
 enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos);
+#endif
 
 /**
  * Decode a subtitle message.
@@ -2804,10 +2791,10 @@
  */
 
 enum AVPictureStructure {
-    AV_PICTURE_STRUCTURE_UNKNOWN,      //< unknown
-    AV_PICTURE_STRUCTURE_TOP_FIELD,    //< coded as top field
-    AV_PICTURE_STRUCTURE_BOTTOM_FIELD, //< coded as bottom field
-    AV_PICTURE_STRUCTURE_FRAME,        //< coded as frame
+    AV_PICTURE_STRUCTURE_UNKNOWN,      ///< unknown
+    AV_PICTURE_STRUCTURE_TOP_FIELD,    ///< coded as top field
+    AV_PICTURE_STRUCTURE_BOTTOM_FIELD, ///< coded as bottom field
+    AV_PICTURE_STRUCTURE_FRAME,        ///< coded as frame
 };
 
 typedef struct AVCodecParserContext {
--- a/third_party/ffmpeg/libavcodec/bitstream_filters.c
+++ b/third_party/ffmpeg/libavcodec/bitstream_filters.c
@@ -31,6 +31,7 @@
 extern const FFBitStreamFilter ff_chomp_bsf;
 extern const FFBitStreamFilter ff_dump_extradata_bsf;
 extern const FFBitStreamFilter ff_dca_core_bsf;
+extern const FFBitStreamFilter ff_dts2pts_bsf;
 extern const FFBitStreamFilter ff_dv_error_marker_bsf;
 extern const FFBitStreamFilter ff_eac3_core_bsf;
 extern const FFBitStreamFilter ff_extract_extradata_bsf;
--- a/third_party/ffmpeg/libavcodec/bsf.h
+++ b/third_party/ffmpeg/libavcodec/bsf.h
@@ -164,6 +164,8 @@
 /**
  * Prepare the filter for use, after all the parameters and options have been
  * set.
+ *
+ * @param ctx a AVBSFContext previously allocated with av_bsf_alloc()
  */
 int av_bsf_init(AVBSFContext *ctx);
 
@@ -174,6 +176,7 @@
  * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
  * AVERROR_EOF.
  *
+ * @param ctx an initialized AVBSFContext
  * @param pkt the packet to filter. The bitstream filter will take ownership of
  * the packet and reset the contents of pkt. pkt is not touched if an error occurs.
  * If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),
@@ -192,6 +195,7 @@
 /**
  * Retrieve a filtered packet.
  *
+ * @param ctx an initialized AVBSFContext
  * @param[out] pkt this struct will be filled with the contents of the filtered
  *                 packet. It is owned by the caller and must be freed using
  *                 av_packet_unref() when it is no longer needed.
--- a/third_party/ffmpeg/libavcodec/bswapdsp.c
+++ b/third_party/ffmpeg/libavcodec/bswapdsp.c
@@ -51,7 +51,9 @@
     c->bswap_buf   = bswap_buf;
     c->bswap16_buf = bswap16_buf;
 
-#if ARCH_X86
+#if ARCH_RISCV
+    ff_bswapdsp_init_riscv(c);
+#elif ARCH_X86
     ff_bswapdsp_init_x86(c);
 #endif
 }
--- a/third_party/ffmpeg/libavcodec/bswapdsp.h
+++ b/third_party/ffmpeg/libavcodec/bswapdsp.h
@@ -27,6 +27,7 @@
 } BswapDSPContext;
 
 void ff_bswapdsp_init(BswapDSPContext *c);
+void ff_bswapdsp_init_riscv(BswapDSPContext *c);
 void ff_bswapdsp_init_x86(BswapDSPContext *c);
 
 #endif /* AVCODEC_BSWAPDSP_H */
--- a/third_party/ffmpeg/libavcodec/c93.c
+++ b/third_party/ffmpeg/libavcodec/c93.c
@@ -130,7 +130,8 @@
     AVFrame * const oldpic = c93->pictures[c93->currentpic^1];
     GetByteContext gb;
     uint8_t *out;
-    int stride, ret, i, x, y, b, bt = 0;
+    int ret, i, x, y, b, bt = 0;
+    ptrdiff_t stride;
 
     if ((ret = ff_set_dimensions(avctx, WIDTH, HEIGHT)) < 0)
         return ret;
@@ -156,7 +157,6 @@
         out = newpic->data[0] + y * stride;
         for (x = 0; x < WIDTH; x += 8) {
             uint8_t *copy_from = oldpic->data[0];
-            unsigned int offset, j;
             uint8_t cols[4], grps[4];
             C93BlockType block_type;
 
@@ -165,16 +165,17 @@
 
             block_type= bt & 0x0F;
             switch (block_type) {
-            case C93_8X8_FROM_PREV:
-                offset = bytestream2_get_le16(&gb);
+            case C93_8X8_FROM_PREV: {
+                int offset = bytestream2_get_le16(&gb);
                 if ((ret = copy_block(avctx, out, copy_from, offset, 8, stride)) < 0)
                     return ret;
                 break;
+            }
 
             case C93_4X4_FROM_CURR:
                 copy_from = newpic->data[0];
             case C93_4X4_FROM_PREV:
-                for (j = 0; j < 8; j += 4) {
+                for (int j = 0; j < 8; j += 4) {
                     for (i = 0; i < 8; i += 4) {
                         int offset = bytestream2_get_le16(&gb);
                         int from_x = offset % WIDTH;
@@ -203,7 +204,7 @@
             case C93_4X4_2COLOR:
             case C93_4X4_4COLOR:
             case C93_4X4_4COLOR_GRP:
-                for (j = 0; j < 8; j += 4) {
+                for (int j = 0; j < 8; j += 4) {
                     for (i = 0; i < 8; i += 4) {
                         if (block_type == C93_4X4_2COLOR) {
                             bytestream2_get_buffer(&gb, cols, 2);
@@ -226,7 +227,7 @@
                 break;
 
             case C93_8X8_INTRA:
-                for (j = 0; j < 8; j++)
+                for (int j = 0; j < 8; j++)
                     bytestream2_get_buffer(&gb, out + j*stride, 8);
                 break;
 
--- a/third_party/ffmpeg/libavcodec/cavs.c
+++ b/third_party/ffmpeg/libavcodec/cavs.c
@@ -792,15 +792,14 @@
 av_cold int ff_cavs_init(AVCodecContext *avctx)
 {
     AVSContext *h = avctx->priv_data;
+    uint8_t permutation[64];
 
     ff_blockdsp_init(&h->bdsp);
     ff_h264chroma_init(&h->h264chroma, 8);
-    ff_idctdsp_init(&h->idsp, avctx);
     ff_videodsp_init(&h->vdsp, 8);
     ff_cavsdsp_init(&h->cdsp);
-    ff_init_scantable_permutation(h->idsp.idct_permutation,
-                                  h->cdsp.idct_perm);
-    ff_init_scantable(h->idsp.idct_permutation, &h->scantable, ff_zigzag_direct);
+    ff_init_scantable_permutation(permutation, h->cdsp.idct_perm);
+    ff_permute_scantable(h->permutated_scantable, ff_zigzag_direct, permutation);
 
     h->avctx       = avctx;
     avctx->pix_fmt = AV_PIX_FMT_YUV420P;
--- a/third_party/ffmpeg/libavcodec/cavs.h
+++ b/third_party/ffmpeg/libavcodec/cavs.h
@@ -22,12 +22,16 @@
 #ifndef AVCODEC_CAVS_H
 #define AVCODEC_CAVS_H
 
+#include <stddef.h>
+#include <stdint.h>
+
+#include "libavutil/frame.h"
 #include "libavutil/mem_internal.h"
 
+#include "avcodec.h"
 #include "cavsdsp.h"
 #include "blockdsp.h"
 #include "h264chroma.h"
-#include "idctdsp.h"
 #include "get_bits.h"
 #include "videodsp.h"
 
@@ -166,7 +170,6 @@
     AVCodecContext *avctx;
     BlockDSPContext bdsp;
     H264ChromaContext h264chroma;
-    IDCTDSPContext idsp;
     VideoDSPContext vdsp;
     CAVSDSPContext  cdsp;
     GetBitContext gb;
@@ -220,7 +223,7 @@
     int qp_fixed;
     int pic_qp_fixed;
     int cbp;
-    ScanTable scantable;
+    uint8_t permutated_scantable[64];
 
     /** intra prediction is done with un-deblocked samples
      they are saved here before deblocking the MB  */
--- a/third_party/ffmpeg/libavcodec/cavsdec.c
+++ b/third_party/ffmpeg/libavcodec/cavsdec.c
@@ -521,7 +521,7 @@
 {
     int round = 1 << (shift - 1);
     int pos = -1;
-    const uint8_t *scantab = h->scantable.permutated;
+    const uint8_t *scantab = h->permutated_scantable;
 
     /* inverse scan and dequantization */
     while (--coeff_num >= 0) {
--- a/third_party/ffmpeg/libavcodec/cavsdsp.c
+++ b/third_party/ffmpeg/libavcodec/cavsdsp.c
@@ -425,13 +425,14 @@
 \
 static void OPNAME ## cavs_filt16_hv_ ## NAME(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, ptrdiff_t dstStride, ptrdiff_t srcStride)\
 {                                                                       \
-    OPNAME ## cavs_filt8_hv_ ## NAME(dst  , src1,   src2  , dstStride, srcStride); \
-    OPNAME ## cavs_filt8_hv_ ## NAME(dst+8, src1+8, src2+8, dstStride, srcStride); \
+    OPNAME ## cavs_filt8_hv_ ## NAME(dst  , src1,   FULL ? src2     : NULL, dstStride, srcStride); \
+    OPNAME ## cavs_filt8_hv_ ## NAME(dst+8, src1+8, FULL ? src2 + 8 : NULL, dstStride, srcStride); \
     src1 += 8*srcStride;\
-    src2 += 8*srcStride;\
+    if (FULL) \
+        src2 += 8*srcStride;\
     dst += 8*dstStride;\
-    OPNAME ## cavs_filt8_hv_ ## NAME(dst  , src1,   src2  , dstStride, srcStride); \
-    OPNAME ## cavs_filt8_hv_ ## NAME(dst+8, src1+8, src2+8, dstStride, srcStride); \
+    OPNAME ## cavs_filt8_hv_ ## NAME(dst  , src1,   FULL ? src2     : NULL, dstStride, srcStride); \
+    OPNAME ## cavs_filt8_hv_ ## NAME(dst+8, src1+8, FULL ? src2 + 8 : NULL, dstStride, srcStride); \
 }\
 
 #define CAVS_MC(OPNAME, SIZE) \
@@ -492,22 +493,22 @@
 \
 static void OPNAME ## cavs_qpel ## SIZE ## _mc21_c(uint8_t *dst, const uint8_t *src, ptrdiff_t stride)\
 {\
-  OPNAME ## cavs_filt ## SIZE ## _hv_ff(dst, src, src+stride+1,stride, stride); \
+  OPNAME ## cavs_filt ## SIZE ## _hv_ff(dst, src, NULL, stride, stride); \
 }\
 \
 static void OPNAME ## cavs_qpel ## SIZE ## _mc12_c(uint8_t *dst, const uint8_t *src, ptrdiff_t stride)\
 {\
-  OPNAME ## cavs_filt ## SIZE ## _hv_ii(dst, src, src+stride+1,stride, stride); \
+  OPNAME ## cavs_filt ## SIZE ## _hv_ii(dst, src, NULL, stride, stride); \
 }\
 \
 static void OPNAME ## cavs_qpel ## SIZE ## _mc32_c(uint8_t *dst, const uint8_t *src, ptrdiff_t stride)\
 {\
-  OPNAME ## cavs_filt ## SIZE ## _hv_kk(dst, src, src+stride+1,stride, stride); \
+  OPNAME ## cavs_filt ## SIZE ## _hv_kk(dst, src, NULL, stride, stride); \
 }\
 \
 static void OPNAME ## cavs_qpel ## SIZE ## _mc23_c(uint8_t *dst, const uint8_t *src, ptrdiff_t stride)\
 {\
-  OPNAME ## cavs_filt ## SIZE ## _hv_qq(dst, src, src+stride+1,stride, stride); \
+  OPNAME ## cavs_filt ## SIZE ## _hv_qq(dst, src, NULL, stride, stride); \
 }\
 
 #define op_put1(a, b)  a = cm[((b)+4)>>3]
--- a/third_party/ffmpeg/libavcodec/cbs.c
+++ b/third_party/ffmpeg/libavcodec/cbs.c
@@ -438,6 +438,10 @@
         return err;
 
     av_freep(&par->extradata);
+    par->extradata_size = 0;
+
+    if (!frag->data_size)
+        return 0;
 
     par->extradata = av_malloc(frag->data_size +
                                AV_INPUT_BUFFER_PADDING_SIZE);
@@ -835,12 +839,10 @@
 static void cbs_default_free_unit_content(void *opaque, uint8_t *data)
 {
     const CodedBitstreamUnitTypeDescriptor *desc = opaque;
-    if (desc->content_type == CBS_CONTENT_TYPE_INTERNAL_REFS) {
-        int i;
-        for (i = 0; i < desc->type.ref.nb_offsets; i++) {
-            void **ptr = (void**)(data + desc->type.ref.offsets[i]);
-            av_buffer_unref((AVBufferRef**)(ptr + 1));
-        }
+
+    for (int i = 0; i < desc->type.ref.nb_offsets; i++) {
+        void **ptr = (void**)(data + desc->type.ref.offsets[i]);
+        av_buffer_unref((AVBufferRef**)(ptr + 1));
     }
     av_free(data);
 }
@@ -977,14 +979,6 @@
         return AVERROR(ENOSYS);
 
     switch (desc->content_type) {
-    case CBS_CONTENT_TYPE_POD:
-        ref = av_buffer_alloc(desc->content_size);
-        if (!ref)
-            return AVERROR(ENOMEM);
-        memcpy(ref->data, unit->content, desc->content_size);
-        err = 0;
-        break;
-
     case CBS_CONTENT_TYPE_INTERNAL_REFS:
         err = cbs_clone_internal_refs_unit_content(&ref, unit, desc);
         break;
--- a/third_party/ffmpeg/libavcodec/cbs_av1.c
+++ b/third_party/ffmpeg/libavcodec/cbs_av1.c
@@ -1058,15 +1058,31 @@
     AV1RawTileData *td;
     size_t header_size;
     int err, start_pos, end_pos, data_pos;
+    CodedBitstreamAV1Context av1ctx;
 
     // OBUs in the normal bitstream format must contain a size field
     // in every OBU (in annex B it is optional, but we don't support
     // writing that).
     obu->header.obu_has_size_field = 1;
+    av1ctx = *priv;
+
+    if (priv->sequence_header_ref) {
+        av1ctx.sequence_header_ref = av_buffer_ref(priv->sequence_header_ref);
+        if (!av1ctx.sequence_header_ref)
+            return AVERROR(ENOMEM);
+    }
+
+    if (priv->frame_header_ref) {
+        av1ctx.frame_header_ref = av_buffer_ref(priv->frame_header_ref);
+        if (!av1ctx.frame_header_ref) {
+            err = AVERROR(ENOMEM);
+            goto error;
+        }
+    }
 
     err = cbs_av1_write_obu_header(ctx, pbc, &obu->header);
     if (err < 0)
-        return err;
+        goto error;
 
     if (obu->header.obu_has_size_field) {
         pbc_tmp = *pbc;
@@ -1084,18 +1100,21 @@
             err = cbs_av1_write_sequence_header_obu(ctx, pbc,
                                                     &obu->obu.sequence_header);
             if (err < 0)
-                return err;
+                goto error;
 
             av_buffer_unref(&priv->sequence_header_ref);
             priv->sequence_header = NULL;
 
             err = ff_cbs_make_unit_refcounted(ctx, unit);
             if (err < 0)
-                return err;
+                goto error;
 
             priv->sequence_header_ref = av_buffer_ref(unit->content_ref);
-            if (!priv->sequence_header_ref)
-                return AVERROR(ENOMEM);
+            if (!priv->sequence_header_ref) {
+                err = AVERROR(ENOMEM);
+                goto error;
+            }
+
             priv->sequence_header = &obu->obu.sequence_header;
         }
         break;
@@ -1103,7 +1122,7 @@
         {
             err = cbs_av1_write_temporal_delimiter_obu(ctx, pbc);
             if (err < 0)
-                return err;
+                goto error;
         }
         break;
     case AV1_OBU_FRAME_HEADER:
@@ -1115,7 +1134,7 @@
                                                  AV1_OBU_REDUNDANT_FRAME_HEADER,
                                                  NULL);
             if (err < 0)
-                return err;
+                goto error;
         }
         break;
     case AV1_OBU_TILE_GROUP:
@@ -1123,7 +1142,7 @@
             err = cbs_av1_write_tile_group_obu(ctx, pbc,
                                                &obu->obu.tile_group);
             if (err < 0)
-                return err;
+                goto error;
 
             td = &obu->obu.tile_group.tile_data;
         }
@@ -1132,7 +1151,7 @@
         {
             err = cbs_av1_write_frame_obu(ctx, pbc, &obu->obu.frame, NULL);
             if (err < 0)
-                return err;
+                goto error;
 
             td = &obu->obu.frame.tile_group.tile_data;
         }
@@ -1141,7 +1160,7 @@
         {
             err = cbs_av1_write_tile_list_obu(ctx, pbc, &obu->obu.tile_list);
             if (err < 0)
-                return err;
+                goto error;
 
             td = &obu->obu.tile_list.tile_data;
         }
@@ -1150,18 +1169,19 @@
         {
             err = cbs_av1_write_metadata_obu(ctx, pbc, &obu->obu.metadata);
             if (err < 0)
-                return err;
+                goto error;
         }
         break;
     case AV1_OBU_PADDING:
         {
             err = cbs_av1_write_padding_obu(ctx, pbc, &obu->obu.padding);
             if (err < 0)
-                return err;
+                goto error;
         }
         break;
     default:
-        return AVERROR(ENOSYS);
+        err = AVERROR(ENOSYS);
+        goto error;
     }
 
     end_pos = put_bits_count(pbc);
@@ -1172,7 +1192,7 @@
         // Add trailing bits and recalculate.
         err = cbs_av1_write_trailing_bits(ctx, pbc, 8 - end_pos % 8);
         if (err < 0)
-            return err;
+            goto error;
         end_pos = put_bits_count(pbc);
         obu->obu_size = header_size = (end_pos - start_pos + 7) / 8;
     } else {
@@ -1190,14 +1210,19 @@
     *pbc = pbc_tmp;
     err = cbs_av1_write_leb128(ctx, pbc, "obu_size", obu->obu_size);
     if (err < 0)
-        return err;
+        goto error;
 
     data_pos = put_bits_count(pbc) / 8;
     flush_put_bits(pbc);
     av_assert0(data_pos <= start_pos);
 
-    if (8 * obu->obu_size > put_bits_left(pbc))
+    if (8 * obu->obu_size > put_bits_left(pbc)) {
+        av_buffer_unref(&priv->sequence_header_ref);
+        av_buffer_unref(&priv->frame_header_ref);
+        *priv = av1ctx;
+
         return AVERROR(ENOSPC);
+    }
 
     if (obu->obu_size > 0) {
         memmove(pbc->buf + data_pos,
@@ -1213,8 +1238,13 @@
 
     // OBU data must be byte-aligned.
     av_assert0(put_bits_count(pbc) % 8 == 0);
+    err = 0;
+
+error:
+    av_buffer_unref(&av1ctx.sequence_header_ref);
+    av_buffer_unref(&av1ctx.frame_header_ref);
 
-    return 0;
+    return err;
 }
 
 static int cbs_av1_assemble_fragment(CodedBitstreamContext *ctx,
--- a/third_party/ffmpeg/libavcodec/cbs_internal.h
+++ b/third_party/ffmpeg/libavcodec/cbs_internal.h
@@ -31,9 +31,7 @@
 
 
 enum CBSContentType {
-    // Unit content is a simple structure.
-    CBS_CONTENT_TYPE_POD,
-    // Unit content contains some references to other structures, but all
+    // Unit content may contain some references to other structures, but all
     // managed via buffer reference counting.  The descriptor defines the
     // structure offsets of every buffer reference.
     CBS_CONTENT_TYPE_INTERNAL_REFS,
@@ -43,9 +41,9 @@
 };
 
 enum {
-      // Maximum number of unit types described by the same unit type
-      // descriptor.
-      CBS_MAX_UNIT_TYPES  = 3,
+      // Maximum number of unit types described by the same non-range
+      // unit type descriptor.
+      CBS_MAX_LIST_UNIT_TYPES = 3,
       // Maximum number of reference buffer offsets in any one unit.
       CBS_MAX_REF_OFFSETS = 2,
       // Special value used in a unit type descriptor to indicate that it
@@ -62,7 +60,7 @@
 
     union {
         // Array of unit types that this entry describes.
-        CodedBitstreamUnitType list[CBS_MAX_UNIT_TYPES];
+        CodedBitstreamUnitType list[CBS_MAX_LIST_UNIT_TYPES];
         // Start and end of unit type range, used if nb_unit_types is
         // CBS_UNIT_TYPE_RANGE.
         struct {
@@ -78,9 +76,12 @@
     size_t content_size;
 
     union {
+        // This union's state is determined by content_type:
+        // ref for CBS_CONTENT_TYPE_INTERNAL_REFS,
+        // complex for CBS_CONTENT_TYPE_COMPLEX.
         struct {
-            // Number of entries in the ref_offsets array.  Only nonzero
-            // if the content_type is CBS_CONTENT_TYPE_INTERNAL_REFS.
+            // Number of entries in the ref_offsets array.
+            // May be zero, then the structure is POD-like.
             int nb_offsets;
             // The structure must contain two adjacent elements:
             //   type        *field;
@@ -191,18 +192,20 @@
 #define MIN_INT_BITS(length) (-(INT64_C(1) << ((length) - 1)))
 
 #define TYPE_LIST(...) { __VA_ARGS__ }
-#define CBS_UNIT_TYPE_POD(type, structure) { \
+#define CBS_UNIT_TYPE_POD(type_, structure) { \
         .nb_unit_types  = 1, \
-        .unit_type.list = { type }, \
-        .content_type   = CBS_CONTENT_TYPE_POD, \
+        .unit_type.list = { type_ }, \
+        .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS, \
         .content_size   = sizeof(structure), \
+        .type.ref       = { .nb_offsets = 0 }, \
     }
 #define CBS_UNIT_RANGE_POD(range_start, range_end, structure) { \
         .nb_unit_types         = CBS_UNIT_TYPE_RANGE, \
         .unit_type.range.start = range_start, \
         .unit_type.range.end   = range_end, \
-        .content_type          = CBS_CONTENT_TYPE_POD, \
+        .content_type          = CBS_CONTENT_TYPE_INTERNAL_REFS, \
         .content_size          = sizeof(structure), \
+        .type.ref              = { .nb_offsets = 0 }, \
     }
 
 #define CBS_UNIT_TYPES_INTERNAL_REF(types, structure, ref_field) { \
--- a/third_party/ffmpeg/libavcodec/codec_desc.c
+++ b/third_party/ffmpeg/libavcodec/codec_desc.c
@@ -1909,6 +1909,20 @@
         .long_name = NULL_IF_CONFIG_SMALL("WBMP (Wireless Application Protocol Bitmap) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
+    {
+        .id        = AV_CODEC_ID_MEDIA100,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "media100",
+        .long_name = NULL_IF_CONFIG_SMALL("Media 100i"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_VQC,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "vqc",
+        .long_name = NULL_IF_CONFIG_SMALL("ViewQuest VQC"),
+        .props     = AV_CODEC_PROP_LOSSY,
+    },
 
     /* various PCM "codecs" */
     {
@@ -3304,6 +3318,20 @@
         .long_name = NULL_IF_CONFIG_SMALL("Micronas SC-4 Audio"),
         .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_INTRA_ONLY,
     },
+    {
+        .id        = AV_CODEC_ID_APAC,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "apac",
+        .long_name = NULL_IF_CONFIG_SMALL("Marian's A-pac audio"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+    },
+    {
+        .id        = AV_CODEC_ID_FTR,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "ftr",
+        .long_name = NULL_IF_CONFIG_SMALL("FTR Voice"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
 
     /* subtitle codecs */
     {
--- a/third_party/ffmpeg/libavcodec/codec_id.h
+++ b/third_party/ffmpeg/libavcodec/codec_id.h
@@ -318,6 +318,8 @@
     AV_CODEC_ID_PHM,
     AV_CODEC_ID_RADIANCE_HDR,
     AV_CODEC_ID_WBMP,
+    AV_CODEC_ID_MEDIA100,
+    AV_CODEC_ID_VQC,
 
     /* various PCM "codecs" */
     AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
@@ -529,6 +531,8 @@
     AV_CODEC_ID_DFPWM,
     AV_CODEC_ID_BONK,
     AV_CODEC_ID_MISC4,
+    AV_CODEC_ID_APAC,
+    AV_CODEC_ID_FTR,
 
     /* subtitle codecs */
     AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
--- a/third_party/ffmpeg/libavcodec/codec_internal.h
+++ b/third_party/ffmpeg/libavcodec/codec_internal.h
@@ -276,6 +276,25 @@
         .update_thread_context_for_user = NULL
 #endif
 
+#if FF_API_OLD_CHANNEL_LAYOUT
+#define CODEC_OLD_CHANNEL_LAYOUTS(...) CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(((const uint64_t[]) { __VA_ARGS__, 0 }))
+#if defined(__clang__)
+#define CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(array) \
+        FF_DISABLE_DEPRECATION_WARNINGS \
+        .p.channel_layouts = (array), \
+        FF_ENABLE_DEPRECATION_WARNINGS
+#else
+#define CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(array) .p.channel_layouts = (array),
+#endif
+#else
+/* This is only provided to allow to test disabling FF_API_OLD_CHANNEL_LAYOUT
+ * without removing all the FF_API_OLD_CHANNEL_LAYOUT codeblocks.
+ * It is of course still expected to be removed when FF_API_OLD_CHANNEL_LAYOUT
+ * will be finally removed (along with all usages of these macros). */
+#define CODEC_OLD_CHANNEL_LAYOUTS(...)
+#define CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(array)
+#endif
+
 #define FF_CODEC_DECODE_CB(func)                          \
     .cb_type           = FF_CODEC_CB_TYPE_DECODE,         \
     .cb.decode         = (func)
--- a/third_party/ffmpeg/libavcodec/codec_par.h
+++ b/third_party/ffmpeg/libavcodec/codec_par.h
@@ -32,15 +32,16 @@
 
 /**
  * @addtogroup lavc_core
+ * @{
  */
 
 enum AVFieldOrder {
     AV_FIELD_UNKNOWN,
     AV_FIELD_PROGRESSIVE,
-    AV_FIELD_TT,          //< Top coded_first, top displayed first
-    AV_FIELD_BB,          //< Bottom coded first, bottom displayed first
-    AV_FIELD_TB,          //< Top coded first, bottom displayed first
-    AV_FIELD_BT,          //< Bottom coded first, top displayed first
+    AV_FIELD_TT,          ///< Top coded_first, top displayed first
+    AV_FIELD_BB,          ///< Bottom coded first, bottom displayed first
+    AV_FIELD_TB,          ///< Top coded first, bottom displayed first
+    AV_FIELD_BT,          ///< Bottom coded first, top displayed first
 };
 
 /**
--- a/third_party/ffmpeg/libavcodec/cri.c
+++ b/third_party/ffmpeg/libavcodec/cri.c
@@ -317,6 +317,9 @@
     if (!s->data || !s->data_size)
         return AVERROR_INVALIDDATA;
 
+    if (avctx->skip_frame >= AVDISCARD_ALL)
+        return avpkt->size;
+
     if ((ret = ff_thread_get_buffer(avctx, p, 0)) < 0)
         return ret;
 
@@ -432,6 +435,7 @@
     FF_CODEC_DECODE_CB(cri_decode_frame),
     .close          = cri_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
+                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     CODEC_LONG_NAME("Cintel RAW"),
 };
--- a/third_party/ffmpeg/libavcodec/cyuv.c
+++ b/third_party/ffmpeg/libavcodec/cyuv.c
@@ -37,22 +37,11 @@
 #include "decode.h"
 #include "libavutil/internal.h"
 
-
-typedef struct CyuvDecodeContext {
-    AVCodecContext *avctx;
-    int width, height;
-} CyuvDecodeContext;
-
 static av_cold int cyuv_decode_init(AVCodecContext *avctx)
 {
-    CyuvDecodeContext *s = avctx->priv_data;
-
-    s->avctx = avctx;
-    s->width = avctx->width;
     /* width needs to be divisible by 4 for this codec to work */
-    if (s->width & 0x3)
+    if (avctx->width & 0x3)
         return AVERROR_INVALIDDATA;
-    s->height = avctx->height;
 
     return 0;
 }
@@ -62,7 +51,6 @@
 {
     const uint8_t *buf = avpkt->data;
     int buf_size = avpkt->size;
-    CyuvDecodeContext *s=avctx->priv_data;
 
     unsigned char *y_plane;
     unsigned char *u_plane;
@@ -80,7 +68,7 @@
     int stream_ptr;
     unsigned char cur_byte;
     int pixel_groups;
-    int rawsize = s->height * FFALIGN(s->width,2) * 2;
+    int rawsize = avctx->height * FFALIGN(avctx->width,2) * 2;
     int ret;
 
     if (avctx->codec_id == AV_CODEC_ID_AURA) {
@@ -91,13 +79,13 @@
      * followed by (height) lines each with 3 bytes to represent groups
      * of 4 pixels. Thus, the total size of the buffer ought to be:
      *    (3 * 16) + height * (width * 3 / 4) */
-    if (buf_size == 48 + s->height * (s->width * 3 / 4)) {
+    if (buf_size == 48 + avctx->height * (avctx->width * 3 / 4)) {
         avctx->pix_fmt = AV_PIX_FMT_YUV411P;
     } else if(buf_size == rawsize ) {
         avctx->pix_fmt = AV_PIX_FMT_UYVY422;
     } else {
         av_log(avctx, AV_LOG_ERROR, "got a buffer with %d bytes when %d were expected\n",
-               buf_size, 48 + s->height * (s->width * 3 / 4));
+               buf_size, 48 + avctx->height * (avctx->width * 3 / 4));
         return AVERROR_INVALIDDATA;
     }
 
@@ -112,8 +100,8 @@
     v_plane = frame->data[2];
 
     if (buf_size == rawsize) {
-        int linesize = FFALIGN(s->width,2) * 2;
-        y_plane += frame->linesize[0] * s->height;
+        int linesize = FFALIGN(avctx->width, 2) * 2;
+        y_plane += frame->linesize[0] * avctx->height;
         for (stream_ptr = 0; stream_ptr < rawsize; stream_ptr += linesize) {
             y_plane -= frame->linesize[0];
             memcpy(y_plane, buf+stream_ptr, linesize);
@@ -122,10 +110,10 @@
 
     /* iterate through each line in the height */
     for (y_ptr = 0, u_ptr = 0, v_ptr = 0;
-         y_ptr < (s->height * frame->linesize[0]);
-         y_ptr += frame->linesize[0] - s->width,
-         u_ptr += frame->linesize[1] - s->width / 4,
-         v_ptr += frame->linesize[2] - s->width / 4) {
+         y_ptr < (avctx->height * frame->linesize[0]);
+         y_ptr += frame->linesize[0] - avctx->width,
+         u_ptr += frame->linesize[1] - avctx->width / 4,
+         v_ptr += frame->linesize[2] - avctx->width / 4) {
 
         /* reset predictors */
         cur_byte = buf[stream_ptr++];
@@ -144,7 +132,7 @@
         y_plane[y_ptr++] = y_pred;
 
         /* iterate through the remaining pixel groups (4 pixels/group) */
-        pixel_groups = s->width / 4 - 1;
+        pixel_groups = avctx->width / 4 - 1;
         while (pixel_groups--) {
 
             cur_byte = buf[stream_ptr++];
@@ -180,7 +168,6 @@
     CODEC_LONG_NAME("Auravision AURA"),
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_AURA,
-    .priv_data_size = sizeof(CyuvDecodeContext),
     .init           = cyuv_decode_init,
     FF_CODEC_DECODE_CB(cyuv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
@@ -193,7 +180,6 @@
     CODEC_LONG_NAME("Creative YUV (CYUV)"),
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_CYUV,
-    .priv_data_size = sizeof(CyuvDecodeContext),
     .init           = cyuv_decode_init,
     FF_CODEC_DECODE_CB(cyuv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
--- a/third_party/ffmpeg/libavcodec/dcaenc.c
+++ b/third_party/ffmpeg/libavcodec/dcaenc.c
@@ -1324,14 +1324,9 @@
     .p.sample_fmts         = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S32,
                                                             AV_SAMPLE_FMT_NONE },
     .p.supported_samplerates = sample_rates,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_MONO,
-                                                  AV_CH_LAYOUT_STEREO,
-                                                  AV_CH_LAYOUT_2_2,
-                                                  AV_CH_LAYOUT_5POINT0,
-                                                  AV_CH_LAYOUT_5POINT1,
-                                                  0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO,
+                              AV_CH_LAYOUT_2_2,  AV_CH_LAYOUT_5POINT0,
+                              AV_CH_LAYOUT_5POINT1)
     .p.ch_layouts     = (const AVChannelLayout[]){
         AV_CHANNEL_LAYOUT_MONO,
         AV_CHANNEL_LAYOUT_STEREO,
--- a/third_party/ffmpeg/libavcodec/defs.h
+++ b/third_party/ffmpeg/libavcodec/defs.h
@@ -40,6 +40,28 @@
 #define AV_INPUT_BUFFER_PADDING_SIZE 64
 
 /**
+ * Verify checksums embedded in the bitstream (could be of either encoded or
+ * decoded data, depending on the format) and print an error message on mismatch.
+ * If AV_EF_EXPLODE is also set, a mismatching checksum will result in the
+ * decoder/demuxer returning an error.
+ */
+#define AV_EF_CRCCHECK       (1<<0)
+#define AV_EF_BITSTREAM      (1<<1)   ///< detect bitstream specification deviations
+#define AV_EF_BUFFER         (1<<2)   ///< detect improper bitstream length
+#define AV_EF_EXPLODE        (1<<3)   ///< abort decoding on minor error detection
+
+#define AV_EF_IGNORE_ERR     (1<<15)  ///< ignore errors and continue
+#define AV_EF_CAREFUL        (1<<16)  ///< consider things that violate the spec, are fast to calculate and have not been seen in the wild as errors
+#define AV_EF_COMPLIANT      (1<<17)  ///< consider all spec non compliances as errors
+#define AV_EF_AGGRESSIVE     (1<<18)  ///< consider things that a sane encoder/muxer should not do as an error
+
+#define FF_COMPLIANCE_VERY_STRICT   2 ///< Strictly conform to an older more strict version of the spec or reference software.
+#define FF_COMPLIANCE_STRICT        1 ///< Strictly conform to all the things in the spec no matter what consequences.
+#define FF_COMPLIANCE_NORMAL        0
+#define FF_COMPLIANCE_UNOFFICIAL   -1 ///< Allow unofficial extensions
+#define FF_COMPLIANCE_EXPERIMENTAL -2 ///< Allow nonstandardized experimental things.
+
+/**
  * @ingroup lavc_decoding
  */
 enum AVDiscard{
--- a/third_party/ffmpeg/libavcodec/dirac_dwt.c
+++ b/third_party/ffmpeg/libavcodec/dirac_dwt.c
@@ -45,11 +45,11 @@
     d->decomposition_count = decomposition_count;
 
     if (bit_depth == 8)
-        ret = ff_spatial_idwt_init_8bit(d, type);
+        ret = spatial_idwt_init_8bit(d, type);
     else if (bit_depth == 10)
-        ret = ff_spatial_idwt_init_10bit(d, type);
+        ret = spatial_idwt_init_10bit(d, type);
     else if (bit_depth == 12)
-        ret = ff_spatial_idwt_init_12bit(d, type);
+        ret = spatial_idwt_init_12bit(d, type);
     else
         av_log(NULL, AV_LOG_WARNING, "Unsupported bit depth = %i\n", bit_depth);
 
--- a/third_party/ffmpeg/libavcodec/dirac_dwt.h
+++ b/third_party/ffmpeg/libavcodec/dirac_dwt.h
@@ -61,11 +61,14 @@
     int support;
 
     void (*spatial_compose)(struct DWTContext *cs, int level, int width, int height, int stride);
-    void (*vertical_compose_l0)(void);
-    void (*vertical_compose_h0)(void);
-    void (*vertical_compose_l1)(void);
-    void (*vertical_compose_h1)(void);
-    void (*vertical_compose)(void);     ///< one set of lowpass and highpass combined
+    union {
+        vertical_compose_3tap tap3;
+        vertical_compose_5tap tap5;
+        vertical_compose_9tap tap9;
+    } vertical_compose_l0, vertical_compose_h0;
+    vertical_compose_3tap vertical_compose_l1;
+    vertical_compose_3tap vertical_compose_h1;
+    vertical_compose_2tap vertical_compose;     ///< one set of lowpass and highpass combined
     void (*horizontal_compose)(uint8_t *b, uint8_t *tmp, int width);
 
     DWTCompose cs[MAX_DECOMPOSITIONS];
--- a/third_party/ffmpeg/libavcodec/dirac_dwt_template.c
+++ b/third_party/ffmpeg/libavcodec/dirac_dwt_template.c
@@ -338,8 +338,8 @@
 
 static void RENAME(spatial_compose_dd97i_dy)(DWTContext *d, int level, int width, int height, int stride)
 {
-    vertical_compose_3tap vertical_compose_l0 = (void*)d->vertical_compose_l0;
-    vertical_compose_5tap vertical_compose_h0 = (void*)d->vertical_compose_h0;
+    vertical_compose_3tap vertical_compose_l0 = d->vertical_compose_l0.tap3;
+    vertical_compose_5tap vertical_compose_h0 = d->vertical_compose_h0.tap5;
     DWTCompose *cs = d->cs + level;
 
     int i, y = cs->y;
@@ -362,8 +362,8 @@
 
 static void RENAME(spatial_compose_dirac53i_dy)(DWTContext *d, int level, int width, int height, int stride)
 {
-    vertical_compose_3tap vertical_compose_l0 = (void*)d->vertical_compose_l0;
-    vertical_compose_3tap vertical_compose_h0 = (void*)d->vertical_compose_h0;
+    vertical_compose_3tap vertical_compose_l0 = d->vertical_compose_l0.tap3;
+    vertical_compose_3tap vertical_compose_h0 = d->vertical_compose_h0.tap3;
     DWTCompose *cs = d->cs + level;
 
     int y= cs->y;
@@ -384,8 +384,8 @@
 
 static void RENAME(spatial_compose_dd137i_dy)(DWTContext *d, int level, int width, int height, int stride)
 {
-    vertical_compose_5tap vertical_compose_l0 = (void*)d->vertical_compose_l0;
-    vertical_compose_5tap vertical_compose_h0 = (void*)d->vertical_compose_h0;
+    vertical_compose_5tap vertical_compose_l0 = d->vertical_compose_l0.tap5;
+    vertical_compose_5tap vertical_compose_h0 = d->vertical_compose_h0.tap5;
     DWTCompose *cs = d->cs + level;
 
     int i, y = cs->y;
@@ -409,7 +409,7 @@
 // haar makes the assumption that height is even (always true for dirac)
 static void RENAME(spatial_compose_haari_dy)(DWTContext *d, int level, int width, int height, int stride)
 {
-    vertical_compose_2tap vertical_compose = (void*)d->vertical_compose;
+    vertical_compose_2tap vertical_compose = d->vertical_compose;
     int y = d->cs[level].y;
     uint8_t *b0 = d->buffer + (y-1)*stride;
     uint8_t *b1 = d->buffer + (y  )*stride;
@@ -425,8 +425,8 @@
 // Fortunately, this filter isn't used in practice.
 static void RENAME(spatial_compose_fidelity)(DWTContext *d, int level, int width, int height, int stride)
 {
-    vertical_compose_9tap vertical_compose_l0 = (void*)d->vertical_compose_l0;
-    vertical_compose_9tap vertical_compose_h0 = (void*)d->vertical_compose_h0;
+    vertical_compose_9tap vertical_compose_l0 = d->vertical_compose_l0.tap9;
+    vertical_compose_9tap vertical_compose_h0 = d->vertical_compose_h0.tap9;
     int i, y;
     uint8_t *b[8];
 
@@ -450,10 +450,10 @@
 
 static void RENAME(spatial_compose_daub97i_dy)(DWTContext *d, int level, int width, int height, int stride)
 {
-    vertical_compose_3tap vertical_compose_l0 = (void*)d->vertical_compose_l0;
-    vertical_compose_3tap vertical_compose_h0 = (void*)d->vertical_compose_h0;
-    vertical_compose_3tap vertical_compose_l1 = (void*)d->vertical_compose_l1;
-    vertical_compose_3tap vertical_compose_h1 = (void*)d->vertical_compose_h1;
+    vertical_compose_3tap vertical_compose_l0 = d->vertical_compose_l0.tap3;
+    vertical_compose_3tap vertical_compose_h0 = d->vertical_compose_h0.tap3;
+    vertical_compose_3tap vertical_compose_l1 = d->vertical_compose_l1;
+    vertical_compose_3tap vertical_compose_h1 = d->vertical_compose_h1;
     DWTCompose *cs = d->cs + level;
 
     int i, y = cs->y;
@@ -516,7 +516,7 @@
     cs->y = -5;
 }
 
-static int RENAME(ff_spatial_idwt_init)(DWTContext *d, enum dwt_type type)
+static int RENAME(spatial_idwt_init)(DWTContext *d, enum dwt_type type)
 {
     int level;
 
@@ -552,29 +552,29 @@
     switch (type) {
         case DWT_DIRAC_DD9_7:
             d->spatial_compose = RENAME(spatial_compose_dd97i_dy);
-            d->vertical_compose_l0 = (void*)RENAME(vertical_compose53iL0);
-            d->vertical_compose_h0 = (void*)RENAME(vertical_compose_dd97iH0);
+            d->vertical_compose_l0.tap3 = RENAME(vertical_compose53iL0);
+            d->vertical_compose_h0.tap5 = RENAME(vertical_compose_dd97iH0);
             d->horizontal_compose = RENAME(horizontal_compose_dd97i);
             d->support = 7;
             break;
         case DWT_DIRAC_LEGALL5_3:
             d->spatial_compose = RENAME(spatial_compose_dirac53i_dy);
-            d->vertical_compose_l0 = (void*)RENAME(vertical_compose53iL0);
-            d->vertical_compose_h0 = (void*)RENAME(vertical_compose_dirac53iH0);
+            d->vertical_compose_l0.tap3 = RENAME(vertical_compose53iL0);
+            d->vertical_compose_h0.tap3 = RENAME(vertical_compose_dirac53iH0);
             d->horizontal_compose = RENAME(horizontal_compose_dirac53i);
             d->support = 3;
             break;
         case DWT_DIRAC_DD13_7:
             d->spatial_compose = RENAME(spatial_compose_dd137i_dy);
-            d->vertical_compose_l0 = (void*)RENAME(vertical_compose_dd137iL0);
-            d->vertical_compose_h0 = (void*)RENAME(vertical_compose_dd97iH0);
+            d->vertical_compose_l0.tap5 = RENAME(vertical_compose_dd137iL0);
+            d->vertical_compose_h0.tap5 = RENAME(vertical_compose_dd97iH0);
             d->horizontal_compose = RENAME(horizontal_compose_dd137i);
             d->support = 7;
             break;
         case DWT_DIRAC_HAAR0:
         case DWT_DIRAC_HAAR1:
             d->spatial_compose = RENAME(spatial_compose_haari_dy);
-            d->vertical_compose = (void*)RENAME(vertical_compose_haar);
+            d->vertical_compose = RENAME(vertical_compose_haar);
             if (type == DWT_DIRAC_HAAR0)
                 d->horizontal_compose = RENAME(horizontal_compose_haar0i);
             else
@@ -583,17 +583,17 @@
             break;
         case DWT_DIRAC_FIDELITY:
             d->spatial_compose = RENAME(spatial_compose_fidelity);
-            d->vertical_compose_l0 = (void*)RENAME(vertical_compose_fidelityiL0);
-            d->vertical_compose_h0 = (void*)RENAME(vertical_compose_fidelityiH0);
+            d->vertical_compose_l0.tap9 = RENAME(vertical_compose_fidelityiL0);
+            d->vertical_compose_h0.tap9 = RENAME(vertical_compose_fidelityiH0);
             d->horizontal_compose = RENAME(horizontal_compose_fidelityi);
             d->support = 0; // not really used
             break;
         case DWT_DIRAC_DAUB9_7:
             d->spatial_compose = RENAME(spatial_compose_daub97i_dy);
-            d->vertical_compose_l0 = (void*)RENAME(vertical_compose_daub97iL0);
-            d->vertical_compose_h0 = (void*)RENAME(vertical_compose_daub97iH0);
-            d->vertical_compose_l1 = (void*)RENAME(vertical_compose_daub97iL1);
-            d->vertical_compose_h1 = (void*)RENAME(vertical_compose_daub97iH1);
+            d->vertical_compose_l0.tap3 = RENAME(vertical_compose_daub97iL0);
+            d->vertical_compose_h0.tap3 = RENAME(vertical_compose_daub97iH0);
+            d->vertical_compose_l1 = RENAME(vertical_compose_daub97iL1);
+            d->vertical_compose_h1 = RENAME(vertical_compose_daub97iH1);
             d->horizontal_compose = RENAME(horizontal_compose_daub97i);
             d->support = 5;
             break;
--- a/third_party/ffmpeg/libavcodec/dnxhddec.c
+++ b/third_party/ffmpeg/libavcodec/dnxhddec.c
@@ -65,7 +65,7 @@
     int cur_field;                      ///< current interlaced field
     VLC ac_vlc, dc_vlc, run_vlc;
     IDCTDSPContext idsp;
-    ScanTable scantable;
+    uint8_t permutated_scantable[64];
     const CIDEntry *cid_table;
     int bit_depth; // 8, 10, 12 or 0 if not initialized at all.
     int is_444;
@@ -275,8 +275,8 @@
     if (ctx->bit_depth != old_bit_depth) {
         ff_blockdsp_init(&ctx->bdsp);
         ff_idctdsp_init(&ctx->idsp, ctx->avctx);
-        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,
-                          ff_zigzag_direct);
+        ff_permute_scantable(ctx->permutated_scantable, ff_zigzag_direct,
+                             ctx->idsp.idct_permutation);
     }
 
     // make sure profile size constraints are respected
@@ -436,7 +436,7 @@
             break;
         }
 
-        j     = ctx->scantable.permutated[i];
+        j      = ctx->permutated_scantable[i];
         level *= scale[i];
         level += scale[i] >> 1;
         if (level_bias < 32 || weight_matrix[i] != level_bias)
--- a/third_party/ffmpeg/libavcodec/dstdec.c
+++ b/third_party/ffmpeg/libavcodec/dstdec.c
@@ -215,7 +215,7 @@
     return (ff_reverse[c & 127] >> 1) + 1;
 }
 
-static void build_filter(int16_t table[DST_MAX_ELEMENTS][16][256], const Table *fsets)
+static int build_filter(int16_t table[DST_MAX_ELEMENTS][16][256], const Table *fsets)
 {
     int i, j, k, l;
 
@@ -226,14 +226,17 @@
             int total = av_clip(length - j * 8, 0, 8);
 
             for (k = 0; k < 256; k++) {
-                int v = 0;
+                int64_t v = 0;
 
                 for (l = 0; l < total; l++)
                     v += (((k >> l) & 1) * 2 - 1) * fsets->coeff[i][j * 8 + l];
+                if ((int16_t)v != v)
+                    return AVERROR_INVALIDDATA;
                 table[i][j][k] = v;
             }
         }
     }
+    return 0;
 }
 
 static int decode_frame(AVCodecContext *avctx, AVFrame *frame,
@@ -328,7 +331,9 @@
         return AVERROR_INVALIDDATA;
     ac_init(ac, gb);
 
-    build_filter(s->filter, &s->fsets);
+    ret = build_filter(s->filter, &s->fsets);
+    if (ret < 0)
+        return ret;
 
     memset(s->status, 0xAA, sizeof(s->status));
     memset(dsd, 0, frame->nb_samples * 4 * channels);
--- a/third_party/ffmpeg/libavcodec/dxva2_vc1.c
+++ b/third_party/ffmpeg/libavcodec/dxva2_vc1.c
@@ -372,8 +372,6 @@
                                     &ctx_pic->pp, sizeof(ctx_pic->pp),
                                     NULL, 0,
                                     commit_bitstream_and_slice_buffer);
-    if (!ret)
-        ff_mpeg_draw_horiz_band(&v->s, 0, avctx->height);
     return ret;
 }
 
--- a/third_party/ffmpeg/libavcodec/eac3enc.c
+++ b/third_party/ffmpeg/libavcodec/eac3enc.c
@@ -249,7 +249,6 @@
 }
 
 
-FF_DISABLE_DEPRECATION_WARNINGS
 const FFCodec ff_eac3_encoder = {
     .p.name          = "eac3",
     CODEC_LONG_NAME("ATSC A/52 E-AC-3"),
@@ -264,11 +263,8 @@
                                                       AV_SAMPLE_FMT_NONE },
     .p.priv_class    = &eac3enc_class,
     .p.supported_samplerates = ff_ac3_sample_rate_tab,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = ff_ac3_channel_layouts,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(ff_ac3_channel_layouts)
     .p.ch_layouts    = ff_ac3_ch_layouts,
     .defaults        = ff_ac3_enc_defaults,
     .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 };
-FF_ENABLE_DEPRECATION_WARNINGS
--- a/third_party/ffmpeg/libavcodec/eamad.c
+++ b/third_party/ffmpeg/libavcodec/eamad.c
@@ -39,7 +39,6 @@
 #include "get_bits.h"
 #include "aandcttab.h"
 #include "eaidct.h"
-#include "idctdsp.h"
 #include "mpeg12data.h"
 #include "mpeg12vlc.h"
 
@@ -52,13 +51,11 @@
     AVCodecContext *avctx;
     BlockDSPContext bdsp;
     BswapDSPContext bbdsp;
-    IDCTDSPContext idsp;
     AVFrame *last_frame;
     GetBitContext gb;
     void *bitstream_buf;
     unsigned int bitstream_buf_size;
     DECLARE_ALIGNED(32, int16_t, block)[64];
-    ScanTable scantable;
     uint16_t quant_matrix[64];
     int mb_x;
     int mb_y;
@@ -71,9 +68,6 @@
     avctx->pix_fmt = AV_PIX_FMT_YUV420P;
     ff_blockdsp_init(&s->bdsp);
     ff_bswapdsp_init(&s->bbdsp);
-    ff_idctdsp_init(&s->idsp, avctx);
-    ff_init_scantable_permutation(s->idsp.idct_permutation, FF_IDCT_PERM_NONE);
-    ff_init_scantable(s->idsp.idct_permutation, &s->scantable, ff_zigzag_direct);
     ff_mpeg12_init_vlcs();
 
     s->last_frame = av_frame_alloc();
@@ -134,8 +128,7 @@
 static inline int decode_block_intra(MadContext *s, int16_t * block)
 {
     int level, i, j, run;
-    RLTable *rl = &ff_rl_mpeg1;
-    const uint8_t *scantable = s->scantable.permutated;
+    const uint8_t *scantable = ff_zigzag_direct;
     int16_t *quant_matrix = s->quant_matrix;
 
     block[0] = (128 + get_sbits(&s->gb, 8)) * quant_matrix[0];
@@ -148,7 +141,7 @@
         /* now quantify & encode AC coefficients */
         for (;;) {
             UPDATE_CACHE(re, &s->gb);
-            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
+            GET_RL_VLC(level, run, re, &s->gb, ff_mpeg1_rl_vlc, TEX_VLC_BITS, 2, 0);
 
             if (level == 127) {
                 break;
--- a/third_party/ffmpeg/libavcodec/eatgq.c
+++ b/third_party/ffmpeg/libavcodec/eatgq.c
@@ -39,24 +39,18 @@
 #include "decode.h"
 #include "eaidct.h"
 #include "get_bits.h"
-#include "idctdsp.h"
 
 typedef struct TgqContext {
     AVCodecContext *avctx;
     int width, height;
-    ScanTable scantable;
     int qtable[64];
     DECLARE_ALIGNED(16, int16_t, block)[6][64];
-    GetByteContext gb;
 } TgqContext;
 
 static av_cold int tgq_decode_init(AVCodecContext *avctx)
 {
     TgqContext *s = avctx->priv_data;
-    uint8_t idct_permutation[64];
     s->avctx = avctx;
-    ff_init_scantable_permutation(idct_permutation, FF_IDCT_PERM_NONE);
-    ff_init_scantable(idct_permutation, &s->scantable, ff_zigzag_direct);
     avctx->framerate = (AVRational){ 15, 1 };
     avctx->pix_fmt   = AV_PIX_FMT_YUV420P;
     return 0;
@@ -64,15 +58,15 @@
 
 static void tgq_decode_block(TgqContext *s, int16_t block[64], GetBitContext *gb)
 {
-    uint8_t *perm = s->scantable.permutated;
+    const uint8_t *scantable = ff_zigzag_direct;
     int i, j, value;
     block[0] = get_sbits(gb, 8) * s->qtable[0];
     for (i = 1; i < 64;) {
         switch (show_bits(gb, 3)) {
         case 4:
-            block[perm[i++]] = 0;
+            block[scantable[i++]] = 0;
         case 0:
-            block[perm[i++]] = 0;
+            block[scantable[i++]] = 0;
             skip_bits(gb, 3);
             break;
         case 5:
@@ -80,16 +74,16 @@
             skip_bits(gb, 2);
             value = get_bits(gb, 6);
             for (j = 0; j < value; j++)
-                block[perm[i++]] = 0;
+                block[scantable[i++]] = 0;
             break;
         case 6:
             skip_bits(gb, 3);
-            block[perm[i]] = -s->qtable[perm[i]];
+            block[scantable[i]] = -s->qtable[scantable[i]];
             i++;
             break;
         case 2:
             skip_bits(gb, 3);
-            block[perm[i]] = s->qtable[perm[i]];
+            block[scantable[i]] = s->qtable[scantable[i]];
             i++;
             break;
         case 7: // 111b
@@ -97,9 +91,9 @@
             skip_bits(gb, 2);
             if (show_bits(gb, 6) == 0x3F) {
                 skip_bits(gb, 6);
-                block[perm[i]] = get_sbits(gb, 8) * s->qtable[perm[i]];
+                block[scantable[i]] = get_sbits(gb, 8) * s->qtable[scantable[i]];
             } else {
-                block[perm[i]] = get_sbits(gb, 6) * s->qtable[perm[i]];
+                block[scantable[i]] = get_sbits(gb, 6) * s->qtable[scantable[i]];
             }
             i++;
             break;
@@ -152,34 +146,35 @@
     }
 }
 
-static int tgq_decode_mb(TgqContext *s, AVFrame *frame, int mb_y, int mb_x)
+static int tgq_decode_mb(TgqContext *s, GetByteContext *gbyte,
+                         AVFrame *frame, int mb_y, int mb_x)
 {
     int mode;
     int i;
     int8_t dc[6];
 
-    mode = bytestream2_get_byte(&s->gb);
+    mode = bytestream2_get_byte(gbyte);
     if (mode > 12) {
         GetBitContext gb;
-        int ret = init_get_bits8(&gb, s->gb.buffer, FFMIN(bytestream2_get_bytes_left(&s->gb), mode));
+        int ret = init_get_bits8(&gb, gbyte->buffer, FFMIN(bytestream2_get_bytes_left(gbyte), mode));
         if (ret < 0)
             return ret;
 
         for (i = 0; i < 6; i++)
             tgq_decode_block(s, s->block[i], &gb);
         tgq_idct_put_mb(s, s->block, frame, mb_x, mb_y);
-        bytestream2_skip(&s->gb, mode);
+        bytestream2_skip(gbyte, mode);
     } else {
         if (mode == 3) {
-            memset(dc, bytestream2_get_byte(&s->gb), 4);
-            dc[4] = bytestream2_get_byte(&s->gb);
-            dc[5] = bytestream2_get_byte(&s->gb);
+            memset(dc, bytestream2_get_byte(gbyte), 4);
+            dc[4] = bytestream2_get_byte(gbyte);
+            dc[5] = bytestream2_get_byte(gbyte);
         } else if (mode == 6) {
-            bytestream2_get_buffer(&s->gb, dc, 6);
+            bytestream2_get_buffer(gbyte, dc, 6);
         } else if (mode == 12) {
             for (i = 0; i < 6; i++) {
-                dc[i] = bytestream2_get_byte(&s->gb);
-                bytestream2_skip(&s->gb, 1);
+                dc[i] = bytestream2_get_byte(gbyte);
+                bytestream2_skip(gbyte, 1);
             }
         } else {
             av_log(s->avctx, AV_LOG_ERROR, "unsupported mb mode %i\n", mode);
@@ -207,6 +202,7 @@
     const uint8_t *buf = avpkt->data;
     int buf_size       = avpkt->size;
     TgqContext *s      = avctx->priv_data;
+    GetByteContext gbyte;
     int x, y, ret;
     int big_endian;
 
@@ -215,21 +211,21 @@
         return AVERROR_INVALIDDATA;
     }
     big_endian = AV_RL32(&buf[4]) > 0x000FFFFF;
-    bytestream2_init(&s->gb, buf + 8, buf_size - 8);
+    bytestream2_init(&gbyte, buf + 8, buf_size - 8);
     if (big_endian) {
-        s->width  = bytestream2_get_be16u(&s->gb);
-        s->height = bytestream2_get_be16u(&s->gb);
+        s->width  = bytestream2_get_be16u(&gbyte);
+        s->height = bytestream2_get_be16u(&gbyte);
     } else {
-        s->width  = bytestream2_get_le16u(&s->gb);
-        s->height = bytestream2_get_le16u(&s->gb);
+        s->width  = bytestream2_get_le16u(&gbyte);
+        s->height = bytestream2_get_le16u(&gbyte);
     }
 
     ret = ff_set_dimensions(s->avctx, s->width, s->height);
     if (ret < 0)
         return ret;
 
-    tgq_calculate_qtable(s, bytestream2_get_byteu(&s->gb));
-    bytestream2_skip(&s->gb, 3);
+    tgq_calculate_qtable(s, bytestream2_get_byteu(&gbyte));
+    bytestream2_skipu(&gbyte, 3);
 
     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
         return ret;
@@ -238,7 +234,7 @@
 
     for (y = 0; y < FFALIGN(avctx->height, 16) >> 4; y++)
         for (x = 0; x < FFALIGN(avctx->width, 16) >> 4; x++)
-            if (tgq_decode_mb(s, frame, y, x) < 0)
+            if (tgq_decode_mb(s, &gbyte, frame, y, x) < 0)
                 return AVERROR_INVALIDDATA;
 
     *got_frame = 1;
--- a/third_party/ffmpeg/libavcodec/eatqi.c
+++ b/third_party/ffmpeg/libavcodec/eatqi.c
@@ -36,7 +36,6 @@
 #include "get_bits.h"
 #include "aandcttab.h"
 #include "eaidct.h"
-#include "idctdsp.h"
 #include "mpeg12data.h"
 #include "mpeg12dec.h"
 
@@ -45,8 +44,6 @@
     GetBitContext gb;
     BlockDSPContext bdsp;
     BswapDSPContext bsdsp;
-    IDCTDSPContext idsp;
-    ScanTable intra_scantable;
 
     void *bitstream_buf;
     unsigned int bitstream_buf_size;
@@ -64,9 +61,6 @@
 
     ff_blockdsp_init(&t->bdsp);
     ff_bswapdsp_init(&t->bsdsp);
-    ff_idctdsp_init(&t->idsp, avctx);
-    ff_init_scantable_permutation(t->idsp.idct_permutation, FF_IDCT_PERM_NONE);
-    ff_init_scantable(t->idsp.idct_permutation, &t->intra_scantable, ff_zigzag_direct);
 
     avctx->framerate = (AVRational){ 15, 1 };
     avctx->pix_fmt = AV_PIX_FMT_YUV420P;
@@ -82,7 +76,7 @@
     for (n = 0; n < 6; n++) {
         int ret = ff_mpeg1_decode_block_intra(&t->gb,
                                               t->intra_matrix,
-                                              t->intra_scantable.permutated,
+                                              ff_zigzag_direct,
                                               t->last_dc, block[n], n, 1);
         if (ret < 0) {
             av_log(t->avctx, AV_LOG_ERROR, "ac-tex damaged at %d %d\n",
--- a/third_party/ffmpeg/libavcodec/encode.c
+++ b/third_party/ffmpeg/libavcodec/encode.c
@@ -209,21 +209,24 @@
             av_assert0(avpkt->buf);
         }
 
-        if (avctx->codec->type == AVMEDIA_TYPE_VIDEO &&
-            !(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))
-            avpkt->pts = avpkt->dts = frame->pts;
+        // set the timestamps for the simple no-delay case
+        // encoders with delay have to set the timestamps themselves
         if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY)) {
+            if (avpkt->pts == AV_NOPTS_VALUE)
+                avpkt->pts = frame->pts;
+
             if (avctx->codec->type == AVMEDIA_TYPE_AUDIO) {
-                if (avpkt->pts == AV_NOPTS_VALUE)
-                    avpkt->pts = frame->pts;
                 if (!avpkt->duration)
                     avpkt->duration = ff_samples_to_time_base(avctx,
                                                               frame->nb_samples);
             }
         }
-        if (avctx->codec->type == AVMEDIA_TYPE_AUDIO) {
+
+        // dts equals pts unless there is reordering
+        // there can be no reordering if there is no encoder delay
+        if (!(avctx->codec_descriptor->props & AV_CODEC_PROP_REORDER) ||
+            !(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))
             avpkt->dts = avpkt->pts;
-        }
     } else {
 unref:
         av_packet_unref(avpkt);
--- a/third_party/ffmpeg/libavcodec/escape124.c
+++ b/third_party/ffmpeg/libavcodec/escape124.c
@@ -178,8 +178,8 @@
    dst[4] = mb.pixels32[1];
 }
 
-static void copy_superblock(uint16_t* dest, unsigned dest_stride,
-                            uint16_t* src, unsigned src_stride)
+static void copy_superblock(uint16_t* dest, ptrdiff_t dest_stride,
+                            uint16_t* src,  ptrdiff_t src_stride)
 {
     unsigned y;
     if (src)
@@ -211,7 +211,7 @@
              superblocks_per_row = avctx->width / 8, skip = -1;
 
     uint16_t* old_frame_data, *new_frame_data;
-    unsigned old_stride, new_stride;
+    ptrdiff_t old_stride, new_stride;
 
     int ret;
 
--- a/third_party/ffmpeg/libavcodec/exr.c
+++ b/third_party/ffmpeg/libavcodec/exr.c
@@ -2121,6 +2121,9 @@
 
     ff_set_sar(s->avctx, av_d2q(av_int2float(s->sar), 255));
 
+    if (avctx->skip_frame >= AVDISCARD_ALL)
+        return avpkt->size;
+
     s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);
     if (!s->desc)
         return AVERROR_INVALIDDATA;
@@ -2351,5 +2354,6 @@
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |
                         AV_CODEC_CAP_SLICE_THREADS,
+    .caps_internal    = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .p.priv_class     = &exr_class,
 };
--- a/third_party/ffmpeg/libavcodec/ffv1.h
+++ b/third_party/ffmpeg/libavcodec/ffv1.h
@@ -182,16 +182,4 @@
     state->count = count;
 }
 
-#define TYPE int16_t
-#define RENAME(name) name
-#include "ffv1_template.c"
-#undef TYPE
-#undef RENAME
-
-#define TYPE int32_t
-#define RENAME(name) name ## 32
-#include "ffv1_template.c"
-#undef TYPE
-#undef RENAME
-
 #endif /* AVCODEC_FFV1_H */
--- a/third_party/ffmpeg/libavcodec/ffv1dec.c
+++ b/third_party/ffmpeg/libavcodec/ffv1dec.c
@@ -303,8 +303,11 @@
     }
     if ((ret = ff_ffv1_init_slice_state(f, fs)) < 0)
         return ret;
-    if (f->cur->key_frame || fs->slice_reset_contexts)
+    if (f->cur->key_frame || fs->slice_reset_contexts) {
         ff_ffv1_clear_slice_state(f, fs);
+    } else if (fs->slice_damaged) {
+        return AVERROR_INVALIDDATA;
+    }
 
     width  = fs->slice_width;
     height = fs->slice_height;
@@ -1099,7 +1102,7 @@
     .close          = ffv1_decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     UPDATE_THREAD_CONTEXT(update_thread_context),
-    .p.capabilities = AV_CODEC_CAP_DR1 /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/ |
+    .p.capabilities = AV_CODEC_CAP_DR1 |
                       AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS,
     .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_ALLOCATE_PROGRESS,
--- a/third_party/ffmpeg/libavcodec/ffv1dec_template.c
+++ b/third_party/ffmpeg/libavcodec/ffv1dec_template.c
@@ -20,6 +20,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "ffv1_template.c"
+
 static av_always_inline int RENAME(decode_line)(FFV1Context *s, int w,
                                                  TYPE *sample[2],
                                                  int plane_index, int bits)
--- a/third_party/ffmpeg/libavcodec/ffv1enc_template.c
+++ b/third_party/ffmpeg/libavcodec/ffv1enc_template.c
@@ -20,6 +20,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "ffv1_template.c"
+
 static av_always_inline int RENAME(encode_line)(FFV1Context *s, int w,
                                                 TYPE *sample[3],
                                                 int plane_index, int bits)
--- a/third_party/ffmpeg/libavcodec/fmtconvert.c
+++ b/third_party/ffmpeg/libavcodec/fmtconvert.c
@@ -52,6 +52,8 @@
     ff_fmt_convert_init_arm(c);
 #elif ARCH_PPC
     ff_fmt_convert_init_ppc(c);
+#elif ARCH_RISCV
+    ff_fmt_convert_init_riscv(c);
 #elif ARCH_X86
     ff_fmt_convert_init_x86(c);
 #endif
--- a/third_party/ffmpeg/libavcodec/fmtconvert.h
+++ b/third_party/ffmpeg/libavcodec/fmtconvert.h
@@ -61,6 +61,7 @@
 void ff_fmt_convert_init_aarch64(FmtConvertContext *c);
 void ff_fmt_convert_init_arm(FmtConvertContext *c);
 void ff_fmt_convert_init_ppc(FmtConvertContext *c);
+void ff_fmt_convert_init_riscv(FmtConvertContext *c);
 void ff_fmt_convert_init_x86(FmtConvertContext *c);
 void ff_fmt_convert_init_mips(FmtConvertContext *c);
 
--- a/third_party/ffmpeg/libavcodec/fraps.c
+++ b/third_party/ffmpeg/libavcodec/fraps.c
@@ -141,7 +141,6 @@
     int buf_size           = avpkt->size;
     uint32_t header;
     unsigned int version,header_size;
-    unsigned int x, y;
     const uint32_t *buf32;
     uint32_t *luma1,*luma2,*cb,*cr;
     uint32_t offs[4];
@@ -238,12 +237,12 @@
         }
 
         buf32 = (const uint32_t*)buf;
-        for (y = 0; y < avctx->height / 2; y++) {
+        for (ptrdiff_t y = 0; y < avctx->height / 2; y++) {
             luma1 = (uint32_t*)&f->data[0][  y * 2      * f->linesize[0] ];
             luma2 = (uint32_t*)&f->data[0][ (y * 2 + 1) * f->linesize[0] ];
             cr    = (uint32_t*)&f->data[1][  y          * f->linesize[1] ];
             cb    = (uint32_t*)&f->data[2][  y          * f->linesize[2] ];
-            for (x = 0; x < avctx->width; x += 8) {
+            for (ptrdiff_t x = 0; x < avctx->width; x += 8) {
                 *luma1++ = *buf32++;
                 *luma1++ = *buf32++;
                 *luma2++ = *buf32++;
@@ -258,18 +257,18 @@
         if (is_pal) {
             uint32_t *pal = (uint32_t *)f->data[1];
 
-            for (y = 0; y < 256; y++) {
+            for (unsigned y = 0; y < 256; y++) {
                 pal[y] = AV_RL32(buf) | 0xFF000000;
                 buf += 4;
             }
 
-            for (y = 0; y <avctx->height; y++)
+            for (ptrdiff_t y = 0; y < avctx->height; y++)
                 memcpy(&f->data[0][y * f->linesize[0]],
                        &buf[y * avctx->width],
                        avctx->width);
         } else {
         /* Fraps v1 is an upside-down BGR24 */
-            for (y = 0; y<avctx->height; y++)
+            for (ptrdiff_t y = 0; y < avctx->height; y++)
                 memcpy(&f->data[0][(avctx->height - y - 1) * f->linesize[0]],
                        &buf[y * avctx->width * 3],
                        3 * avctx->width);
--- a/third_party/ffmpeg/libavcodec/g2meet.c
+++ b/third_party/ffmpeg/libavcodec/g2meet.c
@@ -59,22 +59,23 @@
     COMPR_KEMPF_J_B,
 };
 
+/* These tables are already permuted according to ff_zigzag_direct */
 static const uint8_t luma_quant[64] = {
-     8,  6,  5,  8, 12, 20, 26, 31,
-     6,  6,  7, 10, 13, 29, 30, 28,
-     7,  7,  8, 12, 20, 29, 35, 28,
-     7,  9, 11, 15, 26, 44, 40, 31,
-     9, 11, 19, 28, 34, 55, 52, 39,
-    12, 18, 28, 32, 41, 52, 57, 46,
-    25, 32, 39, 44, 52, 61, 60, 51,
-    36, 46, 48, 49, 56, 50, 52, 50
+     8,  6,  6,  7,  6,  5,  8,  7,
+     7,  7,  9,  9,  8, 10, 12, 20,
+    13, 12, 11, 11, 12, 25, 18, 19,
+    15, 20, 29, 26, 31, 30, 29, 26,
+    28, 28, 32, 36, 46, 39, 32, 34,
+    44, 35, 28, 28, 40, 55, 41, 44,
+    48, 49, 52, 52, 52, 31, 39, 57,
+    61, 56, 50, 60, 46, 51, 52, 50,
 };
 
 static const uint8_t chroma_quant[64] = {
-     9,  9, 12, 24, 50, 50, 50, 50,
-     9, 11, 13, 33, 50, 50, 50, 50,
-    12, 13, 28, 50, 50, 50, 50, 50,
-    24, 33, 50, 50, 50, 50, 50, 50,
+     9,  9,  9, 12, 11, 12, 24, 13,
+    13, 24, 50, 33, 28, 33, 50, 50,
+    50, 50, 50, 50, 50, 50, 50, 50,
+    50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50,
@@ -120,7 +121,7 @@
 typedef struct JPGContext {
     BlockDSPContext bdsp;
     IDCTDSPContext idsp;
-    ScanTable  scantable;
+    uint8_t    permutated_scantable[64];
 
     VLC        dc_vlc[2], ac_vlc[2];
     int        prev_dc[3];
@@ -182,8 +183,8 @@
 
     ff_blockdsp_init(&c->bdsp);
     ff_idctdsp_init(&c->idsp, avctx);
-    ff_init_scantable(c->idsp.idct_permutation, &c->scantable,
-                      ff_zigzag_direct);
+    ff_permute_scantable(c->permutated_scantable, ff_zigzag_direct,
+                         c->idsp.idct_permutation);
 
     return 0;
 }
@@ -250,8 +251,8 @@
             int nbits = val;
 
             val                                 = get_xbits(gb, nbits);
-            val                                *= qmat[ff_zigzag_direct[pos]];
-            block[c->scantable.permutated[pos]] = val;
+            val                                *= qmat[pos];
+            block[c->permutated_scantable[pos]] = val;
         }
     }
     return 0;
--- a/third_party/ffmpeg/libavcodec/g722enc.c
+++ b/third_party/ffmpeg/libavcodec/g722enc.c
@@ -381,9 +381,7 @@
     .close           = g722_encode_close,
     FF_CODEC_ENCODE_CB(g722_encode_frame),
     .p.sample_fmts   = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE },
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = (const uint64_t[]){ AV_CH_LAYOUT_MONO, 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO)
     .p.ch_layouts   = (const AVChannelLayout[]){
         AV_CHANNEL_LAYOUT_MONO, { 0 }
     },
--- a/third_party/ffmpeg/libavcodec/g723_1enc.c
+++ b/third_party/ffmpeg/libavcodec/g723_1enc.c
@@ -126,7 +126,7 @@
 {
     int i;
     for (i = 0; i < FRAME_LEN; i++) {
-        *iir   = (buf[i] << 15) + ((-*fir) << 15) + MULL2(*iir, 0x7f00);
+        *iir   = (buf[i] - *fir) * (1 << 15) + MULL2(*iir, 0x7f00);
         *fir   = buf[i];
         buf[i] = av_clipl_int32((int64_t)*iir + (1 << 15)) >> 16;
     }
@@ -166,7 +166,7 @@
     } else {
         for (i = 1; i <= LPC_ORDER; i++) {
             temp        = ff_dot_product(vector, vector + i, LPC_FRAME - i);
-            temp        = MULL2((temp << scale), binomial_window[i - 1]);
+            temp        = MULL2(temp * (1 << scale), binomial_window[i - 1]);
             autocorr[i] = av_clipl_int32((int64_t) temp + (1 << 15)) >> 16;
         }
     }
@@ -193,15 +193,14 @@
         temp = 0;
         for (j = 0; j < i; j++)
             temp -= lpc[j] * autocorr[i - j - 1];
-        temp = ((autocorr[i] << 13) + temp) << 3;
+        temp = (autocorr[i] * (1 << 13) + temp) * (1 << 3);
 
         if (FFABS(temp) >= (error << 16))
             break;
 
         partial_corr = temp / (error << 1);
 
-        lpc[i] = av_clipl_int32((int64_t) (partial_corr << 14) +
-                                (1 << 15)) >> 16;
+        lpc[i] = (partial_corr + (1 << 1)) >> 2;
 
         /* Update the prediction error */
         temp  = MULL2(temp, partial_corr);
@@ -210,8 +209,8 @@
 
         memcpy(vector, lpc, i * sizeof(int16_t));
         for (j = 0; j < i; j++) {
-            temp   = partial_corr * vector[i - j - 1] << 1;
-            lpc[j] = av_clipl_int32((int64_t) (lpc[j] << 16) - temp +
+            temp   = partial_corr * vector[i - j - 1] * 2;
+            lpc[j] = av_clipl_int32((int64_t) (lpc[j] * (1 << 16)) - temp +
                                     (1 << 15)) >> 16;
         }
     }
@@ -260,9 +259,9 @@
     /* Compute the remaining coefficients */
     for (i = 0; i < LPC_ORDER / 2; i++) {
         /* f1 */
-        f[2 * i + 2] = -f[2 * i] - ((lsp[i] + lsp[LPC_ORDER - 1 - i]) << 12);
+        f[2 * i + 2] = -f[2 * i]    - (lsp[i] + lsp[LPC_ORDER - 1 - i]) * (1 << 12);
         /* f2 */
-        f[2 * i + 3] = f[2 * i + 1] - ((lsp[i] - lsp[LPC_ORDER - 1 - i]) << 12);
+        f[2 * i + 3] = f[2 * i + 1] - (lsp[i] - lsp[LPC_ORDER - 1 - i]) * (1 << 12);
     }
 
     /* Divide f1[5] and f2[5] by 2 for use in polynomial evaluation */
@@ -277,7 +276,7 @@
     shift = ff_g723_1_normalize_bits(max, 31);
 
     for (i = 0; i < LPC_ORDER + 2; i++)
-        f[i] = av_clipl_int32((int64_t) (f[i] << shift) + (1 << 15)) >> 16;
+        f[i] = av_clipl_int32((int64_t) (f[i] * (1 << shift)) + (1 << 15)) >> 16;
 
     /**
      * Evaluate F1 and F2 at uniform intervals of pi/256 along the
@@ -294,7 +293,7 @@
         temp = 0;
         for (j = 0; j <= LPC_ORDER / 2; j++)
             temp += f[LPC_ORDER - 2 * j + p] * ff_g723_1_cos_tab[i * j % COS_TBL_SIZE];
-        cur_val = av_clipl_int32(temp << 1);
+        cur_val = av_clipl_int32(temp * 2);
 
         /* Check for sign change, indicating a zero crossing */
         if ((cur_val ^ prev_val) < 0) {
@@ -318,7 +317,7 @@
             for (j = 0; j <= LPC_ORDER / 2; j++)
                 temp += f[LPC_ORDER - 2 * j + p] *
                         ff_g723_1_cos_tab[i * j % COS_TBL_SIZE];
-            cur_val = av_clipl_int32(temp << 1);
+            cur_val = av_clipl_int32(temp * 2);
         }
         prev_val = cur_val;
     }
@@ -345,7 +344,7 @@
             temp[j] = (weight[j + (offset)] * ff_g723_1_lsp_band##num[i][j] + \
                       (1 << 14)) >> 15;                                       \
         }                                                                     \
-        error  = ff_g723_1_dot_product(lsp + (offset), temp, size) << 1;      \
+        error  = ff_g723_1_dot_product(lsp + (offset), temp, size) * 2;       \
         error -= ff_g723_1_dot_product(ff_g723_1_lsp_band##num[i], temp, size); \
         if (error > max) {                                                    \
             max = error;                                                      \
@@ -420,7 +419,7 @@
                       iir_coef[n - 1] * dest[m - n];
         }
 
-        dest[m] = av_clipl_int32((src[m] << 16) + (filter << 3) +
+        dest[m] = av_clipl_int32(src[m] * (1 << 16) + filter * (1 << 3) +
                                  (1 << 15)) >> 16;
     }
 }
@@ -560,7 +559,7 @@
 
     exp = ff_g723_1_normalize_bits(max, 31);
     for (i = 0; i < 15; i++) {
-        energy[i] = av_clipl_int32((int64_t)(energy[i] << exp) +
+        energy[i] = av_clipl_int32((int64_t)(energy[i] * (1 << exp)) +
                                    (1 << 15)) >> 16;
     }
 
@@ -614,8 +613,8 @@
     int i;
 
     for (i = 0; i < SUBFRAME_LEN; i++) {
-        int64_t temp = hf->gain * src[i - hf->index] << 1;
-        dest[i] = av_clipl_int32((src[i] << 16) - temp + (1 << 15)) >> 16;
+        int64_t temp = hf->gain * src[i - hf->index] * 2;
+        dest[i] = av_clipl_int32(src[i] * (1 << 16) - temp + (1 << 15)) >> 16;
     }
 }
 
@@ -623,8 +622,8 @@
 {
     int i;
     for (i = 0; i < SUBFRAME_LEN; i++) {
-        int64_t temp = hf->gain * src[i - hf->index] << 1;
-        dest[i] = av_clipl_int32(((dest[i] - src[i]) << 16) + temp +
+        int64_t temp = hf->gain * src[i - hf->index] * 2;
+        dest[i] = av_clipl_int32((dest[i] - src[i]) * (1 << 16) + temp +
                                  (1 << 15)) >> 16;
     }
 }
@@ -656,7 +655,7 @@
         for (j = 1; j <= LPC_ORDER; j++)
             temp -= qnt_lpc[j - 1] * bptr_16[i - j];
 
-        buf[i]     = (src[i] << 15) + (temp << 3);
+        buf[i]     = src[i] * (1 << 15) + temp * (1 << 3);
         bptr_16[i] = av_clipl_int32(buf[i] + (1 << 15)) >> 16;
     }
 
@@ -666,7 +665,7 @@
             fir -= perf_lpc[j - 1] * bptr_16[i - j];
             iir += perf_lpc[j + LPC_ORDER - 1] * dest[i - j];
         }
-        dest[i] = av_clipl_int32(((buf[i] + (fir << 3)) << scale) + (iir << 3) +
+        dest[i] = av_clipl_int32((buf[i] + fir * (1 << 3)) * (1 << scale) + iir * (1 << 3) +
                                  (1 << 15)) >> 16;
     }
     memcpy(perf_fir, buf_16 + SUBFRAME_LEN, sizeof(int16_t) * LPC_ORDER);
@@ -715,23 +714,22 @@
             temp = 0;
             for (k = 0; k <= j; k++)
                 temp += residual[PITCH_ORDER - 1 + k] * impulse_resp[j - k];
-            flt_buf[PITCH_ORDER - 1][j] = av_clipl_int32((temp << 1) +
-                                                         (1 << 15)) >> 16;
+            flt_buf[PITCH_ORDER - 1][j] = av_clipl_int32(temp * 2 + (1 << 15)) >> 16;
         }
 
         for (j = PITCH_ORDER - 2; j >= 0; j--) {
-            flt_buf[j][0] = ((residual[j] << 13) + (1 << 14)) >> 15;
+            flt_buf[j][0] = (residual[j] + (1 << 1)) >> 2;
             for (k = 1; k < SUBFRAME_LEN; k++) {
-                temp = (flt_buf[j + 1][k - 1] << 15) +
+                temp = flt_buf[j + 1][k - 1] * (1 << 15) +
                        residual[j] * impulse_resp[k];
-                flt_buf[j][k] = av_clipl_int32((temp << 1) + (1 << 15)) >> 16;
+                flt_buf[j][k] = av_clipl_int32(temp * 2 + (1 << 15)) >> 16;
             }
         }
 
         /* Compute crosscorrelation with the signal */
         for (j = 0; j < PITCH_ORDER; j++) {
             temp             = ff_dot_product(buf, flt_buf[j], SUBFRAME_LEN);
-            ccr_buf[count++] = av_clipl_int32(temp << 1);
+            ccr_buf[count++] = av_clipl_int32(temp * 2);
         }
 
         /* Compute energies */
@@ -743,7 +741,7 @@
         for (j = 1; j < PITCH_ORDER; j++) {
             for (k = 0; k < j; k++) {
                 temp             = ff_dot_product(flt_buf[j], flt_buf[k], SUBFRAME_LEN);
-                ccr_buf[count++] = av_clipl_int32(temp << 2);
+                ccr_buf[count++] = av_clipl_int32(temp * (1 << 2));
             }
         }
     }
@@ -756,7 +754,7 @@
     temp = ff_g723_1_normalize_bits(max, 31);
 
     for (i = 0; i < 20 * iter; i++)
-        ccr_buf[i] = av_clipl_int32((int64_t) (ccr_buf[i] << temp) +
+        ccr_buf[i] = av_clipl_int32((int64_t) (ccr_buf[i] * (1 << temp)) +
                                     (1 << 15)) >> 16;
 
     max = 0;
@@ -804,11 +802,11 @@
     int i, j;
     /* Subtract adaptive CB contribution to obtain the residual */
     for (i = 0; i < SUBFRAME_LEN; i++) {
-        int64_t temp = buf[i] << 14;
+        int64_t temp = buf[i] * (1 << 14);
         for (j = 0; j <= i; j++)
             temp -= residual[j] * impulse_resp[i - j];
 
-        buf[i] = av_clipl_int32((temp << 2) + (1 << 15)) >> 16;
+        buf[i] = av_clipl_int32(temp * (1 << 2) + (1 << 15)) >> 16;
     }
 }
 
@@ -852,7 +850,7 @@
     for (i = 1; i < SUBFRAME_LEN; i++) {
         temp = ff_g723_1_dot_product(temp_corr + i, temp_corr,
                                      SUBFRAME_LEN - i);
-        impulse_corr[i] = av_clipl_int32((temp << scale) + (1 << 15)) >> 16;
+        impulse_corr[i] = av_clipl_int32(temp * (1 << scale) + (1 << 15)) >> 16;
     }
 
     /* Compute crosscorrelation of impulse response with residual signal */
@@ -862,7 +860,7 @@
         if (scale < 0)
             ccr1[i] = temp >> -scale;
         else
-            ccr1[i] = av_clipl_int32(temp << scale);
+            ccr1[i] = av_clipl_int32(temp * (1 << scale));
     }
 
     /* Search loop */
@@ -911,7 +909,7 @@
                         continue;
                     temp = impulse_corr[FFABS(l - param.pulse_pos[k - 1])];
                     temp = av_clipl_int32((int64_t) temp *
-                                          param.pulse_sign[k - 1] << 1);
+                                          param.pulse_sign[k - 1] * 2);
                     ccr2[l] -= temp;
                     temp     = FFABS(ccr2[l]);
                     if (temp > max) {
@@ -935,17 +933,17 @@
                 temp = 0;
                 for (l = 0; l <= k; l++) {
                     int prod = av_clipl_int32((int64_t) temp_corr[l] *
-                                              impulse_r[k - l] << 1);
+                                              impulse_r[k - l] * 2);
                     temp = av_clipl_int32(temp + prod);
                 }
-                temp_corr[k] = temp << 2 >> 16;
+                temp_corr[k] = temp >> 14;
             }
 
             /* Compute square of error */
             err = 0;
             for (k = 0; k < SUBFRAME_LEN; k++) {
                 int64_t prod;
-                prod = av_clipl_int32((int64_t) buf[k] * temp_corr[k] << 1);
+                prod = av_clipl_int32((int64_t) buf[k] * temp_corr[k] * 2);
                 err  = av_clipl_int32(err - prod);
                 prod = av_clipl_int32((int64_t) temp_corr[k] * temp_corr[k]);
                 err  = av_clipl_int32(err + prod);
@@ -1205,7 +1203,7 @@
         memmove(p->prev_excitation, p->prev_excitation + SUBFRAME_LEN,
                 sizeof(int16_t) * (PITCH_MAX - SUBFRAME_LEN));
         for (j = 0; j < SUBFRAME_LEN; j++)
-            in[j] = av_clip_int16((in[j] << 1) + impulse_resp[j]);
+            in[j] = av_clip_int16(in[j] * 2 + impulse_resp[j]);
         memcpy(p->prev_excitation + PITCH_MAX - SUBFRAME_LEN, in,
                sizeof(int16_t) * SUBFRAME_LEN);
 
--- a/third_party/ffmpeg/libavcodec/h261.c
+++ b/third_party/ffmpeg/libavcodec/h261.c
@@ -30,9 +30,9 @@
 
 #define IS_FIL(a)    ((a) & MB_TYPE_H261_FIL)
 
-static void h261_loop_filter(uint8_t *src, int stride)
+static void h261_loop_filter(uint8_t *src, ptrdiff_t stride)
 {
-    int x, y, xy, yz;
+    int x, y;
     int temp[64];
 
     for (x = 0; x < 8; x++) {
@@ -41,8 +41,8 @@
     }
     for (y = 1; y < 7; y++) {
         for (x = 0; x < 8; x++) {
-            xy       = y * stride + x;
-            yz       = y * 8      + x;
+            ptrdiff_t xy = y * stride + x;
+            ptrdiff_t yz = y * 8      + x;
             temp[yz] = src[xy - stride] + 2 * src[xy] + src[xy + stride];
         }
     }
@@ -51,8 +51,8 @@
         src[y * stride]     = (temp[y * 8]     + 2) >> 2;
         src[y * stride + 7] = (temp[y * 8 + 7] + 2) >> 2;
         for (x = 1; x < 7; x++) {
-            xy      = y * stride + x;
-            yz      = y * 8      + x;
+            ptrdiff_t xy = y * stride + x;
+            ptrdiff_t yz = y * 8      + x;
             src[xy] = (temp[yz - 1] + 2 * temp[yz] + temp[yz + 1] + 8) >> 4;
         }
     }
@@ -61,8 +61,8 @@
 void ff_h261_loop_filter(MpegEncContext *s)
 {
     H261Context *const h = s->private_ctx;
-    const int linesize   = s->linesize;
-    const int uvlinesize = s->uvlinesize;
+    const ptrdiff_t linesize   = s->linesize;
+    const ptrdiff_t uvlinesize = s->uvlinesize;
     uint8_t *dest_y      = s->dest[0];
     uint8_t *dest_cb     = s->dest[1];
     uint8_t *dest_cr     = s->dest[2];
--- a/third_party/ffmpeg/libavcodec/h261enc.c
+++ b/third_party/ffmpeg/libavcodec/h261enc.c
@@ -46,25 +46,16 @@
     H261Context common;
 
     int gob_number;
+    enum {
+        H261_QCIF = 0,
+        H261_CIF  = 1,
+    } format;
 } H261EncContext;
 
-int ff_h261_get_picture_format(int width, int height)
-{
-    // QCIF
-    if (width == 176 && height == 144)
-        return 0;
-    // CIF
-    else if (width == 352 && height == 288)
-        return 1;
-    // ERROR
-    else
-        return AVERROR(EINVAL);
-}
-
 void ff_h261_encode_picture_header(MpegEncContext *s, int picture_number)
 {
     H261EncContext *const h = (H261EncContext *)s;
-    int format, temp_ref;
+    int temp_ref;
 
     align_put_bits(&s->pb);
 
@@ -81,18 +72,13 @@
     put_bits(&s->pb, 1, 0); /* camera  off */
     put_bits(&s->pb, 1, s->pict_type == AV_PICTURE_TYPE_I); /* freeze picture release on/off */
 
-    format = ff_h261_get_picture_format(s->width, s->height);
-
-    put_bits(&s->pb, 1, format); /* 0 == QCIF, 1 == CIF */
+    put_bits(&s->pb, 1, h->format); /* 0 == QCIF, 1 == CIF */
 
     put_bits(&s->pb, 1, 1); /* still image mode */
     put_bits(&s->pb, 1, 1); /* reserved */
 
     put_bits(&s->pb, 1, 0); /* no PEI */
-    if (format == 0)
-        h->gob_number = -1;
-    else
-        h->gob_number = 0;
+    h->gob_number = h->format - 1;
     s->mb_skip_run = 0;
 }
 
@@ -102,7 +88,7 @@
 static void h261_encode_gob_header(MpegEncContext *s, int mb_line)
 {
     H261EncContext *const h = (H261EncContext *)s;
-    if (ff_h261_get_picture_format(s->width, s->height) == 0) {
+    if (h->format == H261_QCIF) {
         h->gob_number += 2; // QCIF
     } else {
         h->gob_number++;    // CIF
@@ -118,6 +104,7 @@
 
 void ff_h261_reorder_mb_index(MpegEncContext *s)
 {
+    const H261EncContext *const h = (H261EncContext*)s;
     int index = s->mb_x + s->mb_y * s->mb_width;
 
     if (index % 11 == 0) {
@@ -129,7 +116,7 @@
 
     /* for CIF the GOB's are fragmented in the middle of a scanline
      * that's why we need to adjust the x and y index of the macroblocks */
-    if (ff_h261_get_picture_format(s->width, s->height) == 1) { // CIF
+    if (h->format == H261_CIF) {
         s->mb_x  = index % 11;
         index   /= 11;
         s->mb_y  = index % 3;
@@ -382,11 +369,22 @@
     init_uni_h261_rl_tab(&ff_h261_rl_tcoeff, uni_h261_rl_len);
 }
 
-av_cold void ff_h261_encode_init(MpegEncContext *s)
+av_cold int ff_h261_encode_init(MpegEncContext *s)
 {
     H261EncContext *const h = (H261EncContext*)s;
     static AVOnce init_static_once = AV_ONCE_INIT;
 
+    if (s->width == 176 && s->height == 144) {
+        h->format = H261_QCIF;
+    } else if (s->width == 352 && s->height == 288) {
+        h->format = H261_CIF;
+    } else {
+        av_log(s->avctx, AV_LOG_ERROR,
+                "The specified picture size of %dx%d is not valid for the "
+                "H.261 codec.\nValid sizes are 176x144, 352x288\n",
+                s->width, s->height);
+        return AVERROR(EINVAL);
+    }
     s->private_ctx = &h->common;
 
     s->min_qcoeff       = -127;
@@ -398,6 +396,8 @@
     s->intra_ac_vlc_length      = s->inter_ac_vlc_length      = uni_h261_rl_len;
     s->intra_ac_vlc_last_length = s->inter_ac_vlc_last_length = uni_h261_rl_len + 128*64;
     ff_thread_once(&init_static_once, h261_encode_init_static);
+
+    return 0;
 }
 
 const FFCodec ff_h261_encoder = {
--- a/third_party/ffmpeg/libavcodec/h261enc.h
+++ b/third_party/ffmpeg/libavcodec/h261enc.h
@@ -30,11 +30,10 @@
 
 #include "mpegvideo.h"
 
-int ff_h261_get_picture_format(int width, int height);
 void ff_h261_reorder_mb_index(MpegEncContext *s);
 void ff_h261_encode_mb(MpegEncContext *s, int16_t block[6][64],
                        int motion_x, int motion_y);
 void ff_h261_encode_picture_header(MpegEncContext *s, int picture_number);
-void ff_h261_encode_init(MpegEncContext *s);
+int ff_h261_encode_init(MpegEncContext *s);
 
 #endif
--- a/third_party/ffmpeg/libavcodec/h264_redundant_pps_bsf.c
+++ b/third_party/ffmpeg/libavcodec/h264_redundant_pps_bsf.c
@@ -80,26 +80,15 @@
                                               CodedBitstreamFragment *au)
 {
     H264RedundantPPSContext *ctx = bsf->priv_data;
-    int au_has_sps;
     int err, i;
 
-    au_has_sps = 0;
     for (i = 0; i < au->nb_units; i++) {
         CodedBitstreamUnit *nal = &au->units[i];
 
-        if (nal->type == H264_NAL_SPS)
-            au_has_sps = 1;
         if (nal->type == H264_NAL_PPS) {
             err = h264_redundant_pps_fixup_pps(ctx, nal);
             if (err < 0)
                 return err;
-            if (!au_has_sps) {
-                av_log(bsf, AV_LOG_VERBOSE, "Deleting redundant PPS "
-                       "at %"PRId64".\n", pkt->pts);
-                ff_cbs_delete_unit(au, i);
-                i--;
-                continue;
-            }
         }
         if (nal->type == H264_NAL_SLICE ||
             nal->type == H264_NAL_IDR_SLICE) {
--- a/third_party/ffmpeg/libavcodec/h264dec.c
+++ b/third_party/ffmpeg/libavcodec/h264dec.c
@@ -1075,7 +1075,7 @@
     .init                  = h264_decode_init,
     .close                 = h264_decode_end,
     FF_CODEC_DECODE_CB(h264_decode_frame),
-    .p.capabilities        = /*AV_CODEC_CAP_DRAW_HORIZ_BAND |*/ AV_CODEC_CAP_DR1 |
+    .p.capabilities        = AV_CODEC_CAP_DR1 |
                              AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS |
                              AV_CODEC_CAP_FRAME_THREADS,
     .hw_configs            = (const AVCodecHWConfigInternal *const []) {
--- a/third_party/ffmpeg/libavcodec/hdrdec.c
+++ b/third_party/ffmpeg/libavcodec/hdrdec.c
@@ -88,14 +88,13 @@
 static int hdr_decode_frame(AVCodecContext *avctx, AVFrame *p,
                             int *got_frame, AVPacket *avpkt)
 {
-    const uint8_t *buf = avpkt->data;
-    int ret, buf_size = avpkt->size;
     int width = 0, height = 0;
     GetByteContext gb;
     uint8_t line[512];
     float sar;
+    int ret;
 
-    bytestream2_init(&gb, buf, buf_size);
+    bytestream2_init(&gb, avpkt->data, avpkt->size);
     hdr_get_line(&gb, line, sizeof(line));
     if (memcmp("#?RADIANCE\n", line, 11))
         return AVERROR_INVALIDDATA;
@@ -129,6 +128,10 @@
         return ret;
 
     avctx->pix_fmt = AV_PIX_FMT_GBRPF32;
+
+    if (avctx->skip_frame >= AVDISCARD_ALL)
+        return avpkt->size;
+
     if ((ret = ff_thread_get_buffer(avctx, p, 0)) < 0)
         return ret;
 
@@ -206,7 +209,7 @@
 
     *got_frame   = 1;
 
-    return buf_size;
+    return avpkt->size;
 }
 
 const FFCodec ff_hdr_decoder = {
@@ -215,5 +218,6 @@
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_RADIANCE_HDR,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(hdr_decode_frame),
 };
--- a/third_party/ffmpeg/libavcodec/huffyuv.c
+++ b/third_party/ffmpeg/libavcodec/huffyuv.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2002-2014 Michael Niedermayer <michaelni@gmx.at>
  *
- * see http://www.pcisys.net/~melanson/codecs/huffyuv.txt for a description of
+ * see https://multimedia.cx/huffyuv.txt for a description of
  * the algorithm used
  *
  * This file is part of FFmpeg.
@@ -30,65 +30,55 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes.h"
+#include "libavutil/error.h"
+#include "libavutil/log.h"
 #include "libavutil/mem.h"
 
-#include "avcodec.h"
-#include "bswapdsp.h"
 #include "huffyuv.h"
 
 int ff_huffyuv_generate_bits_table(uint32_t *dst, const uint8_t *len_table, int n)
 {
-    int len, index;
-    uint32_t bits = 0;
+    int lens[33] = { 0 };
+    uint32_t codes[33];
 
-    for (len = 32; len > 0; len--) {
-        for (index = 0; index < n; index++) {
-            if (len_table[index] == len)
-                dst[index] = bits++;
-        }
-        if (bits & 1) {
+    for (int i = 0; i < n; i++)
+        lens[len_table[i]]++;
+
+    codes[32] = 0;
+    for (int i = FF_ARRAY_ELEMS(lens) - 1; i > 0; i--) {
+        if ((lens[i] + codes[i]) & 1) {
             av_log(NULL, AV_LOG_ERROR, "Error generating huffman table\n");
             return -1;
         }
-        bits >>= 1;
+        codes[i - 1] = (lens[i] + codes[i]) >> 1;
+    }
+    for (int i = 0; i < n; i++) {
+        if (len_table[i])
+            dst[i] = codes[len_table[i]]++;
     }
     return 0;
 }
 
-av_cold int ff_huffyuv_alloc_temp(HYuvContext *s)
+av_cold int ff_huffyuv_alloc_temp(uint8_t *temp[3], uint16_t *temp16[3], int width)
 {
     int i;
 
     for (i=0; i<3; i++) {
-        s->temp[i]= av_malloc(4*s->width + 16);
-        if (!s->temp[i])
+        temp[i] = av_malloc(4 * width + 16);
+        if (!temp[i])
             return AVERROR(ENOMEM);
-        s->temp16[i] = (uint16_t*)s->temp[i];
+        temp16[i] = (uint16_t*)temp[i];
     }
     return 0;
 }
 
-av_cold void ff_huffyuv_common_init(AVCodecContext *avctx)
-{
-    HYuvContext *s = avctx->priv_data;
-
-    s->avctx = avctx;
-    s->flags = avctx->flags;
-
-    ff_bswapdsp_init(&s->bdsp);
-
-    s->width = avctx->width;
-    s->height = avctx->height;
-
-    av_assert1(s->width > 0 && s->height > 0);
-}
-
-av_cold void ff_huffyuv_common_end(HYuvContext *s)
+av_cold void ff_huffyuv_common_end(uint8_t *temp[3], uint16_t *temp16[3])
 {
     int i;
 
     for(i = 0; i < 3; i++) {
-        av_freep(&s->temp[i]);
-        s->temp16[i] = NULL;
+        av_freep(&temp[i]);
+        temp16[i] = NULL;
     }
 }
--- a/third_party/ffmpeg/libavcodec/huffyuv.h
+++ b/third_party/ffmpeg/libavcodec/huffyuv.h
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2002-2014 Michael Niedermayer <michaelni@gmx.at>
  *
- * see http://www.pcisys.net/~melanson/codecs/huffyuv.txt for a description of
+ * see https://multimedia.cx/huffyuv.txt for a description of
  * the algorithm used
  *
  * This file is part of FFmpeg.
@@ -31,16 +31,19 @@
 
 #include <stdint.h>
 
-#include "avcodec.h"
-#include "bswapdsp.h"
-#include "get_bits.h"
-#include "huffyuvdsp.h"
-#include "huffyuvencdsp.h"
-#include "put_bits.h"
-#include "lossless_videodsp.h"
-#include "lossless_videoencdsp.h"
+#include "config.h"
 
-#define VLC_BITS 12
+#if HAVE_BIGENDIAN
+#define B 3
+#define G 2
+#define R 1
+#define A 0
+#else
+#define B 0
+#define G 1
+#define R 2
+#define A 3
+#endif
 
 #define MAX_BITS 16
 #define MAX_N (1<<MAX_BITS)
@@ -52,51 +55,8 @@
     MEDIAN,
 } Predictor;
 
-typedef struct HYuvContext {
-    AVClass *class;
-    AVCodecContext *avctx;
-    Predictor predictor;
-    GetBitContext gb;
-    PutBitContext pb;
-    int interlaced;
-    int decorrelate;
-    int bitstream_bpp;
-    int version;
-    int yuy2;                               //use yuy2 instead of 422P
-    int bgr32;                              //use bgr32 instead of bgr24
-    int bps;
-    int n;                                  // 1<<bps
-    int vlc_n;                              // number of vlc codes (FFMIN(1<<bps, MAX_VLC_N))
-    int alpha;
-    int chroma;
-    int yuv;
-    int chroma_h_shift;
-    int chroma_v_shift;
-    int width, height;
-    int flags;
-    int context;
-    int picture_number;
-    int last_slice_end;
-    uint8_t *temp[3];
-    uint16_t *temp16[3];                    ///< identical to temp but 16bit type
-    uint64_t stats[4][MAX_VLC_N];
-    uint8_t len[4][MAX_VLC_N];
-    uint32_t bits[4][MAX_VLC_N];
-    uint32_t pix_bgr_map[1<<VLC_BITS];
-    VLC vlc[8];                             //Y,U,V,A,YY,YU,YV,AA
-    uint8_t *bitstream_buffer;
-    unsigned int bitstream_buffer_size;
-    BswapDSPContext bdsp;
-    HuffYUVDSPContext hdsp;
-    HuffYUVEncDSPContext hencdsp;
-    LLVidDSPContext llviddsp;
-    LLVidEncDSPContext llvidencdsp;
-    int non_determ; // non-deterministic, multi-threaded encoder allowed
-} HYuvContext;
-
-void ff_huffyuv_common_init(AVCodecContext *s);
-void ff_huffyuv_common_end(HYuvContext *s);
-int  ff_huffyuv_alloc_temp(HYuvContext *s);
+void ff_huffyuv_common_end(uint8_t *temp[3], uint16_t *temp16[3]);
+int  ff_huffyuv_alloc_temp(uint8_t *temp[3], uint16_t *temp16[3], int width);
 int ff_huffyuv_generate_bits_table(uint32_t *dst, const uint8_t *len_table, int n);
 
 #endif /* AVCODEC_HUFFYUV_H */
--- a/third_party/ffmpeg/libavcodec/huffyuvdec.c
+++ b/third_party/ffmpeg/libavcodec/huffyuvdec.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2002-2014 Michael Niedermayer <michaelni@gmx.at>
  *
- * see http://www.pcisys.net/~melanson/codecs/huffyuv.txt for a description of
+ * see https://multimedia.cx/huffyuv.txt for a description of
  * the algorithm used
  *
  * This file is part of FFmpeg.
@@ -35,6 +35,7 @@
 #include "config_components.h"
 
 #include "avcodec.h"
+#include "bswapdsp.h"
 #include "codec_internal.h"
 #include "get_bits.h"
 #include "huffyuv.h"
@@ -44,6 +45,43 @@
 #include "libavutil/imgutils.h"
 #include "libavutil/pixdesc.h"
 
+#define VLC_BITS 12
+
+typedef struct HYuvDecContext {
+    GetBitContext gb;
+    Predictor predictor;
+    int interlaced;
+    int decorrelate;
+    int bitstream_bpp;
+    int version;
+    int yuy2;                               //use yuy2 instead of 422P
+    int bgr32;                              //use bgr32 instead of bgr24
+    int bps;
+    int n;                                  // 1<<bps
+    int vlc_n;                              // number of vlc codes (FFMIN(1<<bps, MAX_VLC_N))
+    int alpha;
+    int chroma;
+    int yuv;
+    int chroma_h_shift;
+    int chroma_v_shift;
+    int flags;
+    int context;
+    int last_slice_end;
+
+    uint8_t *temp[3];
+    uint16_t *temp16[3];                    ///< identical to temp but 16bit type
+    uint8_t len[4][MAX_VLC_N];
+    uint32_t bits[4][MAX_VLC_N];
+    uint32_t pix_bgr_map[1<<VLC_BITS];
+    VLC vlc[8];                             //Y,U,V,A,YY,YU,YV,AA
+    uint8_t *bitstream_buffer;
+    unsigned int bitstream_buffer_size;
+    BswapDSPContext bdsp;
+    HuffYUVDSPContext hdsp;
+    LLVidDSPContext llviddsp;
+} HYuvDecContext;
+
+
 #define classic_shift_luma_table_size 42
 static const unsigned char classic_shift_luma[classic_shift_luma_table_size + AV_INPUT_BUFFER_PADDING_SIZE] = {
     34, 36, 35, 69, 135, 232,   9, 16, 10, 24,  11,  23,  12,  16, 13, 10,
@@ -118,7 +156,7 @@
     return 0;
 }
 
-static int generate_joint_tables(HYuvContext *s)
+static int generate_joint_tables(HYuvDecContext *s)
 {
     int ret;
     uint16_t *symbols = av_mallocz(5 << VLC_BITS);
@@ -208,7 +246,7 @@
     return ret;
 }
 
-static int read_huffman_tables(HYuvContext *s, const uint8_t *src, int length)
+static int read_huffman_tables(HYuvDecContext *s, const uint8_t *src, int length)
 {
     GetBitContext gb;
     int i, ret;
@@ -237,7 +275,7 @@
     return (get_bits_count(&gb) + 7) / 8;
 }
 
-static int read_old_huffman_tables(HYuvContext *s)
+static int read_old_huffman_tables(HYuvDecContext *s)
 {
     GetBitContext gb;
     int i, ret;
@@ -279,10 +317,10 @@
 
 static av_cold int decode_end(AVCodecContext *avctx)
 {
-    HYuvContext *s = avctx->priv_data;
+    HYuvDecContext *s = avctx->priv_data;
     int i;
 
-    ff_huffyuv_common_end(s);
+    ff_huffyuv_common_end(s->temp, s->temp16);
     av_freep(&s->bitstream_buffer);
 
     for (i = 0; i < 8; i++)
@@ -293,13 +331,16 @@
 
 static av_cold int decode_init(AVCodecContext *avctx)
 {
-    HYuvContext *s = avctx->priv_data;
+    HYuvDecContext *s = avctx->priv_data;
     int ret;
 
     ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);
     if (ret < 0)
         return ret;
 
+    s->flags = avctx->flags;
+
+    ff_bswapdsp_init(&s->bdsp);
     ff_huffyuvdsp_init(&s->hdsp, avctx->pix_fmt);
     ff_llviddsp_init(&s->llviddsp);
     memset(s->vlc, 0, 4 * sizeof(VLC));
@@ -545,8 +586,6 @@
         }
     }
 
-    ff_huffyuv_common_init(avctx);
-
     if ((avctx->pix_fmt == AV_PIX_FMT_YUV422P || avctx->pix_fmt == AV_PIX_FMT_YUV420P) && avctx->width & 1) {
         av_log(avctx, AV_LOG_ERROR, "width must be even for this colorspace\n");
         return AVERROR_INVALIDDATA;
@@ -558,7 +597,7 @@
         return AVERROR_INVALIDDATA;
     }
 
-    if ((ret = ff_huffyuv_alloc_temp(s)) < 0)
+    if ((ret = ff_huffyuv_alloc_temp(s->temp, s->temp16, avctx->width)) < 0)
         return ret;
 
     return 0;
@@ -617,7 +656,7 @@
     GET_VLC_DUAL(dst0, dst1, re, &s->gb, s->vlc[4+plane1].table,        \
                  s->vlc[0].table, s->vlc[plane1].table, VLC_BITS, 3, OP8bits)
 
-static void decode_422_bitstream(HYuvContext *s, int count)
+static void decode_422_bitstream(HYuvDecContext *s, int count)
 {
     int i, icount;
     OPEN_READER(re, &s->gb);
@@ -661,7 +700,7 @@
     dst1 = get_vlc2(&s->gb, s->vlc[plane].table, VLC_BITS, 3)<<2;\
     dst1 += get_bits(&s->gb, 2);\
 }
-static void decode_plane_bitstream(HYuvContext *s, int width, int plane)
+static void decode_plane_bitstream(HYuvDecContext *s, int width, int plane)
 {
     int i, count = width/2;
 
@@ -722,7 +761,7 @@
     }
 }
 
-static void decode_gray_bitstream(HYuvContext *s, int count)
+static void decode_gray_bitstream(HYuvDecContext *s, int count)
 {
     int i;
     OPEN_READER(re, &s->gb);
@@ -740,7 +779,7 @@
     CLOSE_READER(re, &s->gb);
 }
 
-static av_always_inline void decode_bgr_1(HYuvContext *s, int count,
+static av_always_inline void decode_bgr_1(HYuvDecContext *s, int count,
                                           int decorrelate, int alpha)
 {
     int i;
@@ -798,7 +837,7 @@
     CLOSE_READER(re, &s->gb);
 }
 
-static void decode_bgr_bitstream(HYuvContext *s, int count)
+static void decode_bgr_bitstream(HYuvDecContext *s, int count)
 {
     if (s->decorrelate) {
         if (s->bitstream_bpp == 24)
@@ -813,12 +852,12 @@
     }
 }
 
-static void draw_slice(HYuvContext *s, AVFrame *frame, int y)
+static void draw_slice(HYuvDecContext *s, AVCodecContext *avctx, AVFrame *frame, int y)
 {
     int h, cy, i;
     int offset[AV_NUM_DATA_POINTERS];
 
-    if (!s->avctx->draw_horiz_band)
+    if (!avctx->draw_horiz_band)
         return;
 
     h  = y - s->last_slice_end;
@@ -836,12 +875,12 @@
         offset[i] = 0;
     emms_c();
 
-    s->avctx->draw_horiz_band(s->avctx, frame, offset, y, 3, h);
+    avctx->draw_horiz_band(avctx, frame, offset, y, 3, h);
 
     s->last_slice_end = y + h;
 }
 
-static int left_prediction(HYuvContext *s, uint8_t *dst, const uint8_t *src, int w, int acc)
+static int left_prediction(HYuvDecContext *s, uint8_t *dst, const uint8_t *src, int w, int acc)
 {
     if (s->bps <= 8) {
         return s->llviddsp.add_left_pred(dst, src, w, acc);
@@ -850,7 +889,7 @@
     }
 }
 
-static void add_bytes(HYuvContext *s, uint8_t *dst, uint8_t *src, int w)
+static void add_bytes(HYuvDecContext *s, uint8_t *dst, uint8_t *src, int w)
 {
     if (s->bps <= 8) {
         s->llviddsp.add_bytes(dst, src, w);
@@ -859,7 +898,7 @@
     }
 }
 
-static void add_median_prediction(HYuvContext *s, uint8_t *dst, const uint8_t *src, const uint8_t *diff, int w, int *left, int *left_top)
+static void add_median_prediction(HYuvDecContext *s, uint8_t *dst, const uint8_t *src, const uint8_t *diff, int w, int *left, int *left_top)
 {
     if (s->bps <= 8) {
         s->llviddsp.add_median_pred(dst, src, diff, w, left, left_top);
@@ -871,10 +910,10 @@
 static int decode_slice(AVCodecContext *avctx, AVFrame *p, int height,
                         int buf_size, int y_offset, int table_size)
 {
-    HYuvContext *s = avctx->priv_data;
+    HYuvDecContext *s = avctx->priv_data;
     int fake_ystride, fake_ustride, fake_vstride;
-    const int width  = s->width;
-    const int width2 = s->width >> 1;
+    const int width  = avctx->width;
+    const int width2 = avctx->width >> 1;
     int ret;
 
     if ((ret = init_get_bits8(&s->gb, s->bitstream_buffer + table_size, buf_size - table_size)) < 0)
@@ -952,7 +991,7 @@
                 break;
             }
         }
-        draw_slice(s, p, height);
+        draw_slice(s, avctx, p, height);
     } else if (s->bitstream_bpp < 24) {
         int y, cy;
         int lefty, leftu, leftv;
@@ -1006,7 +1045,7 @@
                             break;
                     }
 
-                    draw_slice(s, p, y);
+                    draw_slice(s, avctx, p, y);
 
                     ydst = p->data[0] + p->linesize[0] * (y  + y_offset);
                     udst = p->data[1] + p->linesize[1] * (cy + y_offset);
@@ -1029,7 +1068,7 @@
                         }
                     }
                 }
-                draw_slice(s, p, height);
+                draw_slice(s, avctx, p, height);
 
                 break;
             case MEDIAN:
@@ -1100,7 +1139,7 @@
                         if (y >= height)
                             break;
                     }
-                    draw_slice(s, p, y);
+                    draw_slice(s, avctx, p, y);
 
                     decode_422_bitstream(s, width);
 
@@ -1117,7 +1156,7 @@
                     }
                 }
 
-                draw_slice(s, p, height);
+                draw_slice(s, avctx, p, height);
                 break;
             }
         }
@@ -1163,7 +1202,7 @@
                     }
                 }
                 // just 1 large slice as this is not possible in reverse order
-                draw_slice(s, p, height);
+                draw_slice(s, avctx, p, height);
                 break;
             default:
                 av_log(avctx, AV_LOG_ERROR,
@@ -1184,9 +1223,9 @@
 {
     const uint8_t *buf = avpkt->data;
     int buf_size       = avpkt->size;
-    HYuvContext *s = avctx->priv_data;
-    const int width  = s->width;
-    const int height = s->height;
+    HYuvDecContext *s = avctx->priv_data;
+    const int width  = avctx->width;
+    const int height = avctx->height;
     int slice, table_size = 0, ret, nb_slices;
     unsigned slices_info_offset;
     int slice_height;
@@ -1267,7 +1306,7 @@
     CODEC_LONG_NAME("Huffyuv / HuffYUV"),
     .p.type           = AVMEDIA_TYPE_VIDEO,
     .p.id             = AV_CODEC_ID_HUFFYUV,
-    .priv_data_size   = sizeof(HYuvContext),
+    .priv_data_size   = sizeof(HYuvDecContext),
     .init             = decode_init,
     .close            = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
@@ -1282,7 +1321,7 @@
     CODEC_LONG_NAME("Huffyuv FFmpeg variant"),
     .p.type           = AVMEDIA_TYPE_VIDEO,
     .p.id             = AV_CODEC_ID_FFVHUFF,
-    .priv_data_size   = sizeof(HYuvContext),
+    .priv_data_size   = sizeof(HYuvDecContext),
     .init             = decode_init,
     .close            = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
@@ -1298,7 +1337,7 @@
     CODEC_LONG_NAME("HuffYUV MT"),
     .p.type           = AVMEDIA_TYPE_VIDEO,
     .p.id             = AV_CODEC_ID_HYMT,
-    .priv_data_size   = sizeof(HYuvContext),
+    .priv_data_size   = sizeof(HYuvDecContext),
     .init             = decode_init,
     .close            = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
--- a/third_party/ffmpeg/libavcodec/huffyuvdsp.c
+++ b/third_party/ffmpeg/libavcodec/huffyuvdsp.c
@@ -21,6 +21,7 @@
 #include "config.h"
 #include "libavutil/attributes.h"
 #include "mathops.h"
+#include "huffyuv.h"
 #include "huffyuvdsp.h"
 
 // 0x00010001 or 0x0001000100010001 or whatever, depending on the cpu's native arithmetic size
--- a/third_party/ffmpeg/libavcodec/huffyuvdsp.h
+++ b/third_party/ffmpeg/libavcodec/huffyuvdsp.h
@@ -21,19 +21,6 @@
 
 #include <stdint.h>
 #include "libavutil/pixfmt.h"
-#include "config.h"
-
-#if HAVE_BIGENDIAN
-#define B 3
-#define G 2
-#define R 1
-#define A 0
-#else
-#define B 0
-#define G 1
-#define R 2
-#define A 3
-#endif
 
 typedef struct HuffYUVDSPContext {
     void (*add_int16)(uint16_t *dst/*align 16*/, const uint16_t *src/*align 16*/,
--- a/third_party/ffmpeg/libavcodec/huffyuvenc.c
+++ b/third_party/ffmpeg/libavcodec/huffyuvenc.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2002-2014 Michael Niedermayer <michaelni@gmx.at>
  *
- * see http://www.pcisys.net/~melanson/codecs/huffyuv.txt for a description of
+ * see https://multimedia.cx/huffyuv.txt for a description of
  * the algorithm used
  *
  * This file is part of FFmpeg.
@@ -31,6 +31,7 @@
 #include "config_components.h"
 
 #include "avcodec.h"
+#include "bswapdsp.h"
 #include "codec_internal.h"
 #include "encode.h"
 #include "huffyuv.h"
@@ -41,7 +42,39 @@
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 
-static inline void diff_bytes(HYuvContext *s, uint8_t *dst,
+typedef struct HYuvEncContext {
+    AVClass *class;
+    AVCodecContext *avctx;
+    PutBitContext pb;
+    Predictor predictor;
+    int interlaced;
+    int decorrelate;
+    int bitstream_bpp;
+    int version;
+    int bps;
+    int n;                                  // 1<<bps
+    int vlc_n;                              // number of vlc codes (FFMIN(1<<bps, MAX_VLC_N))
+    int alpha;
+    int chroma;
+    int yuv;
+    int chroma_h_shift;
+    int chroma_v_shift;
+    int flags;
+    int context;
+    int picture_number;
+
+    uint8_t *temp[3];
+    uint16_t *temp16[3];                    ///< identical to temp but 16bit type
+    uint64_t stats[4][MAX_VLC_N];
+    uint8_t len[4][MAX_VLC_N];
+    uint32_t bits[4][MAX_VLC_N];
+    BswapDSPContext bdsp;
+    HuffYUVEncDSPContext hencdsp;
+    LLVidEncDSPContext llvidencdsp;
+    int non_determ; // non-deterministic, multi-threaded encoder allowed
+} HYuvEncContext;
+
+static inline void diff_bytes(HYuvEncContext *s, uint8_t *dst,
                               const uint8_t *src0, const uint8_t *src1, int w)
 {
     if (s->bps <= 8) {
@@ -51,7 +84,7 @@
     }
 }
 
-static inline int sub_left_prediction(HYuvContext *s, uint8_t *dst,
+static inline int sub_left_prediction(HYuvEncContext *s, uint8_t *dst,
                                       const uint8_t *src, int w, int left)
 {
     int i;
@@ -82,7 +115,7 @@
     }
 }
 
-static inline void sub_left_prediction_bgr32(HYuvContext *s, uint8_t *dst,
+static inline void sub_left_prediction_bgr32(HYuvEncContext *s, uint8_t *dst,
                                              const uint8_t *src, int w,
                                              int *red, int *green, int *blue,
                                              int *alpha)
@@ -118,7 +151,7 @@
     *alpha = src[(w - 1) * 4 + A];
 }
 
-static inline void sub_left_prediction_rgb24(HYuvContext *s, uint8_t *dst,
+static inline void sub_left_prediction_rgb24(HYuvEncContext *s, uint8_t *dst,
                                              const uint8_t *src, int w,
                                              int *red, int *green, int *blue)
 {
@@ -146,7 +179,9 @@
     *blue  = src[(w - 1) * 3 + 2];
 }
 
-static void sub_median_prediction(HYuvContext *s, uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w, int *left, int *left_top)
+static void sub_median_prediction(HYuvEncContext *s, uint8_t *dst,
+                                  const uint8_t *src1, const uint8_t *src2,
+                                  int w, int *left, int *left_top)
 {
     if (s->bps <= 8) {
         s->llvidencdsp.sub_median_pred(dst, src1, src2, w , left, left_top);
@@ -155,7 +190,7 @@
     }
 }
 
-static int store_table(HYuvContext *s, const uint8_t *len, uint8_t *buf)
+static int store_table(HYuvEncContext *s, const uint8_t *len, uint8_t *buf)
 {
     int i;
     int index = 0;
@@ -180,7 +215,7 @@
     return index;
 }
 
-static int store_huffman_tables(HYuvContext *s, uint8_t *buf)
+static int store_huffman_tables(HYuvEncContext *s, uint8_t *buf)
 {
     int i, ret;
     int size = 0;
@@ -204,16 +239,21 @@
 
 static av_cold int encode_init(AVCodecContext *avctx)
 {
-    HYuvContext *s = avctx->priv_data;
+    HYuvEncContext *s = avctx->priv_data;
     int i, j;
     int ret;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
+    const AVPixFmtDescriptor *desc;
+
+    s->avctx = avctx;
+    s->flags = avctx->flags;
 
-    ff_huffyuv_common_init(avctx);
-    ff_huffyuvencdsp_init(&s->hencdsp, avctx);
+    ff_bswapdsp_init(&s->bdsp);
+    ff_huffyuvencdsp_init(&s->hencdsp, avctx->pix_fmt);
     ff_llvidencdsp_init(&s->llvidencdsp);
 
     avctx->extradata = av_mallocz(3*MAX_N + 4);
+    if (!avctx->extradata)
+        return AVERROR(ENOMEM);
     if (s->flags&AV_CODEC_FLAG_PASS1) {
 #define STATS_OUT_SIZE 21*MAX_N*3 + 4
         avctx->stats_out = av_mallocz(STATS_OUT_SIZE); // 21*256*3(%llu ) + 3(\n) + 1(0) = 16132
@@ -222,21 +262,18 @@
     }
     s->version = 2;
 
-    if (!avctx->extradata)
-        return AVERROR(ENOMEM);
-
+    desc   = av_pix_fmt_desc_get(avctx->pix_fmt);
     s->bps = desc->comp[0].depth;
     s->yuv = !(desc->flags & AV_PIX_FMT_FLAG_RGB) && desc->nb_components >= 2;
     s->chroma = desc->nb_components > 2;
     s->alpha = !!(desc->flags & AV_PIX_FMT_FLAG_ALPHA);
-    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt,
-                                     &s->chroma_h_shift,
-                                     &s->chroma_v_shift);
+    s->chroma_h_shift = desc->log2_chroma_w;
+    s->chroma_v_shift = desc->log2_chroma_h;
 
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
     case AV_PIX_FMT_YUV422P:
-        if (s->width & 1) {
+        if (avctx->width & 1) {
             av_log(avctx, AV_LOG_ERROR, "Width must be even for this colorspace.\n");
             return AVERROR(EINVAL);
         }
@@ -310,13 +347,7 @@
     }
 
     if (avctx->codec->id == AV_CODEC_ID_HUFFYUV) {
-        if (avctx->pix_fmt == AV_PIX_FMT_YUV420P) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "Error: YV12 is not supported by huffyuv; use "
-                   "vcodec=ffvhuff or format=422p\n");
-            return AVERROR(EINVAL);
-        }
-        if (s->interlaced != ( s->height > 288 ))
+        if (s->interlaced != ( avctx->height > 288 ))
             av_log(avctx, AV_LOG_INFO,
                    "using huffyuv 2.2.0 or newer interlacing flag\n");
     }
@@ -333,22 +364,22 @@
         return AVERROR(EINVAL);
     }
 
-    ((uint8_t*)avctx->extradata)[0] = s->predictor | (s->decorrelate << 6);
-    ((uint8_t*)avctx->extradata)[2] = s->interlaced ? 0x10 : 0x20;
+    avctx->extradata[0] = s->predictor | (s->decorrelate << 6);
+    avctx->extradata[2] = s->interlaced ? 0x10 : 0x20;
     if (s->context)
-        ((uint8_t*)avctx->extradata)[2] |= 0x40;
+        avctx->extradata[2] |= 0x40;
     if (s->version < 3) {
-        ((uint8_t*)avctx->extradata)[1] = s->bitstream_bpp;
-        ((uint8_t*)avctx->extradata)[3] = 0;
+        avctx->extradata[1] = s->bitstream_bpp;
+        avctx->extradata[3] = 0;
     } else {
-        ((uint8_t*)avctx->extradata)[1] = ((s->bps-1)<<4) | s->chroma_h_shift | (s->chroma_v_shift<<2);
+        avctx->extradata[1] = ((s->bps-1)<<4) | s->chroma_h_shift | (s->chroma_v_shift<<2);
         if (s->chroma)
-            ((uint8_t*)avctx->extradata)[2] |= s->yuv ? 1 : 2;
+            avctx->extradata[2] |= s->yuv ? 1 : 2;
         if (s->alpha)
-            ((uint8_t*)avctx->extradata)[2] |= 4;
-        ((uint8_t*)avctx->extradata)[3] = 1;
+            avctx->extradata[2] |= 4;
+        avctx->extradata[3] = 1;
     }
-    s->avctx->extradata_size = 4;
+    avctx->extradata_size = 4;
 
     if (avctx->stats_in) {
         char *p = avctx->stats_in;
@@ -378,14 +409,14 @@
             }
     }
 
-    ret = store_huffman_tables(s, s->avctx->extradata + s->avctx->extradata_size);
+    ret = store_huffman_tables(s, avctx->extradata + avctx->extradata_size);
     if (ret < 0)
         return ret;
-    s->avctx->extradata_size += ret;
+    avctx->extradata_size += ret;
 
     if (s->context) {
         for (i = 0; i < 4; i++) {
-            int pels = s->width * s->height / (i ? 40 : 10);
+            int pels = avctx->width * avctx->height / (i ? 40 : 10);
             for (j = 0; j < s->vlc_n; j++) {
                 int d = FFMIN(j, s->vlc_n - j);
                 s->stats[i][j] = pels/(d*d + 1);
@@ -397,16 +428,15 @@
                 s->stats[i][j]= 0;
     }
 
-    if (ff_huffyuv_alloc_temp(s)) {
-        ff_huffyuv_common_end(s);
-        return AVERROR(ENOMEM);
-    }
+    ret = ff_huffyuv_alloc_temp(s->temp, s->temp16, avctx->width);
+    if (ret < 0)
+        return ret;
 
     s->picture_number=0;
 
     return 0;
 }
-static int encode_422_bitstream(HYuvContext *s, int offset, int count)
+static int encode_422_bitstream(HYuvEncContext *s, int offset, int count)
 {
     int i;
     const uint8_t *y = s->temp[0] + offset;
@@ -461,7 +491,7 @@
     return 0;
 }
 
-static int encode_plane_bitstream(HYuvContext *s, int width, int plane)
+static int encode_plane_bitstream(HYuvEncContext *s, int width, int plane)
 {
     int i, count = width/2;
 
@@ -623,7 +653,7 @@
     return 0;
 }
 
-static int encode_gray_bitstream(HYuvContext *s, int count)
+static int encode_gray_bitstream(HYuvEncContext *s, int count)
 {
     int i;
 
@@ -668,7 +698,7 @@
     return 0;
 }
 
-static inline int encode_bgra_bitstream(HYuvContext *s, int count, int planes)
+static inline int encode_bgra_bitstream(HYuvEncContext *s, int count, int planes)
 {
     int i;
 
@@ -721,10 +751,10 @@
 static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                         const AVFrame *pict, int *got_packet)
 {
-    HYuvContext *s = avctx->priv_data;
-    const int width = s->width;
-    const int width2 = s->width>>1;
-    const int height = s->height;
+    HYuvEncContext *s = avctx->priv_data;
+    const int width = avctx->width;
+    const int width2 = avctx->width >> 1;
+    const int height = avctx->height;
     const int fake_ystride = s->interlaced ? pict->linesize[0]*2  : pict->linesize[0];
     const int fake_ustride = s->interlaced ? pict->linesize[1]*2  : pict->linesize[1];
     const int fake_vstride = s->interlaced ? pict->linesize[2]*2  : pict->linesize[2];
@@ -855,7 +885,6 @@
         const uint8_t *data = p->data[0] + (height - 1) * p->linesize[0];
         const int stride = -p->linesize[0];
         const int fake_stride = -fake_ystride;
-        int y;
         int leftr, leftg, leftb, lefta;
 
         put_bits(&s->pb, 8, lefta = data[A]);
@@ -867,7 +896,7 @@
                                   &leftr, &leftg, &leftb, &lefta);
         encode_bgra_bitstream(s, width - 1, 4);
 
-        for (y = 1; y < s->height; y++) {
+        for (int y = 1; y < height; y++) {
             const uint8_t *dst = data + y*stride;
             if (s->predictor == PLANE && s->interlaced < y) {
                 s->llvidencdsp.diff_bytes(s->temp[1], dst, dst - fake_stride, width * 4);
@@ -883,7 +912,6 @@
         const uint8_t *data = p->data[0] + (height - 1) * p->linesize[0];
         const int stride = -p->linesize[0];
         const int fake_stride = -fake_ystride;
-        int y;
         int leftr, leftg, leftb;
 
         put_bits(&s->pb, 8, leftr = data[0]);
@@ -895,7 +923,7 @@
                                   &leftr, &leftg, &leftb);
         encode_bgra_bitstream(s, width-1, 3);
 
-        for (y = 1; y < s->height; y++) {
+        for (int y = 1; y < height; y++) {
             const uint8_t *dst = data + y * stride;
             if (s->predictor == PLANE && s->interlaced < y) {
                 s->llvidencdsp.diff_bytes(s->temp[1], dst, dst - fake_stride,
@@ -1003,16 +1031,16 @@
 
 static av_cold int encode_end(AVCodecContext *avctx)
 {
-    HYuvContext *s = avctx->priv_data;
+    HYuvEncContext *s = avctx->priv_data;
 
-    ff_huffyuv_common_end(s);
+    ff_huffyuv_common_end(s->temp, s->temp16);
 
     av_freep(&avctx->stats_out);
 
     return 0;
 }
 
-#define OFFSET(x) offsetof(HYuvContext, x)
+#define OFFSET(x) offsetof(HYuvEncContext, x)
 #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
 
 #define COMMON_OPTIONS \
@@ -1055,7 +1083,7 @@
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_HUFFYUV,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .priv_data_size = sizeof(HYuvContext),
+    .priv_data_size = sizeof(HYuvEncContext),
     .init           = encode_init,
     FF_CODEC_ENCODE_CB(encode_frame),
     .close          = encode_end,
@@ -1074,7 +1102,7 @@
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_FFVHUFF,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .priv_data_size = sizeof(HYuvContext),
+    .priv_data_size = sizeof(HYuvEncContext),
     .init           = encode_init,
     FF_CODEC_ENCODE_CB(encode_frame),
     .close          = encode_end,
--- a/third_party/ffmpeg/libavcodec/huffyuvencdsp.c
+++ b/third_party/ffmpeg/libavcodec/huffyuvencdsp.c
@@ -68,12 +68,12 @@
     *left_top = lt;
 }
 
-av_cold void ff_huffyuvencdsp_init(HuffYUVEncDSPContext *c, AVCodecContext *avctx)
+av_cold void ff_huffyuvencdsp_init(HuffYUVEncDSPContext *c, enum AVPixelFormat pix_fmt)
 {
     c->diff_int16           = diff_int16_c;
     c->sub_hfyu_median_pred_int16 = sub_hfyu_median_pred_int16_c;
 
 #if ARCH_X86
-    ff_huffyuvencdsp_init_x86(c, avctx);
+    ff_huffyuvencdsp_init_x86(c, pix_fmt);
 #endif
 }
--- a/third_party/ffmpeg/libavcodec/huffyuvencdsp.h
+++ b/third_party/ffmpeg/libavcodec/huffyuvencdsp.h
@@ -21,7 +21,7 @@
 
 #include <stdint.h>
 
-#include "avcodec.h"
+#include "libavutil/pixfmt.h"
 
 typedef struct HuffYUVEncDSPContext {
     void (*diff_int16)(uint16_t *dst /* align 16 */,
@@ -34,7 +34,7 @@
                                        int w, int *left, int *left_top);
 } HuffYUVEncDSPContext;
 
-void ff_huffyuvencdsp_init(HuffYUVEncDSPContext *c, AVCodecContext *avctx);
-void ff_huffyuvencdsp_init_x86(HuffYUVEncDSPContext *c, AVCodecContext *avctx);
+void ff_huffyuvencdsp_init(HuffYUVEncDSPContext *c, enum AVPixelFormat pix_fmt);
+void ff_huffyuvencdsp_init_x86(HuffYUVEncDSPContext *c, enum AVPixelFormat pix_fmt);
 
 #endif /* AVCODEC_HUFFYUVENCDSP_H */
--- a/third_party/ffmpeg/libavcodec/idctdsp.c
+++ b/third_party/ffmpeg/libavcodec/idctdsp.c
@@ -27,24 +27,12 @@
 #include "simple_idct.h"
 #include "xvididct.h"
 
-av_cold void ff_init_scantable(const uint8_t *permutation, ScanTable *st,
-                               const uint8_t *src_scantable)
+av_cold void ff_permute_scantable(uint8_t dst[64], const uint8_t src[64],
+                                  const uint8_t permutation[64])
 {
-    int i, end;
-
-    st->scantable = src_scantable;
-
-    for (i = 0; i < 64; i++) {
-        int j = src_scantable[i];
-        st->permutated[i] = permutation[j];
-    }
-
-    end = -1;
-    for (i = 0; i < 64; i++) {
-        int j = st->permutated[i];
-        if (j > end)
-            end = j;
-        st->raster_end[i] = end;
+    for (int i = 0; i < 64; i++) {
+        int j = src[i];
+        dst[i] = permutation[j];
     }
 }
 
@@ -312,6 +300,8 @@
     ff_idctdsp_init_arm(c, avctx, high_bit_depth);
 #elif ARCH_PPC
     ff_idctdsp_init_ppc(c, avctx, high_bit_depth);
+#elif ARCH_RISCV
+    ff_idctdsp_init_riscv(c, avctx, high_bit_depth);
 #elif ARCH_X86
     ff_idctdsp_init_x86(c, avctx, high_bit_depth);
 #elif ARCH_MIPS
--- a/third_party/ffmpeg/libavcodec/idctdsp.h
+++ b/third_party/ffmpeg/libavcodec/idctdsp.h
@@ -25,15 +25,6 @@
 
 #include "avcodec.h"
 
-/**
- * Scantable.
- */
-typedef struct ScanTable {
-    const uint8_t *scantable;
-    uint8_t permutated[64];
-    uint8_t raster_end[64];
-} ScanTable;
-
 enum idct_permutation_type {
     FF_IDCT_PERM_NONE,
     FF_IDCT_PERM_LIBMPEG2,
@@ -43,8 +34,8 @@
     FF_IDCT_PERM_SSE2,
 };
 
-void ff_init_scantable(const uint8_t *permutation, ScanTable *st,
-                       const uint8_t *src_scantable);
+void ff_permute_scantable(uint8_t dst[64], const uint8_t src[64],
+                          const uint8_t permutation[64]);
 void ff_init_scantable_permutation(uint8_t *idct_permutation,
                                    enum idct_permutation_type perm_type);
 int ff_init_scantable_permutation_x86(uint8_t *idct_permutation,
@@ -114,6 +105,8 @@
                          unsigned high_bit_depth);
 void ff_idctdsp_init_ppc(IDCTDSPContext *c, AVCodecContext *avctx,
                          unsigned high_bit_depth);
+void ff_idctdsp_init_riscv(IDCTDSPContext *c, AVCodecContext *avctx,
+                           unsigned high_bit_depth);
 void ff_idctdsp_init_x86(IDCTDSPContext *c, AVCodecContext *avctx,
                          unsigned high_bit_depth);
 void ff_idctdsp_init_mips(IDCTDSPContext *c, AVCodecContext *avctx,
--- a/third_party/ffmpeg/libavcodec/imm4.c
+++ b/third_party/ffmpeg/libavcodec/imm4.c
@@ -51,9 +51,8 @@
     unsigned lo;
     unsigned hi;
 
-    ScanTable intra_scantable;
-    DECLARE_ALIGNED(32, int16_t, block)[6][64];
     IDCTDSPContext idsp;
+    DECLARE_ALIGNED(32, int16_t, block)[6][64];
 } IMM4Context;
 
 static const uint8_t intra_cb[] = {
@@ -129,7 +128,7 @@
                         int block, int factor, int flag, int offset, int flag2)
 {
     IMM4Context *s = avctx->priv_data;
-    const uint8_t *scantable = s->intra_scantable.permutated;
+    const uint8_t *idct_permutation = s->idsp.idct_permutation;
     int i, last, len, factor2;
 
     for (i = !flag; i < 64; i++) {
@@ -152,17 +151,17 @@
         i += len;
         if (i >= 64)
             break;
-        s->block[block][scantable[i]] = offset * (factor2 < 0 ? -1 : 1) + factor * factor2;
+        s->block[block][idct_permutation[i]] = offset * (factor2 < 0 ? -1 : 1) + factor * factor2;
         if (last)
             break;
     }
 
     if (s->hi == 2 && flag2 && block < 4) {
         if (flag)
-            s->block[block][scantable[0]]  *= 2;
-        s->block[block][scantable[1]]  *= 2;
-        s->block[block][scantable[8]]  *= 2;
-        s->block[block][scantable[16]] *= 2;
+            s->block[block][idct_permutation[0]]  *= 2;
+        s->block[block][idct_permutation[1]]  *= 2;
+        s->block[block][idct_permutation[8]]  *= 2;
+        s->block[block][idct_permutation[16]] *= 2;
     }
 
     return 0;
@@ -172,7 +171,7 @@
                          unsigned cbp, int flag, int offset, unsigned flag2)
 {
     IMM4Context *s = avctx->priv_data;
-    const uint8_t *scantable = s->intra_scantable.permutated;
+    const uint8_t *idct_permutation = s->idsp.idct_permutation;
     int ret, i;
 
     memset(s->block, 0, sizeof(s->block));
@@ -185,7 +184,7 @@
                 x = 128;
             x *= 8;
 
-            s->block[i][scantable[0]] = x;
+            s->block[i][idct_permutation[0]] = x;
         }
 
         if (cbp & (1 << (5 - i))) {
@@ -495,14 +494,9 @@
 {
     static AVOnce init_static_once = AV_ONCE_INIT;
     IMM4Context *s = avctx->priv_data;
-    uint8_t table[64];
-
-    for (int i = 0; i < 64; i++)
-        table[i] = i;
 
     ff_bswapdsp_init(&s->bdsp);
     ff_idctdsp_init(&s->idsp, avctx);
-    ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, table);
 
     s->prev_frame = av_frame_alloc();
     if (!s->prev_frame)
--- a/third_party/ffmpeg/libavcodec/intrax8.c
+++ b/third_party/ffmpeg/libavcodec/intrax8.c
@@ -25,6 +25,7 @@
 #include "libavutil/thread.h"
 #include "avcodec.h"
 #include "get_bits.h"
+#include "idctdsp.h"
 #include "msmpeg4data.h"
 #include "intrax8huf.h"
 #include "intrax8.h"
@@ -576,7 +577,7 @@
         x8_select_ac_table(w, ac_mode);
         /* scantable_selector[12] = { 0, 2, 0, 1, 1, 1, 0, 2, 2, 0, 1, 2 }; <-
          * -> 10'01' 00'10' 10'00' 01'01' 01'00' 10'00 => 0x928548 */
-        scantable = w->scantable[(0x928548 >> (2 * w->orient)) & 3].permutated;
+        scantable = w->permutated_scantable[(0x928548 >> (2 * w->orient)) & 3];
         pos       = 0;
         do {
             n++;
@@ -714,12 +715,12 @@
     ff_init_scantable_permutation(w->idct_permutation,
                                   w->wdsp.idct_perm);
 
-    ff_init_scantable(w->idct_permutation, &w->scantable[0],
-                      ff_wmv1_scantable[0]);
-    ff_init_scantable(w->idct_permutation, &w->scantable[1],
-                      ff_wmv1_scantable[2]);
-    ff_init_scantable(w->idct_permutation, &w->scantable[2],
-                      ff_wmv1_scantable[3]);
+    ff_permute_scantable(w->permutated_scantable[0], ff_wmv1_scantable[0],
+                         w->idct_permutation);
+    ff_permute_scantable(w->permutated_scantable[1], ff_wmv1_scantable[2],
+                         w->idct_permutation);
+    ff_permute_scantable(w->permutated_scantable[2], ff_wmv1_scantable[3],
+                         w->idct_permutation);
 
     ff_intrax8dsp_init(&w->dsp);
     ff_blockdsp_init(&w->bdsp);
--- a/third_party/ffmpeg/libavcodec/intrax8.h
+++ b/third_party/ffmpeg/libavcodec/intrax8.h
@@ -21,7 +21,6 @@
 
 #include "blockdsp.h"
 #include "get_bits.h"
-#include "idctdsp.h"
 #include "intrax8dsp.h"
 #include "wmv2dsp.h"
 #include "mpegpicture.h"
@@ -35,7 +34,7 @@
 
     // set by ff_intrax8_common_init
     uint8_t *prediction_table; // 2 * (mb_w * 2)
-    ScanTable scantable[3];
+    uint8_t permutated_scantable[3][64];
     WMV2DSPContext wdsp;
     uint8_t idct_permutation[64];
     AVCodecContext *avctx;
--- a/third_party/ffmpeg/libavcodec/ituh263dec.c
+++ b/third_party/ffmpeg/libavcodec/ituh263dec.c
@@ -544,9 +544,9 @@
         i = 0;
         if (s->ac_pred) {
             if (s->h263_aic_dir)
-                scan_table = s->intra_v_scantable.permutated; /* left */
+                scan_table = s->permutated_intra_v_scantable; /* left */
             else
-                scan_table = s->intra_h_scantable.permutated; /* top */
+                scan_table = s->permutated_intra_h_scantable; /* top */
         }
     } else if (s->mb_intra) {
         /* DC coef */
--- a/third_party/ffmpeg/libavcodec/jpeg2000dec.c
+++ b/third_party/ffmpeg/libavcodec/jpeg2000dec.c
@@ -2519,6 +2519,15 @@
     if (ret = jpeg2000_read_main_headers(s))
         goto end;
 
+    if (s->sar.num && s->sar.den)
+        avctx->sample_aspect_ratio = s->sar;
+    s->sar.num = s->sar.den = 0;
+
+    if (avctx->skip_frame >= AVDISCARD_ALL) {
+        jpeg2000_dec_cleanup(s);
+        return avpkt->size;
+    }
+
     /* get picture buffer */
     if ((ret = ff_thread_get_buffer(avctx, picture, 0)) < 0)
         goto end;
@@ -2547,9 +2556,6 @@
 
     if (s->avctx->pix_fmt == AV_PIX_FMT_PAL8)
         memcpy(picture->data[1], s->palette, 256 * sizeof(uint32_t));
-    if (s->sar.num && s->sar.den)
-        avctx->sample_aspect_ratio = s->sar;
-    s->sar.num = s->sar.den = 0;
 
     return bytestream2_tell(&s->g);
 
@@ -2586,4 +2592,5 @@
     .p.priv_class     = &jpeg2000_class,
     .p.max_lowres     = 5,
     .p.profiles       = NULL_IF_CONFIG_SMALL(ff_jpeg2000_profiles),
+    .caps_internal    = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
 };
--- a/third_party/ffmpeg/libavcodec/jpeg2000dsp.c
+++ b/third_party/ffmpeg/libavcodec/jpeg2000dsp.c
@@ -76,14 +76,13 @@
 
 static void rct_int(void *_src0, void *_src1, void *_src2, int csize)
 {
-    int32_t *src0 = _src0, *src1 = _src1, *src2 = _src2;
-    int32_t i0, i1, i2;
+    uint32_t *src0 = _src0, *src1 = _src1, *src2 = _src2;
     int i;
 
     for (i = 0; i < csize; i++) {
-        i1 = *src0 - (*src2 + *src1 >> 2);
-        i0 = i1 + *src2;
-        i2 = i1 + *src1;
+        uint32_t i1 = *src0 - ((int32_t)(*src2 + *src1) >> 2);
+        int32_t i0 = i1 + *src2;
+        int32_t i2 = i1 + *src1;
         *src0++ = i0;
         *src1++ = i1;
         *src2++ = i2;
--- a/third_party/ffmpeg/libavcodec/jpeg2000dwt.c
+++ b/third_party/ffmpeg/libavcodec/jpeg2000dwt.c
@@ -81,7 +81,7 @@
 
     if (i1 <= i0 + 1) {
         if (i0 == 1)
-            p[1] <<= 1;
+            p[1] *= 2;
         return;
     }
 
--- a/third_party/ffmpeg/libavcodec/jpegtables.c
+++ b/third_party/ffmpeg/libavcodec/jpegtables.c
@@ -31,30 +31,3 @@
  */
 
 #include "jpegtabs.h"
-
-#if 0
-/* These are the sample quantization tables given in JPEG spec section K.1.
- * The spec says that the values given produce "good" quality, and
- * when divided by 2, "very good" quality.
- */
-static const unsigned char std_luminance_quant_tbl[64] = {
-    16,  11,  10,  16,  24,  40,  51,  61,
-    12,  12,  14,  19,  26,  58,  60,  55,
-    14,  13,  16,  24,  40,  57,  69,  56,
-    14,  17,  22,  29,  51,  87,  80,  62,
-    18,  22,  37,  56,  68, 109, 103,  77,
-    24,  35,  55,  64,  81, 104, 113,  92,
-    49,  64,  78,  87, 103, 121, 120, 101,
-    72,  92,  95,  98, 112, 100, 103,  99
-};
-static const unsigned char std_chrominance_quant_tbl[64] = {
-    17,  18,  24,  47,  99,  99,  99,  99,
-    18,  21,  26,  66,  99,  99,  99,  99,
-    24,  26,  56,  99,  99,  99,  99,  99,
-    47,  66,  99,  99,  99,  99,  99,  99,
-    99,  99,  99,  99,  99,  99,  99,  99,
-    99,  99,  99,  99,  99,  99,  99,  99,
-    99,  99,  99,  99,  99,  99,  99,  99,
-    99,  99,  99,  99,  99,  99,  99,  99
-};
-#endif
--- a/third_party/ffmpeg/libavcodec/jpegtables.h
+++ b/third_party/ffmpeg/libavcodec/jpegtables.h
@@ -23,6 +23,9 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
+
+FF_VISIBILITY_PUSH_HIDDEN
 extern const uint8_t ff_mjpeg_bits_dc_luminance[];
 extern const uint8_t ff_mjpeg_val_dc[];
 
@@ -33,5 +36,6 @@
 
 extern const uint8_t ff_mjpeg_bits_ac_chrominance[];
 extern const uint8_t ff_mjpeg_val_ac_chrominance[];
+FF_VISIBILITY_POP_HIDDEN
 
 #endif /* AVCODEC_JPEGTABLES_H */
--- a/third_party/ffmpeg/libavcodec/jrevdct.c
+++ b/third_party/ffmpeg/libavcodec/jrevdct.c
@@ -255,7 +255,7 @@
       if (d0) {
           /* Compute a 32 bit value to assign. */
           int16_t dcval = (int16_t) (d0 * (1 << PASS1_BITS));
-          register int v = (dcval & 0xffff) | ((dcval * (1 << 16)) & 0xffff0000);
+          register unsigned v = (dcval & 0xffff) | ((uint32_t)dcval << 16);
 
           AV_WN32A(&idataptr[ 0], v);
           AV_WN32A(&idataptr[ 4], v);
@@ -988,8 +988,8 @@
       /* AC terms all zero */
       if (d0) {
           /* Compute a 32 bit value to assign. */
-          int16_t dcval = (int16_t) (d0 << PASS1_BITS);
-          register int v = (dcval & 0xffff) | ((dcval << 16) & 0xffff0000);
+          int16_t dcval = (int16_t) (d0 * (1 << PASS1_BITS));
+          register unsigned v = (dcval & 0xffff) | ((uint32_t)dcval << 16);
 
           AV_WN32A(&idataptr[0], v);
           AV_WN32A(&idataptr[4], v);
@@ -1008,8 +1008,8 @@
                     tmp2 = z1 + MULTIPLY(-d6, FIX_1_847759065);
                     tmp3 = z1 + MULTIPLY(d2, FIX_0_765366865);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1020,8 +1020,8 @@
                     tmp2 = MULTIPLY(-d6, FIX_1_306562965);
                     tmp3 = MULTIPLY(d6, FIX_0_541196100);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1034,8 +1034,8 @@
                     tmp2 = MULTIPLY(d2, FIX_0_541196100);
                     tmp3 = MULTIPLY(d2, FIX_1_306562965);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1043,8 +1043,8 @@
                     tmp12 = tmp1 - tmp2;
             } else {
                     /* d0 != 0, d2 == 0, d4 != 0, d6 == 0 */
-                    tmp10 = tmp13 = (d0 + d4) << CONST_BITS;
-                    tmp11 = tmp12 = (d0 - d4) << CONST_BITS;
+                    tmp10 = tmp13 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp11 = tmp12 = (d0 - d4) * (1 << CONST_BITS);
             }
       }
 
@@ -1086,8 +1086,8 @@
                     tmp2 = z1 + MULTIPLY(-d6, FIX_1_847759065);
                     tmp3 = z1 + MULTIPLY(d2, FIX_0_765366865);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1098,8 +1098,8 @@
                     tmp2 = MULTIPLY(-d6, FIX_1_306562965);
                     tmp3 = MULTIPLY(d6, FIX_0_541196100);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1112,8 +1112,8 @@
                     tmp2 = MULTIPLY(d2, FIX_0_541196100);
                     tmp3 = MULTIPLY(d2, FIX_1_306562965);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1121,8 +1121,8 @@
                     tmp12 = tmp1 - tmp2;
             } else {
                     /* d0 != 0, d2 == 0, d4 != 0, d6 == 0 */
-                    tmp10 = tmp13 = (d0 + d4) << CONST_BITS;
-                    tmp11 = tmp12 = (d0 - d4) << CONST_BITS;
+                    tmp10 = tmp13 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp11 = tmp12 = (d0 - d4) * (1 << CONST_BITS);
             }
     }
 
--- a/third_party/ffmpeg/libavcodec/libcodec2.c
+++ b/third_party/ffmpeg/libavcodec/libcodec2.c
@@ -189,9 +189,7 @@
     .init                   = libcodec2_init_decoder,
     .close                  = libcodec2_close,
     FF_CODEC_DECODE_CB(libcodec2_decode),
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts      = (const uint64_t[]) { AV_CH_LAYOUT_MONO, 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO)
 };
 
 const FFCodec ff_libcodec2_encoder = {
@@ -209,7 +207,5 @@
     .init                   = libcodec2_init_encoder,
     .close                  = libcodec2_close,
     FF_CODEC_ENCODE_CB(libcodec2_encode),
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts      = (const uint64_t[]) { AV_CH_LAYOUT_MONO, 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO)
 };
--- a/third_party/ffmpeg/libavcodec/libdav1d.c
+++ b/third_party/ffmpeg/libavcodec/libdav1d.c
@@ -50,6 +50,7 @@
     Dav1dData data;
     int tile_threads;
     int frame_threads;
+    int max_frame_delay;
     int apply_grain;
     int operating_point;
     int all_layers;
@@ -246,7 +247,9 @@
         s.n_threads = FFMAX(dav1d->frame_threads, dav1d->tile_threads);
     else
         s.n_threads = FFMIN(threads, DAV1D_MAX_THREADS);
-    s.max_frame_delay = (c->flags & AV_CODEC_FLAG_LOW_DELAY) ? 1 : 0;
+    if (dav1d->max_frame_delay > 0 && (c->flags & AV_CODEC_FLAG_LOW_DELAY))
+        av_log(c, AV_LOG_WARNING, "Low delay mode requested, forcing max_frame_delay 1\n");
+    s.max_frame_delay = (c->flags & AV_CODEC_FLAG_LOW_DELAY) ? 1 : dav1d->max_frame_delay;
     av_log(c, AV_LOG_DEBUG, "Using %d threads, %d max_frame_delay\n",
            s.n_threads, s.max_frame_delay);
 #else
@@ -256,6 +259,8 @@
     s.n_frame_threads = dav1d->frame_threads
                       ? dav1d->frame_threads
                       : FFMIN(ceil(threads / s.n_tile_threads), DAV1D_MAX_FRAME_THREADS);
+    if (dav1d->max_frame_delay > 0)
+        s.n_frame_threads = FFMIN(s.n_frame_threads, dav1d->max_frame_delay);
     av_log(c, AV_LOG_DEBUG, "Using %d frame threads, %d tile threads\n",
            s.n_frame_threads, s.n_tile_threads);
 #endif
@@ -555,12 +560,16 @@
 #ifndef DAV1D_MAX_TILE_THREADS
 #define DAV1D_MAX_TILE_THREADS DAV1D_MAX_THREADS
 #endif
+#ifndef DAV1D_MAX_FRAME_DELAY
+#define DAV1D_MAX_FRAME_DELAY DAV1D_MAX_FRAME_THREADS
+#endif
 
 #define OFFSET(x) offsetof(Libdav1dContext, x)
 #define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM
 static const AVOption libdav1d_options[] = {
     { "tilethreads", "Tile threads", OFFSET(tile_threads), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, DAV1D_MAX_TILE_THREADS, VD | AV_OPT_FLAG_DEPRECATED },
     { "framethreads", "Frame threads", OFFSET(frame_threads), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, DAV1D_MAX_FRAME_THREADS, VD | AV_OPT_FLAG_DEPRECATED },
+    { "max_frame_delay", "Max frame delay", OFFSET(max_frame_delay), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, DAV1D_MAX_FRAME_DELAY, VD },
     { "filmgrain", "Apply Film Grain", OFFSET(apply_grain), AV_OPT_TYPE_BOOL, { .i64 = -1 }, -1, 1, VD | AV_OPT_FLAG_DEPRECATED },
     { "oppoint",  "Select an operating point of the scalable bitstream", OFFSET(operating_point), AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 31, VD },
     { "alllayers", "Output all spatial layers", OFFSET(all_layers), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VD },
--- a/third_party/ffmpeg/libavcodec/libfdk-aacenc.c
+++ b/third_party/ffmpeg/libavcodec/libfdk-aacenc.c
@@ -494,8 +494,6 @@
     .p.profiles            = profiles,
     .p.supported_samplerates = aac_sample_rates,
     .p.wrapper_name        = "libfdk",
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = aac_channel_layout,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(aac_channel_layout)
     .p.ch_layouts          = aac_ch_layouts,
 };
--- a/third_party/ffmpeg/libavcodec/libgsmenc.c
+++ b/third_party/ffmpeg/libavcodec/libgsmenc.c
@@ -127,9 +127,7 @@
     FF_CODEC_ENCODE_CB(libgsm_encode_frame),
     .close          = libgsm_encode_close,
     .defaults       = libgsm_defaults,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = (const uint64_t[]) { AV_CH_LAYOUT_MONO, 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO)
     .p.ch_layouts   = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO, { 0 } },
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
@@ -148,9 +146,7 @@
     FF_CODEC_ENCODE_CB(libgsm_encode_frame),
     .close          = libgsm_encode_close,
     .defaults       = libgsm_defaults,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = (const uint64_t[]) { AV_CH_LAYOUT_MONO, 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO)
     .p.ch_layouts   = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO, { 0 } },
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
--- a/third_party/ffmpeg/libavcodec/libmp3lame.c
+++ b/third_party/ffmpeg/libavcodec/libmp3lame.c
@@ -345,11 +345,7 @@
                                                              AV_SAMPLE_FMT_S16P,
                                                              AV_SAMPLE_FMT_NONE },
     .p.supported_samplerates = libmp3lame_sample_rates,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_MONO,
-                                                  AV_CH_LAYOUT_STEREO,
-                                                  0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO,
                                                          AV_CHANNEL_LAYOUT_STEREO,
                                                          { 0 },
--- a/third_party/ffmpeg/libavcodec/libopusdec.c
+++ b/third_party/ffmpeg/libavcodec/libopusdec.c
@@ -31,9 +31,9 @@
 #include "codec_internal.h"
 #include "decode.h"
 #include "internal.h"
-#include "vorbis.h"
 #include "mathops.h"
 #include "libopus.h"
+#include "vorbis_data.h"
 
 struct libopus_context {
     AVClass *class;
--- a/third_party/ffmpeg/libavcodec/libopusenc.c
+++ b/third_party/ffmpeg/libavcodec/libopusenc.c
@@ -29,8 +29,8 @@
 #include "codec_internal.h"
 #include "encode.h"
 #include "libopus.h"
-#include "vorbis.h"
 #include "audio_frame_queue.h"
+#include "vorbis_data.h"
 
 typedef struct LibopusEncOpts {
     int vbr;
--- a/third_party/ffmpeg/libavcodec/librav1e.c
+++ b/third_party/ffmpeg/libavcodec/librav1e.c
@@ -30,7 +30,6 @@
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 #include "avcodec.h"
-#include "bsf.h"
 #include "codec_internal.h"
 #include "encode.h"
 #include "internal.h"
@@ -41,7 +40,6 @@
     RaContext *ctx;
     AVFrame *frame;
     RaFrame *rframe;
-    AVBSFContext *bsf;
 
     uint8_t *pass_data;
     size_t pass_pos;
@@ -176,7 +174,6 @@
     }
 
     av_frame_free(&ctx->frame);
-    av_bsf_free(&ctx->bsf);
     av_freep(&ctx->pass_data);
 
     return 0;
@@ -245,36 +242,6 @@
         }
     }
 
-    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
-         const AVBitStreamFilter *filter = av_bsf_get_by_name("extract_extradata");
-         int bret;
-
-         if (!filter) {
-            av_log(avctx, AV_LOG_ERROR, "extract_extradata bitstream filter "
-                   "not found. This is a bug, please report it.\n");
-            ret = AVERROR_BUG;
-            goto end;
-         }
-
-         bret = av_bsf_alloc(filter, &ctx->bsf);
-         if (bret < 0) {
-             ret = bret;
-             goto end;
-         }
-
-         bret = avcodec_parameters_from_context(ctx->bsf->par_in, avctx);
-         if (bret < 0) {
-             ret = bret;
-             goto end;
-         }
-
-         bret = av_bsf_init(ctx->bsf);
-         if (bret < 0) {
-             ret = bret;
-             goto end;
-         }
-    }
-
     {
         AVDictionaryEntry *en = NULL;
         while ((en = av_dict_get(ctx->rav1e_opts, "", en, AV_DICT_IGNORE_SUFFIX))) {
@@ -298,6 +265,12 @@
         goto end;
     }
 
+    if (avctx->sample_aspect_ratio.num > 0 && avctx->sample_aspect_ratio.den > 0)
+        rav1e_config_set_sample_aspect_ratio(cfg, (RaRational) {
+                                             avctx->sample_aspect_ratio.num,
+                                             avctx->sample_aspect_ratio.den
+                                             });
+
     rret = rav1e_config_parse_int(cfg, "threads", avctx->thread_count);
     if (rret < 0)
         av_log(avctx, AV_LOG_WARNING, "Invalid number of threads, defaulting to auto.\n");
@@ -421,6 +394,23 @@
         goto end;
     }
 
+    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+        RaData *seq_hdr = rav1e_container_sequence_header(ctx->ctx);
+
+        if (seq_hdr)
+            avctx->extradata = av_mallocz(seq_hdr->len + AV_INPUT_BUFFER_PADDING_SIZE);
+        if (!seq_hdr || !avctx->extradata) {
+            rav1e_data_unref(seq_hdr);
+            av_log(avctx, AV_LOG_ERROR, "Failed to get extradata.\n");
+            ret = seq_hdr ? AVERROR(ENOMEM) : AVERROR_EXTERNAL;
+            goto end;
+        }
+
+        memcpy(avctx->extradata, seq_hdr->data, seq_hdr->len);
+        avctx->extradata_size = seq_hdr->len;
+        rav1e_data_unref(seq_hdr);
+    }
+
     ret = 0;
 
 end:
@@ -548,24 +538,34 @@
 
     pkt->pts = pkt->dts = *((int64_t *) rpkt->opaque);
     av_free(rpkt->opaque);
-    rav1e_packet_unref(rpkt);
 
-    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
-        int ret = av_bsf_send_packet(ctx->bsf, pkt);
+    if (avctx->flags & AV_CODEC_FLAG_RECON_FRAME) {
+        AVCodecInternal *avci = avctx->internal;
+        AVFrame *frame = avci->recon_frame;
+        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
+
+        av_frame_unref(frame);
+
+        frame->format = avctx->pix_fmt;
+        frame->width  = avctx->width;
+        frame->height = avctx->height;
+
+        ret = ff_encode_alloc_frame(avctx, frame);
         if (ret < 0) {
-            av_log(avctx, AV_LOG_ERROR, "extradata extraction send failed.\n");
-            av_packet_unref(pkt);
+            rav1e_packet_unref(rpkt);
             return ret;
         }
 
-        ret = av_bsf_receive_packet(ctx->bsf, pkt);
-        if (ret < 0) {
-            av_log(avctx, AV_LOG_ERROR, "extradata extraction receive failed.\n");
-            av_packet_unref(pkt);
-            return ret;
+        for (int i = 0; i < desc->nb_components; i++) {
+            int shift = i ? desc->log2_chroma_h : 0;
+            rav1e_frame_extract_plane(rpkt->rec, i, frame->data[i],
+                                      (frame->height >> shift) * frame->linesize[i],
+                                      frame->linesize[i], desc->comp[i].step);
         }
     }
 
+    rav1e_packet_unref(rpkt);
+
     return 0;
 }
 
@@ -627,7 +627,7 @@
     .defaults       = librav1e_defaults,
     .p.pix_fmts     = librav1e_pix_fmts,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_OTHER_THREADS |
-                      AV_CODEC_CAP_DR1,
+                      AV_CODEC_CAP_DR1 | AV_CODEC_CAP_ENCODER_RECON_FRAME,
     .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
                       FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_AUTO_THREADS,
     .p.wrapper_name = "librav1e",
--- a/third_party/ffmpeg/libavcodec/libshine.c
+++ b/third_party/ffmpeg/libavcodec/libshine.c
@@ -140,11 +140,7 @@
     .p.sample_fmts         = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16P,
                                                             AV_SAMPLE_FMT_NONE },
     .p.supported_samplerates = libshine_sample_rates,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_MONO,
-                                                  AV_CH_LAYOUT_STEREO,
-                                                  0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO,
                                                          AV_CHANNEL_LAYOUT_STEREO,
                                                          { 0 },
--- a/third_party/ffmpeg/libavcodec/libspeexenc.c
+++ b/third_party/ffmpeg/libavcodec/libspeexenc.c
@@ -354,11 +354,7 @@
     .close          = encode_close,
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = (const uint64_t[]){ AV_CH_LAYOUT_MONO,
-                                           AV_CH_LAYOUT_STEREO,
-                                           0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO)
     .p.ch_layouts    = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO,
                                                    AV_CHANNEL_LAYOUT_STEREO,
                                                    { 0 },
--- a/third_party/ffmpeg/libavcodec/libtwolame.c
+++ b/third_party/ffmpeg/libavcodec/libtwolame.c
@@ -228,12 +228,7 @@
         AV_SAMPLE_FMT_S16P,
         AV_SAMPLE_FMT_NONE
     },
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = (const uint64_t[]) {
-        AV_CH_LAYOUT_MONO,
-        AV_CH_LAYOUT_STEREO,
-        0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO)
     .p.ch_layouts    = (const AVChannelLayout[]) {
         AV_CHANNEL_LAYOUT_MONO,
         AV_CHANNEL_LAYOUT_STEREO,
--- a/third_party/ffmpeg/libavcodec/libvorbisenc.c
+++ b/third_party/ffmpeg/libavcodec/libvorbisenc.c
@@ -29,7 +29,6 @@
 #include "codec_internal.h"
 #include "encode.h"
 #include "version.h"
-#include "vorbis.h"
 #include "vorbis_parser.h"
 
 
--- a/third_party/ffmpeg/libavcodec/libvpxenc.c
+++ b/third_party/ffmpeg/libavcodec/libvpxenc.c
@@ -131,6 +131,7 @@
     int tune_content;
     int corpus_complexity;
     int tpl_model;
+    int min_gf_interval;
     AVFifo *hdr10_plus_fifo;
     /**
      * If the driver does not support ROI then warn the first time we
@@ -186,6 +187,9 @@
 #ifdef VPX_CTRL_VP9E_SET_TPL
     [VP9E_SET_TPL]                     = "VP9E_SET_TPL",
 #endif
+#ifdef VPX_CTRL_VP9E_SET_MIN_GF_INTERVAL
+    [VP9E_SET_MIN_GF_INTERVAL]         = "VP9E_SET_MIN_GF_INTERVAL",
+#endif
 #endif
 };
 
@@ -1174,6 +1178,10 @@
         if (ctx->tpl_model >= 0)
             codecctl_int(avctx, VP9E_SET_TPL, ctx->tpl_model);
 #endif
+#ifdef VPX_CTRL_VP9E_SET_MIN_GF_INTERVAL
+        if (ctx->min_gf_interval >= 0)
+            codecctl_int(avctx, VP9E_SET_MIN_GF_INTERVAL, ctx->min_gf_interval);
+#endif
     }
 #endif
 
@@ -1912,6 +1920,9 @@
 #ifdef VPX_CTRL_VP9E_SET_TPL
     { "enable-tpl",      "Enable temporal dependency model", OFFSET(tpl_model), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, VE },
 #endif
+#ifdef VPX_CTRL_VP9E_SET_MIN_GF_INTERVAL
+    { "min-gf-interval", "Minimum golden/alternate reference frame interval", OFFSET(min_gf_interval), AV_OPT_TYPE_INT, {.i64 = -1}, -1, INT_MAX, VE },
+#endif
     LEGACY_OPTIONS
     { NULL }
 };
--- a/third_party/ffmpeg/libavcodec/ljpegenc.c
+++ b/third_party/ffmpeg/libavcodec/ljpegenc.c
@@ -33,22 +33,16 @@
 #include "libavutil/frame.h"
 #include "libavutil/mem.h"
 #include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
 
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "encode.h"
-#include "idctdsp.h"
 #include "jpegtables.h"
-#include "mathops.h"
 #include "mjpegenc_common.h"
 #include "mjpeg.h"
 
 typedef struct LJpegEncContext {
     AVClass *class;
-    IDCTDSPContext idsp;
-    ScanTable scantable;
-    uint16_t matrix[64];
 
     int vsample[4];
     int hsample[4];
@@ -240,8 +234,8 @@
 
     init_put_bits(&pb, pkt->data, pkt->size);
 
-    ff_mjpeg_encode_picture_header(avctx, &pb, pict, NULL, &s->scantable,
-                                   s->pred, s->matrix, s->matrix, 0);
+    ff_mjpeg_encode_picture_header(avctx, &pb, pict, NULL, NULL,
+                                   s->pred, NULL, NULL, 0);
 
     header_bits = put_bits_count(&pb);
 
@@ -254,8 +248,6 @@
     if (ret < 0)
         return ret;
 
-    emms_c();
-
     ff_mjpeg_escape_FF(&pb, header_bits >> 3);
     ff_mjpeg_encode_picture_trailer(&pb, header_bits);
 
@@ -287,10 +279,6 @@
     if (!s->scratch)
         return AVERROR(ENOMEM);
 
-    ff_idctdsp_init(&s->idsp, avctx);
-    ff_init_scantable(s->idsp.idct_permutation, &s->scantable,
-                      ff_zigzag_direct);
-
     ff_mjpeg_init_hvsample(avctx, s->hsample, s->vsample);
 
     ff_mjpeg_build_huffman_codes(s->huff_size_dc_luminance,
--- a/third_party/ffmpeg/libavcodec/lpc.c
+++ b/third_party/ffmpeg/libavcodec/lpc.c
@@ -31,7 +31,7 @@
 /**
  * Apply Welch window function to audio block
  */
-static void lpc_apply_welch_window_c(const int32_t *data, int len,
+static void lpc_apply_welch_window_c(const int32_t *data, ptrdiff_t len,
                                      double *w_data)
 {
     int i, n2;
@@ -53,6 +53,7 @@
             w_data[i] = data[i] * w;
             w_data[len-1-i] = data[len-1-i] * w;
         }
+        w_data[n2] = 0.0;
         return;
     }
 
@@ -70,7 +71,7 @@
  * Calculate autocorrelation data from audio samples
  * A Welch window function is applied before calculation.
  */
-static void lpc_compute_autocorr_c(const double *data, int len, int lag,
+static void lpc_compute_autocorr_c(const double *data, ptrdiff_t len, int lag,
                                    double *autoc)
 {
     int i, j;
--- a/third_party/ffmpeg/libavcodec/lpc.h
+++ b/third_party/ffmpeg/libavcodec/lpc.h
@@ -23,6 +23,7 @@
 #define AVCODEC_LPC_H
 
 #include <stdint.h>
+#include <stddef.h>
 #include "libavutil/avassert.h"
 #include "libavutil/lls.h"
 #include "aac_defines.h"
@@ -64,7 +65,7 @@
      * @param len     number of input samples
      * @param w_data  output samples
      */
-    void (*lpc_apply_welch_window)(const int32_t *data, int len,
+    void (*lpc_apply_welch_window)(const int32_t *data, ptrdiff_t len,
                                    double *w_data);
     /**
      * Perform autocorrelation on input samples with delay of 0 to lag.
@@ -79,7 +80,7 @@
      * @param autoc output autocorrelation coefficients.
      *              constraints: array size must be at least lag+1.
      */
-    void (*lpc_compute_autocorr)(const double *data, int len, int lag,
+    void (*lpc_compute_autocorr)(const double *data, ptrdiff_t len, int lag,
                                  double *autoc);
 
     // TODO: these should be allocated to reduce ABI compatibility issues
--- a/third_party/ffmpeg/libavcodec/lsp.c
+++ b/third_party/ffmpeg/libavcodec/lsp.c
@@ -23,11 +23,15 @@
 
 #include <math.h>
 
+#include "config.h"
+
 #define FRAC_BITS 14
 #include "libavutil/macros.h"
 #include "mathops.h"
 #include "lsp.h"
+#if ARCH_MIPS
 #include "libavcodec/mips/lsp_mips.h"
+#endif /* ARCH_MIPS */
 #include "libavutil/avassert.h"
 
 void ff_acelp_reorder_lsf(int16_t* lsfq, int lsfq_min_distance, int lsfq_min, int lsfq_max, int lp_order)
@@ -120,6 +124,32 @@
     }
 }
 
+#ifndef lsp2polyf
+/**
+ * Compute the Pa / (1 + z(-1)) or Qa / (1 - z(-1)) coefficients
+ * needed for LSP to LPC conversion.
+ * We only need to calculate the 6 first elements of the polynomial.
+ *
+ * @param lsp line spectral pairs in cosine domain
+ * @param[out] f polynomial input/output as a vector
+ *
+ * TIA/EIA/IS-733 2.4.3.3.5-1/2
+ */
+static void lsp2polyf(const double *lsp, double *f, int lp_half_order)
+{
+    f[0] = 1.0;
+    f[1] = -2 * lsp[0];
+    lsp -= 2;
+    for (int i = 2; i <= lp_half_order; i++) {
+        double val = -2 * lsp[2*i];
+        f[i] = val * f[i-1] + 2*f[i-2];
+        for (int j = i-1; j > 1; j--)
+            f[j] += f[j-1] * val + f[j-2];
+        f[1] += val;
+    }
+}
+#endif /* lsp2polyf */
+
 void ff_acelp_lsp2lpc(int16_t* lp, const int16_t* lsp, int lp_half_order)
 {
     int i;
@@ -152,8 +182,8 @@
 
     qa[-1] = 0.0;
 
-    ff_lsp2polyf(lsp    , pa, lp_half_order    );
-    ff_lsp2polyf(lsp + 1, qa, lp_half_order - 1);
+    lsp2polyf(lsp    , pa, lp_half_order    );
+    lsp2polyf(lsp + 1, qa, lp_half_order - 1);
 
     for (i = 1, j = lp_order - 1; i < lp_half_order; i++, j--) {
         double paf =  pa[i]            * (1 + lsp[lp_order - 1]);
@@ -187,25 +217,6 @@
     ff_acelp_lsp2lpc(lp_2nd, lsp_2nd, lp_order >> 1);
 }
 
-#ifndef ff_lsp2polyf
-void ff_lsp2polyf(const double *lsp, double *f, int lp_half_order)
-{
-    int i, j;
-
-    f[0] = 1.0;
-    f[1] = -2 * lsp[0];
-    lsp -= 2;
-    for(i=2; i<=lp_half_order; i++)
-    {
-        double val = -2 * lsp[2*i];
-        f[i] = val * f[i-1] + 2*f[i-2];
-        for(j=i-1; j>1; j--)
-            f[j] += f[j-1] * val + f[j-2];
-        f[1] += val;
-    }
-}
-#endif /* ff_lsp2polyf */
-
 void ff_acelp_lspd2lpc(const double *lsp, float *lpc, int lp_half_order)
 {
     double pa[MAX_LP_HALF_ORDER+1], qa[MAX_LP_HALF_ORDER+1];
@@ -213,8 +224,8 @@
 
     av_assert2(lp_half_order <= MAX_LP_HALF_ORDER);
 
-    ff_lsp2polyf(lsp,     pa, lp_half_order);
-    ff_lsp2polyf(lsp + 1, qa, lp_half_order);
+    lsp2polyf(lsp,     pa, lp_half_order);
+    lsp2polyf(lsp + 1, qa, lp_half_order);
 
     while (lp_half_order--) {
         double paf = pa[lp_half_order+1] + pa[lp_half_order];
--- a/third_party/ffmpeg/libavcodec/lsp.h
+++ b/third_party/ffmpeg/libavcodec/lsp.h
@@ -115,16 +115,4 @@
  */
 void ff_sort_nearly_sorted_floats(float *vals, int len);
 
-/**
- * Compute the Pa / (1 + z(-1)) or Qa / (1 - z(-1)) coefficients
- * needed for LSP to LPC conversion.
- * We only need to calculate the 6 first elements of the polynomial.
- *
- * @param lsp line spectral pairs in cosine domain
- * @param[out] f polynomial input/output as a vector
- *
- * TIA/EIA/IS-733 2.4.3.3.5-1/2
- */
-void ff_lsp2polyf(const double *lsp, double *f, int lp_half_order);
-
 #endif /* AVCODEC_LSP_H */
--- a/third_party/ffmpeg/libavcodec/mdec.c
+++ b/third_party/ffmpeg/libavcodec/mdec.c
@@ -44,7 +44,7 @@
     BswapDSPContext bbdsp;
     IDCTDSPContext idsp;
     GetBitContext gb;
-    ScanTable scantable;
+    uint8_t permutated_scantable[64];
     int version;
     int qscale;
     int last_dc[3];
@@ -63,8 +63,7 @@
 {
     int level, diff, i, j, run;
     int component;
-    RLTable *rl = &ff_rl_mpeg1;
-    uint8_t * const scantable = a->scantable.permutated;
+    const uint8_t *const scantable = a->permutated_scantable;
     const uint16_t *quant_matrix = a->quant_matrix;
     const int qscale = a->qscale;
 
@@ -84,7 +83,7 @@
         /* now quantify & encode AC coefficients */
         for (;;) {
             UPDATE_CACHE(re, &a->gb);
-            GET_RL_VLC(level, run, re, &a->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
+            GET_RL_VLC(level, run, re, &a->gb, ff_mpeg1_rl_vlc, TEX_VLC_BITS, 2, 0);
 
             if (level == 127) {
                 break;
@@ -223,8 +222,8 @@
     ff_bswapdsp_init(&a->bbdsp);
     ff_idctdsp_init(&a->idsp, avctx);
     ff_mpeg12_init_vlcs();
-    ff_init_scantable(a->idsp.idct_permutation, &a->scantable,
-                      ff_zigzag_direct);
+    ff_permute_scantable(a->permutated_scantable, ff_zigzag_direct,
+                         a->idsp.idct_permutation);
 
     avctx->pix_fmt  = AV_PIX_FMT_YUVJ420P;
     avctx->color_range = AVCOL_RANGE_JPEG;
--- a/third_party/ffmpeg/libavcodec/me_cmp.h
+++ b/third_party/ffmpeg/libavcodec/me_cmp.h
@@ -21,9 +21,11 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
+
 #include "avcodec.h"
 
-extern const uint32_t ff_square_tab[512];
+extern const uint32_t attribute_visibility_hidden ff_square_tab[512];
 
 
 /* minimum alignment rules ;)
--- a/third_party/ffmpeg/libavcodec/mediacodec.h
+++ b/third_party/ffmpeg/libavcodec/mediacodec.h
@@ -88,13 +88,15 @@
 /**
  * Release a MediaCodec buffer and render it at the given time to the surface
  * that is associated with the decoder. The timestamp must be within one second
- * of the current java/lang/System#nanoTime() (which is implemented using
- * CLOCK_MONOTONIC on Android). See the Android MediaCodec documentation
- * of android/media/MediaCodec#releaseOutputBuffer(int,long) for more details.
+ * of the current `java/lang/System#nanoTime()` (which is implemented using
+ * `CLOCK_MONOTONIC` on Android). See the Android MediaCodec documentation
+ * of [`android/media/MediaCodec#releaseOutputBuffer(int,long)`][0] for more details.
  *
  * @param buffer the buffer to render
  * @param time timestamp in nanoseconds of when to render the buffer
  * @return 0 on success, < 0 otherwise
+ *
+ * [0]: https://developer.android.com/reference/android/media/MediaCodec#releaseOutputBuffer(int,%20long)
  */
 int av_mediacodec_render_buffer_at_time(AVMediaCodecBuffer *buffer, int64_t time);
 
--- a/third_party/ffmpeg/libavcodec/mediacodecdec_common.c
+++ b/third_party/ffmpeg/libavcodec/mediacodecdec_common.c
@@ -265,8 +265,7 @@
         ff_AMediaCodec_releaseOutputBuffer(ctx->codec, buffer->index, 0);
     }
 
-    if (ctx->delay_flush)
-        ff_mediacodec_dec_unref(ctx);
+    ff_mediacodec_dec_unref(ctx);
     av_freep(&buffer);
 }
 
@@ -321,8 +320,7 @@
 
     buffer->ctx = s;
     buffer->serial = atomic_load(&s->serial);
-    if (s->delay_flush)
-        ff_mediacodec_dec_ref(s);
+    ff_mediacodec_dec_ref(s);
 
     buffer->index = index;
     buffer->pts = info->presentationTimeUs;
@@ -872,7 +870,7 @@
 */
 int ff_mediacodec_dec_flush(AVCodecContext *avctx, MediaCodecDecContext *s)
 {
-    if (!s->surface || atomic_load(&s->refcount) == 1) {
+    if (!s->surface || !s->delay_flush || atomic_load(&s->refcount) == 1) {
         int ret;
 
         /* No frames (holding a reference to the codec) are retained by the
--- a/third_party/ffmpeg/libavcodec/metasound.c
+++ b/third_party/ffmpeg/libavcodec/metasound.c
@@ -26,15 +26,11 @@
 #include <stdint.h>
 
 #include "libavutil/channel_layout.h"
-#include "libavutil/float_dsp.h"
 
 #define BITSTREAM_READER_LE
 #include "avcodec.h"
 #include "codec_internal.h"
-#include "fft.h"
 #include "get_bits.h"
-#include "lsp.h"
-#include "sinewin.h"
 
 #include "twinvq.h"
 #include "metasound_data.h"
@@ -302,11 +298,6 @@
         props++;
     }
 
-    if (channels <= 0 || channels > TWINVQ_CHANNELS_MAX) {
-        av_log(avctx, AV_LOG_ERROR, "Unsupported number of channels: %i\n",
-               channels);
-        return AVERROR_INVALIDDATA;
-    }
     av_channel_layout_uninit(&avctx->ch_layout);
     av_channel_layout_default(&avctx->ch_layout, channels);
 
--- a/third_party/ffmpeg/libavcodec/mimic.c
+++ b/third_party/ffmpeg/libavcodec/mimic.c
@@ -56,7 +56,7 @@
     DECLARE_ALIGNED(32, int16_t, dct_block)[64];
 
     GetBitContext   gb;
-    ScanTable       scantable;
+    uint8_t         permutated_scantable[64];
     BlockDSPContext bdsp;
     BswapDSPContext bbdsp;
     HpelDSPContext  hdsp;
@@ -137,7 +137,7 @@
     ff_bswapdsp_init(&ctx->bbdsp);
     ff_hpeldsp_init(&ctx->hdsp, avctx->flags);
     ff_idctdsp_init(&ctx->idsp, avctx);
-    ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable, col_zag);
+    ff_permute_scantable(ctx->permutated_scantable, col_zag, ctx->idsp.idct_permutation);
 
     for (i = 0; i < FF_ARRAY_ELEMS(ctx->frames); i++) {
         ctx->frames[i].f = av_frame_alloc();
@@ -250,7 +250,7 @@
         else /* TODO Use >> 10 instead of / 1001 */
             coeff = (coeff * qscale) / 1001;
 
-        block[ctx->scantable.permutated[pos]] = coeff;
+        block[ctx->permutated_scantable[pos]] = coeff;
     }
 
     return 0;
--- a/third_party/ffmpeg/libavcodec/mips/ac3dsp_mips.c
+++ b/third_party/ffmpeg/libavcodec/mips/ac3dsp_mips.c
@@ -401,7 +401,8 @@
 #endif /* HAVE_MIPSFPU */
 #endif /* HAVE_INLINE_ASM */
 
-void ff_ac3dsp_init_mips(AC3DSPContext *c, int bit_exact) {
+void ff_ac3dsp_init_mips(AC3DSPContext *c)
+{
 #if HAVE_INLINE_ASM
 #if HAVE_MIPSDSP
     c->bit_alloc_calc_bap = ac3_bit_alloc_calc_bap_mips;
--- a/third_party/ffmpeg/libavcodec/mips/lsp_mips.h
+++ b/third_party/ffmpeg/libavcodec/mips/lsp_mips.h
@@ -61,7 +61,7 @@
 #include "libavutil/attributes.h"
 #include "libavutil/mips/asmdefs.h"
 
-static av_always_inline void ff_lsp2polyf_mips(const double *lsp, double *f, int lp_half_order)
+static av_always_inline void lsp2polyf_mips(const double *lsp, double *f, int lp_half_order)
 {
     int i, j = 0;
     double * p_fi = f;
@@ -88,8 +88,8 @@
             "addiu  %[j],       %[i], -2                        \n\t"
             "ldc1   %[f_j_2],   -8(%[p_f])                      \n\t"
             "sdc1   %[tmp],     16(%[p_f])                      \n\t"
-            "beqz   %[j],       ff_lsp2polyf_lp_j_end%=         \n\t"
-            "ff_lsp2polyf_lp_j%=:                               \n\t"
+            "beqz   %[j],       lsp2polyf_lp_j_end%=            \n\t"
+            "lsp2polyf_lp_j%=:                                  \n\t"
             "add.d  %[tmp],     %[f_j],     %[f_j_2]            \n\t"
             "madd.d %[tmp],     %[tmp],     %[f_j_1], %[val]    \n\t"
             "mov.d  %[f_j],     %[f_j_1]                        \n\t"
@@ -98,8 +98,8 @@
             "ldc1   %[f_j_2],   -16(%[p_f])                     \n\t"
             "sdc1   %[tmp],     8(%[p_f])                       \n\t"
             PTR_ADDIU "%[p_f], -8                              \n\t"
-            "bgtz   %[j],       ff_lsp2polyf_lp_j%=             \n\t"
-            "ff_lsp2polyf_lp_j_end%=:                           \n\t"
+            "bgtz   %[j],       lsp2polyf_lp_j%=                \n\t"
+            "lsp2polyf_lp_j_end%=:                              \n\t"
 
             : [f_j_2]"=&f"(f_j_2), [f_j_1]"=&f"(f_j_1), [val]"+f"(val),
               [tmp]"=&f"(tmp), [f_j]"=&f"(f_j), [p_f]"+r"(p_f),
@@ -110,7 +110,7 @@
         f[1] += val;
     }
 }
-#define ff_lsp2polyf ff_lsp2polyf_mips
+#define lsp2polyf lsp2polyf_mips
 #endif /* !HAVE_MIPS32R6 && !HAVE_MIPS64R6 */
 #endif /* HAVE_MIPSFPU && HAVE_INLINE_ASM */
 #endif /* AVCODEC_MIPS_LSP_MIPS_H */
--- a/third_party/ffmpeg/libavcodec/mjpegbdec.c
+++ b/third_party/ffmpeg/libavcodec/mjpegbdec.c
@@ -142,8 +142,8 @@
         return buf_size;
     }
 
-    if ((ret = av_frame_ref(rframe, s->picture_ptr)) < 0)
-        return ret;
+    av_frame_move_ref(rframe, s->picture_ptr);
+    s->got_picture = 0;
     *got_frame = 1;
 
     if (!s->lossless && avctx->debug & FF_DEBUG_QP) {
--- a/third_party/ffmpeg/libavcodec/mjpegdec.c
+++ b/third_party/ffmpeg/libavcodec/mjpegdec.c
@@ -115,8 +115,8 @@
     MJpegDecodeContext *s = avctx->priv_data;
 
     ff_idctdsp_init(&s->idsp, avctx);
-    ff_init_scantable(s->idsp.idct_permutation, &s->scantable,
-                      ff_zigzag_direct);
+    ff_permute_scantable(s->permutated_scantable, ff_zigzag_direct,
+                         s->idsp.idct_permutation);
 }
 
 av_cold int ff_mjpeg_decode_init(AVCodecContext *avctx)
@@ -373,7 +373,7 @@
     s->v_max         = 1;
     for (i = 0; i < nb_components; i++) {
         /* component id */
-        s->component_id[i] = get_bits(&s->gb, 8) - 1;
+        s->component_id[i] = get_bits(&s->gb, 8);
         h_count[i]         = get_bits(&s->gb, 4);
         v_count[i]         = get_bits(&s->gb, 4);
         /* compute hmax and vmax (only used in interleaved case) */
@@ -398,10 +398,10 @@
                s->component_id[i], s->quant_index[i]);
     }
     if (   nb_components == 4
-        && s->component_id[0] == 'C' - 1
-        && s->component_id[1] == 'M' - 1
-        && s->component_id[2] == 'Y' - 1
-        && s->component_id[3] == 'K' - 1)
+        && s->component_id[0] == 'C'
+        && s->component_id[1] == 'M'
+        && s->component_id[2] == 'Y'
+        && s->component_id[3] == 'K')
         s->adobe_transform = 0;
 
     if (s->ls && (s->h_max > 1 || s->v_max > 1)) {
@@ -523,7 +523,7 @@
                 s->avctx->pix_fmt = s->bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48;
             else {
                 if (   s->adobe_transform == 0
-                    || s->component_id[0] == 'R' - 1 && s->component_id[1] == 'G' - 1 && s->component_id[2] == 'B' - 1) {
+                    || s->component_id[0] == 'R' && s->component_id[1] == 'G' && s->component_id[2] == 'B') {
                     s->avctx->pix_fmt = s->bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16;
                 } else {
                     if (s->bits <= 8) s->avctx->pix_fmt = s->cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P;
@@ -596,7 +596,7 @@
         case 0x14111100:
         case 0x22211100:
         case 0x22112100:
-            if (s->component_id[0] == 'Q' && s->component_id[1] == 'F' && s->component_id[2] == 'A') {
+            if (s->component_id[0] == 'R' && s->component_id[1] == 'G' && s->component_id[2] == 'B') {
                 if (s->bits <= 8) s->avctx->pix_fmt = AV_PIX_FMT_GBRP;
                 else
                     goto unk_pixfmt;
@@ -611,7 +611,7 @@
             }
             break;
         case 0x21111100:
-            if (s->component_id[0] == 'Q' && s->component_id[1] == 'F' && s->component_id[2] == 'A') {
+            if (s->component_id[0] == 'R' && s->component_id[1] == 'G' && s->component_id[2] == 'B') {
                 if (s->bits <= 8) s->avctx->pix_fmt = AV_PIX_FMT_GBRP;
                 else
                     goto unk_pixfmt;
@@ -846,7 +846,7 @@
                 av_log(s->avctx, AV_LOG_ERROR, "error count: %d\n", i);
                 return AVERROR_INVALIDDATA;
             }
-            j        = s->scantable.permutated[i];
+            j        = s->permutated_scantable[i];
             block[j] = level * quant_matrix[i];
         }
     } while (i < 63);
@@ -909,14 +909,14 @@
 
                 if (i >= se) {
                     if (i == se) {
-                        j = s->scantable.permutated[se];
+                        j = s->permutated_scantable[se];
                         block[j] = level * (quant_matrix[se] << Al);
                         break;
                     }
                     av_log(s->avctx, AV_LOG_ERROR, "error count: %d\n", i);
                     return AVERROR_INVALIDDATA;
                 }
-                j = s->scantable.permutated[i];
+                j = s->permutated_scantable[i];
                 block[j] = level * (quant_matrix[i] << Al);
             } else {
                 if (run == 0xF) {// ZRL - skip 15 coefficients
@@ -964,7 +964,7 @@
         }                                                           \
         break;                                                      \
     }                                                               \
-    j = s->scantable.permutated[i];                                 \
+    j = s->permutated_scantable[i];                                 \
     if (block[j])                                                   \
         REFINE_BIT(j)                                               \
     else if (run-- == 0)                                            \
@@ -994,7 +994,7 @@
                 val = SHOW_UBITS(re, &s->gb, 1);
                 LAST_SKIP_BITS(re, &s->gb, 1);
                 ZERO_RUN;
-                j = s->scantable.permutated[i];
+                j = s->permutated_scantable[i];
                 val--;
                 block[j] = ((quant_matrix[i] << Al) ^ val) - val;
                 if (i == se) {
@@ -1026,7 +1026,7 @@
     }
 
     for (; i <= last; i++) {
-        j = s->scantable.permutated[i];
+        j = s->permutated_scantable[i];
         if (block[j])
             REFINE_BIT(j)
     }
@@ -1677,7 +1677,7 @@
         return AVERROR_INVALIDDATA;
     }
     for (i = 0; i < nb_components; i++) {
-        id = get_bits(&s->gb, 8) - 1;
+        id = get_bits(&s->gb, 8);
         av_log(s->avctx, AV_LOG_DEBUG, "component: %d\n", id);
         /* find component index */
         for (index = 0; index < s->nb_components; index++)
--- a/third_party/ffmpeg/libavcodec/mjpegdec.h
+++ b/third_party/ffmpeg/libavcodec/mjpegdec.h
@@ -118,7 +118,7 @@
     uint64_t coefs_finished[MAX_COMPONENTS]; ///< bitmask of which coefs have been completely decoded (progressive mode)
     int palette_index;
     int force_pal8;
-    ScanTable scantable;
+    uint8_t permutated_scantable[64];
     BlockDSPContext bdsp;
     HpelDSPContext hdsp;
     IDCTDSPContext idsp;
--- a/third_party/ffmpeg/libavcodec/mjpegenc.c
+++ b/third_party/ffmpeg/libavcodec/mjpegenc.c
@@ -81,7 +81,7 @@
 static void mjpeg_encode_picture_header(MpegEncContext *s)
 {
     ff_mjpeg_encode_picture_header(s->avctx, &s->pb, s->picture->f, s->mjpeg_ctx,
-                                   &s->intra_scantable, 0,
+                                   s->intra_scantable.permutated, 0,
                                    s->intra_matrix, s->chroma_intra_matrix,
                                    s->slice_context_count > 1);
 
--- a/third_party/ffmpeg/libavcodec/mjpegenc_common.c
+++ b/third_party/ffmpeg/libavcodec/mjpegenc_common.c
@@ -58,18 +58,16 @@
 
 static void jpeg_table_header(AVCodecContext *avctx, PutBitContext *p,
                               MJpegContext *m,
-                              ScanTable *intra_scantable,
+                              const uint8_t intra_matrix_permutation[64],
                               uint16_t luma_intra_matrix[64],
                               uint16_t chroma_intra_matrix[64],
-                              int hsample[3], int use_slices)
+                              int hsample[3], int use_slices, int matrices_differ)
 {
     int i, j, size;
     uint8_t *ptr;
 
     if (m) {
-        int matrix_count = 1 + !!memcmp(luma_intra_matrix,
-                                        chroma_intra_matrix,
-                                        sizeof(luma_intra_matrix[0]) * 64);
+        int matrix_count = 1 + matrices_differ;
         if (m->force_duplicated_matrix)
             matrix_count = 2;
         /* quant matrixes */
@@ -78,7 +76,7 @@
         put_bits(p, 4, 0); /* 8 bit precision */
         put_bits(p, 4, 0); /* table 0 */
         for (int i = 0; i < 64; i++) {
-            uint8_t j = intra_scantable->permutated[i];
+            uint8_t j = intra_matrix_permutation[i];
             put_bits(p, 8, luma_intra_matrix[j]);
         }
 
@@ -86,7 +84,7 @@
             put_bits(p, 4, 0); /* 8 bit precision */
             put_bits(p, 4, 1); /* table 1 */
             for(i=0;i<64;i++) {
-                j = intra_scantable->permutated[i];
+                j = intra_matrix_permutation[i];
                 put_bits(p, 8, chroma_intra_matrix[j]);
             }
         }
@@ -277,7 +275,7 @@
 
 void ff_mjpeg_encode_picture_header(AVCodecContext *avctx, PutBitContext *pb,
                                     const AVFrame *frame, struct MJpegContext *m,
-                                    ScanTable *intra_scantable, int pred,
+                                    const uint8_t intra_matrix_permutation[64], int pred,
                                     uint16_t luma_intra_matrix[64],
                                     uint16_t chroma_intra_matrix[64],
                                     int use_slices)
@@ -285,9 +283,7 @@
     const int lossless = !m;
     int hsample[4], vsample[4];
     int components = 3 + (avctx->pix_fmt == AV_PIX_FMT_BGRA);
-    int chroma_matrix = !!memcmp(luma_intra_matrix,
-                                 chroma_intra_matrix,
-                                 sizeof(luma_intra_matrix[0])*64);
+    int chroma_matrix;
 
     ff_mjpeg_init_hvsample(avctx, hsample, vsample);
 
@@ -299,9 +295,12 @@
 
     jpeg_put_comments(avctx, pb, frame);
 
-    jpeg_table_header(avctx, pb, m, intra_scantable,
+    chroma_matrix = !lossless && !!memcmp(luma_intra_matrix,
+                                          chroma_intra_matrix,
+                                          sizeof(luma_intra_matrix[0]) * 64);
+    jpeg_table_header(avctx, pb, m, intra_matrix_permutation,
                       luma_intra_matrix, chroma_intra_matrix, hsample,
-                      use_slices);
+                      use_slices, chroma_matrix);
 
     switch (avctx->codec_id) {
     case AV_CODEC_ID_MJPEG:  put_marker(pb, SOF0 ); break;
@@ -424,7 +423,6 @@
 
     if(ff_count==0) return;
 
-    flush_put_bits(pb);
     skip_put_bytes(pb, ff_count);
 
     for(i=size-1; ff_count; i--){
--- a/third_party/ffmpeg/libavcodec/mjpegenc_common.h
+++ b/third_party/ffmpeg/libavcodec/mjpegenc_common.h
@@ -24,7 +24,6 @@
 #include <stdint.h>
 
 #include "avcodec.h"
-#include "idctdsp.h"
 #include "put_bits.h"
 
 struct MJpegContext;
@@ -33,7 +32,8 @@
                                   size_t *max_pkt_size);
 void ff_mjpeg_encode_picture_header(AVCodecContext *avctx, PutBitContext *pb,
                                     const AVFrame *frame, struct MJpegContext *m,
-                                    ScanTable *intra_scantable, int pred,
+                                    const uint8_t intra_matrix_permutation[64],
+                                    int pred,
                                     uint16_t luma_intra_matrix[64],
                                     uint16_t chroma_intra_matrix[64],
                                     int use_slices);
--- a/third_party/ffmpeg/libavcodec/mlpdec.c
+++ b/third_party/ffmpeg/libavcodec/mlpdec.c
@@ -547,6 +547,9 @@
         return AVERROR_PATCHWELCOME;
     }
 
+    if (max_channel + 1 > MAX_CHANNELS || max_channel + 1 < min_channel)
+        return AVERROR_INVALIDDATA;
+
     s->min_channel        = min_channel;
     s->max_channel        = max_channel;
     s->coded_channels     = ((1LL << (max_channel - min_channel + 1)) - 1) << min_channel;
--- a/third_party/ffmpeg/libavcodec/mlpenc.c
+++ b/third_party/ffmpeg/libavcodec/mlpenc.c
@@ -2252,9 +2252,7 @@
     .close                  = mlp_encode_close,
     .p.sample_fmts          = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_S32, AV_SAMPLE_FMT_NONE},
     .p.supported_samplerates = (const int[]) {44100, 48000, 88200, 96000, 176400, 192000, 0},
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts      = ff_mlp_channel_layouts,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(ff_mlp_channel_layouts)
     .p.ch_layouts           = ff_mlp_ch_layouts,
     .caps_internal          = FF_CODEC_CAP_INIT_CLEANUP,
 };
@@ -2274,9 +2272,7 @@
     .close                  = mlp_encode_close,
     .p.sample_fmts          = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_S32, AV_SAMPLE_FMT_NONE},
     .p.supported_samplerates = (const int[]) {44100, 48000, 88200, 96000, 176400, 192000, 0},
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts      = (const uint64_t[]) { AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO, AV_CH_LAYOUT_5POINT0, AV_CH_LAYOUT_5POINT1, 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO, AV_CH_LAYOUT_5POINT0, AV_CH_LAYOUT_5POINT1)
     .p.ch_layouts           = (const AVChannelLayout[]) {
                                   AV_CHANNEL_LAYOUT_MONO,
                                   AV_CHANNEL_LAYOUT_STEREO,
--- a/third_party/ffmpeg/libavcodec/motion_est.h
+++ b/third_party/ffmpeg/libavcodec/motion_est.h
@@ -51,8 +51,6 @@
     int direct_basis_mv[4][2];
     uint8_t *scratchpad;            /**< data area for the ME algo, so that
                                      * the ME does not need to malloc/free. */
-    uint8_t *best_mb;
-    uint8_t *temp_mb[2];
     uint8_t *temp;
     int best_bits;
     uint32_t *map;                  ///< map to avoid duplicate evaluations
--- a/third_party/ffmpeg/libavcodec/motion_est_template.c
+++ b/third_party/ffmpeg/libavcodec/motion_est_template.c
@@ -281,7 +281,7 @@
                     for(i=0; i<8; i++){
                         if(score < best[i]){
                             memmove(&best[i+1], &best[i], sizeof(int)*(7-i));
-                            memmove(&best_pos[i+1][0], &best_pos[i][0], sizeof(int)*2*(7-i));
+                            memmove(&best_pos[i + 1], &best_pos[i], sizeof(*best_pos) * (7 - i));
                             best[i]= score;
                             best_pos[i][0]= nx + 4*mx;
                             best_pos[i][1]= ny + 4*my;
--- a/third_party/ffmpeg/libavcodec/mpeg12.c
+++ b/third_party/ffmpeg/libavcodec/mpeg12.c
@@ -34,9 +34,10 @@
 #include "avcodec.h"
 #include "mpegvideo.h"
 #include "mpeg12.h"
+#include "mpeg12codecs.h"
 #include "mpeg12data.h"
 #include "mpeg12dec.h"
-#include "mpegvideodata.h"
+#include "rl.h"
 #include "startcode.h"
 
 static const uint8_t table_mb_ptype[7][2] = {
@@ -63,13 +64,15 @@
     { 2, 5 }, // 0x1E MB_QUANT|MB_FOR|MB_BACK|MB_PAT
 };
 
-av_cold void ff_init_2d_vlc_rl(RLTable *rl, unsigned static_size, int flags)
+av_cold void ff_init_2d_vlc_rl(const uint16_t table_vlc[][2], RL_VLC_ELEM rl_vlc[],
+                               const int8_t table_run[], const uint8_t table_level[],
+                               int n, unsigned static_size, int flags)
 {
     int i;
     VLCElem table[680] = { 0 };
     VLC vlc = { .table = table, .table_allocated = static_size };
     av_assert0(static_size <= FF_ARRAY_ELEMS(table));
-    init_vlc(&vlc, TEX_VLC_BITS, rl->n + 2, &rl->table_vlc[0][1], 4, 2, &rl->table_vlc[0][0], 4, 2, INIT_VLC_USE_NEW_STATIC | flags);
+    init_vlc(&vlc, TEX_VLC_BITS, n + 2, &table_vlc[0][1], 4, 2, &table_vlc[0][0], 4, 2, INIT_VLC_USE_NEW_STATIC | flags);
 
     for (i = 0; i < vlc.table_size; i++) {
         int code = vlc.table[i].sym;
@@ -83,31 +86,23 @@
             run   = 0;
             level = code;
         } else {
-            if (code == rl->n) { //esc
+            if (code == n) { //esc
                 run   = 65;
                 level = 0;
-            } else if (code == rl->n+1) { //eob
+            } else if (code == n + 1) { //eob
                 run   = 0;
                 level = 127;
             } else {
-                run   = rl->table_run  [code] + 1;
-                level = rl->table_level[code];
+                run   = table_run  [code] + 1;
+                level = table_level[code];
             }
         }
-        rl->rl_vlc[0][i].len   = len;
-        rl->rl_vlc[0][i].level = level;
-        rl->rl_vlc[0][i].run   = run;
+        rl_vlc[i].len   = len;
+        rl_vlc[i].level = level;
+        rl_vlc[i].run   = run;
     }
 }
 
-av_cold void ff_mpeg12_common_init(MpegEncContext *s)
-{
-
-    s->y_dc_scale_table =
-    s->c_dc_scale_table = ff_mpeg2_dc_scale_table[s->intra_dc_precision];
-
-}
-
 void ff_mpeg1_clean_buffers(MpegEncContext *s)
 {
     s->last_dc[0] = 1 << (7 + s->intra_dc_precision);
@@ -130,6 +125,9 @@
 VLC ff_mb_btype_vlc;
 VLC ff_mb_pat_vlc;
 
+RL_VLC_ELEM ff_mpeg1_rl_vlc[680];
+RL_VLC_ELEM ff_mpeg2_rl_vlc[674];
+
 static av_cold void mpeg12_init_vlcs(void)
 {
     INIT_VLC_STATIC(&ff_dc_lum_vlc, DC_VLC_BITS, 12,
@@ -155,8 +153,12 @@
                     &table_mb_btype[0][1], 2, 1,
                     &table_mb_btype[0][0], 2, 1, 64);
 
-    INIT_2D_VLC_RL(ff_rl_mpeg1, 680, 0);
-    INIT_2D_VLC_RL(ff_rl_mpeg2, 674, 0);
+    ff_init_2d_vlc_rl(ff_mpeg1_vlc_table, ff_mpeg1_rl_vlc, ff_mpeg12_run,
+                      ff_mpeg12_level, MPEG12_RL_NB_ELEMS,
+                      FF_ARRAY_ELEMS(ff_mpeg1_rl_vlc), 0);
+    ff_init_2d_vlc_rl(ff_mpeg2_vlc_table, ff_mpeg2_rl_vlc, ff_mpeg12_run,
+                      ff_mpeg12_level, MPEG12_RL_NB_ELEMS,
+                      FF_ARRAY_ELEMS(ff_mpeg2_rl_vlc), 0);
 }
 
 av_cold void ff_mpeg12_init_vlcs(void)
@@ -239,7 +241,6 @@
                                 int16_t *block, int index, int qscale)
 {
     int dc, diff, i = 0, component;
-    RLTable *rl = &ff_rl_mpeg1;
 
     /* DC coefficient */
     component = index <= 3 ? 0 : index - 4 + 1;
@@ -264,7 +265,7 @@
         while (1) {
             int level, run, j;
 
-            GET_RL_VLC(level, run, re, gb, rl->rl_vlc[0],
+            GET_RL_VLC(level, run, re, gb, ff_mpeg1_rl_vlc,
                        TEX_VLC_BITS, 2, 0);
 
             if (level != 0) {
--- a/third_party/ffmpeg/libavcodec/mpeg12.h
+++ b/third_party/ffmpeg/libavcodec/mpeg12.h
@@ -22,7 +22,7 @@
 #ifndef AVCODEC_MPEG12_H
 #define AVCODEC_MPEG12_H
 
-#include "mpegvideo.h"
+#include "libavutil/rational.h"
 
 /* Start codes. */
 #define SEQ_END_CODE            0x000001b7
@@ -34,11 +34,13 @@
 #define EXT_START_CODE          0x000001b5
 #define USER_START_CODE         0x000001b2
 
-void ff_mpeg12_common_init(MpegEncContext *s);
-
-void ff_mpeg1_clean_buffers(MpegEncContext *s);
+#include "version_major.h"
 #if FF_API_FLAG_TRUNCATED
-int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size, AVCodecParserContext *s);
+#include <stdint.h>
+
+struct ParseContext;
+struct AVCodecParserContext;
+int ff_mpeg1_find_frame_end(struct ParseContext *pc, const uint8_t *buf, int buf_size, struct AVCodecParserContext *s);
 #endif
 
 void ff_mpeg12_find_best_frame_rate(AVRational frame_rate,
--- a/third_party/ffmpeg/libavcodec/mpeg12data.c
+++ b/third_party/ffmpeg/libavcodec/mpeg12data.c
@@ -26,6 +26,7 @@
  */
 
 #include "mpeg12data.h"
+#include "mpeg12vlc.h"
 
 const uint16_t ff_mpeg1_default_intra_matrix[256] = {
         8, 16, 19, 22, 26, 27, 29, 34,
@@ -63,7 +64,7 @@
     2, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10,
 };
 
-static const uint16_t mpeg1_vlc[113][2] = {
+const uint16_t ff_mpeg1_vlc_table[MPEG12_RL_NB_ELEMS + 2][2] = {
  { 0x3, 2 }, { 0x4, 4 }, { 0x5, 5 }, { 0x6, 7 },
  { 0x26, 8 }, { 0x21, 8 }, { 0xa, 10 }, { 0x1d, 12 },
  { 0x18, 12 }, { 0x13, 12 }, { 0x10, 12 }, { 0x1a, 13 },
@@ -96,7 +97,7 @@
  { 0x2, 2 }, /* EOB */
 };
 
-static const uint16_t mpeg2_vlc[113][2] = {
+const uint16_t ff_mpeg2_vlc_table[MPEG12_RL_NB_ELEMS + 2][2] = {
   {0x02, 2}, {0x06, 3}, {0x07, 4}, {0x1c, 5},
   {0x1d, 5}, {0x05, 6}, {0x04, 6}, {0x7b, 7},
   {0x7c, 7}, {0x23, 8}, {0x22, 8}, {0xfa, 8},
@@ -129,7 +130,7 @@
   {0x06,4}, /* EOB */
 };
 
-static const int8_t mpeg1_level[111] = {
+const int8_t ff_mpeg12_level[MPEG12_RL_NB_ELEMS] = {
   1,  2,  3,  4,  5,  6,  7,  8,
   9, 10, 11, 12, 13, 14, 15, 16,
  17, 18, 19, 20, 21, 22, 23, 24,
@@ -146,7 +147,7 @@
   1,  1,  1,  1,  1,  1,  1,
 };
 
-static const int8_t mpeg1_run[111] = {
+const int8_t ff_mpeg12_run[MPEG12_RL_NB_ELEMS] = {
   0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,
@@ -163,22 +164,6 @@
  25, 26, 27, 28, 29, 30, 31,
 };
 
-RLTable ff_rl_mpeg1 = {
-    111,
-    111,
-    mpeg1_vlc,
-    mpeg1_run,
-    mpeg1_level,
-};
-
-RLTable ff_rl_mpeg2 = {
-    111,
-    111,
-    mpeg2_vlc,
-    mpeg1_run,
-    mpeg1_level,
-};
-
 const uint8_t ff_mpeg12_mbAddrIncrTable[36][2] = {
     {0x1, 1},
     {0x3, 3},
--- a/third_party/ffmpeg/libavcodec/mpeg12data.h
+++ b/third_party/ffmpeg/libavcodec/mpeg12data.h
@@ -30,7 +30,6 @@
 
 #include <stdint.h>
 #include "libavutil/rational.h"
-#include "rl.h"
 
 extern const uint16_t ff_mpeg1_default_intra_matrix[];
 extern const uint16_t ff_mpeg1_default_non_intra_matrix[64];
@@ -40,9 +39,6 @@
 extern const uint16_t ff_mpeg12_vlc_dc_chroma_code[12];
 extern const unsigned char ff_mpeg12_vlc_dc_chroma_bits[12];
 
-extern RLTable ff_rl_mpeg1;
-extern RLTable ff_rl_mpeg2;
-
 extern const uint8_t ff_mpeg12_mbAddrIncrTable[36][2];
 extern const uint8_t ff_mpeg12_mbPatTable[64][2];
 
--- a/third_party/ffmpeg/libavcodec/mpeg12dec.c
+++ b/third_party/ffmpeg/libavcodec/mpeg12dec.c
@@ -47,6 +47,7 @@
 #include "internal.h"
 #include "mpeg_er.h"
 #include "mpeg12.h"
+#include "mpeg12codecs.h"
 #include "mpeg12data.h"
 #include "mpeg12dec.h"
 #include "mpegutils.h"
@@ -151,7 +152,6 @@
                                            int16_t *block, int n)
 {
     int level, i, j, run;
-    RLTable *rl                  = &ff_rl_mpeg1;
     uint8_t *const scantable     = s->intra_scantable.permutated;
     const uint16_t *quant_matrix = s->inter_matrix;
     const int qscale             = s->qscale;
@@ -174,7 +174,7 @@
         }
         /* now quantify & encode AC coefficients */
         for (;;) {
-            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0],
+            GET_RL_VLC(level, run, re, &s->gb, ff_mpeg1_rl_vlc,
                        TEX_VLC_BITS, 2, 0);
 
             if (level != 0) {
@@ -240,7 +240,6 @@
                                                 int16_t *block, int n)
 {
     int level, i, j, run;
-    RLTable *rl              = &ff_rl_mpeg1;
     uint8_t *const scantable = s->intra_scantable.permutated;
     const int qscale         = s->qscale;
 
@@ -263,7 +262,7 @@
 
         /* now quantify & encode AC coefficients */
         for (;;) {
-            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0],
+            GET_RL_VLC(level, run, re, &s->gb, ff_mpeg1_rl_vlc,
                        TEX_VLC_BITS, 2, 0);
 
             if (level != 0) {
@@ -325,7 +324,6 @@
                                                int16_t *block, int n)
 {
     int level, i, j, run;
-    RLTable *rl = &ff_rl_mpeg1;
     uint8_t *const scantable = s->intra_scantable.permutated;
     const uint16_t *quant_matrix;
     const int qscale = s->qscale;
@@ -357,7 +355,7 @@
 
         /* now quantify & encode AC coefficients */
         for (;;) {
-            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0],
+            GET_RL_VLC(level, run, re, &s->gb, ff_mpeg1_rl_vlc,
                        TEX_VLC_BITS, 2, 0);
 
             if (level != 0) {
@@ -415,7 +413,6 @@
                                                     int16_t *block, int n)
 {
     int level, i, j, run;
-    RLTable *rl              = &ff_rl_mpeg1;
     uint8_t *const scantable = s->intra_scantable.permutated;
     const int qscale         = s->qscale;
     OPEN_READER(re, &s->gb);
@@ -436,7 +433,7 @@
 
     /* now quantify & encode AC coefficients */
     for (;;) {
-        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
+        GET_RL_VLC(level, run, re, &s->gb, ff_mpeg1_rl_vlc, TEX_VLC_BITS, 2, 0);
 
         if (level != 0) {
             i += run;
@@ -488,7 +485,7 @@
 {
     int level, dc, diff, i, j, run;
     int component;
-    RLTable *rl;
+    const RL_VLC_ELEM *rl_vlc;
     uint8_t *const scantable = s->intra_scantable.permutated;
     const uint16_t *quant_matrix;
     const int qscale = s->qscale;
@@ -511,16 +508,16 @@
     mismatch = block[0] ^ 1;
     i = 0;
     if (s->intra_vlc_format)
-        rl = &ff_rl_mpeg2;
+        rl_vlc = ff_mpeg2_rl_vlc;
     else
-        rl = &ff_rl_mpeg1;
+        rl_vlc = ff_mpeg1_rl_vlc;
 
     {
         OPEN_READER(re, &s->gb);
         /* now quantify & encode AC coefficients */
         for (;;) {
             UPDATE_CACHE(re, &s->gb);
-            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0],
+            GET_RL_VLC(level, run, re, &s->gb, rl_vlc,
                        TEX_VLC_BITS, 2, 0);
 
             if (level == 127) {
@@ -574,7 +571,7 @@
 {
     int level, dc, diff, i, j, run;
     int component;
-    RLTable *rl;
+    const RL_VLC_ELEM *rl_vlc;
     uint8_t *const scantable = s->intra_scantable.permutated;
     const uint16_t *quant_matrix;
     const int qscale = s->qscale;
@@ -594,16 +591,16 @@
     block[0] = dc * (1 << (3 - s->intra_dc_precision));
     i = 0;
     if (s->intra_vlc_format)
-        rl = &ff_rl_mpeg2;
+        rl_vlc = ff_mpeg2_rl_vlc;
     else
-        rl = &ff_rl_mpeg1;
+        rl_vlc = ff_mpeg1_rl_vlc;
 
     {
         OPEN_READER(re, &s->gb);
         /* now quantify & encode AC coefficients */
         for (;;) {
             UPDATE_CACHE(re, &s->gb);
-            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0],
+            GET_RL_VLC(level, run, re, &s->gb, rl_vlc,
                        TEX_VLC_BITS, 2, 0);
 
             if (level >= 64 || i > 63) {
@@ -1062,7 +1059,6 @@
     /* we need some permutation to store matrices,
      * until the decoder sets the real permutation. */
     ff_mpv_idct_init(s2);
-    ff_mpeg12_common_init(&s->mpeg_enc_ctx);
     ff_mpeg12_init_vlcs();
 
     s2->chroma_format              = 1;
@@ -1788,7 +1784,7 @@
             return ret;
 
         // Note motion_val is normally NULL unless we want to extract the MVs.
-        if (s->current_picture.motion_val[0] && !s->encoding) {
+        if (s->current_picture.motion_val[0]) {
             const int wrap = s->b8_stride;
             int xy         = s->mb_x * 2 + s->mb_y * 2 * wrap;
             int b8_xy      = 4 * (s->mb_x + s->mb_y * s->mb_stride);
@@ -2797,7 +2793,6 @@
     }
 #endif
 
-    s2->codec_tag = ff_toupper4(avctx->codec_tag);
     if (s->mpeg_enc_ctx_allocated == 0 && (   s2->codec_tag == AV_RL32("VCR2")
                                            || s2->codec_tag == AV_RL32("BW10")
                                           ))
@@ -3075,7 +3070,6 @@
 
     ff_mpv_decode_init(m, avctx);
     ff_mpv_idct_init(m);
-    ff_mpeg12_common_init(m);
     ff_mpeg12_init_vlcs();
 
     for (int i = 0; i < 64; i++) {
--- a/third_party/ffmpeg/libavcodec/mpeg12dec.h
+++ b/third_party/ffmpeg/libavcodec/mpeg12dec.h
@@ -24,16 +24,6 @@
 
 #include "get_bits.h"
 #include "mpeg12vlc.h"
-#include "rl.h"
-
-#define INIT_2D_VLC_RL(rl, static_size, flags)\
-{\
-    static RL_VLC_ELEM rl_vlc_table[static_size];\
-    rl.rl_vlc[0] = rl_vlc_table;\
-    ff_init_2d_vlc_rl(&rl, static_size, flags);\
-}
-
-void ff_init_2d_vlc_rl(RLTable *rl, unsigned static_size, int flags);
 
 static inline int decode_dc(GetBitContext *gb, int component)
 {
--- a/third_party/ffmpeg/libavcodec/mpeg12enc.c
+++ b/third_party/ffmpeg/libavcodec/mpeg12enc.c
@@ -43,10 +43,13 @@
 #include "mpeg12.h"
 #include "mpeg12data.h"
 #include "mpeg12enc.h"
+#include "mpeg12vlc.h"
 #include "mpegutils.h"
 #include "mpegvideo.h"
+#include "mpegvideodata.h"
 #include "mpegvideoenc.h"
 #include "profiles.h"
+#include "rl.h"
 
 #if CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER
 static const uint8_t svcd_scan_offset_placeholder[] = {
@@ -60,6 +63,9 @@
 static uint8_t uni_mpeg1_ac_vlc_len[64 * 64 * 2];
 static uint8_t uni_mpeg2_ac_vlc_len[64 * 64 * 2];
 
+static uint8_t mpeg12_max_level[MAX_LEVEL + 1];
+static uint8_t mpeg12_index_run[MAX_RUN   + 1];
+
 /* simple include everything table for dc, first byte is bits
  * number next 3 are code */
 static uint32_t mpeg1_lum_dc_uni[512];
@@ -81,12 +87,21 @@
     int a53_cc;
     int seq_disp_ext;
     int video_format;
+#define VIDEO_FORMAT_COMPONENT   0
+#define VIDEO_FORMAT_PAL         1
+#define VIDEO_FORMAT_NTSC        2
+#define VIDEO_FORMAT_SECAM       3
+#define VIDEO_FORMAT_MAC         4
+#define VIDEO_FORMAT_UNSPECIFIED 5
 } MPEG12EncContext;
 
 #define A53_MAX_CC_COUNT 0x1f
 #endif /* CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER */
 
-av_cold void ff_mpeg1_init_uni_ac_vlc(const RLTable *rl, uint8_t *uni_ac_vlc_len)
+av_cold void ff_mpeg1_init_uni_ac_vlc(const int8_t max_level[],
+                                      const uint8_t index_run[],
+                                      const uint16_t table_vlc[][2],
+                                      uint8_t uni_ac_vlc_len[])
 {
     int i;
 
@@ -99,16 +114,16 @@
             int len, code;
             int alevel = FFABS(level);
 
-            if (alevel > rl->max_level[0][run])
+            if (alevel > max_level[run])
                 code = 111;                         /* rl->n */
             else
-                code = rl->index_run[0][run] + alevel - 1;
+                code = index_run[run] + alevel - 1;
 
             if (code < 111) {                       /* rl->n */
                 /* length of VLC and sign */
-                len = rl->table_vlc[code][1] + 1;
+                len = table_vlc[code][1] + 1;
             } else {
-                len = rl->table_vlc[111 /* rl->n */][1] + 6;
+                len = table_vlc[MPEG12_RL_NB_ELEMS][1] + 6;
 
                 if (alevel < 128)
                     len += 8;
@@ -701,7 +716,7 @@
 {
     int alevel, level, last_non_zero, dc, diff, i, j, run, last_index, sign;
     int code, component;
-    const uint16_t (*table_vlc)[2] = ff_rl_mpeg1.table_vlc;
+    const uint16_t (*table_vlc)[2] = ff_mpeg1_vlc_table;
 
     last_index = s->block_last_index[n];
 
@@ -714,7 +729,7 @@
         s->last_dc[component] = dc;
         i = 1;
         if (s->intra_vlc_format)
-            table_vlc = ff_rl_mpeg2.table_vlc;
+            table_vlc = ff_mpeg2_vlc_table;
     } else {
         /* encode the first coefficient: needs to be done here because
          * it is handled slightly differently */
@@ -746,8 +761,8 @@
             MASK_ABS(sign, alevel);
             sign &= 1;
 
-            if (alevel <= ff_rl_mpeg1.max_level[0][run]) {
-                code = ff_rl_mpeg1.index_run[0][run] + alevel - 1;
+            if (alevel <= mpeg12_max_level[run]) {
+                code = mpeg12_index_run[run] + alevel - 1;
                 /* store the VLC & sign at once */
                 put_bits(&s->pb, table_vlc[code][1] + 1,
                          (table_vlc[code][0] << 1) + sign);
@@ -1065,13 +1080,13 @@
 
 static av_cold void mpeg12_encode_init_static(void)
 {
-    static uint8_t mpeg12_static_rl_table_store[2][2][2*MAX_RUN + MAX_LEVEL + 3];
-
-    ff_rl_init(&ff_rl_mpeg1, mpeg12_static_rl_table_store[0]);
-    ff_rl_init(&ff_rl_mpeg2, mpeg12_static_rl_table_store[1]);
+    ff_rl_init_level_run(mpeg12_max_level, mpeg12_index_run,
+                         ff_mpeg12_run, ff_mpeg12_level, MPEG12_RL_NB_ELEMS);
 
-    ff_mpeg1_init_uni_ac_vlc(&ff_rl_mpeg1, uni_mpeg1_ac_vlc_len);
-    ff_mpeg1_init_uni_ac_vlc(&ff_rl_mpeg2, uni_mpeg2_ac_vlc_len);
+    ff_mpeg1_init_uni_ac_vlc(mpeg12_max_level, mpeg12_index_run,
+                             ff_mpeg1_vlc_table, uni_mpeg1_ac_vlc_len);
+    ff_mpeg1_init_uni_ac_vlc(mpeg12_max_level, mpeg12_index_run,
+                             ff_mpeg2_vlc_table, uni_mpeg2_ac_vlc_len);
 
     /* build unified dc encoding tables */
     for (int i = -255; i < 256; i++) {
@@ -1132,7 +1147,8 @@
 {
     static AVOnce init_static_once = AV_ONCE_INIT;
 
-    ff_mpeg12_common_init(s);
+    s->y_dc_scale_table =
+    s->c_dc_scale_table = ff_mpeg2_dc_scale_table[s->intra_dc_precision];
 
     s->me.mv_penalty = mv_penalty;
     s->fcode_tab     = fcode_tab;
--- a/third_party/ffmpeg/libavcodec/mpeg12enc.h
+++ b/third_party/ffmpeg/libavcodec/mpeg12enc.h
@@ -25,9 +25,6 @@
 #include <stdint.h>
 
 #include "mpegvideo.h"
-#include "rl.h"
-
-void ff_mpeg1_init_uni_ac_vlc(const RLTable *rl, uint8_t *uni_ac_vlc_len);
 
 void ff_mpeg1_encode_picture_header(MpegEncContext *s, int picture_number);
 void ff_mpeg1_encode_mb(MpegEncContext *s, int16_t block[8][64],
--- a/third_party/ffmpeg/libavcodec/mpeg12vlc.h
+++ b/third_party/ffmpeg/libavcodec/mpeg12vlc.h
@@ -49,4 +49,22 @@
 
 void ff_mpeg12_init_vlcs(void);
 
+#define MPEG12_RL_NB_ELEMS 111
+
+extern const int8_t ff_mpeg12_level[MPEG12_RL_NB_ELEMS];
+extern const int8_t ff_mpeg12_run[MPEG12_RL_NB_ELEMS];
+
+extern const uint16_t ff_mpeg1_vlc_table[MPEG12_RL_NB_ELEMS + 2][2];
+extern const uint16_t ff_mpeg2_vlc_table[MPEG12_RL_NB_ELEMS + 2][2];
+
+extern RL_VLC_ELEM ff_mpeg1_rl_vlc[];
+extern RL_VLC_ELEM ff_mpeg2_rl_vlc[];
+
+void ff_init_2d_vlc_rl(const uint16_t table_vlc[][2], RL_VLC_ELEM rl_vlc[],
+                       const int8_t table_run[], const uint8_t table_level[],
+                       int n, unsigned static_size, int flags);
+
+void ff_mpeg1_init_uni_ac_vlc(const int8_t max_level[], const uint8_t index_run[],
+                              const uint16_t table_vlc[][2], uint8_t uni_ac_vlc_len[]);
+
 #endif /* AVCODEC_MPEG12VLC_H */
--- a/third_party/ffmpeg/libavcodec/mpeg4audio.c
+++ b/third_party/ffmpeg/libavcodec/mpeg4audio.c
@@ -21,7 +21,6 @@
  */
 
 #include "get_bits.h"
-#include "put_bits.h"
 #include "mpeg4audio.h"
 
 /**
--- a/third_party/ffmpeg/libavcodec/mpeg4audio.h
+++ b/third_party/ffmpeg/libavcodec/mpeg4audio.h
@@ -24,10 +24,7 @@
 
 #include <stdint.h>
 
-#include "libavutil/attributes.h"
-
 #include "get_bits.h"
-#include "put_bits.h"
 
 typedef struct MPEG4AudioConfig {
     int object_type;
@@ -120,44 +117,4 @@
 #define MAX_PCE_SIZE 320 ///<Maximum size of a PCE including the 3-bit ID_PCE
                          ///<marker and the comment
 
-static av_always_inline unsigned int ff_pce_copy_bits(PutBitContext *pb,
-                                                      GetBitContext *gb,
-                                                      int bits)
-{
-    unsigned int el = get_bits(gb, bits);
-    put_bits(pb, bits, el);
-    return el;
-}
-
-static inline int ff_copy_pce_data(PutBitContext *pb, GetBitContext *gb)
-{
-    int five_bit_ch, four_bit_ch, comment_size, bits;
-    int offset = put_bits_count(pb);
-
-    ff_pce_copy_bits(pb, gb, 10);               // Tag, Object Type, Frequency
-    five_bit_ch  = ff_pce_copy_bits(pb, gb, 4); // Front
-    five_bit_ch += ff_pce_copy_bits(pb, gb, 4); // Side
-    five_bit_ch += ff_pce_copy_bits(pb, gb, 4); // Back
-    four_bit_ch  = ff_pce_copy_bits(pb, gb, 2); // LFE
-    four_bit_ch += ff_pce_copy_bits(pb, gb, 3); // Data
-    five_bit_ch += ff_pce_copy_bits(pb, gb, 4); // Coupling
-    if (ff_pce_copy_bits(pb, gb, 1))            // Mono Mixdown
-        ff_pce_copy_bits(pb, gb, 4);
-    if (ff_pce_copy_bits(pb, gb, 1))            // Stereo Mixdown
-        ff_pce_copy_bits(pb, gb, 4);
-    if (ff_pce_copy_bits(pb, gb, 1))            // Matrix Mixdown
-        ff_pce_copy_bits(pb, gb, 3);
-    for (bits = five_bit_ch*5+four_bit_ch*4; bits > 16; bits -= 16)
-        ff_pce_copy_bits(pb, gb, 16);
-    if (bits)
-        ff_pce_copy_bits(pb, gb, bits);
-    align_put_bits(pb);
-    align_get_bits(gb);
-    comment_size = ff_pce_copy_bits(pb, gb, 8);
-    for (; comment_size > 0; comment_size--)
-        ff_pce_copy_bits(pb, gb, 8);
-
-    return put_bits_count(pb) - offset;
-}
-
 #endif /* AVCODEC_MPEG4AUDIO_H */
--- a/third_party/ffmpeg/libavcodec/mpeg4videodec.c
+++ b/third_party/ffmpeg/libavcodec/mpeg4videodec.c
@@ -72,6 +72,176 @@
     MB_TYPE_L0      | MB_TYPE_16x16,
 };
 
+static void gmc1_motion(MpegEncContext *s, const Mpeg4DecContext *ctx,
+                        uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
+                        uint8_t *const *ref_picture)
+{
+    const uint8_t *ptr;
+    int src_x, src_y, motion_x, motion_y;
+    ptrdiff_t offset, linesize, uvlinesize;
+    int emu = 0;
+
+    motion_x   = ctx->sprite_offset[0][0];
+    motion_y   = ctx->sprite_offset[0][1];
+    src_x      = s->mb_x * 16 + (motion_x >> (ctx->sprite_warping_accuracy + 1));
+    src_y      = s->mb_y * 16 + (motion_y >> (ctx->sprite_warping_accuracy + 1));
+    motion_x *= 1 << (3 - ctx->sprite_warping_accuracy);
+    motion_y *= 1 << (3 - ctx->sprite_warping_accuracy);
+    src_x      = av_clip(src_x, -16, s->width);
+    if (src_x == s->width)
+        motion_x = 0;
+    src_y = av_clip(src_y, -16, s->height);
+    if (src_y == s->height)
+        motion_y = 0;
+
+    linesize   = s->linesize;
+    uvlinesize = s->uvlinesize;
+
+    ptr = ref_picture[0] + src_y * linesize + src_x;
+
+    if ((unsigned)src_x >= FFMAX(s->h_edge_pos - 17, 0) ||
+        (unsigned)src_y >= FFMAX(s->v_edge_pos - 17, 0)) {
+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
+                                 linesize, linesize,
+                                 17, 17,
+                                 src_x, src_y,
+                                 s->h_edge_pos, s->v_edge_pos);
+        ptr = s->sc.edge_emu_buffer;
+    }
+
+    if ((motion_x | motion_y) & 7) {
+        ctx->mdsp.gmc1(dest_y, ptr, linesize, 16,
+                       motion_x & 15, motion_y & 15, 128 - s->no_rounding);
+        ctx->mdsp.gmc1(dest_y + 8, ptr + 8, linesize, 16,
+                       motion_x & 15, motion_y & 15, 128 - s->no_rounding);
+    } else {
+        int dxy;
+
+        dxy = ((motion_x >> 3) & 1) | ((motion_y >> 2) & 2);
+        if (s->no_rounding) {
+            s->hdsp.put_no_rnd_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);
+        } else {
+            s->hdsp.put_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);
+        }
+    }
+
+    if (CONFIG_GRAY && s->avctx->flags & AV_CODEC_FLAG_GRAY)
+        return;
+
+    motion_x   = ctx->sprite_offset[1][0];
+    motion_y   = ctx->sprite_offset[1][1];
+    src_x      = s->mb_x * 8 + (motion_x >> (ctx->sprite_warping_accuracy + 1));
+    src_y      = s->mb_y * 8 + (motion_y >> (ctx->sprite_warping_accuracy + 1));
+    motion_x  *= 1 << (3 - ctx->sprite_warping_accuracy);
+    motion_y  *= 1 << (3 - ctx->sprite_warping_accuracy);
+    src_x      = av_clip(src_x, -8, s->width >> 1);
+    if (src_x == s->width >> 1)
+        motion_x = 0;
+    src_y = av_clip(src_y, -8, s->height >> 1);
+    if (src_y == s->height >> 1)
+        motion_y = 0;
+
+    offset = (src_y * uvlinesize) + src_x;
+    ptr    = ref_picture[1] + offset;
+    if ((unsigned)src_x >= FFMAX((s->h_edge_pos >> 1) - 9, 0) ||
+        (unsigned)src_y >= FFMAX((s->v_edge_pos >> 1) - 9, 0)) {
+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
+                                 uvlinesize, uvlinesize,
+                                 9, 9,
+                                 src_x, src_y,
+                                 s->h_edge_pos >> 1, s->v_edge_pos >> 1);
+        ptr = s->sc.edge_emu_buffer;
+        emu = 1;
+    }
+    ctx->mdsp.gmc1(dest_cb, ptr, uvlinesize, 8,
+                   motion_x & 15, motion_y & 15, 128 - s->no_rounding);
+
+    ptr = ref_picture[2] + offset;
+    if (emu) {
+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
+                                 uvlinesize, uvlinesize,
+                                 9, 9,
+                                 src_x, src_y,
+                                 s->h_edge_pos >> 1, s->v_edge_pos >> 1);
+        ptr = s->sc.edge_emu_buffer;
+    }
+    ctx->mdsp.gmc1(dest_cr, ptr, uvlinesize, 8,
+                   motion_x & 15, motion_y & 15, 128 - s->no_rounding);
+}
+
+static void gmc_motion(MpegEncContext *s, const Mpeg4DecContext *ctx,
+                       uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
+                       uint8_t *const *ref_picture)
+{
+    const uint8_t *ptr;
+    int linesize, uvlinesize;
+    const int a = ctx->sprite_warping_accuracy;
+    int ox, oy;
+
+    linesize   = s->linesize;
+    uvlinesize = s->uvlinesize;
+
+    ptr = ref_picture[0];
+
+    ox = ctx->sprite_offset[0][0] + ctx->sprite_delta[0][0] * s->mb_x * 16 +
+         ctx->sprite_delta[0][1] * s->mb_y * 16;
+    oy = ctx->sprite_offset[0][1] + ctx->sprite_delta[1][0] * s->mb_x * 16 +
+         ctx->sprite_delta[1][1] * s->mb_y * 16;
+
+    ctx->mdsp.gmc(dest_y, ptr, linesize, 16,
+                  ox, oy,
+                  ctx->sprite_delta[0][0], ctx->sprite_delta[0][1],
+                  ctx->sprite_delta[1][0], ctx->sprite_delta[1][1],
+                  a + 1, (1 << (2 * a + 1)) - s->no_rounding,
+                  s->h_edge_pos, s->v_edge_pos);
+    ctx->mdsp.gmc(dest_y + 8, ptr, linesize, 16,
+                  ox + ctx->sprite_delta[0][0] * 8,
+                  oy + ctx->sprite_delta[1][0] * 8,
+                  ctx->sprite_delta[0][0], ctx->sprite_delta[0][1],
+                  ctx->sprite_delta[1][0], ctx->sprite_delta[1][1],
+                  a + 1, (1 << (2 * a + 1)) - s->no_rounding,
+                  s->h_edge_pos, s->v_edge_pos);
+
+    if (CONFIG_GRAY && s->avctx->flags & AV_CODEC_FLAG_GRAY)
+        return;
+
+    ox = ctx->sprite_offset[1][0] + ctx->sprite_delta[0][0] * s->mb_x * 8 +
+         ctx->sprite_delta[0][1] * s->mb_y * 8;
+    oy = ctx->sprite_offset[1][1] + ctx->sprite_delta[1][0] * s->mb_x * 8 +
+         ctx->sprite_delta[1][1] * s->mb_y * 8;
+
+    ptr = ref_picture[1];
+    ctx->mdsp.gmc(dest_cb, ptr, uvlinesize, 8,
+                  ox, oy,
+                  ctx->sprite_delta[0][0], ctx->sprite_delta[0][1],
+                  ctx->sprite_delta[1][0], ctx->sprite_delta[1][1],
+                  a + 1, (1 << (2 * a + 1)) - s->no_rounding,
+                  (s->h_edge_pos + 1) >> 1, (s->v_edge_pos + 1) >> 1);
+
+    ptr = ref_picture[2];
+    ctx->mdsp.gmc(dest_cr, ptr, uvlinesize, 8,
+                  ox, oy,
+                  ctx->sprite_delta[0][0], ctx->sprite_delta[0][1],
+                  ctx->sprite_delta[1][0], ctx->sprite_delta[1][1],
+                  a + 1, (1 << (2 * a + 1)) - s->no_rounding,
+                  (s->h_edge_pos + 1) >> 1, (s->v_edge_pos + 1) >> 1);
+}
+
+void ff_mpeg4_mcsel_motion(MpegEncContext *s,
+                           uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
+                           uint8_t *const *ref_picture)
+{
+    const Mpeg4DecContext *const ctx = (Mpeg4DecContext*)s;
+
+    if (ctx->real_sprite_warping_points == 1) {
+        gmc1_motion(s, ctx, dest_y, dest_cb, dest_cr,
+                    ref_picture);
+    } else {
+        gmc_motion(s, ctx, dest_y, dest_cb, dest_cr,
+                    ref_picture);
+    }
+}
+
 void ff_mpeg4_decode_studio(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb,
                             uint8_t *dest_cr, int block_size, int uvlinesize,
                             int dct_linesize, int dct_offset)
@@ -248,8 +418,8 @@
 static int mpeg4_decode_sprite_trajectory(Mpeg4DecContext *ctx, GetBitContext *gb)
 {
     MpegEncContext *s = &ctx->m;
-    int a     = 2 << s->sprite_warping_accuracy;
-    int rho   = 3  - s->sprite_warping_accuracy;
+    int a     = 2 << ctx->sprite_warping_accuracy;
+    int rho   = 3  - ctx->sprite_warping_accuracy;
     int r     = 16 / a;
     int alpha = 1;
     int beta  = 0;
@@ -437,7 +607,7 @@
         sprite_delta[1][1] = a;
         ctx->sprite_shift[0] = 0;
         ctx->sprite_shift[1] = 0;
-        s->real_sprite_warping_points = 1;
+        ctx->real_sprite_warping_points = 1;
     } else {
         int shift_y = 16 - ctx->sprite_shift[0];
         int shift_c = 16 - ctx->sprite_shift[1];
@@ -483,18 +653,18 @@
                 goto overflow;
             }
         }
-        s->real_sprite_warping_points = ctx->num_sprite_warping_points;
+        ctx->real_sprite_warping_points = ctx->num_sprite_warping_points;
     }
 
     for (i = 0; i < 4; i++) {
-        s->sprite_offset[i&1][i>>1] = sprite_offset[i&1][i>>1];
-        s->sprite_delta [i&1][i>>1] = sprite_delta [i&1][i>>1];
+        ctx->sprite_offset[i&1][i>>1] = sprite_offset[i&1][i>>1];
+        ctx->sprite_delta [i&1][i>>1] = sprite_delta [i&1][i>>1];
     }
 
     return 0;
 overflow:
-    memset(s->sprite_offset, 0, sizeof(s->sprite_offset));
-    memset(s->sprite_delta, 0, sizeof(s->sprite_delta));
+    memset(ctx->sprite_offset, 0, sizeof(ctx->sprite_offset));
+    memset(ctx->sprite_delta,  0, sizeof(ctx->sprite_delta));
     return AVERROR_PATCHWELCOME;
 }
 
@@ -662,25 +832,25 @@
     MpegEncContext *s = &ctx->m;
     int x, y, mb_v, sum, dx, dy, shift;
     int len     = 1 << (s->f_code + 4);
-    const int a = s->sprite_warping_accuracy;
+    const int a = ctx->sprite_warping_accuracy;
 
     if (s->workaround_bugs & FF_BUG_AMV)
         len >>= s->quarter_sample;
 
-    if (s->real_sprite_warping_points == 1) {
+    if (ctx->real_sprite_warping_points == 1) {
         if (ctx->divx_version == 500 && ctx->divx_build == 413 && a >= s->quarter_sample)
-            sum = s->sprite_offset[0][n] / (1 << (a - s->quarter_sample));
+            sum = ctx->sprite_offset[0][n] / (1 << (a - s->quarter_sample));
         else
-            sum = RSHIFT(s->sprite_offset[0][n] * (1 << s->quarter_sample), a);
+            sum = RSHIFT(ctx->sprite_offset[0][n] * (1 << s->quarter_sample), a);
     } else {
-        dx    = s->sprite_delta[n][0];
-        dy    = s->sprite_delta[n][1];
+        dx    = ctx->sprite_delta[n][0];
+        dy    = ctx->sprite_delta[n][1];
         shift = ctx->sprite_shift[0];
         if (n)
             dy -= 1 << (shift + a + 1);
         else
             dx -= 1 << (shift + a + 1);
-        mb_v = s->sprite_offset[0][n] + dx * s->mb_x * 16U + dy * s->mb_y * 16U;
+        mb_v = ctx->sprite_offset[0][n] + dx * s->mb_x * 16U + dy * s->mb_y * 16U;
 
         sum = 0;
         for (y = 0; y < 16; y++) {
@@ -1157,9 +1327,9 @@
         }
         if (s->ac_pred) {
             if (dc_pred_dir == 0)
-                scan_table = s->intra_v_scantable.permutated;  /* left */
+                scan_table = s->permutated_intra_v_scantable;  /* left */
             else
-                scan_table = s->intra_h_scantable.permutated;  /* top */
+                scan_table = s->permutated_intra_h_scantable;  /* top */
         } else {
             scan_table = s->intra_scantable.permutated;
         }
@@ -1478,6 +1648,7 @@
     int16_t *mot_val;
     static const int8_t quant_tab[4] = { -1, -2, 1, 2 };
     const int xy = s->mb_x + s->mb_y * s->mb_stride;
+    int next;
 
     av_assert2(s ==  (void*)ctx);
     av_assert2(s->h263_pred);
@@ -1829,26 +2000,24 @@
 
 end:
     /* per-MB end of slice check */
-    if (s->codec_id == AV_CODEC_ID_MPEG4) {
-        int next = mpeg4_is_resync(ctx);
-        if (next) {
-            if        (s->mb_x + s->mb_y*s->mb_width + 1 >  next && (s->avctx->err_recognition & AV_EF_AGGRESSIVE)) {
-                return AVERROR_INVALIDDATA;
-            } else if (s->mb_x + s->mb_y*s->mb_width + 1 >= next)
-                return SLICE_END;
-
-            if (s->pict_type == AV_PICTURE_TYPE_B) {
-                const int delta= s->mb_x + 1 == s->mb_width ? 2 : 1;
-                ff_thread_await_progress(&s->next_picture_ptr->tf,
-                                         (s->mb_x + delta >= s->mb_width)
-                                         ? FFMIN(s->mb_y + 1, s->mb_height - 1)
-                                         : s->mb_y, 0);
-                if (s->next_picture.mbskip_table[xy + delta])
-                    return SLICE_OK;
-            }
-
+    next = mpeg4_is_resync(ctx);
+    if (next) {
+        if        (s->mb_x + s->mb_y*s->mb_width + 1 >  next && (s->avctx->err_recognition & AV_EF_AGGRESSIVE)) {
+            return AVERROR_INVALIDDATA;
+        } else if (s->mb_x + s->mb_y*s->mb_width + 1 >= next)
             return SLICE_END;
+
+        if (s->pict_type == AV_PICTURE_TYPE_B) {
+            const int delta = s->mb_x + 1 == s->mb_width ? 2 : 1;
+            ff_thread_await_progress(&s->next_picture_ptr->tf,
+                                        (s->mb_x + delta >= s->mb_width)
+                                        ? FFMIN(s->mb_y + 1, s->mb_height - 1)
+                                        : s->mb_y, 0);
+            if (s->next_picture.mbskip_table[xy + delta])
+                return SLICE_OK;
         }
+
+        return SLICE_END;
     }
 
     return SLICE_OK;
@@ -2528,7 +2697,7 @@
                 ctx->num_sprite_warping_points = 0;
                 return AVERROR_INVALIDDATA;
             }
-            s->sprite_warping_accuracy  = get_bits(gb, 2);
+            ctx->sprite_warping_accuracy  = get_bits(gb, 2);
             ctx->sprite_brightness_change = get_bits1(gb);
             if (ctx->vol_sprite_usage == STATIC_SPRITE)
                 skip_bits1(gb); // low_latency_sprite
@@ -2914,7 +3083,6 @@
                ctx->divx_version, ctx->divx_build, s->divx_packed ? "p" : "");
 
     if (CONFIG_MPEG4_DECODER && ctx->xvid_build >= 0 &&
-        s->codec_id == AV_CODEC_ID_MPEG4 &&
         avctx->idct_algo == FF_IDCT_AUTO) {
         avctx->idct_algo = FF_IDCT_XVID;
         ff_mpv_idct_init(s);
@@ -3090,13 +3258,17 @@
     if (s->alternate_scan) {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
+        ff_permute_scantable(s->permutated_intra_h_scantable, ff_alternate_vertical_scan,
+                             s->idsp.idct_permutation);
+        ff_permute_scantable(s->permutated_intra_v_scantable, ff_alternate_vertical_scan,
+                             s->idsp.idct_permutation);
     } else {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
+        ff_permute_scantable(s->permutated_intra_h_scantable, ff_alternate_horizontal_scan,
+                             s->idsp.idct_permutation);
+        ff_permute_scantable(s->permutated_intra_v_scantable, ff_alternate_vertical_scan,
+                             s->idsp.idct_permutation);
     }
 
     /* Skip at this point when only parsing since the remaining
@@ -3116,8 +3288,8 @@
             if (ctx->vol_sprite_usage == STATIC_SPRITE)
                 av_log(s->avctx, AV_LOG_ERROR, "static sprite not supported\n");
         } else {
-            memset(s->sprite_offset, 0, sizeof(s->sprite_offset));
-            memset(s->sprite_delta, 0, sizeof(s->sprite_delta));
+            memset(ctx->sprite_offset, 0, sizeof(ctx->sprite_offset));
+            memset(ctx->sprite_delta,  0, sizeof(ctx->sprite_delta));
         }
     }
 
@@ -3159,7 +3331,7 @@
                    gb->size_in_bits,s->progressive_sequence, s->alternate_scan,
                    s->top_field_first, s->quarter_sample ? 'q' : 'h',
                    s->data_partitioning, ctx->resync_marker,
-                   ctx->num_sprite_warping_points, s->sprite_warping_accuracy,
+                   ctx->num_sprite_warping_points, ctx->sprite_warping_accuracy,
                    1 - s->no_rounding, ctx->vo_type,
                    ctx->vol_control_parameters ? " VOLC" : " ", ctx->intra_dc_threshold,
                    ctx->cplx_estimation_trash_i, ctx->cplx_estimation_trash_p,
@@ -3264,13 +3436,17 @@
     if (s->alternate_scan) {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
+        ff_permute_scantable(s->permutated_intra_h_scantable, ff_alternate_vertical_scan,
+                             s->idsp.idct_permutation);
+        ff_permute_scantable(s->permutated_intra_v_scantable, ff_alternate_vertical_scan,
+                             s->idsp.idct_permutation);
     } else {
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
+        ff_permute_scantable(s->permutated_intra_h_scantable, ff_alternate_horizontal_scan,
+                             s->idsp.idct_permutation);
+        ff_permute_scantable(s->permutated_intra_v_scantable, ff_alternate_vertical_scan,
+                             s->idsp.idct_permutation);
     }
 
     mpeg4_load_default_matrices(s);
@@ -3516,6 +3692,7 @@
     return 0;
 }
 
+#if CONFIG_MPEG4_DECODER
 #if HAVE_THREADS
 static int mpeg4_update_thread_context(AVCodecContext *dst,
                                        const AVCodecContext *src)
@@ -3534,6 +3711,7 @@
     s->shape                     = s1->shape;
     s->vol_sprite_usage          = s1->vol_sprite_usage;
     s->sprite_brightness_change  = s1->sprite_brightness_change;
+    s->sprite_warping_accuracy   = s1->sprite_warping_accuracy;
     s->num_sprite_warping_points = s1->num_sprite_warping_points;
     s->m.data_partitioning       = s1->m.data_partitioning;
     s->rvlc                      = s1->rvlc;
@@ -3558,7 +3736,7 @@
     memcpy(s->sprite_shift, s1->sprite_shift, sizeof(s1->sprite_shift));
     memcpy(s->sprite_traj,  s1->sprite_traj,  sizeof(s1->sprite_traj));
 
-    if (CONFIG_MPEG4_DECODER && !init && s1->xvid_build >= 0)
+    if (!init && s1->xvid_build >= 0)
         ff_xvid_idct_init(&s->m.idsp, dst);
 
     return 0;
@@ -3646,6 +3824,8 @@
 
     avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;
 
+    ff_mpeg4videodsp_init(&ctx->mdsp);
+
     ff_thread_once(&init_static_once, mpeg4_init_static);
 
     return 0;
@@ -3705,3 +3885,4 @@
                                NULL
                            },
 };
+#endif /* CONFIG_MPEG4_DECODER */
--- a/third_party/ffmpeg/libavcodec/mpeg4videodec.h
+++ b/third_party/ffmpeg/libavcodec/mpeg4videodec.h
@@ -27,6 +27,7 @@
 
 #include "get_bits.h"
 #include "mpegvideo.h"
+#include "mpeg4videodsp.h"
 
 
 typedef struct Mpeg4DecContext {
@@ -37,7 +38,11 @@
     int shape;
     int vol_sprite_usage;
     int sprite_brightness_change;
+    int sprite_warping_accuracy;
     int num_sprite_warping_points;
+    int real_sprite_warping_points;
+    int sprite_offset[2][2];         ///< sprite offset[isChroma][isMVY]
+    int sprite_delta[2][2];          ///< sprite_delta [isY][isMVY]
     /// sprite trajectory points
     uint16_t sprite_traj[4][2];
     /// sprite shift [isChroma]
@@ -76,6 +81,8 @@
 
     int rgb;
 
+    Mpeg4VideoDSPContext mdsp;
+
     int32_t block32[12][64];
     // 0 = DCT, 1 = DPCM top to bottom scan, -1 = DPCM bottom to top scan
     int dpcm_direction;
@@ -87,6 +94,9 @@
 void ff_mpeg4_decode_studio(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb,
                             uint8_t *dest_cr, int block_size, int uvlinesize,
                             int dct_linesize, int dct_offset);
+void ff_mpeg4_mcsel_motion(MpegEncContext *s,
+                           uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
+                           uint8_t *const *ref_picture);
 int ff_mpeg4_decode_partitions(Mpeg4DecContext *ctx);
 int ff_mpeg4_decode_video_packet_header(Mpeg4DecContext *ctx);
 int ff_mpeg4_decode_studio_slice_header(Mpeg4DecContext *ctx);
--- a/third_party/ffmpeg/libavcodec/mpegvideodsp.c
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "config.h"
-#include "libavutil/attributes.h"
-#include "libavutil/common.h"
-#include "mpegvideodsp.h"
-
-static void gmc1_c(uint8_t *dst, const uint8_t *src, int stride, int h,
-                   int x16, int y16, int rounder)
-{
-    const int A = (16 - x16) * (16 - y16);
-    const int B = (x16)      * (16 - y16);
-    const int C = (16 - x16) * (y16);
-    const int D = (x16)      * (y16);
-    int i;
-
-    for (i = 0; i < h; i++) {
-        dst[0] = (A * src[0] + B * src[1] + C * src[stride + 0] + D * src[stride + 1] + rounder) >> 8;
-        dst[1] = (A * src[1] + B * src[2] + C * src[stride + 1] + D * src[stride + 2] + rounder) >> 8;
-        dst[2] = (A * src[2] + B * src[3] + C * src[stride + 2] + D * src[stride + 3] + rounder) >> 8;
-        dst[3] = (A * src[3] + B * src[4] + C * src[stride + 3] + D * src[stride + 4] + rounder) >> 8;
-        dst[4] = (A * src[4] + B * src[5] + C * src[stride + 4] + D * src[stride + 5] + rounder) >> 8;
-        dst[5] = (A * src[5] + B * src[6] + C * src[stride + 5] + D * src[stride + 6] + rounder) >> 8;
-        dst[6] = (A * src[6] + B * src[7] + C * src[stride + 6] + D * src[stride + 7] + rounder) >> 8;
-        dst[7] = (A * src[7] + B * src[8] + C * src[stride + 7] + D * src[stride + 8] + rounder) >> 8;
-        dst   += stride;
-        src   += stride;
-    }
-}
-
-void ff_gmc_c(uint8_t *dst, const uint8_t *src, int stride, int h, int ox, int oy,
-              int dxx, int dxy, int dyx, int dyy, int shift, int r,
-              int width, int height)
-{
-    int y, vx, vy;
-    const int s = 1 << shift;
-
-    width--;
-    height--;
-
-    for (y = 0; y < h; y++) {
-        int x;
-
-        vx = ox;
-        vy = oy;
-        for (x = 0; x < 8; x++) { // FIXME: optimize
-            int index;
-            int src_x  = vx >> 16;
-            int src_y  = vy >> 16;
-            int frac_x = src_x & (s - 1);
-            int frac_y = src_y & (s - 1);
-
-            src_x >>= shift;
-            src_y >>= shift;
-
-            if ((unsigned) src_x < width) {
-                if ((unsigned) src_y < height) {
-                    index = src_x + src_y * stride;
-                    dst[y * stride + x] =
-                        ((src[index]                        * (s - frac_x) +
-                          src[index + 1]          * frac_x) * (s - frac_y) +
-                         (src[index + stride]               * (s - frac_x) +
-                          src[index + stride + 1] * frac_x) *      frac_y  +
-                         r) >> (shift * 2);
-                } else {
-                    index = src_x + av_clip(src_y, 0, height) * stride;
-                    dst[y * stride + x] =
-                        ((src[index]               * (s - frac_x) +
-                          src[index + 1] * frac_x) *  s           +
-                         r) >> (shift * 2);
-                }
-            } else {
-                if ((unsigned) src_y < height) {
-                    index = av_clip(src_x, 0, width) + src_y * stride;
-                    dst[y * stride + x] =
-                        ((src[index]                    * (s - frac_y) +
-                          src[index + stride] * frac_y) *  s           +
-                         r) >> (shift * 2);
-                } else {
-                    index = av_clip(src_x, 0, width) +
-                            av_clip(src_y, 0, height) * stride;
-                    dst[y * stride + x] = src[index];
-                }
-            }
-
-            vx += dxx;
-            vy += dyx;
-        }
-        ox += dxy;
-        oy += dyy;
-    }
-}
-
-av_cold void ff_mpegvideodsp_init(MpegVideoDSPContext *c)
-{
-    c->gmc1 = gmc1_c;
-    c->gmc  = ff_gmc_c;
-
-#if ARCH_PPC
-    ff_mpegvideodsp_init_ppc(c);
-#elif ARCH_X86
-    ff_mpegvideodsp_init_x86(c);
-#endif
-}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/mpeg4videodsp.c
@@ -0,0 +1,120 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/common.h"
+#include "mpeg4videodsp.h"
+
+static void gmc1_c(uint8_t *dst, const uint8_t *src, int stride, int h,
+                   int x16, int y16, int rounder)
+{
+    const int A = (16 - x16) * (16 - y16);
+    const int B = (x16)      * (16 - y16);
+    const int C = (16 - x16) * (y16);
+    const int D = (x16)      * (y16);
+    int i;
+
+    for (i = 0; i < h; i++) {
+        dst[0] = (A * src[0] + B * src[1] + C * src[stride + 0] + D * src[stride + 1] + rounder) >> 8;
+        dst[1] = (A * src[1] + B * src[2] + C * src[stride + 1] + D * src[stride + 2] + rounder) >> 8;
+        dst[2] = (A * src[2] + B * src[3] + C * src[stride + 2] + D * src[stride + 3] + rounder) >> 8;
+        dst[3] = (A * src[3] + B * src[4] + C * src[stride + 3] + D * src[stride + 4] + rounder) >> 8;
+        dst[4] = (A * src[4] + B * src[5] + C * src[stride + 4] + D * src[stride + 5] + rounder) >> 8;
+        dst[5] = (A * src[5] + B * src[6] + C * src[stride + 5] + D * src[stride + 6] + rounder) >> 8;
+        dst[6] = (A * src[6] + B * src[7] + C * src[stride + 6] + D * src[stride + 7] + rounder) >> 8;
+        dst[7] = (A * src[7] + B * src[8] + C * src[stride + 7] + D * src[stride + 8] + rounder) >> 8;
+        dst   += stride;
+        src   += stride;
+    }
+}
+
+void ff_gmc_c(uint8_t *dst, const uint8_t *src, int stride, int h, int ox, int oy,
+              int dxx, int dxy, int dyx, int dyy, int shift, int r,
+              int width, int height)
+{
+    int y, vx, vy;
+    const int s = 1 << shift;
+
+    width--;
+    height--;
+
+    for (y = 0; y < h; y++) {
+        int x;
+
+        vx = ox;
+        vy = oy;
+        for (x = 0; x < 8; x++) { // FIXME: optimize
+            int index;
+            int src_x  = vx >> 16;
+            int src_y  = vy >> 16;
+            int frac_x = src_x & (s - 1);
+            int frac_y = src_y & (s - 1);
+
+            src_x >>= shift;
+            src_y >>= shift;
+
+            if ((unsigned) src_x < width) {
+                if ((unsigned) src_y < height) {
+                    index = src_x + src_y * stride;
+                    dst[y * stride + x] =
+                        ((src[index]                        * (s - frac_x) +
+                          src[index + 1]          * frac_x) * (s - frac_y) +
+                         (src[index + stride]               * (s - frac_x) +
+                          src[index + stride + 1] * frac_x) *      frac_y  +
+                         r) >> (shift * 2);
+                } else {
+                    index = src_x + av_clip(src_y, 0, height) * stride;
+                    dst[y * stride + x] =
+                        ((src[index]               * (s - frac_x) +
+                          src[index + 1] * frac_x) *  s           +
+                         r) >> (shift * 2);
+                }
+            } else {
+                if ((unsigned) src_y < height) {
+                    index = av_clip(src_x, 0, width) + src_y * stride;
+                    dst[y * stride + x] =
+                        ((src[index]                    * (s - frac_y) +
+                          src[index + stride] * frac_y) *  s           +
+                         r) >> (shift * 2);
+                } else {
+                    index = av_clip(src_x, 0, width) +
+                            av_clip(src_y, 0, height) * stride;
+                    dst[y * stride + x] = src[index];
+                }
+            }
+
+            vx += dxx;
+            vy += dyx;
+        }
+        ox += dxy;
+        oy += dyy;
+    }
+}
+
+av_cold void ff_mpeg4videodsp_init(Mpeg4VideoDSPContext *c)
+{
+    c->gmc1 = gmc1_c;
+    c->gmc  = ff_gmc_c;
+
+#if ARCH_PPC
+    ff_mpeg4videodsp_init_ppc(c);
+#elif ARCH_X86
+    ff_mpeg4videodsp_init_x86(c);
+#endif
+}
--- a/third_party/ffmpeg/libavcodec/mpegvideodsp.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_MPEGVIDEODSP_H
-#define AVCODEC_MPEGVIDEODSP_H
-
-#include <stdint.h>
-
-void ff_gmc_c(uint8_t *dst, const uint8_t *src, int stride, int h, int ox, int oy,
-              int dxx, int dxy, int dyx, int dyy, int shift, int r,
-              int width, int height);
-
-typedef struct MpegVideoDSPContext {
-    /**
-     * translational global motion compensation.
-     */
-    void (*gmc1)(uint8_t *dst /* align 8 */, const uint8_t *src /* align 1 */,
-                 int srcStride, int h, int x16, int y16, int rounder);
-    /**
-     * global motion compensation.
-     */
-    void (*gmc)(uint8_t *dst /* align 8 */, const uint8_t *src /* align 1 */,
-                int stride, int h, int ox, int oy,
-                int dxx, int dxy, int dyx, int dyy,
-                int shift, int r, int width, int height);
-} MpegVideoDSPContext;
-
-void ff_mpegvideodsp_init(MpegVideoDSPContext *c);
-void ff_mpegvideodsp_init_ppc(MpegVideoDSPContext *c);
-void ff_mpegvideodsp_init_x86(MpegVideoDSPContext *c);
-
-#endif /* AVCODEC_MPEGVIDEODSP_H */
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/mpeg4videodsp.h
@@ -0,0 +1,47 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_MPEG4VIDEODSP_H
+#define AVCODEC_MPEG4VIDEODSP_H
+
+#include <stdint.h>
+
+void ff_gmc_c(uint8_t *dst, const uint8_t *src, int stride, int h, int ox, int oy,
+              int dxx, int dxy, int dyx, int dyy, int shift, int r,
+              int width, int height);
+
+typedef struct Mpeg4VideoDSPContext {
+    /**
+     * translational global motion compensation.
+     */
+    void (*gmc1)(uint8_t *dst /* align 8 */, const uint8_t *src /* align 1 */,
+                 int srcStride, int h, int x16, int y16, int rounder);
+    /**
+     * global motion compensation.
+     */
+    void (*gmc)(uint8_t *dst /* align 8 */, const uint8_t *src /* align 1 */,
+                int stride, int h, int ox, int oy,
+                int dxx, int dxy, int dyx, int dyy,
+                int shift, int r, int width, int height);
+} Mpeg4VideoDSPContext;
+
+void ff_mpeg4videodsp_init(Mpeg4VideoDSPContext *c);
+void ff_mpeg4videodsp_init_ppc(Mpeg4VideoDSPContext *c);
+void ff_mpeg4videodsp_init_x86(Mpeg4VideoDSPContext *c);
+
+#endif /* AVCODEC_MPEG4VIDEODSP_H */
--- a/third_party/ffmpeg/libavcodec/mpeg4videoenc.c
+++ b/third_party/ffmpeg/libavcodec/mpeg4videoenc.c
@@ -175,7 +175,7 @@
                     ac_val1[i + 8] = level;
                 }
             }
-            st[n] = s->intra_h_scantable.permutated;
+            st[n] = s->permutated_intra_h_scantable;
         } else {
             const int xy = s->mb_x - 1 + s->mb_y * s->mb_stride;
             /* left prediction */
@@ -197,7 +197,7 @@
                     ac_val1[i + 8] = block[n][s->idsp.idct_permutation[i]];
                 }
             }
-            st[n] = s->intra_v_scantable.permutated;
+            st[n] = s->permutated_intra_v_scantable;
         }
 
         for (i = 63; i > 0; i--)  // FIXME optimize
--- a/third_party/ffmpeg/libavcodec/mpeg_er.c
+++ b/third_party/ffmpeg/libavcodec/mpeg_er.c
@@ -18,6 +18,7 @@
 
 #include "error_resilience.h"
 #include "mpegvideo.h"
+#include "mpegvideodec.h"
 #include "mpeg_er.h"
 
 static void set_erpic(ERPicture *dst, Picture *src)
--- a/third_party/ffmpeg/libavcodec/mpegaudiodec_common.c
+++ b/third_party/ffmpeg/libavcodec/mpegaudiodec_common.c
@@ -369,7 +369,7 @@
 { 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
   20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54, }, /* 22050 */
 { 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
-  18, 22, 26, 32, 38, 46, 52, 64, 70, 76, 36, }, /* 24000 */
+  18, 22, 26, 32, 38, 46, 54, 62, 70, 76, 36, }, /* 24000 */
 { 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
   20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54, }, /* 16000 */
 { 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
--- a/third_party/ffmpeg/libavcodec/mpegaudioenc_fixed.c
+++ b/third_party/ffmpeg/libavcodec/mpegaudioenc_fixed.c
@@ -37,11 +37,7 @@
     .p.supported_samplerates = (const int[]){
         44100, 48000,  32000, 22050, 24000, 16000, 0
     },
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]){ AV_CH_LAYOUT_MONO,
-                                                 AV_CH_LAYOUT_STEREO,
-                                                 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]){ AV_CHANNEL_LAYOUT_MONO,
                                                         AV_CHANNEL_LAYOUT_STEREO,
                                                         { 0 } },
--- a/third_party/ffmpeg/libavcodec/mpegaudioenc_float.c
+++ b/third_party/ffmpeg/libavcodec/mpegaudioenc_float.c
@@ -38,11 +38,7 @@
     .p.supported_samplerates = (const int[]){
         44100, 48000,  32000, 22050, 24000, 16000, 0
     },
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]){ AV_CH_LAYOUT_MONO,
-                                                 AV_CH_LAYOUT_STEREO,
-                                                 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]){ AV_CHANNEL_LAYOUT_MONO,
                                                         AV_CHANNEL_LAYOUT_STEREO,
                                                         { 0 } },
--- a/third_party/ffmpeg/libavcodec/mpegutils.c
+++ b/third_party/ffmpeg/libavcodec/mpegutils.c
@@ -53,9 +53,13 @@
                         int y, int h, int picture_structure,
                         int first_field, int low_delay)
 {
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
-    int vshift = desc->log2_chroma_h;
     const int field_pic = picture_structure != PICT_FRAME;
+    const AVFrame *src;
+    int offset[AV_NUM_DATA_POINTERS];
+
+    if (!avctx->draw_horiz_band)
+        return;
+
     if (field_pic) {
         h <<= 1;
         y <<= 1;
@@ -67,37 +71,34 @@
         !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD))
         return;
 
-    if (avctx->draw_horiz_band) {
-        const AVFrame *src;
-        int offset[AV_NUM_DATA_POINTERS];
-        int i;
-
-        if (cur->pict_type == AV_PICTURE_TYPE_B || low_delay ||
-           (avctx->slice_flags & SLICE_FLAG_CODED_ORDER))
-            src = cur;
-        else if (last)
-            src = last;
-        else
-            return;
-
-        if (cur->pict_type == AV_PICTURE_TYPE_B &&
-            picture_structure == PICT_FRAME &&
-            avctx->codec_id != AV_CODEC_ID_SVQ3) {
-            for (i = 0; i < AV_NUM_DATA_POINTERS; i++)
-                offset[i] = 0;
-        } else {
-            offset[0]= y * src->linesize[0];
-            offset[1]=
-            offset[2]= (y >> vshift) * src->linesize[1];
-            for (i = 3; i < AV_NUM_DATA_POINTERS; i++)
-                offset[i] = 0;
-        }
-
-        emms_c();
+    if (cur->pict_type == AV_PICTURE_TYPE_B || low_delay ||
+        (avctx->slice_flags & SLICE_FLAG_CODED_ORDER))
+        src = cur;
+    else if (last)
+        src = last;
+    else
+        return;
 
-        avctx->draw_horiz_band(avctx, src, offset,
-                               y, picture_structure, h);
+    if (cur->pict_type == AV_PICTURE_TYPE_B &&
+        picture_structure == PICT_FRAME &&
+        avctx->codec_id != AV_CODEC_ID_SVQ3) {
+        for (int i = 0; i < AV_NUM_DATA_POINTERS; i++)
+            offset[i] = 0;
+    } else {
+        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
+        int vshift = desc->log2_chroma_h;
+
+        offset[0] = y * src->linesize[0];
+        offset[1] =
+        offset[2] = (y >> vshift) * src->linesize[1];
+        for (int i = 3; i < AV_NUM_DATA_POINTERS; i++)
+            offset[i] = 0;
     }
+
+    emms_c();
+
+    avctx->draw_horiz_band(avctx, src, offset,
+                            y, picture_structure, h);
 }
 
 static char get_type_mv_char(int mb_type)
--- a/third_party/ffmpeg/libavcodec/mpegvideo.c
+++ b/third_party/ffmpeg/libavcodec/mpegvideo.c
@@ -27,8 +27,6 @@
  * The simplest mpeg encoder (well, it was the simplest!).
  */
 
-#include "config_components.h"
-
 #include "libavutil/attributes.h"
 #include "libavutil/avassert.h"
 #include "libavutil/imgutils.h"
@@ -36,18 +34,12 @@
 
 #include "avcodec.h"
 #include "blockdsp.h"
-#include "h264chroma.h"
 #include "idctdsp.h"
 #include "mathops.h"
 #include "mpeg_er.h"
 #include "mpegutils.h"
 #include "mpegvideo.h"
-#include "mpeg4videodec.h"
 #include "mpegvideodata.h"
-#include "qpeldsp.h"
-#include "threadframe.h"
-#include "wmv2dec.h"
-#include <limits.h>
 
 static void dct_unquantize_mpeg1_intra_c(MpegEncContext *s,
                                    int16_t *block, int n, int qscale)
@@ -282,9 +274,7 @@
 static av_cold int dct_init(MpegEncContext *s)
 {
     ff_blockdsp_init(&s->bdsp);
-    ff_h264chroma_init(&s->h264chroma, 8); //for lowres
     ff_hpeldsp_init(&s->hdsp, s->avctx->flags);
-    ff_mpegvideodsp_init(&s->mdsp);
     ff_videodsp_init(&s->vdsp, s->avctx->bits_per_raw_sample);
 
     if (s->avctx->debug & FF_DEBUG_NOMC) {
@@ -328,6 +318,27 @@
     return 0;
 }
 
+av_cold void ff_init_scantable(const uint8_t *permutation, ScanTable *st,
+                               const uint8_t *src_scantable)
+{
+    int end;
+
+    st->scantable = src_scantable;
+
+    for (int i = 0; i < 64; i++) {
+        int j = src_scantable[i];
+        st->permutated[i] = permutation[j];
+    }
+
+    end = -1;
+    for (int i = 0; i < 64; i++) {
+        int j = st->permutated[i];
+        if (j > end)
+            end = j;
+        st->raster_end[i] = end;
+    }
+}
+
 av_cold void ff_mpv_idct_init(MpegEncContext *s)
 {
     if (s->codec_id == AV_CODEC_ID_MPEG4)
@@ -344,8 +355,10 @@
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);
     }
-    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
-    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
+    ff_permute_scantable(s->permutated_intra_h_scantable, ff_alternate_horizontal_scan,
+                         s->idsp.idct_permutation);
+    ff_permute_scantable(s->permutated_intra_v_scantable, ff_alternate_vertical_scan,
+                         s->idsp.idct_permutation);
 }
 
 static int init_duplicate_context(MpegEncContext *s)
@@ -811,456 +824,6 @@
 }
 
 
-static inline int hpel_motion_lowres(MpegEncContext *s,
-                                     uint8_t *dest, const uint8_t *src,
-                                     int field_based, int field_select,
-                                     int src_x, int src_y,
-                                     int width, int height, ptrdiff_t stride,
-                                     int h_edge_pos, int v_edge_pos,
-                                     int w, int h, const h264_chroma_mc_func *pix_op,
-                                     int motion_x, int motion_y)
-{
-    const int lowres   = s->avctx->lowres;
-    const int op_index = FFMIN(lowres, 3);
-    const int s_mask   = (2 << lowres) - 1;
-    int emu = 0;
-    int sx, sy;
-
-    if (s->quarter_sample) {
-        motion_x /= 2;
-        motion_y /= 2;
-    }
-
-    sx = motion_x & s_mask;
-    sy = motion_y & s_mask;
-    src_x += motion_x >> lowres + 1;
-    src_y += motion_y >> lowres + 1;
-
-    src   += src_y * stride + src_x;
-
-    if ((unsigned)src_x > FFMAX( h_edge_pos - (!!sx) - w,                 0) ||
-        (unsigned)src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {
-        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
-                                 s->linesize, s->linesize,
-                                 w + 1, (h + 1) << field_based,
-                                 src_x, src_y   << field_based,
-                                 h_edge_pos, v_edge_pos);
-        src = s->sc.edge_emu_buffer;
-        emu = 1;
-    }
-
-    sx = (sx << 2) >> lowres;
-    sy = (sy << 2) >> lowres;
-    if (field_select)
-        src += s->linesize;
-    pix_op[op_index](dest, src, stride, h, sx, sy);
-    return emu;
-}
-
-/* apply one mpeg motion vector to the three components */
-static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,
-                                                uint8_t *dest_y,
-                                                uint8_t *dest_cb,
-                                                uint8_t *dest_cr,
-                                                int field_based,
-                                                int bottom_field,
-                                                int field_select,
-                                                uint8_t *const *ref_picture,
-                                                const h264_chroma_mc_func *pix_op,
-                                                int motion_x, int motion_y,
-                                                int h, int mb_y)
-{
-    const uint8_t *ptr_y, *ptr_cb, *ptr_cr;
-    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, sx, sy, uvsx, uvsy;
-    ptrdiff_t uvlinesize, linesize;
-    const int lowres     = s->avctx->lowres;
-    const int op_index   = FFMIN(lowres-1+s->chroma_x_shift, 3);
-    const int block_s    = 8>>lowres;
-    const int s_mask     = (2 << lowres) - 1;
-    const int h_edge_pos = s->h_edge_pos >> lowres;
-    const int v_edge_pos = s->v_edge_pos >> lowres;
-    linesize   = s->current_picture.f->linesize[0] << field_based;
-    uvlinesize = s->current_picture.f->linesize[1] << field_based;
-
-    // FIXME obviously not perfect but qpel will not work in lowres anyway
-    if (s->quarter_sample) {
-        motion_x /= 2;
-        motion_y /= 2;
-    }
-
-    if(field_based){
-        motion_y += (bottom_field - field_select)*((1 << lowres)-1);
-    }
-
-    sx = motion_x & s_mask;
-    sy = motion_y & s_mask;
-    src_x = s->mb_x * 2 * block_s + (motion_x >> lowres + 1);
-    src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);
-
-    if (s->out_format == FMT_H263) {
-        uvsx    = ((motion_x >> 1) & s_mask) | (sx & 1);
-        uvsy    = ((motion_y >> 1) & s_mask) | (sy & 1);
-        uvsrc_x = src_x >> 1;
-        uvsrc_y = src_y >> 1;
-    } else if (s->out_format == FMT_H261) {
-        // even chroma mv's are full pel in H261
-        mx      = motion_x / 4;
-        my      = motion_y / 4;
-        uvsx    = (2 * mx) & s_mask;
-        uvsy    = (2 * my) & s_mask;
-        uvsrc_x = s->mb_x * block_s + (mx >> lowres);
-        uvsrc_y =    mb_y * block_s + (my >> lowres);
-    } else {
-        if(s->chroma_y_shift){
-            mx      = motion_x / 2;
-            my      = motion_y / 2;
-            uvsx    = mx & s_mask;
-            uvsy    = my & s_mask;
-            uvsrc_x = s->mb_x * block_s                 + (mx >> lowres + 1);
-            uvsrc_y =   (mb_y * block_s >> field_based) + (my >> lowres + 1);
-        } else {
-            if(s->chroma_x_shift){
-            //Chroma422
-                mx = motion_x / 2;
-                uvsx = mx & s_mask;
-                uvsy = motion_y & s_mask;
-                uvsrc_y = src_y;
-                uvsrc_x = s->mb_x*block_s               + (mx >> (lowres+1));
-            } else {
-            //Chroma444
-                uvsx = motion_x & s_mask;
-                uvsy = motion_y & s_mask;
-                uvsrc_x = src_x;
-                uvsrc_y = src_y;
-            }
-        }
-    }
-
-    ptr_y  = ref_picture[0] + src_y   * linesize   + src_x;
-    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;
-    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;
-
-    if ((unsigned) src_x > FFMAX( h_edge_pos - (!!sx) - 2 * block_s,       0) || uvsrc_y<0 ||
-        (unsigned) src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {
-        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_y,
-                                 linesize >> field_based, linesize >> field_based,
-                                 17, 17 + field_based,
-                                src_x, src_y << field_based, h_edge_pos,
-                                v_edge_pos);
-        ptr_y = s->sc.edge_emu_buffer;
-        if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
-            uint8_t *ubuf = s->sc.edge_emu_buffer + 18 * s->linesize;
-            uint8_t *vbuf =ubuf + 10 * s->uvlinesize;
-            if (s->workaround_bugs & FF_BUG_IEDGE)
-                vbuf -= s->uvlinesize;
-            s->vdsp.emulated_edge_mc(ubuf,  ptr_cb,
-                                     uvlinesize >> field_based, uvlinesize >> field_based,
-                                     9, 9 + field_based,
-                                    uvsrc_x, uvsrc_y << field_based,
-                                    h_edge_pos >> 1, v_edge_pos >> 1);
-            s->vdsp.emulated_edge_mc(vbuf,  ptr_cr,
-                                     uvlinesize >> field_based,uvlinesize >> field_based,
-                                     9, 9 + field_based,
-                                    uvsrc_x, uvsrc_y << field_based,
-                                    h_edge_pos >> 1, v_edge_pos >> 1);
-            ptr_cb = ubuf;
-            ptr_cr = vbuf;
-        }
-    }
-
-    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f->data
-    if (bottom_field) {
-        dest_y  += s->linesize;
-        dest_cb += s->uvlinesize;
-        dest_cr += s->uvlinesize;
-    }
-
-    if (field_select) {
-        ptr_y   += s->linesize;
-        ptr_cb  += s->uvlinesize;
-        ptr_cr  += s->uvlinesize;
-    }
-
-    sx = (sx << 2) >> lowres;
-    sy = (sy << 2) >> lowres;
-    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);
-
-    if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
-        int hc = s->chroma_y_shift ? (h+1-bottom_field)>>1 : h;
-        uvsx = (uvsx << 2) >> lowres;
-        uvsy = (uvsy << 2) >> lowres;
-        if (hc) {
-            pix_op[op_index](dest_cb, ptr_cb, uvlinesize, hc, uvsx, uvsy);
-            pix_op[op_index](dest_cr, ptr_cr, uvlinesize, hc, uvsx, uvsy);
-        }
-    }
-    // FIXME h261 lowres loop filter
-}
-
-static inline void chroma_4mv_motion_lowres(MpegEncContext *s,
-                                            uint8_t *dest_cb, uint8_t *dest_cr,
-                                            uint8_t *const *ref_picture,
-                                            const h264_chroma_mc_func * pix_op,
-                                            int mx, int my)
-{
-    const int lowres     = s->avctx->lowres;
-    const int op_index   = FFMIN(lowres, 3);
-    const int block_s    = 8 >> lowres;
-    const int s_mask     = (2 << lowres) - 1;
-    const int h_edge_pos = s->h_edge_pos >> lowres + 1;
-    const int v_edge_pos = s->v_edge_pos >> lowres + 1;
-    int emu = 0, src_x, src_y, sx, sy;
-    ptrdiff_t offset;
-    const uint8_t *ptr;
-
-    if (s->quarter_sample) {
-        mx /= 2;
-        my /= 2;
-    }
-
-    /* In case of 8X8, we construct a single chroma motion vector
-       with a special rounding */
-    mx = ff_h263_round_chroma(mx);
-    my = ff_h263_round_chroma(my);
-
-    sx = mx & s_mask;
-    sy = my & s_mask;
-    src_x = s->mb_x * block_s + (mx >> lowres + 1);
-    src_y = s->mb_y * block_s + (my >> lowres + 1);
-
-    offset = src_y * s->uvlinesize + src_x;
-    ptr = ref_picture[1] + offset;
-    if ((unsigned) src_x > FFMAX(h_edge_pos - (!!sx) - block_s, 0) ||
-        (unsigned) src_y > FFMAX(v_edge_pos - (!!sy) - block_s, 0)) {
-        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
-                                 s->uvlinesize, s->uvlinesize,
-                                 9, 9,
-                                 src_x, src_y, h_edge_pos, v_edge_pos);
-        ptr = s->sc.edge_emu_buffer;
-        emu = 1;
-    }
-    sx = (sx << 2) >> lowres;
-    sy = (sy << 2) >> lowres;
-    pix_op[op_index](dest_cb, ptr, s->uvlinesize, block_s, sx, sy);
-
-    ptr = ref_picture[2] + offset;
-    if (emu) {
-        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
-                                 s->uvlinesize, s->uvlinesize,
-                                 9, 9,
-                                 src_x, src_y, h_edge_pos, v_edge_pos);
-        ptr = s->sc.edge_emu_buffer;
-    }
-    pix_op[op_index](dest_cr, ptr, s->uvlinesize, block_s, sx, sy);
-}
-
-/**
- * motion compensation of a single macroblock
- * @param s context
- * @param dest_y luma destination pointer
- * @param dest_cb chroma cb/u destination pointer
- * @param dest_cr chroma cr/v destination pointer
- * @param dir direction (0->forward, 1->backward)
- * @param ref_picture array[3] of pointers to the 3 planes of the reference picture
- * @param pix_op halfpel motion compensation function (average or put normally)
- * the motion vectors are taken from s->mv and the MV type from s->mv_type
- */
-static inline void MPV_motion_lowres(MpegEncContext *s,
-                                     uint8_t *dest_y, uint8_t *dest_cb,
-                                     uint8_t *dest_cr,
-                                     int dir, uint8_t *const *ref_picture,
-                                     const h264_chroma_mc_func *pix_op)
-{
-    int mx, my;
-    int mb_x, mb_y, i;
-    const int lowres  = s->avctx->lowres;
-    const int block_s = 8 >>lowres;
-
-    mb_x = s->mb_x;
-    mb_y = s->mb_y;
-
-    switch (s->mv_type) {
-    case MV_TYPE_16X16:
-        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
-                           0, 0, 0,
-                           ref_picture, pix_op,
-                           s->mv[dir][0][0], s->mv[dir][0][1],
-                           2 * block_s, mb_y);
-        break;
-    case MV_TYPE_8X8:
-        mx = 0;
-        my = 0;
-        for (i = 0; i < 4; i++) {
-            hpel_motion_lowres(s, dest_y + ((i & 1) + (i >> 1) *
-                               s->linesize) * block_s,
-                               ref_picture[0], 0, 0,
-                               (2 * mb_x + (i & 1)) * block_s,
-                               (2 * mb_y + (i >> 1)) * block_s,
-                               s->width, s->height, s->linesize,
-                               s->h_edge_pos >> lowres, s->v_edge_pos >> lowres,
-                               block_s, block_s, pix_op,
-                               s->mv[dir][i][0], s->mv[dir][i][1]);
-
-            mx += s->mv[dir][i][0];
-            my += s->mv[dir][i][1];
-        }
-
-        if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY))
-            chroma_4mv_motion_lowres(s, dest_cb, dest_cr, ref_picture,
-                                     pix_op, mx, my);
-        break;
-    case MV_TYPE_FIELD:
-        if (s->picture_structure == PICT_FRAME) {
-            /* top field */
-            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
-                               1, 0, s->field_select[dir][0],
-                               ref_picture, pix_op,
-                               s->mv[dir][0][0], s->mv[dir][0][1],
-                               block_s, mb_y);
-            /* bottom field */
-            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
-                               1, 1, s->field_select[dir][1],
-                               ref_picture, pix_op,
-                               s->mv[dir][1][0], s->mv[dir][1][1],
-                               block_s, mb_y);
-        } else {
-            if (s->picture_structure != s->field_select[dir][0] + 1 &&
-                s->pict_type != AV_PICTURE_TYPE_B && !s->first_field) {
-                ref_picture = s->current_picture_ptr->f->data;
-
-            }
-            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
-                               0, 0, s->field_select[dir][0],
-                               ref_picture, pix_op,
-                               s->mv[dir][0][0],
-                               s->mv[dir][0][1], 2 * block_s, mb_y >> 1);
-            }
-        break;
-    case MV_TYPE_16X8:
-        for (i = 0; i < 2; i++) {
-            uint8_t *const *ref2picture;
-
-            if (s->picture_structure == s->field_select[dir][i] + 1 ||
-                s->pict_type == AV_PICTURE_TYPE_B || s->first_field) {
-                ref2picture = ref_picture;
-            } else {
-                ref2picture = s->current_picture_ptr->f->data;
-            }
-
-            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
-                               0, 0, s->field_select[dir][i],
-                               ref2picture, pix_op,
-                               s->mv[dir][i][0], s->mv[dir][i][1] +
-                               2 * block_s * i, block_s, mb_y >> 1);
-
-            dest_y  +=  2 * block_s *  s->linesize;
-            dest_cb += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;
-            dest_cr += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;
-        }
-        break;
-    case MV_TYPE_DMV:
-        if (s->picture_structure == PICT_FRAME) {
-            for (i = 0; i < 2; i++) {
-                int j;
-                for (j = 0; j < 2; j++) {
-                    mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
-                                       1, j, j ^ i,
-                                       ref_picture, pix_op,
-                                       s->mv[dir][2 * i + j][0],
-                                       s->mv[dir][2 * i + j][1],
-                                       block_s, mb_y);
-                }
-                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;
-            }
-        } else {
-            for (i = 0; i < 2; i++) {
-                mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
-                                   0, 0, s->picture_structure != i + 1,
-                                   ref_picture, pix_op,
-                                   s->mv[dir][2 * i][0],s->mv[dir][2 * i][1],
-                                   2 * block_s, mb_y >> 1);
-
-                // after put we make avg of the same block
-                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;
-
-                // opposite parity is always in the same
-                // frame if this is second field
-                if (!s->first_field) {
-                    ref_picture = s->current_picture_ptr->f->data;
-                }
-            }
-        }
-        break;
-    default:
-        av_assert2(0);
-    }
-}
-
-/**
- * find the lowest MB row referenced in the MVs
- */
-static int lowest_referenced_row(MpegEncContext *s, int dir)
-{
-    int my_max = INT_MIN, my_min = INT_MAX, qpel_shift = !s->quarter_sample;
-    int my, off, i, mvs;
-
-    if (s->picture_structure != PICT_FRAME || s->mcsel)
-        goto unhandled;
-
-    switch (s->mv_type) {
-        case MV_TYPE_16X16:
-            mvs = 1;
-            break;
-        case MV_TYPE_16X8:
-            mvs = 2;
-            break;
-        case MV_TYPE_8X8:
-            mvs = 4;
-            break;
-        default:
-            goto unhandled;
-    }
-
-    for (i = 0; i < mvs; i++) {
-        my = s->mv[dir][i][1];
-        my_max = FFMAX(my_max, my);
-        my_min = FFMIN(my_min, my);
-    }
-
-    off = ((FFMAX(-my_min, my_max)<<qpel_shift) + 63) >> 6;
-
-    return av_clip(s->mb_y + off, 0, s->mb_height - 1);
-unhandled:
-    return s->mb_height-1;
-}
-
-/* put block[] to dest[] */
-static inline void put_dct(MpegEncContext *s,
-                           int16_t *block, int i, uint8_t *dest, int line_size, int qscale)
-{
-    s->dct_unquantize_intra(s, block, i, qscale);
-    s->idsp.idct_put(dest, line_size, block);
-}
-
-/* add block[] to dest[] */
-static inline void add_dct(MpegEncContext *s,
-                           int16_t *block, int i, uint8_t *dest, int line_size)
-{
-    if (s->block_last_index[i] >= 0) {
-        s->idsp.idct_add(dest, line_size, block);
-    }
-}
-
-static inline void add_dequant_dct(MpegEncContext *s,
-                           int16_t *block, int i, uint8_t *dest, int line_size, int qscale)
-{
-    if (s->block_last_index[i] >= 0) {
-        s->dct_unquantize_inter(s, block, i, qscale);
-
-        s->idsp.idct_add(dest, line_size, block);
-    }
-}
-
 /**
  * Clean dc, ac, coded_block for the current non-intra MB.
  */
@@ -1294,278 +857,6 @@
     s->mbintra_table[xy]= 0;
 }
 
-/* generic function called after a macroblock has been parsed by the
-   decoder or after it has been encoded by the encoder.
-
-   Important variables used:
-   s->mb_intra : true if intra macroblock
-   s->mv_dir   : motion vector direction
-   s->mv_type  : motion vector type
-   s->mv       : motion vector
-   s->interlaced_dct : true if interlaced dct used (mpeg2)
- */
-static av_always_inline
-void mpv_reconstruct_mb_internal(MpegEncContext *s, int16_t block[12][64],
-                            int lowres_flag, int is_mpeg12)
-{
-#define IS_ENCODER(s) (CONFIG_MPEGVIDEOENC && !lowres_flag && (s)->encoding)
-#define IS_MPEG12(s) (CONFIG_SMALL ? ((s)->out_format == FMT_MPEG1) : is_mpeg12)
-    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;
-
-    s->current_picture.qscale_table[mb_xy] = s->qscale;
-
-    /* update DC predictors for P macroblocks */
-    if (!s->mb_intra) {
-        if (!is_mpeg12 && (s->h263_pred || s->h263_aic)) {
-            if(s->mbintra_table[mb_xy])
-                ff_clean_intra_table_entries(s);
-        } else {
-            s->last_dc[0] =
-            s->last_dc[1] =
-            s->last_dc[2] = 128 << s->intra_dc_precision;
-        }
-    }
-    else if (!is_mpeg12 && (s->h263_pred || s->h263_aic))
-        s->mbintra_table[mb_xy]=1;
-
-    if (!IS_ENCODER(s) || (s->avctx->flags & AV_CODEC_FLAG_PSNR) || s->frame_skip_threshold || s->frame_skip_factor ||
-        !((s->intra_only || s->pict_type == AV_PICTURE_TYPE_B) &&
-          s->avctx->mb_decision != FF_MB_DECISION_RD)) { // FIXME precalc
-        uint8_t *dest_y, *dest_cb, *dest_cr;
-        int dct_linesize, dct_offset;
-        op_pixels_func (*op_pix)[4];
-        qpel_mc_func (*op_qpix)[16];
-        const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics
-        const int uvlinesize = s->current_picture.f->linesize[1];
-        const int readable = s->pict_type != AV_PICTURE_TYPE_B || IS_ENCODER(s) || s->avctx->draw_horiz_band || lowres_flag;
-        const int block_size= lowres_flag ? 8>>s->avctx->lowres : 8;
-
-        /* avoid copy if macroblock skipped in last frame too */
-        /* skip only during decoding as we might trash the buffers during encoding a bit */
-        if (!IS_ENCODER(s)) {
-            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];
-
-            if (s->mb_skipped) {
-                s->mb_skipped= 0;
-                av_assert2(s->pict_type!=AV_PICTURE_TYPE_I);
-                *mbskip_ptr = 1;
-            } else if(!s->current_picture.reference) {
-                *mbskip_ptr = 1;
-            } else{
-                *mbskip_ptr = 0; /* not skipped */
-            }
-        }
-
-        dct_linesize = linesize << s->interlaced_dct;
-        dct_offset   = s->interlaced_dct ? linesize : linesize * block_size;
-
-        if(readable){
-            dest_y=  s->dest[0];
-            dest_cb= s->dest[1];
-            dest_cr= s->dest[2];
-        }else{
-            dest_y = s->sc.b_scratchpad;
-            dest_cb= s->sc.b_scratchpad+16*linesize;
-            dest_cr= s->sc.b_scratchpad+32*linesize;
-        }
-
-        if (!s->mb_intra) {
-            /* motion handling */
-            /* decoding or more than one mb_type (MC was already done otherwise) */
-            if (!IS_ENCODER(s)) {
-
-                if(HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_FRAME) {
-                    if (s->mv_dir & MV_DIR_FORWARD) {
-                        ff_thread_await_progress(&s->last_picture_ptr->tf,
-                                                 lowest_referenced_row(s, 0),
-                                                 0);
-                    }
-                    if (s->mv_dir & MV_DIR_BACKWARD) {
-                        ff_thread_await_progress(&s->next_picture_ptr->tf,
-                                                 lowest_referenced_row(s, 1),
-                                                 0);
-                    }
-                }
-
-                if(lowres_flag){
-                    const h264_chroma_mc_func *op_pix = s->h264chroma.put_h264_chroma_pixels_tab;
-
-                    if (s->mv_dir & MV_DIR_FORWARD) {
-                        MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix);
-                        op_pix = s->h264chroma.avg_h264_chroma_pixels_tab;
-                    }
-                    if (s->mv_dir & MV_DIR_BACKWARD) {
-                        MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix);
-                    }
-                }else{
-                    op_qpix = s->me.qpel_put;
-                    if ((is_mpeg12 || !s->no_rounding) || s->pict_type == AV_PICTURE_TYPE_B) {
-                        op_pix = s->hdsp.put_pixels_tab;
-                    }else{
-                        op_pix = s->hdsp.put_no_rnd_pixels_tab;
-                    }
-                    if (s->mv_dir & MV_DIR_FORWARD) {
-                        ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix, op_qpix);
-                        op_pix = s->hdsp.avg_pixels_tab;
-                        op_qpix= s->me.qpel_avg;
-                    }
-                    if (s->mv_dir & MV_DIR_BACKWARD) {
-                        ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix, op_qpix);
-                    }
-                }
-            }
-
-            /* skip dequant / idct if we are really late ;) */
-            if(s->avctx->skip_idct){
-                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)
-                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)
-                   || s->avctx->skip_idct >= AVDISCARD_ALL)
-                    goto skip_idct;
-            }
-
-            /* add dct residue */
-            if (IS_ENCODER(s) || !(IS_MPEG12(s) || s->msmpeg4_version
-                                || (s->codec_id==AV_CODEC_ID_MPEG4 && !s->mpeg_quant))){
-                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);
-                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);
-                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);
-                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);
-
-                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
-                    if (s->chroma_y_shift){
-                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);
-                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);
-                    }else{
-                        dct_linesize >>= 1;
-                        dct_offset >>=1;
-                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);
-                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);
-                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);
-                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);
-                    }
-                }
-            } else if(is_mpeg12 || (s->codec_id != AV_CODEC_ID_WMV2)){
-                add_dct(s, block[0], 0, dest_y                          , dct_linesize);
-                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);
-                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);
-                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);
-
-                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
-                    if(s->chroma_y_shift){//Chroma420
-                        add_dct(s, block[4], 4, dest_cb, uvlinesize);
-                        add_dct(s, block[5], 5, dest_cr, uvlinesize);
-                    }else{
-                        //chroma422
-                        dct_linesize = uvlinesize << s->interlaced_dct;
-                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;
-
-                        add_dct(s, block[4], 4, dest_cb, dct_linesize);
-                        add_dct(s, block[5], 5, dest_cr, dct_linesize);
-                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);
-                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);
-                        if(!s->chroma_x_shift){//Chroma444
-                            add_dct(s, block[8], 8, dest_cb+block_size, dct_linesize);
-                            add_dct(s, block[9], 9, dest_cr+block_size, dct_linesize);
-                            add_dct(s, block[10], 10, dest_cb+block_size+dct_offset, dct_linesize);
-                            add_dct(s, block[11], 11, dest_cr+block_size+dct_offset, dct_linesize);
-                        }
-                    }
-                }//fi gray
-            } else if (CONFIG_WMV2_DECODER) {
-                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);
-            }
-        } else {
-            /* Only MPEG-4 Simple Studio Profile is supported in > 8-bit mode.
-               TODO: Integrate 10-bit properly into mpegvideo.c so that ER works properly */
-            if (!is_mpeg12 && CONFIG_MPEG4_DECODER && /* s->codec_id == AV_CODEC_ID_MPEG4 && */
-                s->avctx->bits_per_raw_sample > 8) {
-                ff_mpeg4_decode_studio(s, dest_y, dest_cb, dest_cr, block_size,
-                                       uvlinesize, dct_linesize, dct_offset);
-            }
-            /* dct only in intra block */
-            else if (IS_ENCODER(s) || !IS_MPEG12(s)) {
-                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);
-                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);
-                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);
-                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);
-
-                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
-                    if(s->chroma_y_shift){
-                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);
-                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);
-                    }else{
-                        dct_offset >>=1;
-                        dct_linesize >>=1;
-                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);
-                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);
-                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);
-                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);
-                    }
-                }
-            }else{
-                s->idsp.idct_put(dest_y,                           dct_linesize, block[0]);
-                s->idsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);
-                s->idsp.idct_put(dest_y + dct_offset,              dct_linesize, block[2]);
-                s->idsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);
-
-                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
-                    if(s->chroma_y_shift){
-                        s->idsp.idct_put(dest_cb, uvlinesize, block[4]);
-                        s->idsp.idct_put(dest_cr, uvlinesize, block[5]);
-                    }else{
-
-                        dct_linesize = uvlinesize << s->interlaced_dct;
-                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;
-
-                        s->idsp.idct_put(dest_cb,              dct_linesize, block[4]);
-                        s->idsp.idct_put(dest_cr,              dct_linesize, block[5]);
-                        s->idsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);
-                        s->idsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);
-                        if(!s->chroma_x_shift){//Chroma444
-                            s->idsp.idct_put(dest_cb + block_size,              dct_linesize, block[8]);
-                            s->idsp.idct_put(dest_cr + block_size,              dct_linesize, block[9]);
-                            s->idsp.idct_put(dest_cb + block_size + dct_offset, dct_linesize, block[10]);
-                            s->idsp.idct_put(dest_cr + block_size + dct_offset, dct_linesize, block[11]);
-                        }
-                    }
-                }//gray
-            }
-        }
-skip_idct:
-        if(!readable){
-            s->hdsp.put_pixels_tab[0][0](s->dest[0], dest_y ,   linesize,16);
-            if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
-                s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize,16 >> s->chroma_y_shift);
-                s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize,16 >> s->chroma_y_shift);
-            }
-        }
-    }
-}
-
-void ff_mpv_reconstruct_mb(MpegEncContext *s, int16_t block[12][64])
-{
-    if (s->avctx->debug & FF_DEBUG_DCT_COEFF) {
-       /* print DCT coefficients */
-       av_log(s->avctx, AV_LOG_DEBUG, "DCT coeffs of MB at %dx%d:\n", s->mb_x, s->mb_y);
-       for (int i = 0; i < 6; i++) {
-           for (int j = 0; j < 64; j++) {
-               av_log(s->avctx, AV_LOG_DEBUG, "%5d",
-                      block[i][s->idsp.idct_permutation[j]]);
-           }
-           av_log(s->avctx, AV_LOG_DEBUG, "\n");
-       }
-    }
-
-#if !CONFIG_SMALL
-    if(s->out_format == FMT_MPEG1) {
-        if(s->avctx->lowres) mpv_reconstruct_mb_internal(s, block, 1, 1);
-        else                 mpv_reconstruct_mb_internal(s, block, 0, 1);
-    } else
-#endif
-    if(s->avctx->lowres) mpv_reconstruct_mb_internal(s, block, 1, 0);
-    else                  mpv_reconstruct_mb_internal(s, block, 0, 0);
-}
-
 void ff_init_block_index(MpegEncContext *s){ //FIXME maybe rename
     const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics
     const int uvlinesize = s->current_picture.f->linesize[1];
@@ -1584,18 +875,15 @@
     s->dest[1] = s->current_picture.f->data[1] + (int)((s->mb_x - 1U) << (width_of_mb - s->chroma_x_shift));
     s->dest[2] = s->current_picture.f->data[2] + (int)((s->mb_x - 1U) << (width_of_mb - s->chroma_x_shift));
 
-    if(!(s->pict_type==AV_PICTURE_TYPE_B && s->avctx->draw_horiz_band && s->picture_structure==PICT_FRAME))
-    {
-        if(s->picture_structure==PICT_FRAME){
+    if (s->picture_structure == PICT_FRAME) {
         s->dest[0] += s->mb_y *   linesize << height_of_mb;
         s->dest[1] += s->mb_y * uvlinesize << (height_of_mb - s->chroma_y_shift);
         s->dest[2] += s->mb_y * uvlinesize << (height_of_mb - s->chroma_y_shift);
-        }else{
-            s->dest[0] += (s->mb_y>>1) *   linesize << height_of_mb;
-            s->dest[1] += (s->mb_y>>1) * uvlinesize << (height_of_mb - s->chroma_y_shift);
-            s->dest[2] += (s->mb_y>>1) * uvlinesize << (height_of_mb - s->chroma_y_shift);
-            av_assert1((s->mb_y&1) == (s->picture_structure == PICT_BOTTOM_FIELD));
-        }
+    } else {
+        s->dest[0] += (s->mb_y>>1) *   linesize << height_of_mb;
+        s->dest[1] += (s->mb_y>>1) * uvlinesize << (height_of_mb - s->chroma_y_shift);
+        s->dest[2] += (s->mb_y>>1) * uvlinesize << (height_of_mb - s->chroma_y_shift);
+        av_assert1((s->mb_y&1) == (s->picture_structure == PICT_BOTTOM_FIELD));
     }
 }
 
--- a/third_party/ffmpeg/libavcodec/mpegvideo.h
+++ b/third_party/ffmpeg/libavcodec/mpegvideo.h
@@ -40,7 +40,6 @@
 #include "me_cmp.h"
 #include "motion_est.h"
 #include "mpegpicture.h"
-#include "mpegvideodsp.h"
 #include "mpegvideoencdsp.h"
 #include "pixblockdsp.h"
 #include "put_bits.h"
@@ -57,6 +56,15 @@
 #define MAX_B_FRAMES 16
 
 /**
+ * Scantable.
+ */
+typedef struct ScanTable {
+    const uint8_t *scantable;
+    uint8_t permutated[64];
+    uint8_t raster_end[64];
+} ScanTable;
+
+/**
  * MpegEncContext.
  */
 typedef struct MpegEncContext {
@@ -69,13 +77,14 @@
 
     /* scantables */
     ScanTable inter_scantable; ///< if inter == intra then intra should be used to reduce the cache usage
-    ScanTable intra_scantable;
-    ScanTable intra_h_scantable;
-    ScanTable intra_v_scantable;
 
     /* WARNING: changes above this line require updates to hardcoded
      *          offsets used in ASM. */
 
+    ScanTable intra_scantable;
+    uint8_t permutated_intra_h_scantable[64];
+    uint8_t permutated_intra_v_scantable[64];
+
     struct AVCodecContext *avctx;
     /* The following pointer is intended for codecs sharing code
      * between decoder and encoder and in need of a common context to do so. */
@@ -209,7 +218,6 @@
     HpelDSPContext hdsp;
     IDCTDSPContext idsp;
     MECmpContext mecc;
-    MpegVideoDSPContext mdsp;
     MpegvideoEncDSPContext mpvencdsp;
     PixblockDSPContext pdsp;
     QpelDSPContext qdsp;
@@ -378,13 +386,9 @@
     uint16_t pb_time;               ///< time distance between the last b and p,s,i frame
     uint16_t pp_field_time;
     uint16_t pb_field_time;         ///< like above, just for interlaced
-    int real_sprite_warping_points;
-    int sprite_offset[2][2];         ///< sprite offset[isChroma][isMVY]
-    int sprite_delta[2][2];          ///< sprite_delta [isY][isMVY]
     int mcsel;
     int quant_precision;
     int quarter_sample;              ///< 1->qpel, 0->half pel ME/MC
-    int sprite_warping_accuracy;
     int data_partitioning;           ///< data partitioning flag from header
     int partitioned_frame;           ///< is current frame partitioned
     int low_delay;                   ///< no reordering needed / has no B-frames
@@ -445,12 +449,6 @@
     int brd_scale;
     int intra_vlc_format;
     int alternate_scan;
-#define VIDEO_FORMAT_COMPONENT   0
-#define VIDEO_FORMAT_PAL         1
-#define VIDEO_FORMAT_NTSC        2
-#define VIDEO_FORMAT_SECAM       3
-#define VIDEO_FORMAT_MAC         4
-#define VIDEO_FORMAT_UNSPECIFIED 5
     int repeat_first_field;
     int chroma_420_type;
     int chroma_format;
@@ -582,14 +580,14 @@
 
 void ff_mpv_common_end(MpegEncContext *s);
 
-void ff_mpv_reconstruct_mb(MpegEncContext *s, int16_t block[12][64]);
-
 void ff_clean_intra_table_entries(MpegEncContext *s);
 
 int ff_update_duplicate_context(MpegEncContext *dst, const MpegEncContext *src);
 void ff_set_qscale(MpegEncContext * s, int qscale);
 
 void ff_mpv_idct_init(MpegEncContext *s);
+void ff_init_scantable(const uint8_t *permutation, ScanTable *st,
+                       const uint8_t *src_scantable);
 void ff_init_block_index(MpegEncContext *s);
 
 void ff_mpv_motion(MpegEncContext *s,
--- a/third_party/ffmpeg/libavcodec/mpegvideo_dec.c
+++ b/third_party/ffmpeg/libavcodec/mpegvideo_dec.c
@@ -22,17 +22,22 @@
 
 #include <limits.h>
 
+#include "config_components.h"
+
 #include "libavutil/avassert.h"
 #include "libavutil/imgutils.h"
 #include "libavutil/internal.h"
 #include "libavutil/video_enc_params.h"
 
 #include "avcodec.h"
+#include "h264chroma.h"
 #include "internal.h"
 #include "mpegutils.h"
 #include "mpegvideo.h"
 #include "mpegvideodec.h"
+#include "mpeg4videodec.h"
 #include "threadframe.h"
+#include "wmv2dec.h"
 
 void ff_mpv_decode_init(MpegEncContext *s, AVCodecContext *avctx)
 {
@@ -46,6 +51,8 @@
 
     /* convert fourcc to upper case */
     s->codec_tag       = ff_toupper4(avctx->codec_tag);
+
+    ff_h264chroma_init(&s->h264chroma, 8); //for lowres
 }
 
 int ff_mpeg_update_thread_context(AVCodecContext *dst,
@@ -78,6 +85,7 @@
                 memset(s, 0, sizeof(*s));
                 s->avctx = dst;
                 s->private_ctx = private_ctx;
+                memcpy(&s->h264chroma, &s1->h264chroma, sizeof(s->h264chroma));
                 return err;
             }
         }
@@ -446,8 +454,8 @@
     if (s->picture_structure != PICT_FRAME) {
         for (int i = 0; i < 4; i++) {
             if (s->picture_structure == PICT_BOTTOM_FIELD) {
-                s->current_picture.f->data[i] +=
-                    s->current_picture.f->linesize[i];
+                s->current_picture.f->data[i] = FF_PTR_ADD(s->current_picture.f->data[i],
+                                                           s->current_picture.f->linesize[i]);
             }
             s->current_picture.f->linesize[i] *= 2;
             s->last_picture.f->linesize[i]    *= 2;
@@ -563,3 +571,465 @@
     if (s->pict_type != AV_PICTURE_TYPE_B && !s->partitioned_frame && !s->er.error_occurred)
         ff_thread_report_progress(&s->current_picture_ptr->tf, s->mb_y, 0);
 }
+
+
+static inline int hpel_motion_lowres(MpegEncContext *s,
+                                     uint8_t *dest, const uint8_t *src,
+                                     int field_based, int field_select,
+                                     int src_x, int src_y,
+                                     int width, int height, ptrdiff_t stride,
+                                     int h_edge_pos, int v_edge_pos,
+                                     int w, int h, const h264_chroma_mc_func *pix_op,
+                                     int motion_x, int motion_y)
+{
+    const int lowres   = s->avctx->lowres;
+    const int op_index = FFMIN(lowres, 3);
+    const int s_mask   = (2 << lowres) - 1;
+    int emu = 0;
+    int sx, sy;
+
+    if (s->quarter_sample) {
+        motion_x /= 2;
+        motion_y /= 2;
+    }
+
+    sx = motion_x & s_mask;
+    sy = motion_y & s_mask;
+    src_x += motion_x >> lowres + 1;
+    src_y += motion_y >> lowres + 1;
+
+    src   += src_y * stride + src_x;
+
+    if ((unsigned)src_x > FFMAX( h_edge_pos - (!!sx) - w,                 0) ||
+        (unsigned)src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {
+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,
+                                 s->linesize, s->linesize,
+                                 w + 1, (h + 1) << field_based,
+                                 src_x, src_y * (1 << field_based),
+                                 h_edge_pos, v_edge_pos);
+        src = s->sc.edge_emu_buffer;
+        emu = 1;
+    }
+
+    sx = (sx << 2) >> lowres;
+    sy = (sy << 2) >> lowres;
+    if (field_select)
+        src += s->linesize;
+    pix_op[op_index](dest, src, stride, h, sx, sy);
+    return emu;
+}
+
+/* apply one mpeg motion vector to the three components */
+static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,
+                                                uint8_t *dest_y,
+                                                uint8_t *dest_cb,
+                                                uint8_t *dest_cr,
+                                                int field_based,
+                                                int bottom_field,
+                                                int field_select,
+                                                uint8_t *const *ref_picture,
+                                                const h264_chroma_mc_func *pix_op,
+                                                int motion_x, int motion_y,
+                                                int h, int mb_y)
+{
+    const uint8_t *ptr_y, *ptr_cb, *ptr_cr;
+    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, sx, sy, uvsx, uvsy;
+    ptrdiff_t uvlinesize, linesize;
+    const int lowres     = s->avctx->lowres;
+    const int op_index   = FFMIN(lowres - 1 + s->chroma_x_shift, 3);
+    const int block_s    = 8 >> lowres;
+    const int s_mask     = (2 << lowres) - 1;
+    const int h_edge_pos = s->h_edge_pos >> lowres;
+    const int v_edge_pos = s->v_edge_pos >> lowres;
+    linesize   = s->current_picture.f->linesize[0] << field_based;
+    uvlinesize = s->current_picture.f->linesize[1] << field_based;
+
+    // FIXME obviously not perfect but qpel will not work in lowres anyway
+    if (s->quarter_sample) {
+        motion_x /= 2;
+        motion_y /= 2;
+    }
+
+    if (field_based) {
+        motion_y += (bottom_field - field_select)*((1 << lowres)-1);
+    }
+
+    sx = motion_x & s_mask;
+    sy = motion_y & s_mask;
+    src_x = s->mb_x * 2 * block_s + (motion_x >> lowres + 1);
+    src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);
+
+    if (s->out_format == FMT_H263) {
+        uvsx    = ((motion_x >> 1) & s_mask) | (sx & 1);
+        uvsy    = ((motion_y >> 1) & s_mask) | (sy & 1);
+        uvsrc_x = src_x >> 1;
+        uvsrc_y = src_y >> 1;
+    } else if (s->out_format == FMT_H261) {
+        // even chroma mv's are full pel in H261
+        mx      = motion_x / 4;
+        my      = motion_y / 4;
+        uvsx    = (2 * mx) & s_mask;
+        uvsy    = (2 * my) & s_mask;
+        uvsrc_x = s->mb_x * block_s + (mx >> lowres);
+        uvsrc_y =    mb_y * block_s + (my >> lowres);
+    } else {
+        if (s->chroma_y_shift) {
+            mx      = motion_x / 2;
+            my      = motion_y / 2;
+            uvsx    = mx & s_mask;
+            uvsy    = my & s_mask;
+            uvsrc_x = s->mb_x * block_s                 + (mx >> lowres + 1);
+            uvsrc_y =   (mb_y * block_s >> field_based) + (my >> lowres + 1);
+        } else {
+            if (s->chroma_x_shift) {
+            //Chroma422
+                mx = motion_x / 2;
+                uvsx = mx & s_mask;
+                uvsy = motion_y & s_mask;
+                uvsrc_y = src_y;
+                uvsrc_x = s->mb_x*block_s               + (mx >> (lowres+1));
+            } else {
+            //Chroma444
+                uvsx = motion_x & s_mask;
+                uvsy = motion_y & s_mask;
+                uvsrc_x = src_x;
+                uvsrc_y = src_y;
+            }
+        }
+    }
+
+    ptr_y  = ref_picture[0] + src_y   * linesize   + src_x;
+    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;
+    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;
+
+    if ((unsigned) src_x > FFMAX( h_edge_pos - (!!sx) - 2 * block_s,       0) || uvsrc_y<0 ||
+        (unsigned) src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {
+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_y,
+                                 linesize >> field_based, linesize >> field_based,
+                                 17, 17 + field_based,
+                                src_x, src_y * (1 << field_based), h_edge_pos,
+                                v_edge_pos);
+        ptr_y = s->sc.edge_emu_buffer;
+        if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+            uint8_t *ubuf = s->sc.edge_emu_buffer + 18 * s->linesize;
+            uint8_t *vbuf =ubuf + 10 * s->uvlinesize;
+            if (s->workaround_bugs & FF_BUG_IEDGE)
+                vbuf -= s->uvlinesize;
+            s->vdsp.emulated_edge_mc(ubuf,  ptr_cb,
+                                     uvlinesize >> field_based, uvlinesize >> field_based,
+                                     9, 9 + field_based,
+                                    uvsrc_x, uvsrc_y * (1 << field_based),
+                                    h_edge_pos >> 1, v_edge_pos >> 1);
+            s->vdsp.emulated_edge_mc(vbuf,  ptr_cr,
+                                     uvlinesize >> field_based,uvlinesize >> field_based,
+                                     9, 9 + field_based,
+                                    uvsrc_x, uvsrc_y * (1 << field_based),
+                                    h_edge_pos >> 1, v_edge_pos >> 1);
+            ptr_cb = ubuf;
+            ptr_cr = vbuf;
+        }
+    }
+
+    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f->data
+    if (bottom_field) {
+        dest_y  += s->linesize;
+        dest_cb += s->uvlinesize;
+        dest_cr += s->uvlinesize;
+    }
+
+    if (field_select) {
+        ptr_y   += s->linesize;
+        ptr_cb  += s->uvlinesize;
+        ptr_cr  += s->uvlinesize;
+    }
+
+    sx = (sx << 2) >> lowres;
+    sy = (sy << 2) >> lowres;
+    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);
+
+    if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+        int hc = s->chroma_y_shift ? (h+1-bottom_field)>>1 : h;
+        uvsx = (uvsx << 2) >> lowres;
+        uvsy = (uvsy << 2) >> lowres;
+        if (hc) {
+            pix_op[op_index](dest_cb, ptr_cb, uvlinesize, hc, uvsx, uvsy);
+            pix_op[op_index](dest_cr, ptr_cr, uvlinesize, hc, uvsx, uvsy);
+        }
+    }
+    // FIXME h261 lowres loop filter
+}
+
+static inline void chroma_4mv_motion_lowres(MpegEncContext *s,
+                                            uint8_t *dest_cb, uint8_t *dest_cr,
+                                            uint8_t *const *ref_picture,
+                                            const h264_chroma_mc_func * pix_op,
+                                            int mx, int my)
+{
+    const int lowres     = s->avctx->lowres;
+    const int op_index   = FFMIN(lowres, 3);
+    const int block_s    = 8 >> lowres;
+    const int s_mask     = (2 << lowres) - 1;
+    const int h_edge_pos = s->h_edge_pos >> lowres + 1;
+    const int v_edge_pos = s->v_edge_pos >> lowres + 1;
+    int emu = 0, src_x, src_y, sx, sy;
+    ptrdiff_t offset;
+    const uint8_t *ptr;
+
+    if (s->quarter_sample) {
+        mx /= 2;
+        my /= 2;
+    }
+
+    /* In case of 8X8, we construct a single chroma motion vector
+       with a special rounding */
+    mx = ff_h263_round_chroma(mx);
+    my = ff_h263_round_chroma(my);
+
+    sx = mx & s_mask;
+    sy = my & s_mask;
+    src_x = s->mb_x * block_s + (mx >> lowres + 1);
+    src_y = s->mb_y * block_s + (my >> lowres + 1);
+
+    offset = src_y * s->uvlinesize + src_x;
+    ptr = ref_picture[1] + offset;
+    if ((unsigned) src_x > FFMAX(h_edge_pos - (!!sx) - block_s, 0) ||
+        (unsigned) src_y > FFMAX(v_edge_pos - (!!sy) - block_s, 0)) {
+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
+                                 s->uvlinesize, s->uvlinesize,
+                                 9, 9,
+                                 src_x, src_y, h_edge_pos, v_edge_pos);
+        ptr = s->sc.edge_emu_buffer;
+        emu = 1;
+    }
+    sx = (sx << 2) >> lowres;
+    sy = (sy << 2) >> lowres;
+    pix_op[op_index](dest_cb, ptr, s->uvlinesize, block_s, sx, sy);
+
+    ptr = ref_picture[2] + offset;
+    if (emu) {
+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
+                                 s->uvlinesize, s->uvlinesize,
+                                 9, 9,
+                                 src_x, src_y, h_edge_pos, v_edge_pos);
+        ptr = s->sc.edge_emu_buffer;
+    }
+    pix_op[op_index](dest_cr, ptr, s->uvlinesize, block_s, sx, sy);
+}
+
+/**
+ * motion compensation of a single macroblock
+ * @param s context
+ * @param dest_y luma destination pointer
+ * @param dest_cb chroma cb/u destination pointer
+ * @param dest_cr chroma cr/v destination pointer
+ * @param dir direction (0->forward, 1->backward)
+ * @param ref_picture array[3] of pointers to the 3 planes of the reference picture
+ * @param pix_op halfpel motion compensation function (average or put normally)
+ * the motion vectors are taken from s->mv and the MV type from s->mv_type
+ */
+static inline void MPV_motion_lowres(MpegEncContext *s,
+                                     uint8_t *dest_y, uint8_t *dest_cb,
+                                     uint8_t *dest_cr,
+                                     int dir, uint8_t *const *ref_picture,
+                                     const h264_chroma_mc_func *pix_op)
+{
+    int mx, my;
+    int mb_x, mb_y;
+    const int lowres  = s->avctx->lowres;
+    const int block_s = 8 >>lowres;
+
+    mb_x = s->mb_x;
+    mb_y = s->mb_y;
+
+    switch (s->mv_type) {
+    case MV_TYPE_16X16:
+        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
+                           0, 0, 0,
+                           ref_picture, pix_op,
+                           s->mv[dir][0][0], s->mv[dir][0][1],
+                           2 * block_s, mb_y);
+        break;
+    case MV_TYPE_8X8:
+        mx = 0;
+        my = 0;
+        for (int i = 0; i < 4; i++) {
+            hpel_motion_lowres(s, dest_y + ((i & 1) + (i >> 1) *
+                               s->linesize) * block_s,
+                               ref_picture[0], 0, 0,
+                               (2 * mb_x + (i & 1)) * block_s,
+                               (2 * mb_y + (i >> 1)) * block_s,
+                               s->width, s->height, s->linesize,
+                               s->h_edge_pos >> lowres, s->v_edge_pos >> lowres,
+                               block_s, block_s, pix_op,
+                               s->mv[dir][i][0], s->mv[dir][i][1]);
+
+            mx += s->mv[dir][i][0];
+            my += s->mv[dir][i][1];
+        }
+
+        if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY))
+            chroma_4mv_motion_lowres(s, dest_cb, dest_cr, ref_picture,
+                                     pix_op, mx, my);
+        break;
+    case MV_TYPE_FIELD:
+        if (s->picture_structure == PICT_FRAME) {
+            /* top field */
+            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
+                               1, 0, s->field_select[dir][0],
+                               ref_picture, pix_op,
+                               s->mv[dir][0][0], s->mv[dir][0][1],
+                               block_s, mb_y);
+            /* bottom field */
+            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
+                               1, 1, s->field_select[dir][1],
+                               ref_picture, pix_op,
+                               s->mv[dir][1][0], s->mv[dir][1][1],
+                               block_s, mb_y);
+        } else {
+            if (s->picture_structure != s->field_select[dir][0] + 1 &&
+                s->pict_type != AV_PICTURE_TYPE_B && !s->first_field) {
+                ref_picture = s->current_picture_ptr->f->data;
+
+            }
+            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
+                               0, 0, s->field_select[dir][0],
+                               ref_picture, pix_op,
+                               s->mv[dir][0][0],
+                               s->mv[dir][0][1], 2 * block_s, mb_y >> 1);
+            }
+        break;
+    case MV_TYPE_16X8:
+        for (int i = 0; i < 2; i++) {
+            uint8_t *const *ref2picture;
+
+            if (s->picture_structure == s->field_select[dir][i] + 1 ||
+                s->pict_type == AV_PICTURE_TYPE_B || s->first_field) {
+                ref2picture = ref_picture;
+            } else {
+                ref2picture = s->current_picture_ptr->f->data;
+            }
+
+            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
+                               0, 0, s->field_select[dir][i],
+                               ref2picture, pix_op,
+                               s->mv[dir][i][0], s->mv[dir][i][1] +
+                               2 * block_s * i, block_s, mb_y >> 1);
+
+            dest_y  +=  2 * block_s *  s->linesize;
+            dest_cb += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;
+            dest_cr += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;
+        }
+        break;
+    case MV_TYPE_DMV:
+        if (s->picture_structure == PICT_FRAME) {
+            for (int i = 0; i < 2; i++) {
+                for (int j = 0; j < 2; j++) {
+                    mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
+                                       1, j, j ^ i,
+                                       ref_picture, pix_op,
+                                       s->mv[dir][2 * i + j][0],
+                                       s->mv[dir][2 * i + j][1],
+                                       block_s, mb_y);
+                }
+                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;
+            }
+        } else {
+            for (int i = 0; i < 2; i++) {
+                mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,
+                                   0, 0, s->picture_structure != i + 1,
+                                   ref_picture, pix_op,
+                                   s->mv[dir][2 * i][0],s->mv[dir][2 * i][1],
+                                   2 * block_s, mb_y >> 1);
+
+                // after put we make avg of the same block
+                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;
+
+                // opposite parity is always in the same
+                // frame if this is second field
+                if (!s->first_field) {
+                    ref_picture = s->current_picture_ptr->f->data;
+                }
+            }
+        }
+        break;
+    default:
+        av_assert2(0);
+    }
+}
+
+/**
+ * find the lowest MB row referenced in the MVs
+ */
+static int lowest_referenced_row(MpegEncContext *s, int dir)
+{
+    int my_max = INT_MIN, my_min = INT_MAX, qpel_shift = !s->quarter_sample;
+    int off, mvs;
+
+    if (s->picture_structure != PICT_FRAME || s->mcsel)
+        goto unhandled;
+
+    switch (s->mv_type) {
+        case MV_TYPE_16X16:
+            mvs = 1;
+            break;
+        case MV_TYPE_16X8:
+            mvs = 2;
+            break;
+        case MV_TYPE_8X8:
+            mvs = 4;
+            break;
+        default:
+            goto unhandled;
+    }
+
+    for (int i = 0; i < mvs; i++) {
+        int my = s->mv[dir][i][1];
+        my_max = FFMAX(my_max, my);
+        my_min = FFMIN(my_min, my);
+    }
+
+    off = ((FFMAX(-my_min, my_max) << qpel_shift) + 63) >> 6;
+
+    return av_clip(s->mb_y + off, 0, s->mb_height - 1);
+unhandled:
+    return s->mb_height - 1;
+}
+
+/* add block[] to dest[] */
+static inline void add_dct(MpegEncContext *s,
+                           int16_t *block, int i, uint8_t *dest, int line_size)
+{
+    if (s->block_last_index[i] >= 0) {
+        s->idsp.idct_add(dest, line_size, block);
+    }
+}
+
+#define IS_ENCODER 0
+#include "mpv_reconstruct_mb_template.c"
+
+void ff_mpv_reconstruct_mb(MpegEncContext *s, int16_t block[12][64])
+{
+    if (s->avctx->debug & FF_DEBUG_DCT_COEFF) {
+       /* print DCT coefficients */
+       av_log(s->avctx, AV_LOG_DEBUG, "DCT coeffs of MB at %dx%d:\n", s->mb_x, s->mb_y);
+       for (int i = 0; i < 6; i++) {
+           for (int j = 0; j < 64; j++) {
+               av_log(s->avctx, AV_LOG_DEBUG, "%5d",
+                      block[i][s->idsp.idct_permutation[j]]);
+           }
+           av_log(s->avctx, AV_LOG_DEBUG, "\n");
+       }
+    }
+
+    if (!s->avctx->lowres) {
+#if !CONFIG_SMALL
+        if (s->out_format == FMT_MPEG1)
+            mpv_reconstruct_mb_internal(s, block, 0, DEFINITELY_MPEG12);
+        else
+            mpv_reconstruct_mb_internal(s, block, 0, NOT_MPEG12);
+#else
+        mpv_reconstruct_mb_internal(s, block, 0, MAY_BE_MPEG12);
+#endif
+    } else
+        mpv_reconstruct_mb_internal(s, block, 1, MAY_BE_MPEG12);
+}
--- a/third_party/ffmpeg/libavcodec/mpegvideo_enc.c
+++ b/third_party/ffmpeg/libavcodec/mpegvideo_enc.c
@@ -46,7 +46,7 @@
 #include "dct.h"
 #include "encode.h"
 #include "idctdsp.h"
-#include "mpeg12.h"
+#include "mpeg12codecs.h"
 #include "mpeg12data.h"
 #include "mpeg12enc.h"
 #include "mpegvideo.h"
@@ -647,17 +647,17 @@
     s->time_increment_bits = av_log2(avctx->time_base.den - 1) + 1;
 
     switch (avctx->codec->id) {
-    case AV_CODEC_ID_MPEG1VIDEO:
-        s->out_format = FMT_MPEG1;
-        s->low_delay  = !!(avctx->flags & AV_CODEC_FLAG_LOW_DELAY);
-        avctx->delay  = s->low_delay ? 0 : (s->max_b_frames + 1);
-        break;
+#if CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER
     case AV_CODEC_ID_MPEG2VIDEO:
+        s->rtp_mode   = 1;
+        /* fallthrough */
+    case AV_CODEC_ID_MPEG1VIDEO:
         s->out_format = FMT_MPEG1;
         s->low_delay  = !!(avctx->flags & AV_CODEC_FLAG_LOW_DELAY);
         avctx->delay  = s->low_delay ? 0 : (s->max_b_frames + 1);
-        s->rtp_mode   = 1;
+        ff_mpeg1_encode_init(s);
         break;
+#endif
 #if CONFIG_MJPEG_ENCODER || CONFIG_AMV_ENCODER
     case AV_CODEC_ID_MJPEG:
     case AV_CODEC_ID_AMV:
@@ -682,13 +682,9 @@
     case AV_CODEC_ID_H261:
         if (!CONFIG_H261_ENCODER)
             return AVERROR_ENCODER_NOT_FOUND;
-        if (ff_h261_get_picture_format(s->width, s->height) < 0) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "The specified picture size of %dx%d is not valid for the "
-                   "H.261 codec.\nValid sizes are 176x144, 352x288\n",
-                    s->width, s->height);
-            return AVERROR(EINVAL);
-        }
+        ret = ff_h261_encode_init(s);
+        if (ret < 0)
+            return ret;
         s->out_format = FMT_H261;
         avctx->delay  = 0;
         s->low_delay  = 1;
@@ -899,12 +895,7 @@
     ff_set_cmp(&s->mecc, s->mecc.ildct_cmp,      avctx->ildct_cmp);
     ff_set_cmp(&s->mecc, s->mecc.frame_skip_cmp, s->frame_skip_cmp);
 
-    if (CONFIG_H261_ENCODER && s->out_format == FMT_H261) {
-        ff_h261_encode_init(s);
-    } else if ((CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER)
-               && s->out_format == FMT_MPEG1) {
-        ff_mpeg1_encode_init(s);
-    } else if (CONFIG_H263_ENCODER && s->out_format == FMT_H263) {
+    if (CONFIG_H263_ENCODER && s->out_format == FMT_H263) {
         ff_h263_encode_init(s);
         if (CONFIG_MSMPEG4ENC && s->msmpeg4_version)
             ff_msmpeg4_encode_init(s);
@@ -1026,6 +1017,26 @@
     return 0;
 }
 
+#define IS_ENCODER 1
+#include "mpv_reconstruct_mb_template.c"
+
+static void mpv_reconstruct_mb(MpegEncContext *s, int16_t block[12][64])
+{
+    if (s->avctx->debug & FF_DEBUG_DCT_COEFF) {
+       /* print DCT coefficients */
+       av_log(s->avctx, AV_LOG_DEBUG, "DCT coeffs of MB at %dx%d:\n", s->mb_x, s->mb_y);
+       for (int i = 0; i < 6; i++) {
+           for (int j = 0; j < 64; j++) {
+               av_log(s->avctx, AV_LOG_DEBUG, "%5d",
+                      block[i][s->idsp.idct_permutation[j]]);
+           }
+           av_log(s->avctx, AV_LOG_DEBUG, "\n");
+       }
+    }
+
+    mpv_reconstruct_mb_internal(s, block, 0, MAY_BE_MPEG12);
+}
+
 static int get_sae(const uint8_t *src, int ref, int stride)
 {
     int x,y;
@@ -2586,7 +2597,7 @@
     }
 
     if(s->avctx->mb_decision == FF_MB_DECISION_RD){
-        ff_mpv_reconstruct_mb(s, s->block);
+        mpv_reconstruct_mb(s, s->block);
 
         score *= s->lambda2;
         score += sse_mb(s) << FF_LAMBDA_SHIFT;
@@ -3296,7 +3307,7 @@
                 }
 
                 if(s->avctx->mb_decision == FF_MB_DECISION_BITS)
-                    ff_mpv_reconstruct_mb(s, s->block);
+                    mpv_reconstruct_mb(s, s->block);
             } else {
                 int motion_x = 0, motion_y = 0;
                 s->mv_type=MV_TYPE_16X16;
@@ -3415,7 +3426,7 @@
                     s->out_format == FMT_H263 && s->pict_type!=AV_PICTURE_TYPE_B)
                     ff_h263_update_motion_val(s);
 
-                ff_mpv_reconstruct_mb(s, s->block);
+                mpv_reconstruct_mb(s, s->block);
             }
 
             /* clean the MV table in IPS frames for direct mode in B-frames */
@@ -3753,9 +3764,6 @@
                               s->chroma_intra_matrix, s->intra_quant_bias, 8, 8, 1);
             s->qscale = 8;
         }
-    } else if (s->out_format == FMT_SPEEDHQ) {
-        s->y_dc_scale_table=
-        s->c_dc_scale_table= ff_mpeg2_dc_scale_table[3];
     }
 
     //FIXME var duplication
--- a/third_party/ffmpeg/libavcodec/mpegvideo_motion.c
+++ b/third_party/ffmpeg/libavcodec/mpegvideo_motion.c
@@ -31,164 +31,10 @@
 #include "h261.h"
 #include "mpegutils.h"
 #include "mpegvideo.h"
+#include "mpeg4videodec.h"
 #include "qpeldsp.h"
 #include "wmv2.h"
 
-static void gmc1_motion(MpegEncContext *s,
-                        uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-                        uint8_t *const *ref_picture)
-{
-    const uint8_t *ptr;
-    int src_x, src_y, motion_x, motion_y;
-    ptrdiff_t offset, linesize, uvlinesize;
-    int emu = 0;
-
-    motion_x   = s->sprite_offset[0][0];
-    motion_y   = s->sprite_offset[0][1];
-    src_x      = s->mb_x * 16 + (motion_x >> (s->sprite_warping_accuracy + 1));
-    src_y      = s->mb_y * 16 + (motion_y >> (s->sprite_warping_accuracy + 1));
-    motion_x *= 1 << (3 - s->sprite_warping_accuracy);
-    motion_y *= 1 << (3 - s->sprite_warping_accuracy);
-    src_x      = av_clip(src_x, -16, s->width);
-    if (src_x == s->width)
-        motion_x = 0;
-    src_y = av_clip(src_y, -16, s->height);
-    if (src_y == s->height)
-        motion_y = 0;
-
-    linesize   = s->linesize;
-    uvlinesize = s->uvlinesize;
-
-    ptr = ref_picture[0] + src_y * linesize + src_x;
-
-    if ((unsigned)src_x >= FFMAX(s->h_edge_pos - 17, 0) ||
-        (unsigned)src_y >= FFMAX(s->v_edge_pos - 17, 0)) {
-        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
-                                 linesize, linesize,
-                                 17, 17,
-                                 src_x, src_y,
-                                 s->h_edge_pos, s->v_edge_pos);
-        ptr = s->sc.edge_emu_buffer;
-    }
-
-    if ((motion_x | motion_y) & 7) {
-        s->mdsp.gmc1(dest_y, ptr, linesize, 16,
-                     motion_x & 15, motion_y & 15, 128 - s->no_rounding);
-        s->mdsp.gmc1(dest_y + 8, ptr + 8, linesize, 16,
-                     motion_x & 15, motion_y & 15, 128 - s->no_rounding);
-    } else {
-        int dxy;
-
-        dxy = ((motion_x >> 3) & 1) | ((motion_y >> 2) & 2);
-        if (s->no_rounding) {
-            s->hdsp.put_no_rnd_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);
-        } else {
-            s->hdsp.put_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);
-        }
-    }
-
-    if (CONFIG_GRAY && s->avctx->flags & AV_CODEC_FLAG_GRAY)
-        return;
-
-    motion_x   = s->sprite_offset[1][0];
-    motion_y   = s->sprite_offset[1][1];
-    src_x      = s->mb_x * 8 + (motion_x >> (s->sprite_warping_accuracy + 1));
-    src_y      = s->mb_y * 8 + (motion_y >> (s->sprite_warping_accuracy + 1));
-    motion_x  *= 1 << (3 - s->sprite_warping_accuracy);
-    motion_y  *= 1 << (3 - s->sprite_warping_accuracy);
-    src_x      = av_clip(src_x, -8, s->width >> 1);
-    if (src_x == s->width >> 1)
-        motion_x = 0;
-    src_y = av_clip(src_y, -8, s->height >> 1);
-    if (src_y == s->height >> 1)
-        motion_y = 0;
-
-    offset = (src_y * uvlinesize) + src_x;
-    ptr    = ref_picture[1] + offset;
-    if ((unsigned)src_x >= FFMAX((s->h_edge_pos >> 1) - 9, 0) ||
-        (unsigned)src_y >= FFMAX((s->v_edge_pos >> 1) - 9, 0)) {
-        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
-                                 uvlinesize, uvlinesize,
-                                 9, 9,
-                                 src_x, src_y,
-                                 s->h_edge_pos >> 1, s->v_edge_pos >> 1);
-        ptr = s->sc.edge_emu_buffer;
-        emu = 1;
-    }
-    s->mdsp.gmc1(dest_cb, ptr, uvlinesize, 8,
-                 motion_x & 15, motion_y & 15, 128 - s->no_rounding);
-
-    ptr = ref_picture[2] + offset;
-    if (emu) {
-        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,
-                                 uvlinesize, uvlinesize,
-                                 9, 9,
-                                 src_x, src_y,
-                                 s->h_edge_pos >> 1, s->v_edge_pos >> 1);
-        ptr = s->sc.edge_emu_buffer;
-    }
-    s->mdsp.gmc1(dest_cr, ptr, uvlinesize, 8,
-                 motion_x & 15, motion_y & 15, 128 - s->no_rounding);
-}
-
-static void gmc_motion(MpegEncContext *s,
-                       uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-                       uint8_t *const *ref_picture)
-{
-    const uint8_t *ptr;
-    int linesize, uvlinesize;
-    const int a = s->sprite_warping_accuracy;
-    int ox, oy;
-
-    linesize   = s->linesize;
-    uvlinesize = s->uvlinesize;
-
-    ptr = ref_picture[0];
-
-    ox = s->sprite_offset[0][0] + s->sprite_delta[0][0] * s->mb_x * 16 +
-         s->sprite_delta[0][1] * s->mb_y * 16;
-    oy = s->sprite_offset[0][1] + s->sprite_delta[1][0] * s->mb_x * 16 +
-         s->sprite_delta[1][1] * s->mb_y * 16;
-
-    s->mdsp.gmc(dest_y, ptr, linesize, 16,
-                ox, oy,
-                s->sprite_delta[0][0], s->sprite_delta[0][1],
-                s->sprite_delta[1][0], s->sprite_delta[1][1],
-                a + 1, (1 << (2 * a + 1)) - s->no_rounding,
-                s->h_edge_pos, s->v_edge_pos);
-    s->mdsp.gmc(dest_y + 8, ptr, linesize, 16,
-                ox + s->sprite_delta[0][0] * 8,
-                oy + s->sprite_delta[1][0] * 8,
-                s->sprite_delta[0][0], s->sprite_delta[0][1],
-                s->sprite_delta[1][0], s->sprite_delta[1][1],
-                a + 1, (1 << (2 * a + 1)) - s->no_rounding,
-                s->h_edge_pos, s->v_edge_pos);
-
-    if (CONFIG_GRAY && s->avctx->flags & AV_CODEC_FLAG_GRAY)
-        return;
-
-    ox = s->sprite_offset[1][0] + s->sprite_delta[0][0] * s->mb_x * 8 +
-         s->sprite_delta[0][1] * s->mb_y * 8;
-    oy = s->sprite_offset[1][1] + s->sprite_delta[1][0] * s->mb_x * 8 +
-         s->sprite_delta[1][1] * s->mb_y * 8;
-
-    ptr = ref_picture[1];
-    s->mdsp.gmc(dest_cb, ptr, uvlinesize, 8,
-                ox, oy,
-                s->sprite_delta[0][0], s->sprite_delta[0][1],
-                s->sprite_delta[1][0], s->sprite_delta[1][1],
-                a + 1, (1 << (2 * a + 1)) - s->no_rounding,
-                (s->h_edge_pos + 1) >> 1, (s->v_edge_pos + 1) >> 1);
-
-    ptr = ref_picture[2];
-    s->mdsp.gmc(dest_cr, ptr, uvlinesize, 8,
-                ox, oy,
-                s->sprite_delta[0][0], s->sprite_delta[0][1],
-                s->sprite_delta[1][0], s->sprite_delta[1][1],
-                a + 1, (1 << (2 * a + 1)) - s->no_rounding,
-                (s->h_edge_pos + 1) >> 1, (s->v_edge_pos + 1) >> 1);
-}
-
 static inline int hpel_motion(MpegEncContext *s,
                               uint8_t *dest, uint8_t *src,
                               int src_x, int src_y,
@@ -849,14 +695,8 @@
 
     switch (s->mv_type) {
     case MV_TYPE_16X16:
-        if (!is_mpeg12 && s->mcsel) {
-            if (s->real_sprite_warping_points == 1) {
-                gmc1_motion(s, dest_y, dest_cb, dest_cr,
-                            ref_picture);
-            } else {
-                gmc_motion(s, dest_y, dest_cb, dest_cr,
-                           ref_picture);
-            }
+        if (CONFIG_MPEG4_DECODER && !is_mpeg12 && s->mcsel) {
+            ff_mpeg4_mcsel_motion(s, dest_y, dest_cb, dest_cr, ref_picture);
         } else if (!is_mpeg12 && s->quarter_sample) {
             qpel_motion(s, dest_y, dest_cb, dest_cr,
                         0, 0, 0,
--- a/third_party/ffmpeg/libavcodec/mpegvideodec.h
+++ b/third_party/ffmpeg/libavcodec/mpegvideodec.h
@@ -50,6 +50,7 @@
 int ff_mpv_common_frame_size_change(MpegEncContext *s);
 
 int ff_mpv_frame_start(MpegEncContext *s, AVCodecContext *avctx);
+void ff_mpv_reconstruct_mb(MpegEncContext *s, int16_t block[12][64]);
 void ff_mpv_report_decode_progress(MpegEncContext *s);
 void ff_mpv_frame_end(MpegEncContext *s);
 
--- a/third_party/ffmpeg/libavcodec/msmpeg4.c
+++ b/third_party/ffmpeg/libavcodec/msmpeg4.c
@@ -150,9 +150,11 @@
 
     if(s->msmpeg4_version>=4){
         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_wmv1_scantable[1]);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_wmv1_scantable[2]);
-        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_wmv1_scantable[3]);
         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_wmv1_scantable[0]);
+        ff_permute_scantable(s->permutated_intra_h_scantable, ff_wmv1_scantable[2],
+                             s->idsp.idct_permutation);
+        ff_permute_scantable(s->permutated_intra_v_scantable, ff_wmv1_scantable[3],
+                             s->idsp.idct_permutation);
     }
     //Note the default tables are set in common_init in mpegvideo.c
 
--- a/third_party/ffmpeg/libavcodec/msmpeg4data.h
+++ b/third_party/ffmpeg/libavcodec/msmpeg4data.h
@@ -32,6 +32,8 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
+
 #include "rl.h"
 #include "vlc.h"
 
@@ -45,6 +47,7 @@
     VLC vlc;                /* decoding: vlc */
 } MVTable;
 
+FF_VISIBILITY_PUSH_HIDDEN
 extern VLC ff_msmp4_mb_i_vlc;
 extern VLC ff_msmp4_dc_luma_vlc[2];
 extern VLC ff_msmp4_dc_chroma_vlc[2];
@@ -83,5 +86,6 @@
 
 #define WMV2_INTER_CBP_TABLE_COUNT 4
 extern const uint32_t (* const ff_wmv2_inter_table[WMV2_INTER_CBP_TABLE_COUNT])[2];
+FF_VISIBILITY_POP_HIDDEN
 
 #endif /* AVCODEC_MSMPEG4DATA_H */
--- a/third_party/ffmpeg/libavcodec/msmpeg4dec.c
+++ b/third_party/ffmpeg/libavcodec/msmpeg4dec.c
@@ -687,9 +687,9 @@
         }
         if (s->ac_pred) {
             if (dc_pred_dir == 0)
-                scan_table = s->intra_v_scantable.permutated; /* left */
+                scan_table = s->permutated_intra_v_scantable; /* left */
             else
-                scan_table = s->intra_h_scantable.permutated; /* top */
+                scan_table = s->permutated_intra_h_scantable; /* top */
         } else {
             scan_table = s->intra_scantable.permutated;
         }
--- a/third_party/ffmpeg/libavcodec/msmpeg4enc.c
+++ b/third_party/ffmpeg/libavcodec/msmpeg4enc.c
@@ -279,15 +279,15 @@
 
 void ff_msmpeg4_encode_ext_header(MpegEncContext * s)
 {
-        unsigned fps = s->avctx->time_base.den / s->avctx->time_base.num / FFMAX(s->avctx->ticks_per_frame, 1);
-        put_bits(&s->pb, 5, FFMIN(fps, 31)); //yes 29.97 -> 29
+    unsigned fps = s->avctx->time_base.den / s->avctx->time_base.num / FFMAX(s->avctx->ticks_per_frame, 1);
+    put_bits(&s->pb, 5, FFMIN(fps, 31)); //yes 29.97 -> 29
 
-        put_bits(&s->pb, 11, FFMIN(s->bit_rate/1024, 2047));
+    put_bits(&s->pb, 11, FFMIN(s->bit_rate / 1024, 2047));
 
-        if(s->msmpeg4_version>=3)
-            put_bits(&s->pb, 1, s->flipflop_rounding);
-        else
-            av_assert0(s->flipflop_rounding==0);
+    if (s->msmpeg4_version >= 3)
+        put_bits(&s->pb, 1, s->flipflop_rounding);
+    else
+        av_assert0(!s->flipflop_rounding);
 }
 
 void ff_msmpeg4_encode_motion(MpegEncContext * s,
--- a/third_party/ffmpeg/libavcodec/mss2.c
+++ b/third_party/ffmpeg/libavcodec/mss2.c
@@ -468,6 +468,39 @@
     int coded, x, y, w, h;
 };
 
+struct Rectangle2 {
+    int left, right, top, bottom;
+};
+
+static void calc_draw_region(struct Rectangle2 * draw, const struct Rectangle2 * rect)
+{
+#define COMPARE(top, bottom, left, right)  \
+    if (rect->top <= draw->top && rect->bottom >= draw->bottom) { \
+        if (rect->left <= draw->left && rect->right >= draw->left) \
+            draw->left = FFMIN(rect->right, draw->right); \
+        \
+        if (rect->right >= draw->right) { \
+            if (rect->left >= draw->left) { \
+                if (rect->left < draw->right) \
+                    draw->right = rect->left; \
+            } else { \
+                draw->right = draw->left; \
+            } \
+        } \
+    }
+
+    COMPARE(top, bottom, left, right)
+    COMPARE(left, right, top, bottom)
+}
+
+static int calc_split_position(int split_position, const struct Rectangle2 * rect, int height)
+{
+    if (rect->top || rect->bottom != height)
+        split_position = rect->top + split_position * (rect->bottom - rect->top) / height;
+
+    return av_clip(split_position, rect->top + 1, rect->bottom - 1);
+}
+
 #define MAX_WMV9_RECTANGLES 20
 #define ARITH2_PADDING 2
 
@@ -485,6 +518,7 @@
     int keyframe, has_wmv9, has_mv, is_rle, is_555, ret;
 
     struct Rectangle wmv9rects[MAX_WMV9_RECTANGLES], *r;
+    struct Rectangle2 draw;
     int used_rects = 0, i, implicit_rect = 0, av_uninit(wmv9_mask);
 
     if ((ret = init_get_bits8(&gb, buf, buf_size)) < 0)
@@ -671,11 +705,32 @@
             bytestream2_init(&gB, buf, buf_size + ARITH2_PADDING);
             arith2_init(&acoder, &gB);
             c->keyframe = keyframe;
-            if (c->corrupted = ff_mss12_decode_rect(&ctx->sc[0], &acoder, 0, 0,
-                                                    avctx->width,
-                                                    ctx->split_position))
+
+            draw.left = 0;
+            draw.top = 0;
+            draw.right = avctx->width;
+            draw.bottom = avctx->height;
+            if (wmv9_mask == -1) {
+                for (i = 0; i < used_rects; i++) {
+                    struct Rectangle2 r;
+                    r.left   = wmv9rects[i].x;
+                    r.top    = wmv9rects[i].y;
+                    r.right  = r.left + wmv9rects[i].w;
+                    r.bottom = r.top + wmv9rects[i].h;
+                    calc_draw_region(&draw, &r);
+                }
+            }
+
+            if (draw.left >= avctx->width || draw.right > avctx->width ||
+                draw.top >= avctx->height || draw.bottom > avctx->height)
                 return AVERROR_INVALIDDATA;
 
+            if (c->slice_split && draw.bottom - draw.top >= 10) {
+                ctx->split_position = calc_split_position(ctx->split_position, &draw, avctx->height);
+            if (c->corrupted = ff_mss12_decode_rect(&ctx->sc[0], &acoder, 0, draw.top,
+                                                    avctx->width,
+                                                    ctx->split_position - draw.top))
+                return AVERROR_INVALIDDATA;
             buf      += arith2_get_consumed_bytes(&acoder);
             buf_size -= arith2_get_consumed_bytes(&acoder);
             if (c->slice_split) {
@@ -686,7 +741,14 @@
                 if (c->corrupted = ff_mss12_decode_rect(&ctx->sc[1], &acoder, 0,
                                                         ctx->split_position,
                                                         avctx->width,
-                                                        avctx->height - ctx->split_position))
+                                                        draw.bottom - ctx->split_position))
+                    return AVERROR_INVALIDDATA;
+                buf      += arith2_get_consumed_bytes(&acoder);
+                buf_size -= arith2_get_consumed_bytes(&acoder);
+            }
+            } else {
+                if (c->corrupted = ff_mss12_decode_rect(&ctx->sc[0], &acoder, draw.left, draw.top,
+                                                        draw.right - draw.left, draw.bottom - draw.top))
                     return AVERROR_INVALIDDATA;
 
                 buf      += arith2_get_consumed_bytes(&acoder);
--- a/third_party/ffmpeg/libavcodec/mss34dsp.c
+++ b/third_party/ffmpeg/libavcodec/mss34dsp.c
@@ -22,33 +22,12 @@
 #include <stdint.h>
 #include "libavutil/common.h"
 #include "mss34dsp.h"
-
-static const uint8_t luma_quant[64] = {
-    16,  11,  10,  16,  24,  40,  51,  61,
-    12,  12,  14,  19,  26,  58,  60,  55,
-    14,  13,  16,  24,  40,  57,  69,  56,
-    14,  17,  22,  29,  51,  87,  80,  62,
-    18,  22,  37,  56,  68, 109, 103,  77,
-    24,  35,  55,  64,  81, 104, 113,  92,
-    49,  64,  78,  87, 103, 121, 120, 101,
-    72,  92,  95,  98, 112, 100, 103,  99
-};
-
-static const uint8_t chroma_quant[64] = {
-    17, 18, 24, 47, 99, 99, 99, 99,
-    18, 21, 26, 66, 99, 99, 99, 99,
-    24, 26, 56, 99, 99, 99, 99, 99,
-    47, 66, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99
-};
+#include "jpegquanttables.h"
 
 void ff_mss34_gen_quant_mat(uint16_t *qmat, int quality, int luma)
 {
     int i;
-    const uint8_t *qsrc = luma ? luma_quant : chroma_quant;
+    const uint8_t *qsrc = luma ? ff_mjpeg_std_luminance_quant_tbl : ff_mjpeg_std_chrominance_quant_tbl;
 
     if (quality >= 50) {
         int scale = 200 - 2 * quality;
--- a/third_party/ffmpeg/libavcodec/nuv.c
+++ b/third_party/ffmpeg/libavcodec/nuv.c
@@ -29,6 +29,7 @@
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "decode.h"
+#include "jpegquanttables.h"
 #include "rtjpeg.h"
 
 typedef struct NuvContext {
@@ -42,28 +43,6 @@
     RTJpegContext rtj;
 } NuvContext;
 
-static const uint8_t fallback_lquant[] = {
-    16,  11,  10,  16,  24,  40,  51,  61,
-    12,  12,  14,  19,  26,  58,  60,  55,
-    14,  13,  16,  24,  40,  57,  69,  56,
-    14,  17,  22,  29,  51,  87,  80,  62,
-    18,  22,  37,  56,  68, 109, 103,  77,
-    24,  35,  55,  64,  81, 104, 113,  92,
-    49,  64,  78,  87, 103, 121, 120, 101,
-    72,  92,  95,  98, 112, 100, 103,  99
-};
-
-static const uint8_t fallback_cquant[] = {
-    17, 18, 24, 47, 99, 99, 99, 99,
-    18, 21, 26, 66, 99, 99, 99, 99,
-    24, 26, 56, 99, 99, 99, 99, 99,
-    47, 66, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99
-};
-
 /**
  * @brief copy frame data from buffer to AVFrame, handling stride.
  * @param f destination AVFrame
@@ -107,8 +86,8 @@
     int i;
     quality = FFMAX(quality, 1);
     for (i = 0; i < 64; i++) {
-        c->lq[i] = (fallback_lquant[i] << 7) / quality;
-        c->cq[i] = (fallback_cquant[i] << 7) / quality;
+        c->lq[i] = (ff_mjpeg_std_luminance_quant_tbl[i] << 7) / quality;
+        c->cq[i] = (ff_mjpeg_std_chrominance_quant_tbl[i] << 7) / quality;
     }
 }
 
--- a/third_party/ffmpeg/libavcodec/nvdec_mjpeg.c
+++ b/third_party/ffmpeg/libavcodec/nvdec_mjpeg.c
@@ -20,8 +20,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "config_components.h"
-
 #include "avcodec.h"
 #include "internal.h"
 #include "mjpegdec.h"
@@ -71,7 +69,6 @@
     return ff_nvdec_frame_params(avctx, hw_frames_ctx, 1, 0);
 }
 
-#if CONFIG_MJPEG_NVDEC_HWACCEL
 AVHWAccel ff_mjpeg_nvdec_hwaccel = {
     .name                 = "mjpeg_nvdec",
     .type                 = AVMEDIA_TYPE_VIDEO,
@@ -85,4 +82,3 @@
     .uninit               = ff_nvdec_decode_uninit,
     .priv_data_size       = sizeof(NVDECContext),
 };
-#endif
--- a/third_party/ffmpeg/libavcodec/opus.c
+++ /dev/null
@@ -1,925 +0,0 @@
-/*
- * Copyright (c) 2012 Andrew D'Addesio
- * Copyright (c) 2013-2014 Mozilla Corporation
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * Opus decoder/parser shared code
- */
-
-#include <stdint.h>
-
-#include "libavutil/channel_layout.h"
-#include "libavutil/error.h"
-#include "libavutil/ffmath.h"
-
-#include "opus_celt.h"
-#include "opustab.h"
-#include "internal.h"
-#include "vorbis.h"
-
-static const uint16_t opus_frame_duration[32] = {
-    480, 960, 1920, 2880,
-    480, 960, 1920, 2880,
-    480, 960, 1920, 2880,
-    480, 960,
-    480, 960,
-    120, 240,  480,  960,
-    120, 240,  480,  960,
-    120, 240,  480,  960,
-    120, 240,  480,  960,
-};
-
-/**
- * Read a 1- or 2-byte frame length
- */
-static inline int xiph_lacing_16bit(const uint8_t **ptr, const uint8_t *end)
-{
-    int val;
-
-    if (*ptr >= end)
-        return AVERROR_INVALIDDATA;
-    val = *(*ptr)++;
-    if (val >= 252) {
-        if (*ptr >= end)
-            return AVERROR_INVALIDDATA;
-        val += 4 * *(*ptr)++;
-    }
-    return val;
-}
-
-/**
- * Read a multi-byte length (used for code 3 packet padding size)
- */
-static inline int xiph_lacing_full(const uint8_t **ptr, const uint8_t *end)
-{
-    int val = 0;
-    int next;
-
-    while (1) {
-        if (*ptr >= end || val > INT_MAX - 254)
-            return AVERROR_INVALIDDATA;
-        next = *(*ptr)++;
-        val += next;
-        if (next < 255)
-            break;
-        else
-            val--;
-    }
-    return val;
-}
-
-/**
- * Parse Opus packet info from raw packet data
- */
-int ff_opus_parse_packet(OpusPacket *pkt, const uint8_t *buf, int buf_size,
-                         int self_delimiting)
-{
-    const uint8_t *ptr = buf;
-    const uint8_t *end = buf + buf_size;
-    int padding = 0;
-    int frame_bytes, i;
-
-    if (buf_size < 1)
-        goto fail;
-
-    /* TOC byte */
-    i = *ptr++;
-    pkt->code   = (i     ) & 0x3;
-    pkt->stereo = (i >> 2) & 0x1;
-    pkt->config = (i >> 3) & 0x1F;
-
-    /* code 2 and code 3 packets have at least 1 byte after the TOC */
-    if (pkt->code >= 2 && buf_size < 2)
-        goto fail;
-
-    switch (pkt->code) {
-    case 0:
-        /* 1 frame */
-        pkt->frame_count = 1;
-        pkt->vbr         = 0;
-
-        if (self_delimiting) {
-            int len = xiph_lacing_16bit(&ptr, end);
-            if (len < 0 || len > end - ptr)
-                goto fail;
-            end      = ptr + len;
-            buf_size = end - buf;
-        }
-
-        frame_bytes = end - ptr;
-        if (frame_bytes > MAX_FRAME_SIZE)
-            goto fail;
-        pkt->frame_offset[0] = ptr - buf;
-        pkt->frame_size[0]   = frame_bytes;
-        break;
-    case 1:
-        /* 2 frames, equal size */
-        pkt->frame_count = 2;
-        pkt->vbr         = 0;
-
-        if (self_delimiting) {
-            int len = xiph_lacing_16bit(&ptr, end);
-            if (len < 0 || 2 * len > end - ptr)
-                goto fail;
-            end      = ptr + 2 * len;
-            buf_size = end - buf;
-        }
-
-        frame_bytes = end - ptr;
-        if (frame_bytes & 1 || frame_bytes >> 1 > MAX_FRAME_SIZE)
-            goto fail;
-        pkt->frame_offset[0] = ptr - buf;
-        pkt->frame_size[0]   = frame_bytes >> 1;
-        pkt->frame_offset[1] = pkt->frame_offset[0] + pkt->frame_size[0];
-        pkt->frame_size[1]   = frame_bytes >> 1;
-        break;
-    case 2:
-        /* 2 frames, different sizes */
-        pkt->frame_count = 2;
-        pkt->vbr         = 1;
-
-        /* read 1st frame size */
-        frame_bytes = xiph_lacing_16bit(&ptr, end);
-        if (frame_bytes < 0)
-            goto fail;
-
-        if (self_delimiting) {
-            int len = xiph_lacing_16bit(&ptr, end);
-            if (len < 0 || len + frame_bytes > end - ptr)
-                goto fail;
-            end      = ptr + frame_bytes + len;
-            buf_size = end - buf;
-        }
-
-        pkt->frame_offset[0] = ptr - buf;
-        pkt->frame_size[0]   = frame_bytes;
-
-        /* calculate 2nd frame size */
-        frame_bytes = end - ptr - pkt->frame_size[0];
-        if (frame_bytes < 0 || frame_bytes > MAX_FRAME_SIZE)
-            goto fail;
-        pkt->frame_offset[1] = pkt->frame_offset[0] + pkt->frame_size[0];
-        pkt->frame_size[1]   = frame_bytes;
-        break;
-    case 3:
-        /* 1 to 48 frames, can be different sizes */
-        i = *ptr++;
-        pkt->frame_count = (i     ) & 0x3F;
-        padding          = (i >> 6) & 0x01;
-        pkt->vbr         = (i >> 7) & 0x01;
-
-        if (pkt->frame_count == 0 || pkt->frame_count > MAX_FRAMES)
-            goto fail;
-
-        /* read padding size */
-        if (padding) {
-            padding = xiph_lacing_full(&ptr, end);
-            if (padding < 0)
-                goto fail;
-        }
-
-        /* read frame sizes */
-        if (pkt->vbr) {
-            /* for VBR, all frames except the final one have their size coded
-               in the bitstream. the last frame size is implicit. */
-            int total_bytes = 0;
-            for (i = 0; i < pkt->frame_count - 1; i++) {
-                frame_bytes = xiph_lacing_16bit(&ptr, end);
-                if (frame_bytes < 0)
-                    goto fail;
-                pkt->frame_size[i] = frame_bytes;
-                total_bytes += frame_bytes;
-            }
-
-            if (self_delimiting) {
-                int len = xiph_lacing_16bit(&ptr, end);
-                if (len < 0 || len + total_bytes + padding > end - ptr)
-                    goto fail;
-                end      = ptr + total_bytes + len + padding;
-                buf_size = end - buf;
-            }
-
-            frame_bytes = end - ptr - padding;
-            if (total_bytes > frame_bytes)
-                goto fail;
-            pkt->frame_offset[0] = ptr - buf;
-            for (i = 1; i < pkt->frame_count; i++)
-                pkt->frame_offset[i] = pkt->frame_offset[i-1] + pkt->frame_size[i-1];
-            pkt->frame_size[pkt->frame_count-1] = frame_bytes - total_bytes;
-        } else {
-            /* for CBR, the remaining packet bytes are divided evenly between
-               the frames */
-            if (self_delimiting) {
-                frame_bytes = xiph_lacing_16bit(&ptr, end);
-                if (frame_bytes < 0 || pkt->frame_count * frame_bytes + padding > end - ptr)
-                    goto fail;
-                end      = ptr + pkt->frame_count * frame_bytes + padding;
-                buf_size = end - buf;
-            } else {
-                frame_bytes = end - ptr - padding;
-                if (frame_bytes % pkt->frame_count ||
-                    frame_bytes / pkt->frame_count > MAX_FRAME_SIZE)
-                    goto fail;
-                frame_bytes /= pkt->frame_count;
-            }
-
-            pkt->frame_offset[0] = ptr - buf;
-            pkt->frame_size[0]   = frame_bytes;
-            for (i = 1; i < pkt->frame_count; i++) {
-                pkt->frame_offset[i] = pkt->frame_offset[i-1] + pkt->frame_size[i-1];
-                pkt->frame_size[i]   = frame_bytes;
-            }
-        }
-    }
-
-    pkt->packet_size = buf_size;
-    pkt->data_size   = pkt->packet_size - padding;
-
-    /* total packet duration cannot be larger than 120ms */
-    pkt->frame_duration = opus_frame_duration[pkt->config];
-    if (pkt->frame_duration * pkt->frame_count > MAX_PACKET_DUR)
-        goto fail;
-
-    /* set mode and bandwidth */
-    if (pkt->config < 12) {
-        pkt->mode = OPUS_MODE_SILK;
-        pkt->bandwidth = pkt->config >> 2;
-    } else if (pkt->config < 16) {
-        pkt->mode = OPUS_MODE_HYBRID;
-        pkt->bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND + (pkt->config >= 14);
-    } else {
-        pkt->mode = OPUS_MODE_CELT;
-        pkt->bandwidth = (pkt->config - 16) >> 2;
-        /* skip medium band */
-        if (pkt->bandwidth)
-            pkt->bandwidth++;
-    }
-
-    return 0;
-
-fail:
-    memset(pkt, 0, sizeof(*pkt));
-    return AVERROR_INVALIDDATA;
-}
-
-static int channel_reorder_vorbis(int nb_channels, int channel_idx)
-{
-    return ff_vorbis_channel_layout_offsets[nb_channels - 1][channel_idx];
-}
-
-static int channel_reorder_unknown(int nb_channels, int channel_idx)
-{
-    return channel_idx;
-}
-
-av_cold int ff_opus_parse_extradata(AVCodecContext *avctx,
-                                    OpusContext *s)
-{
-    static const uint8_t default_channel_map[2] = { 0, 1 };
-
-    int (*channel_reorder)(int, int) = channel_reorder_unknown;
-    int channels = avctx->ch_layout.nb_channels;
-
-    const uint8_t *extradata, *channel_map;
-    int extradata_size;
-    int version, map_type, streams, stereo_streams, i, j, ret;
-    AVChannelLayout layout = { 0 };
-
-    if (!avctx->extradata) {
-        if (channels > 2) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "Multichannel configuration without extradata.\n");
-            return AVERROR(EINVAL);
-        }
-        extradata      = opus_default_extradata;
-        extradata_size = sizeof(opus_default_extradata);
-    } else {
-        extradata = avctx->extradata;
-        extradata_size = avctx->extradata_size;
-    }
-
-    if (extradata_size < 19) {
-        av_log(avctx, AV_LOG_ERROR, "Invalid extradata size: %d\n",
-               extradata_size);
-        return AVERROR_INVALIDDATA;
-    }
-
-    version = extradata[8];
-    if (version > 15) {
-        avpriv_request_sample(avctx, "Extradata version %d", version);
-        return AVERROR_PATCHWELCOME;
-    }
-
-    avctx->delay = AV_RL16(extradata + 10);
-    if (avctx->internal)
-        avctx->internal->skip_samples = avctx->delay;
-
-    channels = avctx->extradata ? extradata[9] : (channels == 1) ? 1 : 2;
-    if (!channels) {
-        av_log(avctx, AV_LOG_ERROR, "Zero channel count specified in the extradata\n");
-        return AVERROR_INVALIDDATA;
-    }
-
-    s->gain_i = AV_RL16(extradata + 16);
-    if (s->gain_i)
-        s->gain = ff_exp10(s->gain_i / (20.0 * 256));
-
-    map_type = extradata[18];
-    if (!map_type) {
-        if (channels > 2) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "Channel mapping 0 is only specified for up to 2 channels\n");
-            ret = AVERROR_INVALIDDATA;
-            goto fail;
-        }
-        layout         = (channels == 1) ? (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO :
-                                           (AVChannelLayout)AV_CHANNEL_LAYOUT_STEREO;
-        streams        = 1;
-        stereo_streams = channels - 1;
-        channel_map    = default_channel_map;
-    } else if (map_type == 1 || map_type == 2 || map_type == 255) {
-        if (extradata_size < 21 + channels) {
-            av_log(avctx, AV_LOG_ERROR, "Invalid extradata size: %d\n",
-                   extradata_size);
-            ret = AVERROR_INVALIDDATA;
-            goto fail;
-        }
-
-        streams        = extradata[19];
-        stereo_streams = extradata[20];
-        if (!streams || stereo_streams > streams ||
-            streams + stereo_streams > 255) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "Invalid stream/stereo stream count: %d/%d\n", streams, stereo_streams);
-            ret = AVERROR_INVALIDDATA;
-            goto fail;
-        }
-
-        if (map_type == 1) {
-            if (channels > 8) {
-                av_log(avctx, AV_LOG_ERROR,
-                       "Channel mapping 1 is only specified for up to 8 channels\n");
-                ret = AVERROR_INVALIDDATA;
-                goto fail;
-            }
-            av_channel_layout_copy(&layout, &ff_vorbis_ch_layouts[channels - 1]);
-            channel_reorder = channel_reorder_vorbis;
-        } else if (map_type == 2) {
-            int ambisonic_order = ff_sqrt(channels) - 1;
-            if (channels != ((ambisonic_order + 1) * (ambisonic_order + 1)) &&
-                channels != ((ambisonic_order + 1) * (ambisonic_order + 1) + 2)) {
-                av_log(avctx, AV_LOG_ERROR,
-                       "Channel mapping 2 is only specified for channel counts"
-                       " which can be written as (n + 1)^2 or (n + 1)^2 + 2"
-                       " for nonnegative integer n\n");
-                ret = AVERROR_INVALIDDATA;
-                goto fail;
-            }
-            if (channels > 227) {
-                av_log(avctx, AV_LOG_ERROR, "Too many channels\n");
-                ret = AVERROR_INVALIDDATA;
-                goto fail;
-            }
-
-            layout.order = AV_CHANNEL_ORDER_AMBISONIC;
-            layout.nb_channels = channels;
-            if (channels != ((ambisonic_order + 1) * (ambisonic_order + 1)))
-                layout.u.mask = AV_CH_LAYOUT_STEREO;
-        } else {
-            layout.order       = AV_CHANNEL_ORDER_UNSPEC;
-            layout.nb_channels = channels;
-        }
-
-        channel_map = extradata + 21;
-    } else {
-        avpriv_request_sample(avctx, "Mapping type %d", map_type);
-        return AVERROR_PATCHWELCOME;
-    }
-
-    s->channel_maps = av_calloc(channels, sizeof(*s->channel_maps));
-    if (!s->channel_maps) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-
-    for (i = 0; i < channels; i++) {
-        ChannelMap *map = &s->channel_maps[i];
-        uint8_t     idx = channel_map[channel_reorder(channels, i)];
-
-        if (idx == 255) {
-            map->silence = 1;
-            continue;
-        } else if (idx >= streams + stereo_streams) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "Invalid channel map for output channel %d: %d\n", i, idx);
-            av_freep(&s->channel_maps);
-            ret = AVERROR_INVALIDDATA;
-            goto fail;
-        }
-
-        /* check that we did not see this index yet */
-        map->copy = 0;
-        for (j = 0; j < i; j++)
-            if (channel_map[channel_reorder(channels, j)] == idx) {
-                map->copy     = 1;
-                map->copy_idx = j;
-                break;
-            }
-
-        if (idx < 2 * stereo_streams) {
-            map->stream_idx  = idx / 2;
-            map->channel_idx = idx & 1;
-        } else {
-            map->stream_idx  = idx - stereo_streams;
-            map->channel_idx = 0;
-        }
-    }
-
-    ret = av_channel_layout_copy(&avctx->ch_layout, &layout);
-    if (ret < 0)
-        goto fail;
-
-    s->nb_streams         = streams;
-    s->nb_stereo_streams  = stereo_streams;
-
-    return 0;
-fail:
-    av_channel_layout_uninit(&layout);
-    return ret;
-}
-
-void ff_celt_quant_bands(CeltFrame *f, OpusRangeCoder *rc)
-{
-    float lowband_scratch[8 * 22];
-    float norm1[2 * 8 * 100];
-    float *norm2 = norm1 + 8 * 100;
-
-    int totalbits = (f->framebits << 3) - f->anticollapse_needed;
-
-    int update_lowband = 1;
-    int lowband_offset = 0;
-
-    int i, j;
-
-    for (i = f->start_band; i < f->end_band; i++) {
-        uint32_t cm[2] = { (1 << f->blocks) - 1, (1 << f->blocks) - 1 };
-        int band_offset = ff_celt_freq_bands[i] << f->size;
-        int band_size   = ff_celt_freq_range[i] << f->size;
-        float *X = f->block[0].coeffs + band_offset;
-        float *Y = (f->channels == 2) ? f->block[1].coeffs + band_offset : NULL;
-        float *norm_loc1, *norm_loc2;
-
-        int consumed = opus_rc_tell_frac(rc);
-        int effective_lowband = -1;
-        int b = 0;
-
-        /* Compute how many bits we want to allocate to this band */
-        if (i != f->start_band)
-            f->remaining -= consumed;
-        f->remaining2 = totalbits - consumed - 1;
-        if (i <= f->coded_bands - 1) {
-            int curr_balance = f->remaining / FFMIN(3, f->coded_bands-i);
-            b = av_clip_uintp2(FFMIN(f->remaining2 + 1, f->pulses[i] + curr_balance), 14);
-        }
-
-        if ((ff_celt_freq_bands[i] - ff_celt_freq_range[i] >= ff_celt_freq_bands[f->start_band] ||
-            i == f->start_band + 1) && (update_lowband || lowband_offset == 0))
-            lowband_offset = i;
-
-        if (i == f->start_band + 1) {
-            /* Special Hybrid Folding (RFC 8251 section 9). Copy the first band into
-            the second to ensure the second band never has to use the LCG. */
-            int count = (ff_celt_freq_range[i] - ff_celt_freq_range[i-1]) << f->size;
-
-            memcpy(&norm1[band_offset], &norm1[band_offset - count], count * sizeof(float));
-
-            if (f->channels == 2)
-                memcpy(&norm2[band_offset], &norm2[band_offset - count], count * sizeof(float));
-        }
-
-        /* Get a conservative estimate of the collapse_mask's for the bands we're
-           going to be folding from. */
-        if (lowband_offset != 0 && (f->spread != CELT_SPREAD_AGGRESSIVE ||
-                                    f->blocks > 1 || f->tf_change[i] < 0)) {
-            int foldstart, foldend;
-
-            /* This ensures we never repeat spectral content within one band */
-            effective_lowband = FFMAX(ff_celt_freq_bands[f->start_band],
-                                      ff_celt_freq_bands[lowband_offset] - ff_celt_freq_range[i]);
-            foldstart = lowband_offset;
-            while (ff_celt_freq_bands[--foldstart] > effective_lowband);
-            foldend = lowband_offset - 1;
-            while (++foldend < i && ff_celt_freq_bands[foldend] < effective_lowband + ff_celt_freq_range[i]);
-
-            cm[0] = cm[1] = 0;
-            for (j = foldstart; j < foldend; j++) {
-                cm[0] |= f->block[0].collapse_masks[j];
-                cm[1] |= f->block[f->channels - 1].collapse_masks[j];
-            }
-        }
-
-        if (f->dual_stereo && i == f->intensity_stereo) {
-            /* Switch off dual stereo to do intensity */
-            f->dual_stereo = 0;
-            for (j = ff_celt_freq_bands[f->start_band] << f->size; j < band_offset; j++)
-                norm1[j] = (norm1[j] + norm2[j]) / 2;
-        }
-
-        norm_loc1 = effective_lowband != -1 ? norm1 + (effective_lowband << f->size) : NULL;
-        norm_loc2 = effective_lowband != -1 ? norm2 + (effective_lowband << f->size) : NULL;
-
-        if (f->dual_stereo) {
-            cm[0] = f->pvq->quant_band(f->pvq, f, rc, i, X, NULL, band_size, b >> 1,
-                                       f->blocks, norm_loc1, f->size,
-                                       norm1 + band_offset, 0, 1.0f,
-                                       lowband_scratch, cm[0]);
-
-            cm[1] = f->pvq->quant_band(f->pvq, f, rc, i, Y, NULL, band_size, b >> 1,
-                                       f->blocks, norm_loc2, f->size,
-                                       norm2 + band_offset, 0, 1.0f,
-                                       lowband_scratch, cm[1]);
-        } else {
-            cm[0] = f->pvq->quant_band(f->pvq, f, rc, i, X,    Y, band_size, b >> 0,
-                                       f->blocks, norm_loc1, f->size,
-                                       norm1 + band_offset, 0, 1.0f,
-                                       lowband_scratch, cm[0] | cm[1]);
-            cm[1] = cm[0];
-        }
-
-        f->block[0].collapse_masks[i]               = (uint8_t)cm[0];
-        f->block[f->channels - 1].collapse_masks[i] = (uint8_t)cm[1];
-        f->remaining += f->pulses[i] + consumed;
-
-        /* Update the folding position only as long as we have 1 bit/sample depth */
-        update_lowband = (b > band_size << 3);
-    }
-}
-
-#define NORMC(bits) ((bits) << (f->channels - 1) << f->size >> 2)
-
-void ff_celt_bitalloc(CeltFrame *f, OpusRangeCoder *rc, int encode)
-{
-    int i, j, low, high, total, done, bandbits, remaining, tbits_8ths;
-    int skip_startband      = f->start_band;
-    int skip_bit            = 0;
-    int intensitystereo_bit = 0;
-    int dualstereo_bit      = 0;
-    int dynalloc            = 6;
-    int extrabits           = 0;
-
-    int boost[CELT_MAX_BANDS] = { 0 };
-    int trim_offset[CELT_MAX_BANDS];
-    int threshold[CELT_MAX_BANDS];
-    int bits1[CELT_MAX_BANDS];
-    int bits2[CELT_MAX_BANDS];
-
-    /* Spread */
-    if (opus_rc_tell(rc) + 4 <= f->framebits) {
-        if (encode)
-            ff_opus_rc_enc_cdf(rc, f->spread, ff_celt_model_spread);
-        else
-            f->spread = ff_opus_rc_dec_cdf(rc, ff_celt_model_spread);
-    } else {
-        f->spread = CELT_SPREAD_NORMAL;
-    }
-
-    /* Initialize static allocation caps */
-    for (i = 0; i < CELT_MAX_BANDS; i++)
-        f->caps[i] = NORMC((ff_celt_static_caps[f->size][f->channels - 1][i] + 64) * ff_celt_freq_range[i]);
-
-    /* Band boosts */
-    tbits_8ths = f->framebits << 3;
-    for (i = f->start_band; i < f->end_band; i++) {
-        int quanta = ff_celt_freq_range[i] << (f->channels - 1) << f->size;
-        int b_dynalloc = dynalloc;
-        int boost_amount = f->alloc_boost[i];
-        quanta = FFMIN(quanta << 3, FFMAX(6 << 3, quanta));
-
-        while (opus_rc_tell_frac(rc) + (b_dynalloc << 3) < tbits_8ths && boost[i] < f->caps[i]) {
-            int is_boost;
-            if (encode) {
-                is_boost = boost_amount--;
-                ff_opus_rc_enc_log(rc, is_boost, b_dynalloc);
-            } else {
-                is_boost = ff_opus_rc_dec_log(rc, b_dynalloc);
-            }
-
-            if (!is_boost)
-                break;
-
-            boost[i]   += quanta;
-            tbits_8ths -= quanta;
-
-            b_dynalloc = 1;
-        }
-
-        if (boost[i])
-            dynalloc = FFMAX(dynalloc - 1, 2);
-    }
-
-    /* Allocation trim */
-    if (!encode)
-        f->alloc_trim = 5;
-    if (opus_rc_tell_frac(rc) + (6 << 3) <= tbits_8ths)
-        if (encode)
-            ff_opus_rc_enc_cdf(rc, f->alloc_trim, ff_celt_model_alloc_trim);
-        else
-            f->alloc_trim = ff_opus_rc_dec_cdf(rc, ff_celt_model_alloc_trim);
-
-    /* Anti-collapse bit reservation */
-    tbits_8ths = (f->framebits << 3) - opus_rc_tell_frac(rc) - 1;
-    f->anticollapse_needed = 0;
-    if (f->transient && f->size >= 2 && tbits_8ths >= ((f->size + 2) << 3))
-        f->anticollapse_needed = 1 << 3;
-    tbits_8ths -= f->anticollapse_needed;
-
-    /* Band skip bit reservation */
-    if (tbits_8ths >= 1 << 3)
-        skip_bit = 1 << 3;
-    tbits_8ths -= skip_bit;
-
-    /* Intensity/dual stereo bit reservation */
-    if (f->channels == 2) {
-        intensitystereo_bit = ff_celt_log2_frac[f->end_band - f->start_band];
-        if (intensitystereo_bit <= tbits_8ths) {
-            tbits_8ths -= intensitystereo_bit;
-            if (tbits_8ths >= 1 << 3) {
-                dualstereo_bit = 1 << 3;
-                tbits_8ths -= 1 << 3;
-            }
-        } else {
-            intensitystereo_bit = 0;
-        }
-    }
-
-    /* Trim offsets */
-    for (i = f->start_band; i < f->end_band; i++) {
-        int trim     = f->alloc_trim - 5 - f->size;
-        int band     = ff_celt_freq_range[i] * (f->end_band - i - 1);
-        int duration = f->size + 3;
-        int scale    = duration + f->channels - 1;
-
-        /* PVQ minimum allocation threshold, below this value the band is
-         * skipped */
-        threshold[i] = FFMAX(3 * ff_celt_freq_range[i] << duration >> 4,
-                             f->channels << 3);
-
-        trim_offset[i] = trim * (band << scale) >> 6;
-
-        if (ff_celt_freq_range[i] << f->size == 1)
-            trim_offset[i] -= f->channels << 3;
-    }
-
-    /* Bisection */
-    low  = 1;
-    high = CELT_VECTORS - 1;
-    while (low <= high) {
-        int center = (low + high) >> 1;
-        done = total = 0;
-
-        for (i = f->end_band - 1; i >= f->start_band; i--) {
-            bandbits = NORMC(ff_celt_freq_range[i] * ff_celt_static_alloc[center][i]);
-
-            if (bandbits)
-                bandbits = FFMAX(bandbits + trim_offset[i], 0);
-            bandbits += boost[i];
-
-            if (bandbits >= threshold[i] || done) {
-                done = 1;
-                total += FFMIN(bandbits, f->caps[i]);
-            } else if (bandbits >= f->channels << 3) {
-                total += f->channels << 3;
-            }
-        }
-
-        if (total > tbits_8ths)
-            high = center - 1;
-        else
-            low = center + 1;
-    }
-    high = low--;
-
-    /* Bisection */
-    for (i = f->start_band; i < f->end_band; i++) {
-        bits1[i] = NORMC(ff_celt_freq_range[i] * ff_celt_static_alloc[low][i]);
-        bits2[i] = high >= CELT_VECTORS ? f->caps[i] :
-                   NORMC(ff_celt_freq_range[i] * ff_celt_static_alloc[high][i]);
-
-        if (bits1[i])
-            bits1[i] = FFMAX(bits1[i] + trim_offset[i], 0);
-        if (bits2[i])
-            bits2[i] = FFMAX(bits2[i] + trim_offset[i], 0);
-
-        if (low)
-            bits1[i] += boost[i];
-        bits2[i] += boost[i];
-
-        if (boost[i])
-            skip_startband = i;
-        bits2[i] = FFMAX(bits2[i] - bits1[i], 0);
-    }
-
-    /* Bisection */
-    low  = 0;
-    high = 1 << CELT_ALLOC_STEPS;
-    for (i = 0; i < CELT_ALLOC_STEPS; i++) {
-        int center = (low + high) >> 1;
-        done = total = 0;
-
-        for (j = f->end_band - 1; j >= f->start_band; j--) {
-            bandbits = bits1[j] + (center * bits2[j] >> CELT_ALLOC_STEPS);
-
-            if (bandbits >= threshold[j] || done) {
-                done = 1;
-                total += FFMIN(bandbits, f->caps[j]);
-            } else if (bandbits >= f->channels << 3)
-                total += f->channels << 3;
-        }
-        if (total > tbits_8ths)
-            high = center;
-        else
-            low = center;
-    }
-
-    /* Bisection */
-    done = total = 0;
-    for (i = f->end_band - 1; i >= f->start_band; i--) {
-        bandbits = bits1[i] + (low * bits2[i] >> CELT_ALLOC_STEPS);
-
-        if (bandbits >= threshold[i] || done)
-            done = 1;
-        else
-            bandbits = (bandbits >= f->channels << 3) ?
-            f->channels << 3 : 0;
-
-        bandbits     = FFMIN(bandbits, f->caps[i]);
-        f->pulses[i] = bandbits;
-        total      += bandbits;
-    }
-
-    /* Band skipping */
-    for (f->coded_bands = f->end_band; ; f->coded_bands--) {
-        int allocation;
-        j = f->coded_bands - 1;
-
-        if (j == skip_startband) {
-            /* all remaining bands are not skipped */
-            tbits_8ths += skip_bit;
-            break;
-        }
-
-        /* determine the number of bits available for coding "do not skip" markers */
-        remaining   = tbits_8ths - total;
-        bandbits    = remaining / (ff_celt_freq_bands[j+1] - ff_celt_freq_bands[f->start_band]);
-        remaining  -= bandbits  * (ff_celt_freq_bands[j+1] - ff_celt_freq_bands[f->start_band]);
-        allocation  = f->pulses[j] + bandbits * ff_celt_freq_range[j];
-        allocation += FFMAX(remaining - (ff_celt_freq_bands[j] - ff_celt_freq_bands[f->start_band]), 0);
-
-        /* a "do not skip" marker is only coded if the allocation is
-         * above the chosen threshold */
-        if (allocation >= FFMAX(threshold[j], (f->channels + 1) << 3)) {
-            int do_not_skip;
-            if (encode) {
-                do_not_skip = f->coded_bands <= f->skip_band_floor;
-                ff_opus_rc_enc_log(rc, do_not_skip, 1);
-            } else {
-                do_not_skip = ff_opus_rc_dec_log(rc, 1);
-            }
-
-            if (do_not_skip)
-                break;
-
-            total      += 1 << 3;
-            allocation -= 1 << 3;
-        }
-
-        /* the band is skipped, so reclaim its bits */
-        total -= f->pulses[j];
-        if (intensitystereo_bit) {
-            total -= intensitystereo_bit;
-            intensitystereo_bit = ff_celt_log2_frac[j - f->start_band];
-            total += intensitystereo_bit;
-        }
-
-        total += f->pulses[j] = (allocation >= f->channels << 3) ? f->channels << 3 : 0;
-    }
-
-    /* IS start band */
-    if (encode) {
-        if (intensitystereo_bit) {
-            f->intensity_stereo = FFMIN(f->intensity_stereo, f->coded_bands);
-            ff_opus_rc_enc_uint(rc, f->intensity_stereo, f->coded_bands + 1 - f->start_band);
-        }
-    } else {
-        f->intensity_stereo = f->dual_stereo = 0;
-        if (intensitystereo_bit)
-            f->intensity_stereo = f->start_band + ff_opus_rc_dec_uint(rc, f->coded_bands + 1 - f->start_band);
-    }
-
-    /* DS flag */
-    if (f->intensity_stereo <= f->start_band)
-        tbits_8ths += dualstereo_bit; /* no intensity stereo means no dual stereo */
-    else if (dualstereo_bit)
-        if (encode)
-            ff_opus_rc_enc_log(rc, f->dual_stereo, 1);
-        else
-            f->dual_stereo = ff_opus_rc_dec_log(rc, 1);
-
-    /* Supply the remaining bits in this frame to lower bands */
-    remaining = tbits_8ths - total;
-    bandbits  = remaining / (ff_celt_freq_bands[f->coded_bands] - ff_celt_freq_bands[f->start_band]);
-    remaining -= bandbits * (ff_celt_freq_bands[f->coded_bands] - ff_celt_freq_bands[f->start_band]);
-    for (i = f->start_band; i < f->coded_bands; i++) {
-        const int bits = FFMIN(remaining, ff_celt_freq_range[i]);
-        f->pulses[i] += bits + bandbits * ff_celt_freq_range[i];
-        remaining    -= bits;
-    }
-
-    /* Finally determine the allocation */
-    for (i = f->start_band; i < f->coded_bands; i++) {
-        int N = ff_celt_freq_range[i] << f->size;
-        int prev_extra = extrabits;
-        f->pulses[i] += extrabits;
-
-        if (N > 1) {
-            int dof;        /* degrees of freedom */
-            int temp;       /* dof * channels * log(dof) */
-            int fine_bits;
-            int max_bits;
-            int offset;     /* fine energy quantization offset, i.e.
-                             * extra bits assigned over the standard
-                             * totalbits/dof */
-
-            extrabits = FFMAX(f->pulses[i] - f->caps[i], 0);
-            f->pulses[i] -= extrabits;
-
-            /* intensity stereo makes use of an extra degree of freedom */
-            dof = N * f->channels + (f->channels == 2 && N > 2 && !f->dual_stereo && i < f->intensity_stereo);
-            temp = dof * (ff_celt_log_freq_range[i] + (f->size << 3));
-            offset = (temp >> 1) - dof * CELT_FINE_OFFSET;
-            if (N == 2) /* dof=2 is the only case that doesn't fit the model */
-                offset += dof << 1;
-
-            /* grant an additional bias for the first and second pulses */
-            if (f->pulses[i] + offset < 2 * (dof << 3))
-                offset += temp >> 2;
-            else if (f->pulses[i] + offset < 3 * (dof << 3))
-                offset += temp >> 3;
-
-            fine_bits = (f->pulses[i] + offset + (dof << 2)) / (dof << 3);
-            max_bits  = FFMIN((f->pulses[i] >> 3) >> (f->channels - 1), CELT_MAX_FINE_BITS);
-            max_bits  = FFMAX(max_bits, 0);
-            f->fine_bits[i] = av_clip(fine_bits, 0, max_bits);
-
-            /* If fine_bits was rounded down or capped,
-             * give priority for the final fine energy pass */
-            f->fine_priority[i] = (f->fine_bits[i] * (dof << 3) >= f->pulses[i] + offset);
-
-            /* the remaining bits are assigned to PVQ */
-            f->pulses[i] -= f->fine_bits[i] << (f->channels - 1) << 3;
-        } else {
-            /* all bits go to fine energy except for the sign bit */
-            extrabits = FFMAX(f->pulses[i] - (f->channels << 3), 0);
-            f->pulses[i] -= extrabits;
-            f->fine_bits[i] = 0;
-            f->fine_priority[i] = 1;
-        }
-
-        /* hand back a limited number of extra fine energy bits to this band */
-        if (extrabits > 0) {
-            int fineextra = FFMIN(extrabits >> (f->channels + 2),
-                                  CELT_MAX_FINE_BITS - f->fine_bits[i]);
-            f->fine_bits[i] += fineextra;
-
-            fineextra <<= f->channels + 2;
-            f->fine_priority[i] = (fineextra >= extrabits - prev_extra);
-            extrabits -= fineextra;
-        }
-    }
-    f->remaining = extrabits;
-
-    /* skipped bands dedicate all of their bits for fine energy */
-    for (; i < f->end_band; i++) {
-        f->fine_bits[i]     = f->pulses[i] >> (f->channels - 1) >> 3;
-        f->pulses[i]        = 0;
-        f->fine_priority[i] = f->fine_bits[i] < 1;
-    }
-}
--- a/third_party/ffmpeg/libavcodec/opus.h
+++ b/third_party/ffmpeg/libavcodec/opus.h
@@ -1,5 +1,5 @@
 /*
- * Opus decoder/demuxer common functions
+ * Opus common header
  * Copyright (c) 2012 Andrew D'Addesio
  * Copyright (c) 2013-2014 Mozilla Corporation
  *
@@ -25,31 +25,9 @@
 
 #include <stdint.h>
 
-#include "libavutil/audio_fifo.h"
-#include "libavutil/float_dsp.h"
-#include "libavutil/frame.h"
-#include "libavutil/mem_internal.h"
-
-#include "libswresample/swresample.h"
-
-#include "avcodec.h"
-#include "opus_rc.h"
-
-#define MAX_FRAME_SIZE               1275
-#define MAX_FRAMES                   48
-#define MAX_PACKET_DUR               5760
-
-#define CELT_SHORT_BLOCKSIZE         120
-#define CELT_OVERLAP                 CELT_SHORT_BLOCKSIZE
-#define CELT_MAX_LOG_BLOCKS          3
-#define CELT_MAX_FRAME_SIZE          (CELT_SHORT_BLOCKSIZE * (1 << CELT_MAX_LOG_BLOCKS))
-#define CELT_MAX_BANDS               21
-
-#define SILK_HISTORY                 322
-#define SILK_MAX_LPC                 16
-
-#define ROUND_MULL(a,b,s) (((MUL64(a, b) >> ((s) - 1)) + 1) >> 1)
-#define ROUND_MUL16(a,b)  ((MUL16(a, b) + 16384) >> 15)
+#define OPUS_MAX_FRAME_SIZE          1275
+#define OPUS_MAX_FRAMES                48
+#define OPUS_MAX_PACKET_DUR          5760
 
 #define OPUS_TS_HEADER     0x7FE0        // 0x3ff (11 bits)
 #define OPUS_TS_MASK       0xFFE0        // top 11 bits
@@ -78,124 +56,4 @@
     OPUS_BANDWITH_NB
 };
 
-typedef struct SilkContext SilkContext;
-
-typedef struct CeltFrame CeltFrame;
-
-typedef struct OpusPacket {
-    int packet_size;                /**< packet size */
-    int data_size;                  /**< size of the useful data -- packet size - padding */
-    int code;                       /**< packet code: specifies the frame layout */
-    int stereo;                     /**< whether this packet is mono or stereo */
-    int vbr;                        /**< vbr flag */
-    int config;                     /**< configuration: tells the audio mode,
-                                     **                bandwidth, and frame duration */
-    int frame_count;                /**< frame count */
-    int frame_offset[MAX_FRAMES];   /**< frame offsets */
-    int frame_size[MAX_FRAMES];     /**< frame sizes */
-    int frame_duration;             /**< frame duration, in samples @ 48kHz */
-    enum OpusMode mode;             /**< mode */
-    enum OpusBandwidth bandwidth;   /**< bandwidth */
-} OpusPacket;
-
-typedef struct OpusStreamContext {
-    AVCodecContext *avctx;
-    int output_channels;
-
-    /* number of decoded samples for this stream */
-    int decoded_samples;
-    /* current output buffers for this stream */
-    float *out[2];
-    int out_size;
-    /* Buffer with samples from this stream for synchronizing
-     * the streams when they have different resampling delays */
-    AVAudioFifo *sync_buffer;
-
-    OpusRangeCoder rc;
-    OpusRangeCoder redundancy_rc;
-    SilkContext *silk;
-    CeltFrame *celt;
-    AVFloatDSPContext *fdsp;
-
-    float silk_buf[2][960];
-    float *silk_output[2];
-    DECLARE_ALIGNED(32, float, celt_buf)[2][960];
-    float *celt_output[2];
-
-    DECLARE_ALIGNED(32, float, redundancy_buf)[2][960];
-    float *redundancy_output[2];
-
-    /* buffers for the next samples to be decoded */
-    float *cur_out[2];
-    int remaining_out_size;
-
-    float *out_dummy;
-    int    out_dummy_allocated_size;
-
-    SwrContext *swr;
-    AVAudioFifo *celt_delay;
-    int silk_samplerate;
-    /* number of samples we still want to get from the resampler */
-    int delayed_samples;
-
-    OpusPacket packet;
-
-    int redundancy_idx;
-} OpusStreamContext;
-
-// a mapping between an opus stream and an output channel
-typedef struct ChannelMap {
-    int stream_idx;
-    int channel_idx;
-
-    // when a single decoded channel is mapped to multiple output channels, we
-    // write to the first output directly and copy from it to the others
-    // this field is set to 1 for those copied output channels
-    int copy;
-    // this is the index of the output channel to copy from
-    int copy_idx;
-
-    // this channel is silent
-    int silence;
-} ChannelMap;
-
-typedef struct OpusContext {
-    AVClass *av_class;
-    OpusStreamContext *streams;
-    int apply_phase_inv;
-
-    int             nb_streams;
-    int      nb_stereo_streams;
-
-    AVFloatDSPContext *fdsp;
-    int16_t gain_i;
-    float   gain;
-
-    ChannelMap *channel_maps;
-} OpusContext;
-
-int ff_opus_parse_packet(OpusPacket *pkt, const uint8_t *buf, int buf_size,
-                         int self_delimited);
-
-int ff_opus_parse_extradata(AVCodecContext *avctx, OpusContext *s);
-
-int ff_silk_init(AVCodecContext *avctx, SilkContext **ps, int output_channels);
-void ff_silk_free(SilkContext **ps);
-void ff_silk_flush(SilkContext *s);
-
-/**
- * Decode the LP layer of one Opus frame (which may correspond to several SILK
- * frames).
- */
-int ff_silk_decode_superframe(SilkContext *s, OpusRangeCoder *rc,
-                              float *output[2],
-                              enum OpusBandwidth bandwidth, int coded_channels,
-                              int duration_ms);
-
-/* Encode or decode CELT bands */
-void ff_celt_quant_bands(CeltFrame *f, OpusRangeCoder *rc);
-
-/* Encode or decode CELT bitallocation */
-void ff_celt_bitalloc(CeltFrame *f, OpusRangeCoder *rc, int encode);
-
 #endif /* AVCODEC_OPUS_H */
--- a/third_party/ffmpeg/libavcodec/opus_celt.c
+++ b/third_party/ffmpeg/libavcodec/opus_celt.c
@@ -1,7 +1,6 @@
 /*
  * Copyright (c) 2012 Andrew D'Addesio
  * Copyright (c) 2013-2014 Mozilla Corporation
- * Copyright (c) 2016 Rostislav Pehlivanov <atomnuker@gmail.com>
  *
  * This file is part of FFmpeg.
  *
@@ -20,561 +19,466 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-/**
- * @file
- * Opus CELT decoder
- */
+#include <stdint.h>
 
 #include "opus_celt.h"
-#include "opustab.h"
 #include "opus_pvq.h"
+#include "opustab.h"
 
-/* Use the 2D z-transform to apply prediction in both the time domain (alpha)
- * and the frequency domain (beta) */
-static void celt_decode_coarse_energy(CeltFrame *f, OpusRangeCoder *rc)
+void ff_celt_quant_bands(CeltFrame *f, OpusRangeCoder *rc)
 {
-    int i, j;
-    float prev[2] = { 0 };
-    float alpha = ff_celt_alpha_coef[f->size];
-    float beta  = ff_celt_beta_coef[f->size];
-    const uint8_t *model = ff_celt_coarse_energy_dist[f->size][0];
-
-    /* intra frame */
-    if (opus_rc_tell(rc) + 3 <= f->framebits && ff_opus_rc_dec_log(rc, 3)) {
-        alpha = 0.0f;
-        beta  = 1.0f - (4915.0f/32768.0f);
-        model = ff_celt_coarse_energy_dist[f->size][1];
-    }
-
-    for (i = 0; i < CELT_MAX_BANDS; i++) {
-        for (j = 0; j < f->channels; j++) {
-            CeltBlock *block = &f->block[j];
-            float value;
-            int available;
-
-            if (i < f->start_band || i >= f->end_band) {
-                block->energy[i] = 0.0;
-                continue;
-            }
+    float lowband_scratch[8 * 22];
+    float norm1[2 * 8 * 100];
+    float *norm2 = norm1 + 8 * 100;
 
-            available = f->framebits - opus_rc_tell(rc);
-            if (available >= 15) {
-                /* decode using a Laplace distribution */
-                int k = FFMIN(i, 20) << 1;
-                value = ff_opus_rc_dec_laplace(rc, model[k] << 7, model[k+1] << 6);
-            } else if (available >= 2) {
-                int x = ff_opus_rc_dec_cdf(rc, ff_celt_model_energy_small);
-                value = (x>>1) ^ -(x&1);
-            } else if (available >= 1) {
-                value = -(float)ff_opus_rc_dec_log(rc, 1);
-            } else value = -1;
+    int totalbits = (f->framebits << 3) - f->anticollapse_needed;
 
-            block->energy[i] = FFMAX(-9.0f, block->energy[i]) * alpha + prev[j] + value;
-            prev[j] += beta * value;
-        }
-    }
-}
+    int update_lowband = 1;
+    int lowband_offset = 0;
 
-static void celt_decode_fine_energy(CeltFrame *f, OpusRangeCoder *rc)
-{
-    int i;
-    for (i = f->start_band; i < f->end_band; i++) {
-        int j;
-        if (!f->fine_bits[i])
-            continue;
-
-        for (j = 0; j < f->channels; j++) {
-            CeltBlock *block = &f->block[j];
-            int q2;
-            float offset;
-            q2 = ff_opus_rc_get_raw(rc, f->fine_bits[i]);
-            offset = (q2 + 0.5f) * (1 << (14 - f->fine_bits[i])) / 16384.0f - 0.5f;
-            block->energy[i] += offset;
-        }
-    }
-}
-
-static void celt_decode_final_energy(CeltFrame *f, OpusRangeCoder *rc)
-{
-    int priority, i, j;
-    int bits_left = f->framebits - opus_rc_tell(rc);
+    int i, j;
 
-    for (priority = 0; priority < 2; priority++) {
-        for (i = f->start_band; i < f->end_band && bits_left >= f->channels; i++) {
-            if (f->fine_priority[i] != priority || f->fine_bits[i] >= CELT_MAX_FINE_BITS)
-                continue;
-
-            for (j = 0; j < f->channels; j++) {
-                int q2;
-                float offset;
-                q2 = ff_opus_rc_get_raw(rc, 1);
-                offset = (q2 - 0.5f) * (1 << (14 - f->fine_bits[i] - 1)) / 16384.0f;
-                f->block[j].energy[i] += offset;
-                bits_left--;
+    for (i = f->start_band; i < f->end_band; i++) {
+        uint32_t cm[2] = { (1 << f->blocks) - 1, (1 << f->blocks) - 1 };
+        int band_offset = ff_celt_freq_bands[i] << f->size;
+        int band_size   = ff_celt_freq_range[i] << f->size;
+        float *X = f->block[0].coeffs + band_offset;
+        float *Y = (f->channels == 2) ? f->block[1].coeffs + band_offset : NULL;
+        float *norm_loc1, *norm_loc2;
+
+        int consumed = opus_rc_tell_frac(rc);
+        int effective_lowband = -1;
+        int b = 0;
+
+        /* Compute how many bits we want to allocate to this band */
+        if (i != f->start_band)
+            f->remaining -= consumed;
+        f->remaining2 = totalbits - consumed - 1;
+        if (i <= f->coded_bands - 1) {
+            int curr_balance = f->remaining / FFMIN(3, f->coded_bands-i);
+            b = av_clip_uintp2(FFMIN(f->remaining2 + 1, f->pulses[i] + curr_balance), 14);
+        }
+
+        if ((ff_celt_freq_bands[i] - ff_celt_freq_range[i] >= ff_celt_freq_bands[f->start_band] ||
+            i == f->start_band + 1) && (update_lowband || lowband_offset == 0))
+            lowband_offset = i;
+
+        if (i == f->start_band + 1) {
+            /* Special Hybrid Folding (RFC 8251 section 9). Copy the first band into
+            the second to ensure the second band never has to use the LCG. */
+            int count = (ff_celt_freq_range[i] - ff_celt_freq_range[i-1]) << f->size;
+
+            memcpy(&norm1[band_offset], &norm1[band_offset - count], count * sizeof(float));
+
+            if (f->channels == 2)
+                memcpy(&norm2[band_offset], &norm2[band_offset - count], count * sizeof(float));
+        }
+
+        /* Get a conservative estimate of the collapse_mask's for the bands we're
+           going to be folding from. */
+        if (lowband_offset != 0 && (f->spread != CELT_SPREAD_AGGRESSIVE ||
+                                    f->blocks > 1 || f->tf_change[i] < 0)) {
+            int foldstart, foldend;
+
+            /* This ensures we never repeat spectral content within one band */
+            effective_lowband = FFMAX(ff_celt_freq_bands[f->start_band],
+                                      ff_celt_freq_bands[lowband_offset] - ff_celt_freq_range[i]);
+            foldstart = lowband_offset;
+            while (ff_celt_freq_bands[--foldstart] > effective_lowband);
+            foldend = lowband_offset - 1;
+            while (++foldend < i && ff_celt_freq_bands[foldend] < effective_lowband + ff_celt_freq_range[i]);
+
+            cm[0] = cm[1] = 0;
+            for (j = foldstart; j < foldend; j++) {
+                cm[0] |= f->block[0].collapse_masks[j];
+                cm[1] |= f->block[f->channels - 1].collapse_masks[j];
             }
         }
-    }
-}
 
-static void celt_decode_tf_changes(CeltFrame *f, OpusRangeCoder *rc)
-{
-    int i, diff = 0, tf_select = 0, tf_changed = 0, tf_select_bit;
-    int consumed, bits = f->transient ? 2 : 4;
+        if (f->dual_stereo && i == f->intensity_stereo) {
+            /* Switch off dual stereo to do intensity */
+            f->dual_stereo = 0;
+            for (j = ff_celt_freq_bands[f->start_band] << f->size; j < band_offset; j++)
+                norm1[j] = (norm1[j] + norm2[j]) / 2;
+        }
+
+        norm_loc1 = effective_lowband != -1 ? norm1 + (effective_lowband << f->size) : NULL;
+        norm_loc2 = effective_lowband != -1 ? norm2 + (effective_lowband << f->size) : NULL;
+
+        if (f->dual_stereo) {
+            cm[0] = f->pvq->quant_band(f->pvq, f, rc, i, X, NULL, band_size, b >> 1,
+                                       f->blocks, norm_loc1, f->size,
+                                       norm1 + band_offset, 0, 1.0f,
+                                       lowband_scratch, cm[0]);
+
+            cm[1] = f->pvq->quant_band(f->pvq, f, rc, i, Y, NULL, band_size, b >> 1,
+                                       f->blocks, norm_loc2, f->size,
+                                       norm2 + band_offset, 0, 1.0f,
+                                       lowband_scratch, cm[1]);
+        } else {
+            cm[0] = f->pvq->quant_band(f->pvq, f, rc, i, X,    Y, band_size, b >> 0,
+                                       f->blocks, norm_loc1, f->size,
+                                       norm1 + band_offset, 0, 1.0f,
+                                       lowband_scratch, cm[0] | cm[1]);
+            cm[1] = cm[0];
+        }
 
-    consumed = opus_rc_tell(rc);
-    tf_select_bit = (f->size != 0 && consumed+bits+1 <= f->framebits);
+        f->block[0].collapse_masks[i]               = (uint8_t)cm[0];
+        f->block[f->channels - 1].collapse_masks[i] = (uint8_t)cm[1];
+        f->remaining += f->pulses[i] + consumed;
 
-    for (i = f->start_band; i < f->end_band; i++) {
-        if (consumed+bits+tf_select_bit <= f->framebits) {
-            diff ^= ff_opus_rc_dec_log(rc, bits);
-            consumed = opus_rc_tell(rc);
-            tf_changed |= diff;
-        }
-        f->tf_change[i] = diff;
-        bits = f->transient ? 4 : 5;
-    }
-
-    if (tf_select_bit && ff_celt_tf_select[f->size][f->transient][0][tf_changed] !=
-                         ff_celt_tf_select[f->size][f->transient][1][tf_changed])
-        tf_select = ff_opus_rc_dec_log(rc, 1);
-
-    for (i = f->start_band; i < f->end_band; i++) {
-        f->tf_change[i] = ff_celt_tf_select[f->size][f->transient][tf_select][f->tf_change[i]];
+        /* Update the folding position only as long as we have 1 bit/sample depth */
+        update_lowband = (b > band_size << 3);
     }
 }
 
-static void celt_denormalize(CeltFrame *f, CeltBlock *block, float *data)
-{
-    int i, j;
-
-    for (i = f->start_band; i < f->end_band; i++) {
-        float *dst = data + (ff_celt_freq_bands[i] << f->size);
-        float log_norm = block->energy[i] + ff_celt_mean_energy[i];
-        float norm = exp2f(FFMIN(log_norm, 32.0f));
-
-        for (j = 0; j < ff_celt_freq_range[i] << f->size; j++)
-            dst[j] *= norm;
-    }
-}
+#define NORMC(bits) ((bits) << (f->channels - 1) << f->size >> 2)
 
-static void celt_postfilter_apply_transition(CeltBlock *block, float *data)
+void ff_celt_bitalloc(CeltFrame *f, OpusRangeCoder *rc, int encode)
 {
-    const int T0 = block->pf_period_old;
-    const int T1 = block->pf_period;
+    int i, j, low, high, total, done, bandbits, remaining, tbits_8ths;
+    int skip_startband      = f->start_band;
+    int skip_bit            = 0;
+    int intensitystereo_bit = 0;
+    int dualstereo_bit      = 0;
+    int dynalloc            = 6;
+    int extrabits           = 0;
 
-    float g00, g01, g02;
-    float g10, g11, g12;
+    int boost[CELT_MAX_BANDS] = { 0 };
+    int trim_offset[CELT_MAX_BANDS];
+    int threshold[CELT_MAX_BANDS];
+    int bits1[CELT_MAX_BANDS];
+    int bits2[CELT_MAX_BANDS];
 
-    float x0, x1, x2, x3, x4;
-
-    int i;
-
-    if (block->pf_gains[0]     == 0.0 &&
-        block->pf_gains_old[0] == 0.0)
-        return;
-
-    g00 = block->pf_gains_old[0];
-    g01 = block->pf_gains_old[1];
-    g02 = block->pf_gains_old[2];
-    g10 = block->pf_gains[0];
-    g11 = block->pf_gains[1];
-    g12 = block->pf_gains[2];
-
-    x1 = data[-T1 + 1];
-    x2 = data[-T1];
-    x3 = data[-T1 - 1];
-    x4 = data[-T1 - 2];
-
-    for (i = 0; i < CELT_OVERLAP; i++) {
-        float w = ff_celt_window2[i];
-        x0 = data[i - T1 + 2];
-
-        data[i] +=  (1.0 - w) * g00 * data[i - T0]                          +
-                    (1.0 - w) * g01 * (data[i - T0 - 1] + data[i - T0 + 1]) +
-                    (1.0 - w) * g02 * (data[i - T0 - 2] + data[i - T0 + 2]) +
-                    w         * g10 * x2                                    +
-                    w         * g11 * (x1 + x3)                             +
-                    w         * g12 * (x0 + x4);
-        x4 = x3;
-        x3 = x2;
-        x2 = x1;
-        x1 = x0;
+    /* Spread */
+    if (opus_rc_tell(rc) + 4 <= f->framebits) {
+        if (encode)
+            ff_opus_rc_enc_cdf(rc, f->spread, ff_celt_model_spread);
+        else
+            f->spread = ff_opus_rc_dec_cdf(rc, ff_celt_model_spread);
+    } else {
+        f->spread = CELT_SPREAD_NORMAL;
     }
-}
-
-static void celt_postfilter(CeltFrame *f, CeltBlock *block)
-{
-    int len = f->blocksize * f->blocks;
-    const int filter_len = len - 2 * CELT_OVERLAP;
-
-    celt_postfilter_apply_transition(block, block->buf + 1024);
 
-    block->pf_period_old = block->pf_period;
-    memcpy(block->pf_gains_old, block->pf_gains, sizeof(block->pf_gains));
+    /* Initialize static allocation caps */
+    for (i = 0; i < CELT_MAX_BANDS; i++)
+        f->caps[i] = NORMC((ff_celt_static_caps[f->size][f->channels - 1][i] + 64) * ff_celt_freq_range[i]);
 
-    block->pf_period = block->pf_period_new;
-    memcpy(block->pf_gains, block->pf_gains_new, sizeof(block->pf_gains));
-
-    if (len > CELT_OVERLAP) {
-        celt_postfilter_apply_transition(block, block->buf + 1024 + CELT_OVERLAP);
-
-        if (block->pf_gains[0] > FLT_EPSILON && filter_len > 0)
-            f->opusdsp.postfilter(block->buf + 1024 + 2 * CELT_OVERLAP,
-                                  block->pf_period, block->pf_gains,
-                                  filter_len);
-
-        block->pf_period_old = block->pf_period;
-        memcpy(block->pf_gains_old, block->pf_gains, sizeof(block->pf_gains));
-    }
+    /* Band boosts */
+    tbits_8ths = f->framebits << 3;
+    for (i = f->start_band; i < f->end_band; i++) {
+        int quanta = ff_celt_freq_range[i] << (f->channels - 1) << f->size;
+        int b_dynalloc = dynalloc;
+        int boost_amount = f->alloc_boost[i];
+        quanta = FFMIN(quanta << 3, FFMAX(6 << 3, quanta));
+
+        while (opus_rc_tell_frac(rc) + (b_dynalloc << 3) < tbits_8ths && boost[i] < f->caps[i]) {
+            int is_boost;
+            if (encode) {
+                is_boost = boost_amount--;
+                ff_opus_rc_enc_log(rc, is_boost, b_dynalloc);
+            } else {
+                is_boost = ff_opus_rc_dec_log(rc, b_dynalloc);
+            }
 
-    memmove(block->buf, block->buf + len, (1024 + CELT_OVERLAP / 2) * sizeof(float));
-}
+            if (!is_boost)
+                break;
 
-static int parse_postfilter(CeltFrame *f, OpusRangeCoder *rc, int consumed)
-{
-    int i;
+            boost[i]   += quanta;
+            tbits_8ths -= quanta;
 
-    memset(f->block[0].pf_gains_new, 0, sizeof(f->block[0].pf_gains_new));
-    memset(f->block[1].pf_gains_new, 0, sizeof(f->block[1].pf_gains_new));
+            b_dynalloc = 1;
+        }
 
-    if (f->start_band == 0 && consumed + 16 <= f->framebits) {
-        int has_postfilter = ff_opus_rc_dec_log(rc, 1);
-        if (has_postfilter) {
-            float gain;
-            int tapset, octave, period;
-
-            octave = ff_opus_rc_dec_uint(rc, 6);
-            period = (16 << octave) + ff_opus_rc_get_raw(rc, 4 + octave) - 1;
-            gain   = 0.09375f * (ff_opus_rc_get_raw(rc, 3) + 1);
-            tapset = (opus_rc_tell(rc) + 2 <= f->framebits) ?
-                     ff_opus_rc_dec_cdf(rc, ff_celt_model_tapset) : 0;
-
-            for (i = 0; i < 2; i++) {
-                CeltBlock *block = &f->block[i];
-
-                block->pf_period_new = FFMAX(period, CELT_POSTFILTER_MINPERIOD);
-                block->pf_gains_new[0] = gain * ff_celt_postfilter_taps[tapset][0];
-                block->pf_gains_new[1] = gain * ff_celt_postfilter_taps[tapset][1];
-                block->pf_gains_new[2] = gain * ff_celt_postfilter_taps[tapset][2];
+        if (boost[i])
+            dynalloc = FFMAX(dynalloc - 1, 2);
+    }
+
+    /* Allocation trim */
+    if (!encode)
+        f->alloc_trim = 5;
+    if (opus_rc_tell_frac(rc) + (6 << 3) <= tbits_8ths)
+        if (encode)
+            ff_opus_rc_enc_cdf(rc, f->alloc_trim, ff_celt_model_alloc_trim);
+        else
+            f->alloc_trim = ff_opus_rc_dec_cdf(rc, ff_celt_model_alloc_trim);
+
+    /* Anti-collapse bit reservation */
+    tbits_8ths = (f->framebits << 3) - opus_rc_tell_frac(rc) - 1;
+    f->anticollapse_needed = 0;
+    if (f->transient && f->size >= 2 && tbits_8ths >= ((f->size + 2) << 3))
+        f->anticollapse_needed = 1 << 3;
+    tbits_8ths -= f->anticollapse_needed;
+
+    /* Band skip bit reservation */
+    if (tbits_8ths >= 1 << 3)
+        skip_bit = 1 << 3;
+    tbits_8ths -= skip_bit;
+
+    /* Intensity/dual stereo bit reservation */
+    if (f->channels == 2) {
+        intensitystereo_bit = ff_celt_log2_frac[f->end_band - f->start_band];
+        if (intensitystereo_bit <= tbits_8ths) {
+            tbits_8ths -= intensitystereo_bit;
+            if (tbits_8ths >= 1 << 3) {
+                dualstereo_bit = 1 << 3;
+                tbits_8ths -= 1 << 3;
             }
+        } else {
+            intensitystereo_bit = 0;
         }
-
-        consumed = opus_rc_tell(rc);
     }
 
-    return consumed;
-}
-
-static void process_anticollapse(CeltFrame *f, CeltBlock *block, float *X)
-{
-    int i, j, k;
-
+    /* Trim offsets */
     for (i = f->start_band; i < f->end_band; i++) {
-        int renormalize = 0;
-        float *xptr;
-        float prev[2];
-        float Ediff, r;
-        float thresh, sqrt_1;
-        int depth;
-
-        /* depth in 1/8 bits */
-        depth = (1 + f->pulses[i]) / (ff_celt_freq_range[i] << f->size);
-        thresh = exp2f(-1.0 - 0.125f * depth);
-        sqrt_1 = 1.0f / sqrtf(ff_celt_freq_range[i] << f->size);
-
-        xptr = X + (ff_celt_freq_bands[i] << f->size);
-
-        prev[0] = block->prev_energy[0][i];
-        prev[1] = block->prev_energy[1][i];
-        if (f->channels == 1) {
-            CeltBlock *block1 = &f->block[1];
-
-            prev[0] = FFMAX(prev[0], block1->prev_energy[0][i]);
-            prev[1] = FFMAX(prev[1], block1->prev_energy[1][i]);
-        }
-        Ediff = block->energy[i] - FFMIN(prev[0], prev[1]);
-        Ediff = FFMAX(0, Ediff);
-
-        /* r needs to be multiplied by 2 or 2*sqrt(2) depending on LM because
-        short blocks don't have the same energy as long */
-        r = exp2f(1 - Ediff);
-        if (f->size == 3)
-            r *= M_SQRT2;
-        r = FFMIN(thresh, r) * sqrt_1;
-        for (k = 0; k < 1 << f->size; k++) {
-            /* Detect collapse */
-            if (!(block->collapse_masks[i] & 1 << k)) {
-                /* Fill with noise */
-                for (j = 0; j < ff_celt_freq_range[i]; j++)
-                    xptr[(j << f->size) + k] = (celt_rng(f) & 0x8000) ? r : -r;
-                renormalize = 1;
+        int trim     = f->alloc_trim - 5 - f->size;
+        int band     = ff_celt_freq_range[i] * (f->end_band - i - 1);
+        int duration = f->size + 3;
+        int scale    = duration + f->channels - 1;
+
+        /* PVQ minimum allocation threshold, below this value the band is
+         * skipped */
+        threshold[i] = FFMAX(3 * ff_celt_freq_range[i] << duration >> 4,
+                             f->channels << 3);
+
+        trim_offset[i] = trim * (band << scale) >> 6;
+
+        if (ff_celt_freq_range[i] << f->size == 1)
+            trim_offset[i] -= f->channels << 3;
+    }
+
+    /* Bisection */
+    low  = 1;
+    high = CELT_VECTORS - 1;
+    while (low <= high) {
+        int center = (low + high) >> 1;
+        done = total = 0;
+
+        for (i = f->end_band - 1; i >= f->start_band; i--) {
+            bandbits = NORMC(ff_celt_freq_range[i] * ff_celt_static_alloc[center][i]);
+
+            if (bandbits)
+                bandbits = FFMAX(bandbits + trim_offset[i], 0);
+            bandbits += boost[i];
+
+            if (bandbits >= threshold[i] || done) {
+                done = 1;
+                total += FFMIN(bandbits, f->caps[i]);
+            } else if (bandbits >= f->channels << 3) {
+                total += f->channels << 3;
             }
         }
 
-        /* We just added some energy, so we need to renormalize */
-        if (renormalize)
-            celt_renormalize_vector(xptr, ff_celt_freq_range[i] << f->size, 1.0f);
-    }
-}
-
-int ff_celt_decode_frame(CeltFrame *f, OpusRangeCoder *rc,
-                         float **output, int channels, int frame_size,
-                         int start_band,  int end_band)
-{
-    int i, j, downmix = 0;
-    int consumed;           // bits of entropy consumed thus far for this frame
-    MDCT15Context *imdct;
-
-    if (channels != 1 && channels != 2) {
-        av_log(f->avctx, AV_LOG_ERROR, "Invalid number of coded channels: %d\n",
-               channels);
-        return AVERROR_INVALIDDATA;
-    }
-    if (start_band < 0 || start_band > end_band || end_band > CELT_MAX_BANDS) {
-        av_log(f->avctx, AV_LOG_ERROR, "Invalid start/end band: %d %d\n",
-               start_band, end_band);
-        return AVERROR_INVALIDDATA;
+        if (total > tbits_8ths)
+            high = center - 1;
+        else
+            low = center + 1;
     }
+    high = low--;
 
-    f->silence        = 0;
-    f->transient      = 0;
-    f->anticollapse   = 0;
-    f->flushed        = 0;
-    f->channels       = channels;
-    f->start_band     = start_band;
-    f->end_band       = end_band;
-    f->framebits      = rc->rb.bytes * 8;
-
-    f->size = av_log2(frame_size / CELT_SHORT_BLOCKSIZE);
-    if (f->size > CELT_MAX_LOG_BLOCKS ||
-        frame_size != CELT_SHORT_BLOCKSIZE * (1 << f->size)) {
-        av_log(f->avctx, AV_LOG_ERROR, "Invalid CELT frame size: %d\n",
-               frame_size);
-        return AVERROR_INVALIDDATA;
-    }
-
-    if (!f->output_channels)
-        f->output_channels = channels;
-
-    for (i = 0; i < f->channels; i++) {
-        memset(f->block[i].coeffs,         0, sizeof(f->block[i].coeffs));
-        memset(f->block[i].collapse_masks, 0, sizeof(f->block[i].collapse_masks));
-    }
-
-    consumed = opus_rc_tell(rc);
-
-    /* obtain silence flag */
-    if (consumed >= f->framebits)
-        f->silence = 1;
-    else if (consumed == 1)
-        f->silence = ff_opus_rc_dec_log(rc, 15);
-
-
-    if (f->silence) {
-        consumed = f->framebits;
-        rc->total_bits += f->framebits - opus_rc_tell(rc);
-    }
-
-    /* obtain post-filter options */
-    consumed = parse_postfilter(f, rc, consumed);
-
-    /* obtain transient flag */
-    if (f->size != 0 && consumed+3 <= f->framebits)
-        f->transient = ff_opus_rc_dec_log(rc, 3);
-
-    f->blocks    = f->transient ? 1 << f->size : 1;
-    f->blocksize = frame_size / f->blocks;
-
-    imdct = f->imdct[f->transient ? 0 : f->size];
-
-    if (channels == 1) {
-        for (i = 0; i < CELT_MAX_BANDS; i++)
-            f->block[0].energy[i] = FFMAX(f->block[0].energy[i], f->block[1].energy[i]);
-    }
-
-    celt_decode_coarse_energy(f, rc);
-    celt_decode_tf_changes   (f, rc);
-    ff_celt_bitalloc         (f, rc, 0);
-    celt_decode_fine_energy  (f, rc);
-    ff_celt_quant_bands      (f, rc);
-
-    if (f->anticollapse_needed)
-        f->anticollapse = ff_opus_rc_get_raw(rc, 1);
-
-    celt_decode_final_energy(f, rc);
-
-    /* apply anti-collapse processing and denormalization to
-     * each coded channel */
-    for (i = 0; i < f->channels; i++) {
-        CeltBlock *block = &f->block[i];
-
-        if (f->anticollapse)
-            process_anticollapse(f, block, f->block[i].coeffs);
-
-        celt_denormalize(f, block, f->block[i].coeffs);
-    }
-
-    /* stereo -> mono downmix */
-    if (f->output_channels < f->channels) {
-        f->dsp->vector_fmac_scalar(f->block[0].coeffs, f->block[1].coeffs, 1.0, FFALIGN(frame_size, 16));
-        downmix = 1;
-    } else if (f->output_channels > f->channels)
-        memcpy(f->block[1].coeffs, f->block[0].coeffs, frame_size * sizeof(float));
-
-    if (f->silence) {
-        for (i = 0; i < 2; i++) {
-            CeltBlock *block = &f->block[i];
-
-            for (j = 0; j < FF_ARRAY_ELEMS(block->energy); j++)
-                block->energy[j] = CELT_ENERGY_SILENCE;
-        }
-        memset(f->block[0].coeffs, 0, sizeof(f->block[0].coeffs));
-        memset(f->block[1].coeffs, 0, sizeof(f->block[1].coeffs));
-    }
-
-    /* transform and output for each output channel */
-    for (i = 0; i < f->output_channels; i++) {
-        CeltBlock *block = &f->block[i];
+    /* Bisection */
+    for (i = f->start_band; i < f->end_band; i++) {
+        bits1[i] = NORMC(ff_celt_freq_range[i] * ff_celt_static_alloc[low][i]);
+        bits2[i] = high >= CELT_VECTORS ? f->caps[i] :
+                   NORMC(ff_celt_freq_range[i] * ff_celt_static_alloc[high][i]);
+
+        if (bits1[i])
+            bits1[i] = FFMAX(bits1[i] + trim_offset[i], 0);
+        if (bits2[i])
+            bits2[i] = FFMAX(bits2[i] + trim_offset[i], 0);
+
+        if (low)
+            bits1[i] += boost[i];
+        bits2[i] += boost[i];
+
+        if (boost[i])
+            skip_startband = i;
+        bits2[i] = FFMAX(bits2[i] - bits1[i], 0);
+    }
+
+    /* Bisection */
+    low  = 0;
+    high = 1 << CELT_ALLOC_STEPS;
+    for (i = 0; i < CELT_ALLOC_STEPS; i++) {
+        int center = (low + high) >> 1;
+        done = total = 0;
+
+        for (j = f->end_band - 1; j >= f->start_band; j--) {
+            bandbits = bits1[j] + (center * bits2[j] >> CELT_ALLOC_STEPS);
+
+            if (bandbits >= threshold[j] || done) {
+                done = 1;
+                total += FFMIN(bandbits, f->caps[j]);
+            } else if (bandbits >= f->channels << 3)
+                total += f->channels << 3;
+        }
+        if (total > tbits_8ths)
+            high = center;
+        else
+            low = center;
+    }
+
+    /* Bisection */
+    done = total = 0;
+    for (i = f->end_band - 1; i >= f->start_band; i--) {
+        bandbits = bits1[i] + (low * bits2[i] >> CELT_ALLOC_STEPS);
+
+        if (bandbits >= threshold[i] || done)
+            done = 1;
+        else
+            bandbits = (bandbits >= f->channels << 3) ?
+            f->channels << 3 : 0;
+
+        bandbits     = FFMIN(bandbits, f->caps[i]);
+        f->pulses[i] = bandbits;
+        total      += bandbits;
+    }
+
+    /* Band skipping */
+    for (f->coded_bands = f->end_band; ; f->coded_bands--) {
+        int allocation;
+        j = f->coded_bands - 1;
+
+        if (j == skip_startband) {
+            /* all remaining bands are not skipped */
+            tbits_8ths += skip_bit;
+            break;
+        }
+
+        /* determine the number of bits available for coding "do not skip" markers */
+        remaining   = tbits_8ths - total;
+        bandbits    = remaining / (ff_celt_freq_bands[j+1] - ff_celt_freq_bands[f->start_band]);
+        remaining  -= bandbits  * (ff_celt_freq_bands[j+1] - ff_celt_freq_bands[f->start_band]);
+        allocation  = f->pulses[j] + bandbits * ff_celt_freq_range[j];
+        allocation += FFMAX(remaining - (ff_celt_freq_bands[j] - ff_celt_freq_bands[f->start_band]), 0);
+
+        /* a "do not skip" marker is only coded if the allocation is
+         * above the chosen threshold */
+        if (allocation >= FFMAX(threshold[j], (f->channels + 1) << 3)) {
+            int do_not_skip;
+            if (encode) {
+                do_not_skip = f->coded_bands <= f->skip_band_floor;
+                ff_opus_rc_enc_log(rc, do_not_skip, 1);
+            } else {
+                do_not_skip = ff_opus_rc_dec_log(rc, 1);
+            }
 
-        /* iMDCT and overlap-add */
-        for (j = 0; j < f->blocks; j++) {
-            float *dst  = block->buf + 1024 + j * f->blocksize;
+            if (do_not_skip)
+                break;
 
-            imdct->imdct_half(imdct, dst + CELT_OVERLAP / 2, f->block[i].coeffs + j,
-                              f->blocks);
-            f->dsp->vector_fmul_window(dst, dst, dst + CELT_OVERLAP / 2,
-                                       ff_celt_window, CELT_OVERLAP / 2);
+            total      += 1 << 3;
+            allocation -= 1 << 3;
         }
 
-        if (downmix)
-            f->dsp->vector_fmul_scalar(&block->buf[1024], &block->buf[1024], 0.5f, frame_size);
-
-        /* postfilter */
-        celt_postfilter(f, block);
-
-        /* deemphasis */
-        block->emph_coeff = f->opusdsp.deemphasis(output[i],
-                                                  &block->buf[1024 - frame_size],
-                                                  block->emph_coeff, frame_size);
-    }
+        /* the band is skipped, so reclaim its bits */
+        total -= f->pulses[j];
+        if (intensitystereo_bit) {
+            total -= intensitystereo_bit;
+            intensitystereo_bit = ff_celt_log2_frac[j - f->start_band];
+            total += intensitystereo_bit;
+        }
+
+        total += f->pulses[j] = (allocation >= f->channels << 3) ? f->channels << 3 : 0;
+    }
+
+    /* IS start band */
+    if (encode) {
+        if (intensitystereo_bit) {
+            f->intensity_stereo = FFMIN(f->intensity_stereo, f->coded_bands);
+            ff_opus_rc_enc_uint(rc, f->intensity_stereo, f->coded_bands + 1 - f->start_band);
+        }
+    } else {
+        f->intensity_stereo = f->dual_stereo = 0;
+        if (intensitystereo_bit)
+            f->intensity_stereo = f->start_band + ff_opus_rc_dec_uint(rc, f->coded_bands + 1 - f->start_band);
+    }
+
+    /* DS flag */
+    if (f->intensity_stereo <= f->start_band)
+        tbits_8ths += dualstereo_bit; /* no intensity stereo means no dual stereo */
+    else if (dualstereo_bit)
+        if (encode)
+            ff_opus_rc_enc_log(rc, f->dual_stereo, 1);
+        else
+            f->dual_stereo = ff_opus_rc_dec_log(rc, 1);
+
+    /* Supply the remaining bits in this frame to lower bands */
+    remaining = tbits_8ths - total;
+    bandbits  = remaining / (ff_celt_freq_bands[f->coded_bands] - ff_celt_freq_bands[f->start_band]);
+    remaining -= bandbits * (ff_celt_freq_bands[f->coded_bands] - ff_celt_freq_bands[f->start_band]);
+    for (i = f->start_band; i < f->coded_bands; i++) {
+        const int bits = FFMIN(remaining, ff_celt_freq_range[i]);
+        f->pulses[i] += bits + bandbits * ff_celt_freq_range[i];
+        remaining    -= bits;
+    }
+
+    /* Finally determine the allocation */
+    for (i = f->start_band; i < f->coded_bands; i++) {
+        int N = ff_celt_freq_range[i] << f->size;
+        int prev_extra = extrabits;
+        f->pulses[i] += extrabits;
+
+        if (N > 1) {
+            int dof;        /* degrees of freedom */
+            int temp;       /* dof * channels * log(dof) */
+            int fine_bits;
+            int max_bits;
+            int offset;     /* fine energy quantization offset, i.e.
+                             * extra bits assigned over the standard
+                             * totalbits/dof */
+
+            extrabits = FFMAX(f->pulses[i] - f->caps[i], 0);
+            f->pulses[i] -= extrabits;
+
+            /* intensity stereo makes use of an extra degree of freedom */
+            dof = N * f->channels + (f->channels == 2 && N > 2 && !f->dual_stereo && i < f->intensity_stereo);
+            temp = dof * (ff_celt_log_freq_range[i] + (f->size << 3));
+            offset = (temp >> 1) - dof * CELT_FINE_OFFSET;
+            if (N == 2) /* dof=2 is the only case that doesn't fit the model */
+                offset += dof << 1;
+
+            /* grant an additional bias for the first and second pulses */
+            if (f->pulses[i] + offset < 2 * (dof << 3))
+                offset += temp >> 2;
+            else if (f->pulses[i] + offset < 3 * (dof << 3))
+                offset += temp >> 3;
+
+            fine_bits = (f->pulses[i] + offset + (dof << 2)) / (dof << 3);
+            max_bits  = FFMIN((f->pulses[i] >> 3) >> (f->channels - 1), CELT_MAX_FINE_BITS);
+            max_bits  = FFMAX(max_bits, 0);
+            f->fine_bits[i] = av_clip(fine_bits, 0, max_bits);
+
+            /* If fine_bits was rounded down or capped,
+             * give priority for the final fine energy pass */
+            f->fine_priority[i] = (f->fine_bits[i] * (dof << 3) >= f->pulses[i] + offset);
 
-    if (channels == 1)
-        memcpy(f->block[1].energy, f->block[0].energy, sizeof(f->block[0].energy));
-
-    for (i = 0; i < 2; i++ ) {
-        CeltBlock *block = &f->block[i];
-
-        if (!f->transient) {
-            memcpy(block->prev_energy[1], block->prev_energy[0], sizeof(block->prev_energy[0]));
-            memcpy(block->prev_energy[0], block->energy,         sizeof(block->prev_energy[0]));
+            /* the remaining bits are assigned to PVQ */
+            f->pulses[i] -= f->fine_bits[i] << (f->channels - 1) << 3;
         } else {
-            for (j = 0; j < CELT_MAX_BANDS; j++)
-                block->prev_energy[0][j] = FFMIN(block->prev_energy[0][j], block->energy[j]);
-        }
-
-        for (j = 0; j < f->start_band; j++) {
-            block->prev_energy[0][j] = CELT_ENERGY_SILENCE;
-            block->energy[j]         = 0.0;
-        }
-        for (j = f->end_band; j < CELT_MAX_BANDS; j++) {
-            block->prev_energy[0][j] = CELT_ENERGY_SILENCE;
-            block->energy[j]         = 0.0;
-        }
+            /* all bits go to fine energy except for the sign bit */
+            extrabits = FFMAX(f->pulses[i] - (f->channels << 3), 0);
+            f->pulses[i] -= extrabits;
+            f->fine_bits[i] = 0;
+            f->fine_priority[i] = 1;
+        }
+
+        /* hand back a limited number of extra fine energy bits to this band */
+        if (extrabits > 0) {
+            int fineextra = FFMIN(extrabits >> (f->channels + 2),
+                                  CELT_MAX_FINE_BITS - f->fine_bits[i]);
+            f->fine_bits[i] += fineextra;
+
+            fineextra <<= f->channels + 2;
+            f->fine_priority[i] = (fineextra >= extrabits - prev_extra);
+            extrabits -= fineextra;
+        }
+    }
+    f->remaining = extrabits;
+
+    /* skipped bands dedicate all of their bits for fine energy */
+    for (; i < f->end_band; i++) {
+        f->fine_bits[i]     = f->pulses[i] >> (f->channels - 1) >> 3;
+        f->pulses[i]        = 0;
+        f->fine_priority[i] = f->fine_bits[i] < 1;
     }
-
-    f->seed = rc->range;
-
-    return 0;
-}
-
-void ff_celt_flush(CeltFrame *f)
-{
-    int i, j;
-
-    if (f->flushed)
-        return;
-
-    for (i = 0; i < 2; i++) {
-        CeltBlock *block = &f->block[i];
-
-        for (j = 0; j < CELT_MAX_BANDS; j++)
-            block->prev_energy[0][j] = block->prev_energy[1][j] = CELT_ENERGY_SILENCE;
-
-        memset(block->energy, 0, sizeof(block->energy));
-        memset(block->buf,    0, sizeof(block->buf));
-
-        memset(block->pf_gains,     0, sizeof(block->pf_gains));
-        memset(block->pf_gains_old, 0, sizeof(block->pf_gains_old));
-        memset(block->pf_gains_new, 0, sizeof(block->pf_gains_new));
-
-        /* libopus uses CELT_EMPH_COEFF on init, but 0 is better since there's
-         * a lesser discontinuity when seeking.
-         * The deemphasis functions differ from libopus in that they require
-         * an initial state divided by the coefficient. */
-        block->emph_coeff = 0.0f / CELT_EMPH_COEFF;
-    }
-    f->seed = 0;
-
-    f->flushed = 1;
-}
-
-void ff_celt_free(CeltFrame **f)
-{
-    CeltFrame *frm = *f;
-    int i;
-
-    if (!frm)
-        return;
-
-    for (i = 0; i < FF_ARRAY_ELEMS(frm->imdct); i++)
-        ff_mdct15_uninit(&frm->imdct[i]);
-
-    ff_celt_pvq_uninit(&frm->pvq);
-
-    av_freep(&frm->dsp);
-    av_freep(f);
-}
-
-int ff_celt_init(AVCodecContext *avctx, CeltFrame **f, int output_channels,
-                 int apply_phase_inv)
-{
-    CeltFrame *frm;
-    int i, ret;
-
-    if (output_channels != 1 && output_channels != 2) {
-        av_log(avctx, AV_LOG_ERROR, "Invalid number of output channels: %d\n",
-               output_channels);
-        return AVERROR(EINVAL);
-    }
-
-    frm = av_mallocz(sizeof(*frm));
-    if (!frm)
-        return AVERROR(ENOMEM);
-
-    frm->avctx           = avctx;
-    frm->output_channels = output_channels;
-    frm->apply_phase_inv = apply_phase_inv;
-
-    for (i = 0; i < FF_ARRAY_ELEMS(frm->imdct); i++)
-        if ((ret = ff_mdct15_init(&frm->imdct[i], 1, i + 3, -1.0f/32768)) < 0)
-            goto fail;
-
-    if ((ret = ff_celt_pvq_init(&frm->pvq, 0)) < 0)
-        goto fail;
-
-    frm->dsp = avpriv_float_dsp_alloc(avctx->flags & AV_CODEC_FLAG_BITEXACT);
-    if (!frm->dsp) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-
-    ff_opus_dsp_init(&frm->opusdsp);
-    ff_celt_flush(frm);
-
-    *f = frm;
-
-    return 0;
-fail:
-    ff_celt_free(&frm);
-    return ret;
 }
--- a/third_party/ffmpeg/libavcodec/opus_celt.h
+++ b/third_party/ffmpeg/libavcodec/opus_celt.h
@@ -1,5 +1,5 @@
 /*
- * Opus decoder/demuxer common functions
+ * Opus decoder/encoder CELT functions
  * Copyright (c) 2012 Andrew D'Addesio
  * Copyright (c) 2013-2014 Mozilla Corporation
  * Copyright (c) 2016 Rostislav Pehlivanov <atomnuker@gmail.com>
@@ -24,16 +24,22 @@
 #ifndef AVCODEC_OPUS_CELT_H
 #define AVCODEC_OPUS_CELT_H
 
-#include <float.h>
+#include <stdint.h>
 
-#include "opus.h"
-#include "opus_pvq.h"
+#include "avcodec.h"
 #include "opusdsp.h"
+#include "opus_rc.h"
 
-#include "mdct15.h"
 #include "libavutil/float_dsp.h"
 #include "libavutil/libm.h"
 #include "libavutil/mem_internal.h"
+#include "libavutil/tx.h"
+
+#define CELT_SHORT_BLOCKSIZE         120
+#define CELT_OVERLAP                 CELT_SHORT_BLOCKSIZE
+#define CELT_MAX_LOG_BLOCKS          3
+#define CELT_MAX_FRAME_SIZE          (CELT_SHORT_BLOCKSIZE * (1 << CELT_MAX_LOG_BLOCKS))
+#define CELT_MAX_BANDS               21
 
 #define CELT_VECTORS                 11
 #define CELT_ALLOC_STEPS             6
@@ -45,8 +51,6 @@
 #define CELT_POSTFILTER_MINPERIOD    15
 #define CELT_ENERGY_SILENCE          (-28.0f)
 
-typedef struct CeltPVQ CeltPVQ;
-
 enum CeltSpread {
     CELT_SPREAD_NONE,
     CELT_SPREAD_LIGHT,
@@ -90,13 +94,14 @@
     float emph_coeff;
 } CeltBlock;
 
-struct CeltFrame {
+typedef struct CeltFrame {
     // constant values that do not change during context lifetime
     AVCodecContext      *avctx;
-    MDCT15Context       *imdct[4];
+    AVTXContext        *tx[4];
+    av_tx_fn            tx_fn[4];
     AVFloatDSPContext   *dsp;
     CeltBlock           block[2];
-    CeltPVQ             *pvq;
+    struct CeltPVQ      *pvq;
     OpusDSP             opusdsp;
     int channels;
     int output_channels;
@@ -138,7 +143,7 @@
     int fine_priority[CELT_MAX_BANDS];
     int pulses       [CELT_MAX_BANDS];
     int tf_change    [CELT_MAX_BANDS];
-};
+} CeltFrame;
 
 /* LCG for noise generation */
 static av_always_inline uint32_t celt_rng(CeltFrame *f)
@@ -169,4 +174,10 @@
 int ff_celt_decode_frame(CeltFrame *f, OpusRangeCoder *rc, float **output,
                          int coded_channels, int frame_size, int startband, int endband);
 
+/* Encode or decode CELT bands */
+void ff_celt_quant_bands(CeltFrame *f, OpusRangeCoder *rc);
+
+/* Encode or decode CELT bitallocation */
+void ff_celt_bitalloc(CeltFrame *f, OpusRangeCoder *rc, int encode);
+
 #endif /* AVCODEC_OPUS_CELT_H */
--- a/third_party/ffmpeg/libavcodec/opus_parser.c
+++ b/third_party/ffmpeg/libavcodec/opus_parser.c
@@ -28,15 +28,16 @@
 #include "avcodec.h"
 #include "bytestream.h"
 #include "opus.h"
+#include "opus_parse.h"
 #include "parser.h"
 
-typedef struct OpusParseContext {
+typedef struct OpusParserContext {
     ParseContext pc;
-    OpusContext ctx;
+    OpusParseContext ctx;
     OpusPacket pkt;
     int extradata_parsed;
     int ts_framing;
-} OpusParseContext;
+} OpusParserContext;
 
 static const uint8_t *parse_opus_ts_header(const uint8_t *start, int *payload_len, int buf_len)
 {
@@ -83,7 +84,7 @@
 static int opus_find_frame_end(AVCodecParserContext *ctx, AVCodecContext *avctx,
                                const uint8_t *buf, int buf_size, int *header_len)
 {
-    OpusParseContext *s = ctx->priv_data;
+    OpusParserContext *s = ctx->priv_data;
     ParseContext *pc    = &s->pc;
     int ret, start_found, i = 0, payload_len = 0;
     const uint8_t *payload;
@@ -166,7 +167,7 @@
                        const uint8_t **poutbuf, int *poutbuf_size,
                        const uint8_t *buf, int buf_size)
 {
-    OpusParseContext *s = ctx->priv_data;
+    OpusParserContext *s = ctx->priv_data;
     ParseContext *pc    = &s->pc;
     int next, header_len;
 
@@ -192,7 +193,7 @@
 
 const AVCodecParser ff_opus_parser = {
     .codec_ids      = { AV_CODEC_ID_OPUS },
-    .priv_data_size = sizeof(OpusParseContext),
+    .priv_data_size = sizeof(OpusParserContext),
     .parser_parse   = opus_parse,
     .parser_close   = ff_parse_close
 };
--- a/third_party/ffmpeg/libavcodec/opus_pvq.c
+++ b/third_party/ffmpeg/libavcodec/opus_pvq.c
@@ -23,11 +23,16 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <float.h>
+
 #include "config_components.h"
 
+#include "mathops.h"
 #include "opustab.h"
 #include "opus_pvq.h"
 
+#define ROUND_MUL16(a,b)  ((MUL16(a, b) + 16384) >> 15)
+
 #define CELT_PVQ_U(n, k) (ff_celt_pvq_u_row[FFMIN(n, k)][FFMAX(n, k)])
 #define CELT_PVQ_V(n, k) (CELT_PVQ_U(n, k) + CELT_PVQ_U(n, (k) + 1))
 
@@ -361,6 +366,7 @@
     return celt_cwrsi(N, K, idx, y);
 }
 
+#if CONFIG_OPUS_ENCODER
 /*
  * Faster than libopus's search, operates entirely in the signed domain.
  * Slightly worse/better depending on N, K and the input vector.
@@ -413,6 +419,7 @@
 
     return (float)y_norm;
 }
+#endif
 
 static uint32_t celt_alg_quant(OpusRangeCoder *rc, float *X, uint32_t N, uint32_t K,
                                enum CeltSpread spread, uint32_t blocks, float gain,
@@ -902,12 +909,14 @@
     if (!s)
         return AVERROR(ENOMEM);
 
-    s->pvq_search = ppp_pvq_search_c;
     s->quant_band = encode ? pvq_encode_band : pvq_decode_band;
 
-#if CONFIG_OPUS_ENCODER && ARCH_X86
+#if CONFIG_OPUS_ENCODER
+    s->pvq_search = ppp_pvq_search_c;
+#if ARCH_X86
     ff_celt_pvq_init_x86(s);
 #endif
+#endif
 
     *pvq = s;
 
--- a/third_party/ffmpeg/libavcodec/opus_pvq.h
+++ b/third_party/ffmpeg/libavcodec/opus_pvq.h
@@ -34,13 +34,13 @@
                                        float *lowband_out, int level, float gain,    \
                                        float *lowband_scratch, int fill)
 
-struct CeltPVQ {
+typedef struct CeltPVQ {
     DECLARE_ALIGNED(32, int,   qcoeff      )[256];
     DECLARE_ALIGNED(32, float, hadamard_tmp)[256];
 
     float (*pvq_search)(float *X, int *y, int K, int N);
     QUANT_FN(*quant_band);
-};
+} CeltPVQ;
 
 void ff_celt_pvq_init_x86(struct CeltPVQ *s);
 
--- a/third_party/ffmpeg/libavcodec/opus_rc.c
+++ b/third_party/ffmpeg/libavcodec/opus_rc.c
@@ -390,7 +390,7 @@
         int i, lap;
         uint8_t *rb_src, *rb_dst;
         ff_opus_rc_put_raw(rc, 0, 32 - rc->rb.cachelen);
-        rb_src = rc->buf + OPUS_MAX_PACKET_SIZE + 12 - rc->rb.bytes;
+        rb_src = rc->buf + OPUS_MAX_FRAME_SIZE + 12 - rc->rb.bytes;
         rb_dst = dst + FFMAX(size - rc->rb.bytes, 0);
         lap = &dst[rng_bytes] - rb_dst;
         for (i = 0; i < lap; i++)
@@ -407,5 +407,5 @@
     rc->rem = -1;
     rc->ext =  0;
     rc->rng_cur = rc->buf;
-    ff_opus_rc_dec_raw_init(rc, rc->buf + OPUS_MAX_PACKET_SIZE + 8, 0);
+    ff_opus_rc_dec_raw_init(rc, rc->buf + OPUS_MAX_FRAME_SIZE + 8, 0);
 }
--- a/third_party/ffmpeg/libavcodec/opus_rc.h
+++ b/third_party/ffmpeg/libavcodec/opus_rc.h
@@ -25,8 +25,7 @@
 
 #include <stdint.h>
 #include "get_bits.h"
-
-#define OPUS_MAX_PACKET_SIZE 1275
+#include "opus.h"
 
 #define opus_ilog(i) (av_log2(i) + !!(i))
 
@@ -45,7 +44,7 @@
     uint32_t total_bits;
 
     /* Encoder */
-    uint8_t buf[OPUS_MAX_PACKET_SIZE + 12]; /* memcpy vs (memmove + overreading) */
+    uint8_t buf[OPUS_MAX_FRAME_SIZE + 12]; /* memcpy vs (memmove + overreading) */
     uint8_t *rng_cur;                      /* Current range coded byte */
     int ext;                               /* Awaiting propagation */
     int rem;                               /* Carryout flag */
--- a/third_party/ffmpeg/libavcodec/opus_silk.c
+++ b/third_party/ffmpeg/libavcodec/opus_silk.c
@@ -26,9 +26,14 @@
 
 #include <stdint.h>
 
+#include "mathops.h"
 #include "opus.h"
+#include "opus_rc.h"
+#include "opus_silk.h"
 #include "opustab.h"
 
+#define ROUND_MULL(a,b,s) (((MUL64(a, b) >> ((s) - 1)) + 1) >> 1)
+
 typedef struct SilkFrame {
     int coded;
     int log_gain;
@@ -833,6 +838,8 @@
                 int active1 = (j == 0 && !(redundancy[1] & (1 << i))) ? 0 : 1;
                 silk_decode_frame(s, rc, i, j, coded_channels, 1, active1, 1);
             }
+
+        s->midonly = 0;
     }
 
     for (i = 0; i < nb_frames; i++) {
--- a/third_party/ffmpeg/libavcodec/opusdec.c
+++ b/third_party/ffmpeg/libavcodec/opusdec.c
@@ -38,6 +38,10 @@
 #include "libavutil/attributes.h"
 #include "libavutil/audio_fifo.h"
 #include "libavutil/channel_layout.h"
+#include "libavutil/ffmath.h"
+#include "libavutil/float_dsp.h"
+#include "libavutil/frame.h"
+#include "libavutil/mem_internal.h"
 #include "libavutil/opt.h"
 
 #include "libswresample/swresample.h"
@@ -48,6 +52,9 @@
 #include "opus.h"
 #include "opustab.h"
 #include "opus_celt.h"
+#include "opus_parse.h"
+#include "opus_rc.h"
+#include "opus_silk.h"
 
 static const uint16_t silk_frame_duration_ms[16] = {
     10, 20, 40, 60,
@@ -63,6 +70,63 @@
     4, 8, 11, 11, 11
 };
 
+typedef struct OpusStreamContext {
+    AVCodecContext *avctx;
+    int output_channels;
+
+    /* number of decoded samples for this stream */
+    int decoded_samples;
+    /* current output buffers for this stream */
+    float *out[2];
+    int out_size;
+    /* Buffer with samples from this stream for synchronizing
+     * the streams when they have different resampling delays */
+    AVAudioFifo *sync_buffer;
+
+    OpusRangeCoder rc;
+    OpusRangeCoder redundancy_rc;
+    SilkContext *silk;
+    CeltFrame *celt;
+    AVFloatDSPContext *fdsp;
+
+    float silk_buf[2][960];
+    float *silk_output[2];
+    DECLARE_ALIGNED(32, float, celt_buf)[2][960];
+    float *celt_output[2];
+
+    DECLARE_ALIGNED(32, float, redundancy_buf)[2][960];
+    float *redundancy_output[2];
+
+    /* buffers for the next samples to be decoded */
+    float *cur_out[2];
+    int remaining_out_size;
+
+    float *out_dummy;
+    int    out_dummy_allocated_size;
+
+    SwrContext *swr;
+    AVAudioFifo *celt_delay;
+    int silk_samplerate;
+    /* number of samples we still want to get from the resampler */
+    int delayed_samples;
+
+    OpusPacket packet;
+
+    int redundancy_idx;
+} OpusStreamContext;
+
+typedef struct OpusContext {
+    AVClass *av_class;
+
+    struct OpusStreamContext *streams;
+    int apply_phase_inv;
+
+    AVFloatDSPContext *fdsp;
+    float   gain;
+
+    OpusParseContext p;
+} OpusContext;
+
 static int get_silk_samplerate(int config)
 {
     if (config < 4)
@@ -422,7 +486,7 @@
     int i, ret;
 
     /* calculate the number of delayed samples */
-    for (i = 0; i < c->nb_streams; i++) {
+    for (int i = 0; i < c->p.nb_streams; i++) {
         OpusStreamContext *s = &c->streams[i];
         s->out[0] =
         s->out[1] = NULL;
@@ -433,7 +497,7 @@
     /* decode the header of the first sub-packet to find out the sample count */
     if (buf) {
         OpusPacket *pkt = &c->streams[0].packet;
-        ret = ff_opus_parse_packet(pkt, buf, buf_size, c->nb_streams > 1);
+        ret = ff_opus_parse_packet(pkt, buf, buf_size, c->p.nb_streams > 1);
         if (ret < 0) {
             av_log(avctx, AV_LOG_ERROR, "Error parsing the packet header.\n");
             return ret;
@@ -457,13 +521,13 @@
     frame->nb_samples = 0;
 
     for (i = 0; i < avctx->ch_layout.nb_channels; i++) {
-        ChannelMap *map = &c->channel_maps[i];
+        ChannelMap *map = &c->p.channel_maps[i];
         if (!map->copy)
             c->streams[map->stream_idx].out[map->channel_idx] = (float*)frame->extended_data[i];
     }
 
     /* read the data from the sync buffers */
-    for (i = 0; i < c->nb_streams; i++) {
+    for (int i = 0; i < c->p.nb_streams; i++) {
         OpusStreamContext *s = &c->streams[i];
         float          **out = s->out;
         int sync_size = av_audio_fifo_size(s->sync_buffer);
@@ -495,11 +559,11 @@
     }
 
     /* decode each sub-packet */
-    for (i = 0; i < c->nb_streams; i++) {
+    for (int i = 0; i < c->p.nb_streams; i++) {
         OpusStreamContext *s = &c->streams[i];
 
         if (i && buf) {
-            ret = ff_opus_parse_packet(&s->packet, buf, buf_size, i != c->nb_streams - 1);
+            ret = ff_opus_parse_packet(&s->packet, buf, buf_size, i != c->p.nb_streams - 1);
             if (ret < 0) {
                 av_log(avctx, AV_LOG_ERROR, "Error parsing the packet header.\n");
                 return ret;
@@ -525,7 +589,7 @@
     }
 
     /* buffer the extra samples */
-    for (i = 0; i < c->nb_streams; i++) {
+    for (int i = 0; i < c->p.nb_streams; i++) {
         OpusStreamContext *s = &c->streams[i];
         int   buffer_samples = s->decoded_samples - decoded_samples;
         if (buffer_samples) {
@@ -540,7 +604,7 @@
     }
 
     for (i = 0; i < avctx->ch_layout.nb_channels; i++) {
-        ChannelMap *map = &c->channel_maps[i];
+        ChannelMap *map = &c->p.channel_maps[i];
 
         /* handle copied channels */
         if (map->copy) {
@@ -551,7 +615,7 @@
             memset(frame->extended_data[i], 0, frame->linesize[0]);
         }
 
-        if (c->gain_i && decoded_samples > 0) {
+        if (c->p.gain_i && decoded_samples > 0) {
             c->fdsp->vector_fmul_scalar((float*)frame->extended_data[i],
                                        (float*)frame->extended_data[i],
                                        c->gain, FFALIGN(decoded_samples, 8));
@@ -567,9 +631,8 @@
 static av_cold void opus_decode_flush(AVCodecContext *ctx)
 {
     OpusContext *c = ctx->priv_data;
-    int i;
 
-    for (i = 0; i < c->nb_streams; i++) {
+    for (int i = 0; i < c->p.nb_streams; i++) {
         OpusStreamContext *s = &c->streams[i];
 
         memset(&s->packet, 0, sizeof(s->packet));
@@ -588,9 +651,8 @@
 static av_cold int opus_decode_close(AVCodecContext *avctx)
 {
     OpusContext *c = avctx->priv_data;
-    int i;
 
-    for (i = 0; i < c->nb_streams; i++) {
+    for (int i = 0; i < c->p.nb_streams; i++) {
         OpusStreamContext *s = &c->streams[i];
 
         ff_silk_free(&s->silk);
@@ -606,9 +668,9 @@
 
     av_freep(&c->streams);
 
-    c->nb_streams = 0;
+    c->p.nb_streams = 0;
 
-    av_freep(&c->channel_maps);
+    av_freep(&c->p.channel_maps);
     av_freep(&c->fdsp);
 
     return 0;
@@ -617,7 +679,7 @@
 static av_cold int opus_decode_init(AVCodecContext *avctx)
 {
     OpusContext *c = avctx->priv_data;
-    int ret, i, j;
+    int ret;
 
     avctx->sample_fmt  = AV_SAMPLE_FMT_FLTP;
     avctx->sample_rate = 48000;
@@ -627,26 +689,28 @@
         return AVERROR(ENOMEM);
 
     /* find out the channel configuration */
-    ret = ff_opus_parse_extradata(avctx, c);
+    ret = ff_opus_parse_extradata(avctx, &c->p);
     if (ret < 0)
         return ret;
+    if (c->p.gain_i)
+        c->gain = ff_exp10(c->p.gain_i / (20.0 * 256));
 
     /* allocate and init each independent decoder */
-    c->streams = av_calloc(c->nb_streams, sizeof(*c->streams));
+    c->streams = av_calloc(c->p.nb_streams, sizeof(*c->streams));
     if (!c->streams) {
-        c->nb_streams = 0;
+        c->p.nb_streams = 0;
         return AVERROR(ENOMEM);
     }
 
-    for (i = 0; i < c->nb_streams; i++) {
+    for (int i = 0; i < c->p.nb_streams; i++) {
         OpusStreamContext *s = &c->streams[i];
-        uint64_t layout;
+        AVChannelLayout layout;
 
-        s->output_channels = (i < c->nb_stereo_streams) ? 2 : 1;
+        s->output_channels = (i < c->p.nb_stereo_streams) ? 2 : 1;
 
         s->avctx = avctx;
 
-        for (j = 0; j < s->output_channels; j++) {
+        for (int j = 0; j < s->output_channels; j++) {
             s->silk_output[j]       = s->silk_buf[j];
             s->celt_output[j]       = s->celt_buf[j];
             s->redundancy_output[j] = s->redundancy_buf[j];
@@ -658,11 +722,12 @@
         if (!s->swr)
             return AVERROR(ENOMEM);
 
-        layout = (s->output_channels == 1) ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO;
+        layout = (s->output_channels == 1) ? (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO :
+                                             (AVChannelLayout)AV_CHANNEL_LAYOUT_STEREO;
         av_opt_set_int(s->swr, "in_sample_fmt",      avctx->sample_fmt,  0);
         av_opt_set_int(s->swr, "out_sample_fmt",     avctx->sample_fmt,  0);
-        av_opt_set_int(s->swr, "in_channel_layout",  layout,             0);
-        av_opt_set_int(s->swr, "out_channel_layout", layout,             0);
+        av_opt_set_chlayout(s->swr, "in_chlayout",   &layout,            0);
+        av_opt_set_chlayout(s->swr, "out_chlayout",  &layout,            0);
         av_opt_set_int(s->swr, "out_sample_rate",    avctx->sample_rate, 0);
         av_opt_set_int(s->swr, "filter_size",        16,                 0);
 
--- a/third_party/ffmpeg/libavcodec/opusdsp.c
+++ b/third_party/ffmpeg/libavcodec/opusdsp.c
@@ -58,6 +58,8 @@
 
 #if ARCH_AARCH64
     ff_opus_dsp_init_aarch64(ctx);
+#elif ARCH_RISCV
+    ff_opus_dsp_init_riscv(ctx);
 #elif ARCH_X86
     ff_opus_dsp_init_x86(ctx);
 #endif
--- a/third_party/ffmpeg/libavcodec/opusdsp.h
+++ b/third_party/ffmpeg/libavcodec/opusdsp.h
@@ -30,5 +30,6 @@
 
 void ff_opus_dsp_init_x86(OpusDSP *ctx);
 void ff_opus_dsp_init_aarch64(OpusDSP *ctx);
+void ff_opus_dsp_init_riscv(OpusDSP *ctx);
 
 #endif /* AVCODEC_OPUSDSP_H */
--- a/third_party/ffmpeg/libavcodec/opusenc.c
+++ b/third_party/ffmpeg/libavcodec/opusenc.c
@@ -19,6 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <float.h>
+
 #include "encode.h"
 #include "opusenc.h"
 #include "opus_pvq.h"
@@ -40,7 +42,8 @@
     AVCodecContext *avctx;
     AudioFrameQueue afq;
     AVFloatDSPContext *dsp;
-    MDCT15Context *mdct[CELT_BLOCK_NB];
+    AVTXContext *tx[CELT_BLOCK_NB];
+    av_tx_fn tx_fn[CELT_BLOCK_NB];
     CeltPVQ *pvq;
     struct FFBufQueue bufqueue;
 
@@ -202,9 +205,9 @@
                 float *src2 = &b->samples[CELT_OVERLAP*t];
                 s->dsp->vector_fmul(win, src1, ff_celt_window, 128);
                 s->dsp->vector_fmul_reverse(&win[CELT_OVERLAP], src2,
-                                            ff_celt_window - 8, 128);
+                                            ff_celt_window_padded, 128);
                 src1 = src2;
-                s->mdct[0]->mdct(s->mdct[0], b->coeffs + t, win, f->blocks);
+                s->tx_fn[0](s->tx[0], b->coeffs + t, win, sizeof(float)*f->blocks);
             }
         }
     } else {
@@ -223,10 +226,10 @@
 
             /* Samples, windowed */
             s->dsp->vector_fmul_reverse(temp, b->samples + rwin,
-                                        ff_celt_window - 8, 128);
+                                        ff_celt_window_padded, 128);
             memcpy(win + lap_dst + blk_len, temp, CELT_OVERLAP*sizeof(float));
 
-            s->mdct[f->size]->mdct(s->mdct[f->size], b->coeffs, win, 1);
+            s->tx_fn[f->size](s->tx[f->size], b->coeffs, win, sizeof(float));
         }
     }
 
@@ -591,7 +594,7 @@
     opus_packet_assembler(s, avpkt);
 
     /* Update the psychoacoustic system */
-    ff_opus_psy_postencode_update(&s->psyctx, s->frame, s->rc);
+    ff_opus_psy_postencode_update(&s->psyctx, s->frame);
 
     /* Remove samples from queue and skip if needed */
     ff_af_queue_remove(&s->afq, s->packet.frames*frame_size, &avpkt->pts, &avpkt->duration);
@@ -612,7 +615,7 @@
     OpusEncContext *s = avctx->priv_data;
 
     for (int i = 0; i < CELT_BLOCK_NB; i++)
-        ff_mdct15_uninit(&s->mdct[i]);
+        av_tx_uninit(&s->tx[i]);
 
     ff_celt_pvq_uninit(&s->pvq);
     av_freep(&s->dsp);
@@ -668,9 +671,11 @@
         return AVERROR(ENOMEM);
 
     /* I have no idea why a base scaling factor of 68 works, could be the twiddles */
-    for (int i = 0; i < CELT_BLOCK_NB; i++)
-        if ((ret = ff_mdct15_init(&s->mdct[i], 0, i + 3, 68 << (CELT_BLOCK_NB - 1 - i))))
+    for (int i = 0; i < CELT_BLOCK_NB; i++) {
+        const float scale = 68 << (CELT_BLOCK_NB - 1 - i);
+        if ((ret = av_tx_init(&s->tx[i], &s->tx_fn[i], AV_TX_FLOAT_MDCT, 0, 15 << (i + 3), &scale, 0)))
             return AVERROR(ENOMEM);
+    }
 
     /* Zero out previous energy (matters for inter first frame) */
     for (int ch = 0; ch < s->channels; ch++)
@@ -740,10 +745,7 @@
     .close          = opus_encode_end,
     .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.supported_samplerates = (const int []){ 48000, 0 },
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = (const uint64_t []){ AV_CH_LAYOUT_MONO,
-                                            AV_CH_LAYOUT_STEREO, 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO)
     .p.ch_layouts    = (const AVChannelLayout []){ AV_CHANNEL_LAYOUT_MONO,
                                                    AV_CHANNEL_LAYOUT_STEREO, { 0 } },
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLTP,
--- a/third_party/ffmpeg/libavcodec/opusenc.h
+++ b/third_party/ffmpeg/libavcodec/opusenc.h
@@ -22,7 +22,8 @@
 #ifndef AVCODEC_OPUSENC_H
 #define AVCODEC_OPUSENC_H
 
-#include "opus_celt.h"
+#include "libavutil/intmath.h"
+#include "opus.h"
 
 /* Determines the maximum delay the psychoacoustic system will use for lookahead */
 #define FF_BUFQUEUE_SIZE 145
--- a/third_party/ffmpeg/libavcodec/opusenc_psy.c
+++ b/third_party/ffmpeg/libavcodec/opusenc_psy.c
@@ -19,11 +19,13 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <float.h>
+
 #include "opusenc_psy.h"
+#include "opus_celt.h"
 #include "opus_pvq.h"
 #include "opustab.h"
-#include "mdct15.h"
-#include "libavutil/qsort.h"
+#include "libavfilter/window_func.h"
 
 static float pvq_band_cost(CeltPVQ *pvq, CeltFrame *f, OpusRangeCoder *rc, int band,
                            float *bits, float lambda)
@@ -99,7 +101,8 @@
         s->dsp->vector_fmul(s->scratch, s->scratch, s->window[s->bsize_analysis],
                             (OPUS_BLOCK_SIZE(s->bsize_analysis) << 1));
 
-        s->mdct[s->bsize_analysis]->mdct(s->mdct[s->bsize_analysis], st->coeffs[ch], s->scratch, 1);
+        s->mdct_fn[s->bsize_analysis](s->mdct[s->bsize_analysis], st->coeffs[ch],
+                                      s->scratch, sizeof(float));
 
         for (i = 0; i < CELT_MAX_BANDS; i++)
             st->bands[ch][i] = &st->coeffs[ch][ff_celt_freq_bands[i] << s->bsize_analysis];
@@ -356,7 +359,7 @@
     rate /= s->avctx->sample_rate/frame_size;
 
     f_out->framebits = lrintf(rate);
-    f_out->framebits = FFMIN(f_out->framebits, OPUS_MAX_PACKET_SIZE*8);
+    f_out->framebits = FFMIN(f_out->framebits, OPUS_MAX_FRAME_SIZE * 8);
     f_out->framebits = FFALIGN(f_out->framebits, 8);
 }
 
@@ -467,16 +470,13 @@
 
     if (f->transient != start_transient_flag) {
         f->blocks = f->transient ? OPUS_BLOCK_SIZE(s->p.framesize)/CELT_OVERLAP : 1;
-        s->redo_analysis = 1;
         return 1;
     }
 
-    s->redo_analysis = 0;
-
     return 0;
 }
 
-void ff_opus_psy_postencode_update(OpusPsyContext *s, CeltFrame *f, OpusRangeCoder *rc)
+void ff_opus_psy_postencode_update(OpusPsyContext *s, CeltFrame *f)
 {
     int i, frame_size = OPUS_BLOCK_SIZE(s->p.framesize);
     int steps_out = s->p.frames*(frame_size/120);
@@ -506,7 +506,6 @@
 
     s->avg_is_band /= (s->p.frames + 1);
 
-    s->cs_num = 0;
     s->steps_to_process = 0;
     s->buffered_steps -= steps_out;
     s->total_packets_out += s->p.frames;
@@ -518,7 +517,6 @@
 {
     int i, ch, ret;
 
-    s->redo_analysis = 0;
     s->lambda = 1.0f;
     s->options = options;
     s->avctx = avctx;
@@ -558,13 +556,16 @@
     for (i = 0; i < CELT_BLOCK_NB; i++) {
         float tmp;
         const int len = OPUS_BLOCK_SIZE(i);
+        const float scale = 68 << (CELT_BLOCK_NB - 1 - i);
         s->window[i] = av_malloc(2*len*sizeof(float));
         if (!s->window[i]) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         generate_window_func(s->window[i], 2*len, WFUNC_SINE, &tmp);
-        if ((ret = ff_mdct15_init(&s->mdct[i], 0, i + 3, 68 << (CELT_BLOCK_NB - 1 - i))))
+        ret = av_tx_init(&s->mdct[i], &s->mdct_fn[i], AV_TX_FLOAT_MDCT,
+                         0, 15 << (i + 3), &scale, 0);
+        if (ret < 0)
             goto fail;
     }
 
@@ -575,7 +576,7 @@
     av_freep(&s->dsp);
 
     for (i = 0; i < CELT_BLOCK_NB; i++) {
-        ff_mdct15_uninit(&s->mdct[i]);
+        av_tx_uninit(&s->mdct[i]);
         av_freep(&s->window[i]);
     }
 
@@ -598,7 +599,7 @@
     av_freep(&s->dsp);
 
     for (i = 0; i < CELT_BLOCK_NB; i++) {
-        ff_mdct15_uninit(&s->mdct[i]);
+        av_tx_uninit(&s->mdct[i]);
         av_freep(&s->window[i]);
     }
 
--- a/third_party/ffmpeg/libavcodec/opusenc_psy.h
+++ b/third_party/ffmpeg/libavcodec/opusenc_psy.h
@@ -22,11 +22,12 @@
 #ifndef AVCODEC_OPUSENC_PSY_H
 #define AVCODEC_OPUSENC_PSY_H
 
+#include "libavutil/tx.h"
 #include "libavutil/mem_internal.h"
 
 #include "opusenc.h"
+#include "opus_celt.h"
 #include "opusenc_utils.h"
-#include "libavfilter/window_func.h"
 
 /* Each step is 2.5ms */
 typedef struct OpusPsyStep {
@@ -48,20 +49,12 @@
     float excitation_init;
 } OpusBandExcitation;
 
-typedef struct PsyChain {
-    int start;
-    int end;
-} PsyChain;
-
 typedef struct OpusPsyContext {
     AVCodecContext *avctx;
     AVFloatDSPContext *dsp;
     struct FFBufQueue *bufqueue;
     OpusEncOptions *options;
 
-    PsyChain cs[128];
-    int cs_num;
-
     OpusBandExcitation ex[OPUS_MAX_CHANNELS][CELT_MAX_BANDS];
     FFBesselFilter bfilter_lo[OPUS_MAX_CHANNELS][CELT_MAX_BANDS];
     FFBesselFilter bfilter_hi[OPUS_MAX_CHANNELS][CELT_MAX_BANDS];
@@ -70,21 +63,19 @@
     int max_steps;
 
     float *window[CELT_BLOCK_NB];
-    MDCT15Context *mdct[CELT_BLOCK_NB];
+    AVTXContext *mdct[CELT_BLOCK_NB];
+    av_tx_fn mdct_fn[CELT_BLOCK_NB];
     int bsize_analysis;
 
     DECLARE_ALIGNED(32, float, scratch)[2048];
 
     /* Stats */
-    float rc_waste;
     float avg_is_band;
     int64_t dual_stereo_used;
     int64_t total_packets_out;
 
     /* State */
-    FFBesselFilter lambda_lp;
     OpusPacketInfo p;
-    int redo_analysis;
     int buffered_steps;
     int steps_to_process;
     int eof;
@@ -96,7 +87,7 @@
 int  ff_opus_psy_process           (OpusPsyContext *s, OpusPacketInfo *p);
 void ff_opus_psy_celt_frame_init   (OpusPsyContext *s, CeltFrame *f, int index);
 int  ff_opus_psy_celt_frame_process(OpusPsyContext *s, CeltFrame *f, int index);
-void ff_opus_psy_postencode_update (OpusPsyContext *s, CeltFrame *f, OpusRangeCoder *rc);
+void ff_opus_psy_postencode_update (OpusPsyContext *s, CeltFrame *f);
 
 int  ff_opus_psy_init(OpusPsyContext *s, AVCodecContext *avctx,
                       struct FFBufQueue *bufqueue, OpusEncOptions *options);
--- a/third_party/ffmpeg/libavcodec/opusenc_utils.h
+++ b/third_party/ffmpeg/libavcodec/opusenc_utils.h
@@ -22,6 +22,9 @@
 #ifndef AVCODEC_OPUSENC_UTILS_H
 #define AVCODEC_OPUSENC_UTILS_H
 
+#include <math.h>
+#include <string.h>
+
 #include "opus.h"
 
 typedef struct FFBesselFilter {
--- a/third_party/ffmpeg/libavcodec/opustab.c
+++ b/third_party/ffmpeg/libavcodec/opustab.c
@@ -1101,7 +1101,7 @@
     { 0.7998046875f, 0.1000976562f, 0.0           }
 };
 
-DECLARE_ALIGNED(32, static const float, ff_celt_window_padded)[136] = {
+DECLARE_ALIGNED(32, const float, ff_celt_window_padded)[136] = {
     0.00000000f, 0.00000000f, 0.00000000f, 0.00000000f,
     0.00000000f, 0.00000000f, 0.00000000f, 0.00000000f,
     6.7286966e-05f, 0.00060551348f, 0.0016815970f, 0.0032947962f, 0.0054439943f,
@@ -1132,8 +1132,6 @@
     1.00000000f, 1.00000000f, 1.00000000f,
 };
 
-const float *const ff_celt_window = &ff_celt_window_padded[8];
-
 /* square of the window, used for the postfilter */
 const float ff_celt_window2[120] = {
     4.5275357e-09f, 3.66647e-07f, 2.82777e-06f, 1.08557e-05f, 2.96371e-05f, 6.60594e-05f,
--- a/third_party/ffmpeg/libavcodec/opustab.h
+++ b/third_party/ffmpeg/libavcodec/opustab.h
@@ -25,6 +25,9 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
+
+FF_VISIBILITY_PUSH_HIDDEN
 extern const uint8_t  ff_celt_band_end[];
 
 extern const uint8_t  ff_opus_default_coupled_streams[];
@@ -154,8 +157,11 @@
 extern const float    ff_celt_postfilter_taps[3][3];
 
 extern const float    ff_celt_window2[120];
-extern const float *const ff_celt_window;
+
+extern const float    ff_celt_window_padded[];
+static const float *const ff_celt_window = &ff_celt_window_padded[8];
 
 extern const uint32_t * const ff_celt_pvq_u_row[15];
+FF_VISIBILITY_POP_HIDDEN
 
 #endif /* AVCODEC_OPUSTAB_H */
--- a/third_party/ffmpeg/libavcodec/packet.h
+++ b/third_party/ffmpeg/libavcodec/packet.h
@@ -161,7 +161,7 @@
      * the packet may contain "dual mono" audio specific to Japanese DTV
      * and if it is true, recommends only the selected channel to be used.
      * @code
-     * u8    selected channels (0=mail/left, 1=sub/right, 2=both)
+     * u8    selected channels (0=main/left, 1=sub/right, 2=both)
      * @endcode
      */
     AV_PKT_DATA_JP_DUALMONO,
--- a/third_party/ffmpeg/libavcodec/parser.h
+++ b/third_party/ffmpeg/libavcodec/parser.h
@@ -45,8 +45,6 @@
  *         AVERROR(ENOMEM) if there was a memory allocation error
  */
 int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size);
-int ff_mpeg4video_split(AVCodecContext *avctx, const uint8_t *buf,
-                        int buf_size);
 void ff_parse_close(AVCodecParserContext *s);
 
 /**
--- a/third_party/ffmpeg/libavcodec/parsers.c
+++ b/third_party/ffmpeg/libavcodec/parsers.c
@@ -42,6 +42,7 @@
 extern const AVCodecParser ff_dvdsub_parser;
 extern const AVCodecParser ff_dvd_nav_parser;
 extern const AVCodecParser ff_flac_parser;
+extern const AVCodecParser ff_ftr_parser;
 extern const AVCodecParser ff_g723_1_parser;
 extern const AVCodecParser ff_g729_parser;
 extern const AVCodecParser ff_gif_parser;
--- a/third_party/ffmpeg/libavcodec/pcm-blurayenc.c
+++ b/third_party/ffmpeg/libavcodec/pcm-blurayenc.c
@@ -279,8 +279,7 @@
     .init                  = pcm_bluray_encode_init,
     FF_CODEC_ENCODE_CB(pcm_bluray_encode_frame),
     .p.supported_samplerates = (const int[]) { 48000, 96000, 192000, 0 },
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = (const uint64_t[]) {
+    CODEC_OLD_CHANNEL_LAYOUTS(
         AV_CH_LAYOUT_MONO,
         AV_CH_LAYOUT_STEREO,
         AV_CH_LAYOUT_SURROUND,
@@ -290,9 +289,7 @@
         AV_CH_LAYOUT_5POINT0,
         AV_CH_LAYOUT_5POINT1,
         AV_CH_LAYOUT_7POINT0,
-        AV_CH_LAYOUT_7POINT1,
-        0 },
-#endif
+        AV_CH_LAYOUT_7POINT1)
     .p.ch_layouts   = (const AVChannelLayout[]) {
         AV_CHANNEL_LAYOUT_MONO,
         AV_CHANNEL_LAYOUT_STEREO,
--- a/third_party/ffmpeg/libavcodec/pcm-dvdenc.c
+++ b/third_party/ffmpeg/libavcodec/pcm-dvdenc.c
@@ -181,13 +181,8 @@
     .init           = pcm_dvd_encode_init,
     FF_CODEC_ENCODE_CB(pcm_dvd_encode_frame),
     .p.supported_samplerates = (const int[]) { 48000, 96000, 0},
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = (const uint64_t[]) { AV_CH_LAYOUT_MONO,
-                                            AV_CH_LAYOUT_STEREO,
-                                            AV_CH_LAYOUT_5POINT1,
-                                            AV_CH_LAYOUT_7POINT1,
-                                            0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO,
+                              AV_CH_LAYOUT_5POINT1, AV_CH_LAYOUT_7POINT1)
     .p.ch_layouts   = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO,
                                                   AV_CHANNEL_LAYOUT_STEREO,
                                                   AV_CHANNEL_LAYOUT_5POINT1,
--- a/third_party/ffmpeg/libavcodec/photocd.c
+++ b/third_party/ffmpeg/libavcodec/photocd.c
@@ -325,6 +325,9 @@
     if (ret < 0)
         return ret;
 
+    if (avctx->skip_frame >= AVDISCARD_ALL)
+        return avpkt->size;
+
     if ((ret = ff_thread_get_buffer(avctx, p, 0)) < 0)
         return ret;
 
@@ -466,5 +469,6 @@
     .close          = photocd_decode_close,
     FF_CODEC_DECODE_CB(photocd_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     CODEC_LONG_NAME("Kodak Photo CD"),
 };
--- a/third_party/ffmpeg/libavcodec/pixblockdsp.c
+++ b/third_party/ffmpeg/libavcodec/pixblockdsp.c
@@ -109,6 +109,8 @@
     ff_pixblockdsp_init_arm(c, avctx, high_bit_depth);
 #elif ARCH_PPC
     ff_pixblockdsp_init_ppc(c, avctx, high_bit_depth);
+#elif ARCH_RISCV
+    ff_pixblockdsp_init_riscv(c, avctx, high_bit_depth);
 #elif ARCH_X86
     ff_pixblockdsp_init_x86(c, avctx, high_bit_depth);
 #elif ARCH_MIPS
--- a/third_party/ffmpeg/libavcodec/pixblockdsp.h
+++ b/third_party/ffmpeg/libavcodec/pixblockdsp.h
@@ -52,6 +52,8 @@
                              unsigned high_bit_depth);
 void ff_pixblockdsp_init_ppc(PixblockDSPContext *c, AVCodecContext *avctx,
                              unsigned high_bit_depth);
+void ff_pixblockdsp_init_riscv(PixblockDSPContext *c, AVCodecContext *avctx,
+                               unsigned high_bit_depth);
 void ff_pixblockdsp_init_x86(PixblockDSPContext *c, AVCodecContext *avctx,
                              unsigned high_bit_depth);
 void ff_pixblockdsp_init_mips(PixblockDSPContext *c, AVCodecContext *avctx,
--- a/third_party/ffmpeg/libavcodec/pngdec.c
+++ b/third_party/ffmpeg/libavcodec/pngdec.c
@@ -1387,7 +1387,7 @@
     if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {
         size_t byte_depth = s->bit_depth > 8 ? 2 : 1;
         size_t raw_bpp = s->bpp - byte_depth;
-        unsigned x, y;
+        ptrdiff_t x, y;
 
         av_assert0(s->bit_depth > 1);
 
@@ -1723,7 +1723,7 @@
     .close          = png_dec_end,
     FF_CODEC_DECODE_CB(decode_frame_apng),
     UPDATE_THREAD_CONTEXT(update_thread_context),
-    .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,
+    .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
     .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_ALLOCATE_PROGRESS |
                       FF_CODEC_CAP_ICC_PROFILES,
@@ -1741,7 +1741,7 @@
     .close          = png_dec_end,
     FF_CODEC_DECODE_CB(decode_frame_png),
     UPDATE_THREAD_CONTEXT(update_thread_context),
-    .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,
+    .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
     .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM |
                       FF_CODEC_CAP_ALLOCATE_PROGRESS | FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_ICC_PROFILES,
--- a/third_party/ffmpeg/libavcodec/pnmdec.c
+++ b/third_party/ffmpeg/libavcodec/pnmdec.c
@@ -59,6 +59,9 @@
     if ((ret = ff_pnm_decode_header(avctx, s)) < 0)
         return ret;
 
+    if (avctx->skip_frame >= AVDISCARD_ALL)
+        return avpkt->size;
+
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
         return ret;
     p->pict_type = AV_PICTURE_TYPE_I;
@@ -408,6 +411,7 @@
     .p.id           = AV_CODEC_ID_PGM,
     .p.capabilities = AV_CODEC_CAP_DR1,
     .priv_data_size = sizeof(PNMContext),
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(pnm_decode_frame),
 };
 #endif
@@ -420,6 +424,7 @@
     .p.id           = AV_CODEC_ID_PGMYUV,
     .p.capabilities = AV_CODEC_CAP_DR1,
     .priv_data_size = sizeof(PNMContext),
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(pnm_decode_frame),
 };
 #endif
@@ -432,6 +437,7 @@
     .p.id           = AV_CODEC_ID_PPM,
     .p.capabilities = AV_CODEC_CAP_DR1,
     .priv_data_size = sizeof(PNMContext),
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(pnm_decode_frame),
 };
 #endif
@@ -444,6 +450,7 @@
     .p.id           = AV_CODEC_ID_PBM,
     .p.capabilities = AV_CODEC_CAP_DR1,
     .priv_data_size = sizeof(PNMContext),
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(pnm_decode_frame),
 };
 #endif
@@ -456,6 +463,7 @@
     .p.id           = AV_CODEC_ID_PAM,
     .p.capabilities = AV_CODEC_CAP_DR1,
     .priv_data_size = sizeof(PNMContext),
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(pnm_decode_frame),
 };
 #endif
@@ -468,6 +476,7 @@
     .p.id           = AV_CODEC_ID_PFM,
     .p.capabilities = AV_CODEC_CAP_DR1,
     .priv_data_size = sizeof(PNMContext),
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(pnm_decode_frame),
 };
 #endif
@@ -490,6 +499,7 @@
     .p.capabilities = AV_CODEC_CAP_DR1,
     .priv_data_size = sizeof(PNMContext),
     .init           = phm_dec_init,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(pnm_decode_frame),
 };
 #endif
--- a/third_party/ffmpeg/libavcodec/ppc/Makefile
+++ b/third_party/ffmpeg/libavcodec/ppc/Makefile
@@ -14,8 +14,7 @@
 OBJS-$(CONFIG_LLVIDDSP)                += ppc/lossless_videodsp_altivec.o
 OBJS-$(CONFIG_ME_CMP)                  += ppc/me_cmp.o
 OBJS-$(CONFIG_MPEGAUDIODSP)            += ppc/mpegaudiodsp_altivec.o
-OBJS-$(CONFIG_MPEGVIDEO)               += ppc/mpegvideo_altivec.o      \
-                                          ppc/mpegvideodsp.o
+OBJS-$(CONFIG_MPEGVIDEO)               += ppc/mpegvideo_altivec.o
 OBJS-$(CONFIG_MPEGVIDEOENC)            += ppc/mpegvideoencdsp.o
 OBJS-$(CONFIG_PIXBLOCKDSP)             += ppc/pixblockdsp.o
 OBJS-$(CONFIG_VC1DSP)                  += ppc/vc1dsp_altivec.o
@@ -26,6 +25,7 @@
 # decoders/encoders
 OBJS-$(CONFIG_HEVC_DECODER)            += ppc/hevcdsp.o
 OBJS-$(CONFIG_LLAUDDSP)                += ppc/lossless_audiodsp_altivec.o
+OBJS-$(CONFIG_MPEG4_DECODER)           += ppc/mpeg4videodsp.o
 OBJS-$(CONFIG_SVQ1_ENCODER)            += ppc/svq1enc_altivec.o
 OBJS-$(CONFIG_VORBIS_DECODER)          += ppc/vorbisdsp_altivec.o
 OBJS-$(CONFIG_VP7_DECODER)             += ppc/vp8dsp_altivec.o
--- a/third_party/ffmpeg/libavcodec/ppc/mpegvideodsp.c
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * GMC (Global Motion Compensation), AltiVec-enabled
- *
- * Copyright (c) 2003 Romain Dolbeau <romain@dolbeau.org>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libavutil/attributes.h"
-#include "libavutil/cpu.h"
-#include "libavutil/mem_internal.h"
-#include "libavutil/ppc/cpu.h"
-#include "libavutil/ppc/util_altivec.h"
-
-#include "libavcodec/mpegvideodsp.h"
-
-#if HAVE_ALTIVEC
-/* AltiVec-enhanced gmc1. ATM this code assumes stride is a multiple of 8
- * to preserve proper dst alignment. */
-static void gmc1_altivec(uint8_t *dst /* align 8 */, const uint8_t *src /* align1 */,
-                         int stride, int h, int x16, int y16, int rounder)
-{
-    int i;
-    const DECLARE_ALIGNED(16, unsigned short, rounder_a) = rounder;
-    const DECLARE_ALIGNED(16, unsigned short, ABCD)[8] = {
-        (16 - x16) * (16 - y16), /* A */
-             (x16) * (16 - y16), /* B */
-        (16 - x16) * (y16),      /* C */
-             (x16) * (y16),      /* D */
-        0, 0, 0, 0               /* padding */
-    };
-    register const vector unsigned char vczero =
-        (const vector unsigned char) vec_splat_u8(0);
-    register const vector unsigned short vcsr8 =
-        (const vector unsigned short) vec_splat_u16(8);
-    register vector unsigned char dstv, dstv2, srcvB, srcvC, srcvD;
-    register vector unsigned short tempB, tempC, tempD;
-    unsigned long dst_odd        = (unsigned long) dst & 0x0000000F;
-    unsigned long src_really_odd = (unsigned long) src & 0x0000000F;
-    register vector unsigned short tempA =
-        vec_ld(0, (const unsigned short *) ABCD);
-    register vector unsigned short Av = vec_splat(tempA, 0);
-    register vector unsigned short Bv = vec_splat(tempA, 1);
-    register vector unsigned short Cv = vec_splat(tempA, 2);
-    register vector unsigned short Dv = vec_splat(tempA, 3);
-    register vector unsigned short rounderV =
-        vec_splat((vec_u16) vec_lde(0, &rounder_a), 0);
-
-    /* we'll be able to pick-up our 9 char elements at src from those
-     * 32 bytes we load the first batch here, as inside the loop we can
-     * reuse 'src + stride' from one iteration as the 'src' of the next. */
-    register vector unsigned char src_0 = vec_ld(0, src);
-    register vector unsigned char src_1 = vec_ld(16, src);
-    register vector unsigned char srcvA = vec_perm(src_0, src_1,
-                                                   vec_lvsl(0, src));
-
-    if (src_really_odd != 0x0000000F)
-        /* If (src & 0xF) == 0xF, then (src + 1) is properly aligned
-         * on the second vector. */
-        srcvB = vec_perm(src_0, src_1, vec_lvsl(1, src));
-    else
-        srcvB = src_1;
-    srcvA = vec_mergeh(vczero, srcvA);
-    srcvB = vec_mergeh(vczero, srcvB);
-
-    for (i = 0; i < h; i++) {
-        dst_odd        =   (unsigned long) dst            & 0x0000000F;
-        src_really_odd = (((unsigned long) src) + stride) & 0x0000000F;
-
-        dstv = vec_ld(0, dst);
-
-        /* We'll be able to pick-up our 9 char elements at src + stride from
-         * those 32 bytes then reuse the resulting 2 vectors srvcC and srcvD
-         * as the next srcvA and srcvB. */
-        src_0 = vec_ld(stride +  0, src);
-        src_1 = vec_ld(stride + 16, src);
-        srcvC = vec_perm(src_0, src_1, vec_lvsl(stride + 0, src));
-
-        if (src_really_odd != 0x0000000F)
-            /* If (src & 0xF) == 0xF, then (src + 1) is properly aligned
-             * on the second vector. */
-            srcvD = vec_perm(src_0, src_1, vec_lvsl(stride + 1, src));
-        else
-            srcvD = src_1;
-
-        srcvC = vec_mergeh(vczero, srcvC);
-        srcvD = vec_mergeh(vczero, srcvD);
-
-        /* OK, now we (finally) do the math :-)
-         * Those four instructions replace 32 int muls & 32 int adds.
-         * Isn't AltiVec nice? */
-        tempA = vec_mladd((vector unsigned short) srcvA, Av, rounderV);
-        tempB = vec_mladd((vector unsigned short) srcvB, Bv, tempA);
-        tempC = vec_mladd((vector unsigned short) srcvC, Cv, tempB);
-        tempD = vec_mladd((vector unsigned short) srcvD, Dv, tempC);
-
-        srcvA = srcvC;
-        srcvB = srcvD;
-
-        tempD = vec_sr(tempD, vcsr8);
-
-        dstv2 = vec_pack(tempD, (vector unsigned short) vczero);
-
-        if (dst_odd)
-            dstv2 = vec_perm(dstv, dstv2, vcprm(0, 1, s0, s1));
-        else
-            dstv2 = vec_perm(dstv, dstv2, vcprm(s0, s1, 2, 3));
-
-        vec_st(dstv2, 0, dst);
-
-        dst += stride;
-        src += stride;
-    }
-}
-#endif /* HAVE_ALTIVEC */
-
-av_cold void ff_mpegvideodsp_init_ppc(MpegVideoDSPContext *c)
-{
-#if HAVE_ALTIVEC
-    if (!PPC_ALTIVEC(av_get_cpu_flags()))
-        return;
-
-    c->gmc1 = gmc1_altivec;
-#endif /* HAVE_ALTIVEC */
-}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/ppc/mpeg4videodsp.c
@@ -0,0 +1,139 @@
+/*
+ * GMC (Global Motion Compensation), AltiVec-enabled
+ *
+ * Copyright (c) 2003 Romain Dolbeau <romain@dolbeau.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavutil/mem_internal.h"
+#include "libavutil/ppc/cpu.h"
+#include "libavutil/ppc/util_altivec.h"
+
+#include "libavcodec/mpeg4videodsp.h"
+
+#if HAVE_ALTIVEC
+/* AltiVec-enhanced gmc1. ATM this code assumes stride is a multiple of 8
+ * to preserve proper dst alignment. */
+static void gmc1_altivec(uint8_t *dst /* align 8 */, const uint8_t *src /* align1 */,
+                         int stride, int h, int x16, int y16, int rounder)
+{
+    int i;
+    const DECLARE_ALIGNED(16, unsigned short, rounder_a) = rounder;
+    const DECLARE_ALIGNED(16, unsigned short, ABCD)[8] = {
+        (16 - x16) * (16 - y16), /* A */
+             (x16) * (16 - y16), /* B */
+        (16 - x16) * (y16),      /* C */
+             (x16) * (y16),      /* D */
+        0, 0, 0, 0               /* padding */
+    };
+    register const vector unsigned char vczero =
+        (const vector unsigned char) vec_splat_u8(0);
+    register const vector unsigned short vcsr8 =
+        (const vector unsigned short) vec_splat_u16(8);
+    register vector unsigned char dstv, dstv2, srcvB, srcvC, srcvD;
+    register vector unsigned short tempB, tempC, tempD;
+    unsigned long dst_odd        = (unsigned long) dst & 0x0000000F;
+    unsigned long src_really_odd = (unsigned long) src & 0x0000000F;
+    register vector unsigned short tempA =
+        vec_ld(0, (const unsigned short *) ABCD);
+    register vector unsigned short Av = vec_splat(tempA, 0);
+    register vector unsigned short Bv = vec_splat(tempA, 1);
+    register vector unsigned short Cv = vec_splat(tempA, 2);
+    register vector unsigned short Dv = vec_splat(tempA, 3);
+    register vector unsigned short rounderV =
+        vec_splat((vec_u16) vec_lde(0, &rounder_a), 0);
+
+    /* we'll be able to pick-up our 9 char elements at src from those
+     * 32 bytes we load the first batch here, as inside the loop we can
+     * reuse 'src + stride' from one iteration as the 'src' of the next. */
+    register vector unsigned char src_0 = vec_ld(0, src);
+    register vector unsigned char src_1 = vec_ld(16, src);
+    register vector unsigned char srcvA = vec_perm(src_0, src_1,
+                                                   vec_lvsl(0, src));
+
+    if (src_really_odd != 0x0000000F)
+        /* If (src & 0xF) == 0xF, then (src + 1) is properly aligned
+         * on the second vector. */
+        srcvB = vec_perm(src_0, src_1, vec_lvsl(1, src));
+    else
+        srcvB = src_1;
+    srcvA = vec_mergeh(vczero, srcvA);
+    srcvB = vec_mergeh(vczero, srcvB);
+
+    for (i = 0; i < h; i++) {
+        dst_odd        =   (unsigned long) dst            & 0x0000000F;
+        src_really_odd = (((unsigned long) src) + stride) & 0x0000000F;
+
+        dstv = vec_ld(0, dst);
+
+        /* We'll be able to pick-up our 9 char elements at src + stride from
+         * those 32 bytes then reuse the resulting 2 vectors srvcC and srcvD
+         * as the next srcvA and srcvB. */
+        src_0 = vec_ld(stride +  0, src);
+        src_1 = vec_ld(stride + 16, src);
+        srcvC = vec_perm(src_0, src_1, vec_lvsl(stride + 0, src));
+
+        if (src_really_odd != 0x0000000F)
+            /* If (src & 0xF) == 0xF, then (src + 1) is properly aligned
+             * on the second vector. */
+            srcvD = vec_perm(src_0, src_1, vec_lvsl(stride + 1, src));
+        else
+            srcvD = src_1;
+
+        srcvC = vec_mergeh(vczero, srcvC);
+        srcvD = vec_mergeh(vczero, srcvD);
+
+        /* OK, now we (finally) do the math :-)
+         * Those four instructions replace 32 int muls & 32 int adds.
+         * Isn't AltiVec nice? */
+        tempA = vec_mladd((vector unsigned short) srcvA, Av, rounderV);
+        tempB = vec_mladd((vector unsigned short) srcvB, Bv, tempA);
+        tempC = vec_mladd((vector unsigned short) srcvC, Cv, tempB);
+        tempD = vec_mladd((vector unsigned short) srcvD, Dv, tempC);
+
+        srcvA = srcvC;
+        srcvB = srcvD;
+
+        tempD = vec_sr(tempD, vcsr8);
+
+        dstv2 = vec_pack(tempD, (vector unsigned short) vczero);
+
+        if (dst_odd)
+            dstv2 = vec_perm(dstv, dstv2, vcprm(0, 1, s0, s1));
+        else
+            dstv2 = vec_perm(dstv, dstv2, vcprm(s0, s1, 2, 3));
+
+        vec_st(dstv2, 0, dst);
+
+        dst += stride;
+        src += stride;
+    }
+}
+#endif /* HAVE_ALTIVEC */
+
+av_cold void ff_mpeg4videodsp_init_ppc(Mpeg4VideoDSPContext *c)
+{
+#if HAVE_ALTIVEC
+    if (!PPC_ALTIVEC(av_get_cpu_flags()))
+        return;
+
+    c->gmc1 = gmc1_altivec;
+#endif /* HAVE_ALTIVEC */
+}
--- a/third_party/ffmpeg/libavcodec/ppc/svq1enc_altivec.c
+++ b/third_party/ffmpeg/libavcodec/ppc/svq1enc_altivec.c
@@ -27,7 +27,7 @@
 #include "libavutil/ppc/cpu.h"
 #include "libavutil/ppc/util_altivec.h"
 
-#include "libavcodec/svq1enc.h"
+#include "libavcodec/svq1encdsp.h"
 
 #if HAVE_ALTIVEC
 static int ssd_int8_vs_int16_altivec(const int8_t *pix1, const int16_t *pix2,
@@ -71,7 +71,7 @@
 }
 #endif /* HAVE_ALTIVEC */
 
-av_cold void ff_svq1enc_init_ppc(SVQ1EncContext *c)
+av_cold void ff_svq1enc_init_ppc(SVQ1EncDSPContext *c)
 {
 #if HAVE_ALTIVEC
     if (!PPC_ALTIVEC(av_get_cpu_flags()))
--- a/third_party/ffmpeg/libavcodec/pthread_frame.c
+++ b/third_party/ffmpeg/libavcodec/pthread_frame.c
@@ -179,6 +179,17 @@
     pthread_mutex_unlock(&fctx->async_mutex);
 }
 
+static void thread_set_name(PerThreadContext *p)
+{
+    AVCodecContext *avctx = p->avctx;
+    int idx = p - p->parent->threads;
+    char name[16];
+
+    snprintf(name, sizeof(name), "av:%.7s:df%d", avctx->codec->name, idx);
+
+    ff_thread_setname(name);
+}
+
 /**
  * Codec worker thread.
  *
@@ -192,6 +203,8 @@
     AVCodecContext *avctx = p->avctx;
     const FFCodec *codec = ffcodec(avctx->codec);
 
+    thread_set_name(p);
+
     pthread_mutex_lock(&p->mutex);
     while (1) {
         while (atomic_load(&p->state) == STATE_INPUT_READY && !p->die)
@@ -459,14 +472,14 @@
             pthread_mutex_unlock(&p->mutex);
             return err;
         }
-
-        /* transfer hwaccel state stashed from previous thread, if any */
-        av_assert0(!p->avctx->hwaccel);
-        FFSWAP(const AVHWAccel*, p->avctx->hwaccel,                     fctx->stash_hwaccel);
-        FFSWAP(void*,            p->avctx->hwaccel_context,             fctx->stash_hwaccel_context);
-        FFSWAP(void*,            p->avctx->internal->hwaccel_priv_data, fctx->stash_hwaccel_priv);
     }
 
+    /* transfer the stashed hwaccel state, if any */
+    av_assert0(!p->avctx->hwaccel);
+    FFSWAP(const AVHWAccel*, p->avctx->hwaccel,                     fctx->stash_hwaccel);
+    FFSWAP(void*,            p->avctx->hwaccel_context,             fctx->stash_hwaccel_context);
+    FFSWAP(void*,            p->avctx->internal->hwaccel_priv_data, fctx->stash_hwaccel_priv);
+
     av_packet_unref(p->avpkt);
     ret = av_packet_ref(p->avpkt, avpkt);
     if (ret < 0) {
--- a/third_party/ffmpeg/libavcodec/qoidec.c
+++ b/third_party/ffmpeg/libavcodec/qoidec.c
@@ -28,19 +28,18 @@
 static int qoi_decode_frame(AVCodecContext *avctx, AVFrame *p,
                             int *got_frame, AVPacket *avpkt)
 {
-    const uint8_t *buf = avpkt->data;
-    int ret, buf_size = avpkt->size;
     int width, height, channels, space, run = 0;
     uint8_t index[64][4] = { 0 };
     uint8_t px[4] = { 0, 0, 0, 255 };
     GetByteContext gb;
     uint8_t *dst;
     uint64_t len;
+    int ret;
 
-    if (buf_size < 20)
+    if (avpkt->size < 20)
         return AVERROR_INVALIDDATA;
 
-    bytestream2_init(&gb, buf, buf_size);
+    bytestream2_init(&gb, avpkt->data, avpkt->size);
     bytestream2_skip(&gb, 4);
     width  = bytestream2_get_be32(&gb);
     height = bytestream2_get_be32(&gb);
@@ -61,6 +60,9 @@
     default: return AVERROR_INVALIDDATA;
     }
 
+    if (avctx->skip_frame >= AVDISCARD_ALL)
+        return avpkt->size;
+
     if ((ret = ff_thread_get_buffer(avctx, p, 0)) < 0)
         return ret;
 
@@ -109,7 +111,7 @@
 
     *got_frame   = 1;
 
-    return buf_size;
+    return avpkt->size;
 }
 
 const FFCodec ff_qoi_decoder = {
@@ -118,5 +120,6 @@
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_QOI,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(qoi_decode_frame),
 };
--- a/third_party/ffmpeg/libavcodec/qsv.c
+++ b/third_party/ffmpeg/libavcodec/qsv.c
@@ -212,41 +212,72 @@
     case MFX_FOURCC_YUY2: return AV_PIX_FMT_YUYV422;
     case MFX_FOURCC_Y210: return AV_PIX_FMT_Y210;
     case MFX_FOURCC_AYUV: return AV_PIX_FMT_VUYX;
+    case MFX_FOURCC_Y410: return AV_PIX_FMT_XV30;
+#if QSV_VERSION_ATLEAST(1, 31)
+    case MFX_FOURCC_P016: return AV_PIX_FMT_P012;
+    case MFX_FOURCC_Y216: return AV_PIX_FMT_Y212;
+    case MFX_FOURCC_Y416: return AV_PIX_FMT_XV36;
+#endif
 #endif
     }
     return AV_PIX_FMT_NONE;
 }
 
-int ff_qsv_map_pixfmt(enum AVPixelFormat format, uint32_t *fourcc)
+int ff_qsv_map_pixfmt(enum AVPixelFormat format, uint32_t *fourcc, uint16_t *shift)
 {
     switch (format) {
     case AV_PIX_FMT_YUV420P:
     case AV_PIX_FMT_YUVJ420P:
     case AV_PIX_FMT_NV12:
         *fourcc = MFX_FOURCC_NV12;
+        *shift = 0;
         return AV_PIX_FMT_NV12;
     case AV_PIX_FMT_YUV420P10:
     case AV_PIX_FMT_P010:
         *fourcc = MFX_FOURCC_P010;
+        *shift = 1;
         return AV_PIX_FMT_P010;
     case AV_PIX_FMT_X2RGB10:
         *fourcc = MFX_FOURCC_A2RGB10;
+        *shift = 1;
         return AV_PIX_FMT_X2RGB10;
     case AV_PIX_FMT_BGRA:
         *fourcc = MFX_FOURCC_RGB4;
+        *shift = 0;
         return AV_PIX_FMT_BGRA;
 #if CONFIG_VAAPI
     case AV_PIX_FMT_YUV422P:
     case AV_PIX_FMT_YUYV422:
         *fourcc = MFX_FOURCC_YUY2;
+        *shift = 0;
         return AV_PIX_FMT_YUYV422;
     case AV_PIX_FMT_YUV422P10:
     case AV_PIX_FMT_Y210:
         *fourcc = MFX_FOURCC_Y210;
+        *shift = 1;
         return AV_PIX_FMT_Y210;
     case AV_PIX_FMT_VUYX:
         *fourcc = MFX_FOURCC_AYUV;
+        *shift = 0;
         return AV_PIX_FMT_VUYX;
+    case AV_PIX_FMT_XV30:
+        *fourcc = MFX_FOURCC_Y410;
+        *shift = 0;
+        return AV_PIX_FMT_XV30;
+#if QSV_VERSION_ATLEAST(1, 31)
+    case AV_PIX_FMT_P012:
+        *fourcc = MFX_FOURCC_P016;
+        *shift = 1;
+        return AV_PIX_FMT_P012;
+    case AV_PIX_FMT_Y212:
+        *fourcc = MFX_FOURCC_Y216;
+        *shift = 1;
+        return AV_PIX_FMT_Y212;
+    case AV_PIX_FMT_XV36:
+        *fourcc = MFX_FOURCC_Y416;
+        *shift = 1;
+        return AV_PIX_FMT_XV36;
+#endif
 #endif
     default:
         return AVERROR(ENOSYS);
@@ -258,6 +289,7 @@
     switch (frame->format) {
     case AV_PIX_FMT_NV12:
     case AV_PIX_FMT_P010:
+    case AV_PIX_FMT_P012:
         surface->Data.Y  = frame->data[0];
         surface->Data.UV = frame->data[1];
         /* The SDK checks Data.V when using system memory for VP9 encoding */
@@ -277,6 +309,7 @@
         break;
 
     case AV_PIX_FMT_Y210:
+    case AV_PIX_FMT_Y212:
         surface->Data.Y16 = (mfxU16 *)frame->data[0];
         surface->Data.U16 = (mfxU16 *)frame->data[0] + 1;
         surface->Data.V16 = (mfxU16 *)frame->data[0] + 3;
@@ -291,6 +324,19 @@
         surface->Data.A = frame->data[0] + 3;
         break;
 
+    case AV_PIX_FMT_XV30:
+        surface->Data.U = frame->data[0];
+        break;
+
+    case AV_PIX_FMT_XV36:
+        surface->Data.U = frame->data[0];
+        surface->Data.Y = frame->data[0] + 2;
+        surface->Data.V = frame->data[0] + 4;
+        // Only set Data.A to a valid address, the SDK doesn't
+        // use the value from the frame.
+        surface->Data.A = frame->data[0] + 6;
+        break;
+
     default:
         return AVERROR(ENOSYS);
     }
--- a/third_party/ffmpeg/libavcodec/qsv_internal.h
+++ b/third_party/ffmpeg/libavcodec/qsv_internal.h
@@ -51,7 +51,7 @@
 #define ASYNC_DEPTH_DEFAULT 4       // internal parallelism
 
 #define QSV_MAX_ENC_PAYLOAD 2       // # of mfxEncodeCtrl payloads supported
-#define QSV_MAX_ENC_EXTPARAM 2
+#define QSV_MAX_ENC_EXTPARAM 8      // # of mfxEncodeCtrl extparam supported
 
 #define QSV_MAX_ROI_NUM 256
 
@@ -132,7 +132,7 @@
 
 enum AVPixelFormat ff_qsv_map_fourcc(uint32_t fourcc);
 
-int ff_qsv_map_pixfmt(enum AVPixelFormat format, uint32_t *fourcc);
+int ff_qsv_map_pixfmt(enum AVPixelFormat format, uint32_t *fourcc, uint16_t *shift);
 enum AVPictureType ff_qsv_map_pictype(int mfx_pic_type);
 
 enum AVFieldOrder ff_qsv_map_picstruct(int mfx_pic_struct);
--- a/third_party/ffmpeg/libavcodec/qsvdec.c
+++ b/third_party/ffmpeg/libavcodec/qsvdec.c
@@ -137,13 +137,19 @@
         frame->linesize[0] = FFALIGN(avctx->width, 128);
         break;
     case AV_PIX_FMT_P010:
+    case AV_PIX_FMT_P012:
     case AV_PIX_FMT_YUYV422:
         frame->linesize[0] = 2 * FFALIGN(avctx->width, 128);
         break;
     case AV_PIX_FMT_Y210:
     case AV_PIX_FMT_VUYX:
+    case AV_PIX_FMT_XV30:
+    case AV_PIX_FMT_Y212:
         frame->linesize[0] = 4 * FFALIGN(avctx->width, 128);
         break;
+    case AV_PIX_FMT_XV36:
+        frame->linesize[0] = 8 * FFALIGN(avctx->width, 128);
+        break;
     default:
         av_log(avctx, AV_LOG_ERROR, "Unsupported pixel format.\n");
         return AVERROR(EINVAL);
@@ -155,7 +161,8 @@
 
     frame->data[0] = frame->buf[0]->data;
     if (avctx->pix_fmt == AV_PIX_FMT_NV12 ||
-        avctx->pix_fmt == AV_PIX_FMT_P010) {
+        avctx->pix_fmt == AV_PIX_FMT_P010 ||
+        avctx->pix_fmt == AV_PIX_FMT_P012) {
         frame->linesize[1] = frame->linesize[0];
         frame->data[1] = frame->data[0] +
             frame->linesize[0] * FFALIGN(avctx->height, 64);
@@ -1040,9 +1047,13 @@
     .p.priv_class   = &x##_qsv_class, \
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_NV12, \
                                                     AV_PIX_FMT_P010, \
+                                                    AV_PIX_FMT_P012, \
                                                     AV_PIX_FMT_YUYV422, \
                                                     AV_PIX_FMT_Y210, \
+                                                    AV_PIX_FMT_Y212, \
                                                     AV_PIX_FMT_VUYX, \
+                                                    AV_PIX_FMT_XV30, \
+                                                    AV_PIX_FMT_XV36, \
                                                     AV_PIX_FMT_QSV, \
                                                     AV_PIX_FMT_NONE }, \
     .hw_configs     = qsv_hw_configs, \
--- a/third_party/ffmpeg/libavcodec/qsvenc.c
+++ b/third_party/ffmpeg/libavcodec/qsvenc.c
@@ -82,6 +82,14 @@
     { MFX_PROFILE_VP9_3,                        "vp9 3"                     },
 };
 
+static const struct profile_names av1_profiles[] = {
+#if QSV_VERSION_ATLEAST(1, 34)
+    { MFX_PROFILE_AV1_MAIN,                     "av1 main"                  },
+    { MFX_PROFILE_AV1_HIGH,                     "av1 high"                  },
+    { MFX_PROFILE_AV1_PRO,                      "av1 professional"          },
+#endif
+};
+
 typedef struct QSVPacket {
     AVPacket        pkt;
     mfxSyncPoint   *sync;
@@ -114,6 +122,11 @@
         num_profiles = FF_ARRAY_ELEMS(vp9_profiles);
         break;
 
+    case AV_CODEC_ID_AV1:
+        profiles = av1_profiles;
+        num_profiles = FF_ARRAY_ELEMS(av1_profiles);
+        break;
+
     default:
         return "unknown";
     }
@@ -429,6 +442,88 @@
            info->FrameInfo.FrameRateExtD, info->FrameInfo.FrameRateExtN);
 }
 
+#if QSV_HAVE_EXT_AV1_PARAM
+static void dump_video_av1_param(AVCodecContext *avctx, QSVEncContext *q,
+                                 mfxExtBuffer **coding_opts)
+{
+    mfxInfoMFX *info = &q->param.mfx;
+    mfxExtAV1TileParam *av1_tile_param = (mfxExtAV1TileParam *)coding_opts[0];
+    mfxExtAV1BitstreamParam *av1_bs_param = (mfxExtAV1BitstreamParam *)coding_opts[1];
+    mfxExtCodingOption2 *co2 = (mfxExtCodingOption2*)coding_opts[2];
+    mfxExtCodingOption3 *co3 = (mfxExtCodingOption3*)coding_opts[3];
+
+    av_log(avctx, AV_LOG_VERBOSE, "profile: %s; level: %"PRIu16"\n",
+           print_profile(avctx->codec_id, info->CodecProfile), info->CodecLevel);
+
+    av_log(avctx, AV_LOG_VERBOSE,
+           "GopPicSize: %"PRIu16"; GopRefDist: %"PRIu16"; GopOptFlag:%s%s; IdrInterval: %"PRIu16"\n",
+           info->GopPicSize, info->GopRefDist,
+           info->GopOptFlag & MFX_GOP_CLOSED ? " closed" : "",
+           info->GopOptFlag & MFX_GOP_STRICT ? " strict" : "",
+           info->IdrInterval);
+
+    av_log(avctx, AV_LOG_VERBOSE, "TargetUsage: %"PRIu16"; RateControlMethod: %s\n",
+           info->TargetUsage, print_ratecontrol(info->RateControlMethod));
+
+    if (info->RateControlMethod == MFX_RATECONTROL_CBR ||
+        info->RateControlMethod == MFX_RATECONTROL_VBR)
+        av_log(avctx, AV_LOG_VERBOSE,
+               "BufferSizeInKB: %"PRIu16"; InitialDelayInKB: %"PRIu16"; TargetKbps: %"PRIu16"; MaxKbps: %"PRIu16"; BRCParamMultiplier: %"PRIu16"\n",
+               info->BufferSizeInKB, info->InitialDelayInKB, info->TargetKbps, info->MaxKbps, info->BRCParamMultiplier);
+    else if (info->RateControlMethod == MFX_RATECONTROL_CQP)
+        av_log(avctx, AV_LOG_VERBOSE, "QPI: %"PRIu16"; QPP: %"PRIu16"; QPB: %"PRIu16"\n",
+               info->QPI, info->QPP, info->QPB);
+    else if (info->RateControlMethod == MFX_RATECONTROL_ICQ)
+        av_log(avctx, AV_LOG_VERBOSE, "ICQQuality: %"PRIu16"\n", info->ICQQuality);
+    else
+        av_log(avctx, AV_LOG_VERBOSE, "Unsupported ratecontrol method: %d \n", info->RateControlMethod);
+
+    av_log(avctx, AV_LOG_VERBOSE, "NumRefFrame: %"PRIu16"\n", info->NumRefFrame);
+
+    av_log(avctx, AV_LOG_VERBOSE,
+           "IntRefType: %"PRIu16"; IntRefCycleSize: %"PRIu16
+           "; IntRefQPDelta: %"PRId16"; IntRefCycleDist: %"PRId16"\n",
+           co2->IntRefType, co2->IntRefCycleSize,
+           co2->IntRefQPDelta, co3->IntRefCycleDist);
+
+    av_log(avctx, AV_LOG_VERBOSE, "MaxFrameSize: %d;\n", co2->MaxFrameSize);
+
+    av_log(avctx, AV_LOG_VERBOSE,
+           "BitrateLimit: %s; MBBRC: %s; ExtBRC: %s\n",
+           print_threestate(co2->BitrateLimit), print_threestate(co2->MBBRC),
+           print_threestate(co2->ExtBRC));
+
+    av_log(avctx, AV_LOG_VERBOSE, "VDENC: %s\n", print_threestate(info->LowPower));
+
+    switch (co2->BRefType) {
+    case MFX_B_REF_OFF:     av_log(avctx, AV_LOG_VERBOSE, "BRefType: off\n");       break;
+    case MFX_B_REF_PYRAMID: av_log(avctx, AV_LOG_VERBOSE, "BRefType: pyramid\n");   break;
+    default:                av_log(avctx, AV_LOG_VERBOSE, "BRefType: auto\n");      break;
+    }
+
+    switch (co3->PRefType) {
+    case MFX_P_REF_DEFAULT: av_log(avctx, AV_LOG_VERBOSE, "PRefType: default\n");   break;
+    case MFX_P_REF_SIMPLE:  av_log(avctx, AV_LOG_VERBOSE, "PRefType: simple\n");    break;
+    case MFX_P_REF_PYRAMID: av_log(avctx, AV_LOG_VERBOSE, "PRefType: pyramid\n");   break;
+    default:                av_log(avctx, AV_LOG_VERBOSE, "PRefType: unknown\n");   break;
+    }
+
+    av_log(avctx, AV_LOG_VERBOSE,
+           "MinQPI: %"PRIu8"; MaxQPI: %"PRIu8"; MinQPP: %"PRIu8"; MaxQPP: %"PRIu8"; MinQPB: %"PRIu8"; MaxQPB: %"PRIu8"\n",
+           co2->MinQPI, co2->MaxQPI, co2->MinQPP, co2->MaxQPP, co2->MinQPB, co2->MaxQPB);
+
+    av_log(avctx, AV_LOG_VERBOSE, "FrameRateExtD: %"PRIu32"; FrameRateExtN: %"PRIu32" \n",
+           info->FrameInfo.FrameRateExtD, info->FrameInfo.FrameRateExtN);
+
+    av_log(avctx, AV_LOG_VERBOSE,
+           "NumTileRows: %"PRIu16"; NumTileColumns: %"PRIu16"; NumTileGroups: %"PRIu16"\n",
+           av1_tile_param->NumTileRows, av1_tile_param->NumTileColumns, av1_tile_param->NumTileGroups);
+
+    av_log(avctx, AV_LOG_VERBOSE, "WriteIVFHeaders: %s \n",
+           print_threestate(av1_bs_param->WriteIVFHeaders));
+}
+#endif
+
 static int select_rc_mode(AVCodecContext *avctx, QSVEncContext *q)
 {
     const char *rc_desc;
@@ -553,7 +648,7 @@
     if (!desc)
         return AVERROR_BUG;
 
-    ret = ff_qsv_map_pixfmt(sw_format, &q->param.mfx.FrameInfo.FourCC);
+    ret = ff_qsv_map_pixfmt(sw_format, &q->param.mfx.FrameInfo.FourCC, &q->param.mfx.FrameInfo.Shift);
     if (ret < 0)
         return AVERROR_BUG;
 
@@ -567,7 +662,6 @@
                                             !desc->log2_chroma_w + !desc->log2_chroma_h;
     q->param.mfx.FrameInfo.BitDepthLuma   = desc->comp[0].depth;
     q->param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth;
-    q->param.mfx.FrameInfo.Shift          = desc->comp[0].depth > 8;
 
     q->param.mfx.FrameInfo.Width  = FFALIGN(avctx->width, 16);
     q->param.mfx.FrameInfo.Height = FFALIGN(avctx->height, 16);
@@ -653,7 +747,7 @@
     if (!desc)
         return AVERROR_BUG;
 
-    ret = ff_qsv_map_pixfmt(sw_format, &q->param.mfx.FrameInfo.FourCC);
+    ret = ff_qsv_map_pixfmt(sw_format, &q->param.mfx.FrameInfo.FourCC, &q->param.mfx.FrameInfo.Shift);
     if (ret < 0)
         return AVERROR_BUG;
 
@@ -667,7 +761,6 @@
                                             !desc->log2_chroma_w + !desc->log2_chroma_h;
     q->param.mfx.FrameInfo.BitDepthLuma   = desc->comp[0].depth;
     q->param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth;
-    q->param.mfx.FrameInfo.Shift          = desc->comp[0].depth > 8;
 
     // If the minor version is greater than or equal to 19,
     // then can use the same alignment settings as H.264 for HEVC
@@ -705,6 +798,7 @@
         q->param.mfx.FrameInfo.FrameRateExtN  = avctx->time_base.den;
         q->param.mfx.FrameInfo.FrameRateExtD  = avctx->time_base.num;
     }
+    q->old_framerate = avctx->framerate;
 
     ret = select_rc_mode(avctx, q);
     if (ret < 0)
@@ -717,6 +811,10 @@
     max_bitrate_kbps           = avctx->rc_max_rate / 1000;
     brc_param_multiplier       = (FFMAX(FFMAX3(target_bitrate_kbps, max_bitrate_kbps, buffer_size_in_kilobytes),
                                   initial_delay_in_kilobytes) + 0x10000) / 0x10000;
+    q->old_rc_buffer_size = avctx->rc_buffer_size;
+    q->old_rc_initial_buffer_occupancy = avctx->rc_initial_buffer_occupancy;
+    q->old_bit_rate = avctx->bit_rate;
+    q->old_rc_max_rate = avctx->rc_max_rate;
 
     switch (q->param.mfx.RateControlMethod) {
     case MFX_RATECONTROL_CBR:
@@ -738,10 +836,15 @@
         break;
     case MFX_RATECONTROL_CQP:
         quant = avctx->global_quality / FF_QP2LAMBDA;
-
-        q->param.mfx.QPI = av_clip(quant * fabs(avctx->i_quant_factor) + avctx->i_quant_offset, 0, 51);
-        q->param.mfx.QPP = av_clip(quant, 0, 51);
-        q->param.mfx.QPB = av_clip(quant * fabs(avctx->b_quant_factor) + avctx->b_quant_offset, 0, 51);
+        if (avctx->codec_id == AV_CODEC_ID_AV1) {
+            q->param.mfx.QPI = av_clip_uintp2(quant * fabs(avctx->i_quant_factor) + avctx->i_quant_offset, 8);
+            q->param.mfx.QPP = av_clip_uintp2(quant, 8);
+            q->param.mfx.QPB = av_clip_uintp2(quant * fabs(avctx->b_quant_factor) + avctx->b_quant_offset, 8);
+        } else {
+            q->param.mfx.QPI = av_clip(quant * fabs(avctx->i_quant_factor) + avctx->i_quant_offset, 0, 51);
+            q->param.mfx.QPP = av_clip(quant, 0, 51);
+            q->param.mfx.QPB = av_clip(quant * fabs(avctx->b_quant_factor) + avctx->b_quant_offset, 0, 51);
+        }
         q->old_global_quality = avctx->global_quality;
         q->old_i_quant_factor = avctx->i_quant_factor;
         q->old_i_quant_offset = avctx->i_quant_offset;
@@ -779,6 +882,7 @@
 
         q->extco.PicTimingSEI         = q->pic_timing_sei ?
                                         MFX_CODINGOPTION_ON : MFX_CODINGOPTION_UNKNOWN;
+        q->old_pic_timing_sei = q->pic_timing_sei;
 
         if (q->rdo >= 0)
             q->extco.RateDistortionOpt = q->rdo > 0 ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
@@ -892,6 +996,20 @@
             q->extco2.Header.BufferSz = sizeof(q->extco2);
 
             q->extparam_internal[q->nb_extparam_internal++] = (mfxExtBuffer *)&q->extco2;
+        } else if (avctx->codec_id == AV_CODEC_ID_AV1) {
+            if (q->extbrc >= 0)
+                q->extco2.ExtBRC = q->extbrc ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
+            if (q->b_strategy >= 0)
+                q->extco2.BRefType = q->b_strategy ? MFX_B_REF_PYRAMID : MFX_B_REF_OFF;
+            if (q->adaptive_i >= 0)
+                q->extco2.AdaptiveI = q->adaptive_i ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
+            if (q->adaptive_b >= 0)
+                q->extco2.AdaptiveB = q->adaptive_b ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
+
+            q->extco2.Header.BufferId = MFX_EXTBUFF_CODING_OPTION2;
+            q->extco2.Header.BufferSz = sizeof(q->extco2);
+
+            q->extparam_internal[q->nb_extparam_internal++] = (mfxExtBuffer *)&q->extco2;
         }
 
         if (avctx->codec_id == AV_CODEC_ID_H264) {
@@ -968,6 +1086,27 @@
         q->extparam_internal[q->nb_extparam_internal++] = (mfxExtBuffer *)&q->extvp9param;
     }
 
+#if QSV_HAVE_EXT_AV1_PARAM
+    if (avctx->codec_id == AV_CODEC_ID_AV1) {
+        if (QSV_RUNTIME_VERSION_ATLEAST(q->ver, 2, 5)) {
+            q->extav1tileparam.Header.BufferId = MFX_EXTBUFF_AV1_TILE_PARAM;
+            q->extav1tileparam.Header.BufferSz = sizeof(q->extav1tileparam);
+            q->extav1tileparam.NumTileColumns  = q->tile_cols;
+            q->extav1tileparam.NumTileRows     = q->tile_rows;
+            q->extparam_internal[q->nb_extparam_internal++] = (mfxExtBuffer *)&q->extav1tileparam;
+
+            q->extav1bsparam.Header.BufferId = MFX_EXTBUFF_AV1_BITSTREAM_PARAM;
+            q->extav1bsparam.Header.BufferSz = sizeof(q->extav1bsparam);
+            q->extav1bsparam.WriteIVFHeaders = MFX_CODINGOPTION_OFF;
+            q->extparam_internal[q->nb_extparam_internal++] = (mfxExtBuffer *)&q->extav1bsparam;
+        } else {
+            av_log(avctx, AV_LOG_ERROR,
+                   "This version of runtime doesn't support AV1 encoding\n");
+            return AVERROR_UNKNOWN;
+        }
+    }
+#endif
+
     if (avctx->codec_id == AV_CODEC_ID_HEVC) {
         q->exthevctiles.Header.BufferId = MFX_EXTBUFF_HEVC_TILES;
         q->exthevctiles.Header.BufferSz = sizeof(q->exthevctiles);
@@ -1078,6 +1217,56 @@
     return 0;
 }
 
+static int qsv_retrieve_enc_av1_params(AVCodecContext *avctx, QSVEncContext *q)
+{
+#if QSV_HAVE_EXT_AV1_PARAM
+    int ret = 0;
+    mfxExtAV1TileParam av1_extend_tile_buf = {
+         .Header.BufferId = MFX_EXTBUFF_AV1_TILE_PARAM,
+         .Header.BufferSz = sizeof(av1_extend_tile_buf),
+    };
+    mfxExtAV1BitstreamParam av1_bs_param = {
+         .Header.BufferId = MFX_EXTBUFF_AV1_BITSTREAM_PARAM,
+         .Header.BufferSz = sizeof(av1_bs_param),
+    };
+
+    mfxExtCodingOption2 co2 = {
+        .Header.BufferId = MFX_EXTBUFF_CODING_OPTION2,
+        .Header.BufferSz = sizeof(co2),
+    };
+
+    mfxExtCodingOption3 co3 = {
+        .Header.BufferId = MFX_EXTBUFF_CODING_OPTION3,
+        .Header.BufferSz = sizeof(co3),
+    };
+
+    mfxExtBuffer *ext_buffers[] = {
+        (mfxExtBuffer*)&av1_extend_tile_buf,
+        (mfxExtBuffer*)&av1_bs_param,
+        (mfxExtBuffer*)&co2,
+        (mfxExtBuffer*)&co3,
+    };
+
+    if (!QSV_RUNTIME_VERSION_ATLEAST(q->ver, 2, 5)) {
+        av_log(avctx, AV_LOG_ERROR,
+               "This version of runtime doesn't support AV1 encoding\n");
+        return AVERROR_UNKNOWN;
+    }
+
+    q->param.ExtParam    = ext_buffers;
+    q->param.NumExtParam = FF_ARRAY_ELEMS(ext_buffers);
+
+    ret = MFXVideoENCODE_GetVideoParam(q->session, &q->param);
+    if (ret < 0)
+        return ff_qsv_print_error(avctx, ret,
+                                  "Error calling GetVideoParam");
+
+    q->packet_size = q->param.mfx.BufferSizeInKB * q->param.mfx.BRCParamMultiplier * 1000;
+    dump_video_av1_param(avctx, q, ext_buffers);
+#endif
+    return 0;
+}
+
 static int qsv_retrieve_enc_params(AVCodecContext *avctx, QSVEncContext *q)
 {
     AVCPBProperties *cpb_props;
@@ -1416,6 +1605,9 @@
     case AV_CODEC_ID_VP9:
         ret = qsv_retrieve_enc_vp9_params(avctx, q);
         break;
+    case AV_CODEC_ID_AV1:
+        ret = qsv_retrieve_enc_av1_params(avctx, q);
+        break;
     default:
         ret = qsv_retrieve_enc_params(avctx, q);
         break;
@@ -1430,25 +1622,16 @@
     return 0;
 }
 
-static void free_encoder_ctrl_payloads(mfxEncodeCtrl* enc_ctrl)
+static void free_encoder_ctrl(mfxEncodeCtrl* enc_ctrl)
 {
     if (enc_ctrl) {
-        int i;
-        for (i = 0; i < enc_ctrl->NumPayload && i < QSV_MAX_ENC_PAYLOAD; i++) {
+        for (int i = 0; i < enc_ctrl->NumPayload && i < QSV_MAX_ENC_PAYLOAD; i++)
             av_freep(&enc_ctrl->Payload[i]);
-        }
-        enc_ctrl->NumPayload = 0;
-    }
-}
 
-static void free_encoder_ctrl_extparam(mfxEncodeCtrl* enc_ctrl)
-{
-    if (enc_ctrl) {
-        int i;
-        for (i = 0; i < enc_ctrl->NumExtParam && i < QSV_MAX_ENC_EXTPARAM; i++) {
-            if (enc_ctrl->ExtParam[i])
-                av_freep(&(enc_ctrl->ExtParam[i]));
-        }
+        for (int i = 0; i < enc_ctrl->NumExtParam && i < QSV_MAX_ENC_EXTPARAM; i++)
+            av_freep(&enc_ctrl->ExtParam[i]);
+
+        enc_ctrl->NumPayload = 0;
         enc_ctrl->NumExtParam = 0;
     }
 }
@@ -1458,8 +1641,7 @@
     QSVFrame *cur = q->work_frames;
     while (cur) {
         if (cur->used && !cur->surface.Data.Locked) {
-            free_encoder_ctrl_payloads(&cur->enc_ctrl);
-            free_encoder_ctrl_extparam(&cur->enc_ctrl);
+            free_encoder_ctrl(&cur->enc_ctrl);
             //do not reuse enc_ctrl from previous frame
             memset(&cur->enc_ctrl, 0, sizeof(cur->enc_ctrl));
             cur->enc_ctrl.Payload = cur->payloads;
@@ -1510,6 +1692,64 @@
     return 0;
 }
 
+static int qsvenc_fill_padding_area(AVFrame *frame, int new_w, int new_h)
+{
+    const AVPixFmtDescriptor *desc;
+    int max_step[4], filled[4] = { 0 };
+
+    desc = av_pix_fmt_desc_get(frame->format);
+    av_assert0(desc);
+    av_image_fill_max_pixsteps(max_step, NULL, desc);
+
+    for (int i = 0; i < desc->nb_components; i++) {
+        const AVComponentDescriptor *comp = &desc->comp[i];
+        int sheight, dheight, plane = comp->plane;
+        ptrdiff_t swidth = av_image_get_linesize(frame->format,
+                                                 frame->width,
+                                                 plane);
+        ptrdiff_t dwidth = av_image_get_linesize(frame->format,
+                                                 new_w,
+                                                 plane);
+
+        if (swidth < 0 || dwidth < 0) {
+            av_log(NULL, AV_LOG_ERROR, "av_image_get_linesize failed\n");
+            return AVERROR(EINVAL);
+        }
+
+        if (filled[plane])
+            continue;
+
+        sheight = frame->height;
+        dheight = new_h;
+
+        if (plane) {
+            sheight = AV_CEIL_RSHIFT(frame->height, desc->log2_chroma_h);
+            dheight = AV_CEIL_RSHIFT(new_h, desc->log2_chroma_h);
+        }
+
+        // Fill right padding
+        if (new_w > frame->width) {
+            for (int j = 0; j < sheight; j++) {
+                void *line_ptr = frame->data[plane] + j * frame->linesize[plane] + swidth;
+
+                av_memcpy_backptr(line_ptr,
+                                  max_step[plane],
+                                  new_w - frame->width);
+            }
+        }
+
+        // Fill bottom padding
+        for (int j = sheight; j < dheight; j++)
+            memcpy(frame->data[plane] + j * frame->linesize[plane],
+                   frame->data[plane] + (sheight - 1) * frame->linesize[plane],
+                   dwidth);
+
+        filled[plane] = 1;
+    }
+
+    return 0;
+}
+
 static int submit_frame(QSVEncContext *q, const AVFrame *frame,
                         QSVFrame **new_frame)
 {
@@ -1539,8 +1779,9 @@
         /* and to make allocation continious for data[0]/data[1] */
          if ((frame->height & 31 || frame->linesize[0] & (q->width_align - 1)) ||
             (frame->data[1] - frame->data[0] != frame->linesize[0] * FFALIGN(qf->frame->height, q->height_align))) {
-            qf->frame->height = FFALIGN(frame->height, q->height_align);
-            qf->frame->width  = FFALIGN(frame->width, q->width_align);
+            int tmp_w, tmp_h;
+            qf->frame->height = tmp_h = FFALIGN(frame->height, q->height_align);
+            qf->frame->width  = tmp_w = FFALIGN(frame->width, q->width_align);
 
             qf->frame->format = frame->format;
 
@@ -1558,6 +1799,12 @@
                 av_frame_unref(qf->frame);
                 return ret;
             }
+
+            ret = qsvenc_fill_padding_area(qf->frame, tmp_w, tmp_h);
+            if (ret < 0) {
+                av_frame_unref(qf->frame);
+                return ret;
+            }
         } else {
             av_frame_unref(qf->frame);
             ret = av_frame_ref(qf->frame, frame);
@@ -1760,8 +2007,8 @@
     if (avctx->codec_id != AV_CODEC_ID_H264)
         return 0;
 
-    UPDATE_PARAM(q->old_qmax, avctx->qmin);
-    UPDATE_PARAM(q->old_qmax, avctx->qmin);
+    UPDATE_PARAM(q->old_qmin, avctx->qmin);
+    UPDATE_PARAM(q->old_qmax, avctx->qmax);
     UPDATE_PARAM(q->old_min_qp_i, q->min_qp_i);
     UPDATE_PARAM(q->old_max_qp_i, q->max_qp_i);
     UPDATE_PARAM(q->old_min_qp_p, q->min_qp_p);
@@ -1838,6 +2085,82 @@
     return updated;
 }
 
+static int update_frame_rate(AVCodecContext *avctx, QSVEncContext *q)
+{
+    int updated = 0;
+
+    UPDATE_PARAM(q->old_framerate.num, avctx->framerate.num);
+    UPDATE_PARAM(q->old_framerate.den, avctx->framerate.den);
+    if (!updated)
+        return 0;
+
+    if (avctx->framerate.den > 0 && avctx->framerate.num > 0) {
+        q->param.mfx.FrameInfo.FrameRateExtN = avctx->framerate.num;
+        q->param.mfx.FrameInfo.FrameRateExtD = avctx->framerate.den;
+    } else {
+        q->param.mfx.FrameInfo.FrameRateExtN = avctx->time_base.den;
+        q->param.mfx.FrameInfo.FrameRateExtD = avctx->time_base.num;
+    }
+    av_log(avctx, AV_LOG_DEBUG, "Reset framerate: %d/%d (%.2f fps).\n",
+           q->param.mfx.FrameInfo.FrameRateExtN,
+           q->param.mfx.FrameInfo.FrameRateExtD,
+           (double)q->param.mfx.FrameInfo.FrameRateExtN / q->param.mfx.FrameInfo.FrameRateExtD);
+
+    return updated;
+}
+
+static int update_bitrate(AVCodecContext *avctx, QSVEncContext *q)
+{
+    int updated = 0;
+    int target_bitrate_kbps, max_bitrate_kbps, brc_param_multiplier;
+    int buffer_size_in_kilobytes, initial_delay_in_kilobytes;
+
+    UPDATE_PARAM(q->old_rc_buffer_size, avctx->rc_buffer_size);
+    UPDATE_PARAM(q->old_rc_initial_buffer_occupancy, avctx->rc_initial_buffer_occupancy);
+    UPDATE_PARAM(q->old_bit_rate, avctx->bit_rate);
+    UPDATE_PARAM(q->old_rc_max_rate, avctx->rc_max_rate);
+    if (!updated)
+        return 0;
+
+    buffer_size_in_kilobytes   = avctx->rc_buffer_size / 8000;
+    initial_delay_in_kilobytes = avctx->rc_initial_buffer_occupancy / 8000;
+    target_bitrate_kbps        = avctx->bit_rate / 1000;
+    max_bitrate_kbps           = avctx->rc_max_rate / 1000;
+    brc_param_multiplier       = (FFMAX(FFMAX3(target_bitrate_kbps, max_bitrate_kbps, buffer_size_in_kilobytes),
+                                    initial_delay_in_kilobytes) + 0x10000) / 0x10000;
+
+    q->param.mfx.BufferSizeInKB = buffer_size_in_kilobytes / brc_param_multiplier;
+    q->param.mfx.InitialDelayInKB = initial_delay_in_kilobytes / brc_param_multiplier;
+    q->param.mfx.TargetKbps = target_bitrate_kbps / brc_param_multiplier;
+    q->param.mfx.MaxKbps = max_bitrate_kbps / brc_param_multiplier;
+    q->param.mfx.BRCParamMultiplier = brc_param_multiplier;
+    av_log(avctx, AV_LOG_VERBOSE,
+            "Reset BufferSizeInKB: %d; InitialDelayInKB: %d; "
+            "TargetKbps: %d; MaxKbps: %d; BRCParamMultiplier: %d\n",
+            q->param.mfx.BufferSizeInKB, q->param.mfx.InitialDelayInKB,
+            q->param.mfx.TargetKbps, q->param.mfx.MaxKbps, q->param.mfx.BRCParamMultiplier);
+    return updated;
+}
+
+static int update_pic_timing_sei(AVCodecContext *avctx, QSVEncContext *q)
+{
+    int updated = 0;
+
+    if (avctx->codec_id != AV_CODEC_ID_H264 && avctx->codec_id != AV_CODEC_ID_HEVC)
+        return 0;
+
+    UPDATE_PARAM(q->old_pic_timing_sei, q->pic_timing_sei);
+    if (!updated)
+        return 0;
+
+    q->extco.PicTimingSEI = q->pic_timing_sei ?
+                            MFX_CODINGOPTION_ON : MFX_CODINGOPTION_UNKNOWN;
+    av_log(avctx, AV_LOG_DEBUG, "Reset PicTimingSEI: %s\n",
+           print_threestate(q->extco.PicTimingSEI));
+
+    return updated;
+}
+
 static int update_parameters(AVCodecContext *avctx, QSVEncContext *q,
                              const AVFrame *frame)
 {
@@ -1851,6 +2174,9 @@
     needReset |= update_gop_size(avctx, q);
     needReset |= update_rir(avctx, q);
     needReset |= update_low_delay_brc(avctx, q);
+    needReset |= update_frame_rate(avctx, q);
+    needReset |= update_bitrate(avctx, q);
+    needReset |= update_pic_timing_sei(avctx, q);
     ret = update_min_max_qp(avctx, q);
     if (ret < 0)
         return ret;
@@ -1945,8 +2271,8 @@
         pkt.bs->ExtParam = enc_buf;
     }
 
-    if (q->set_encode_ctrl_cb) {
-        q->set_encode_ctrl_cb(avctx, frame, &qsv_frame->enc_ctrl);
+    if (q->set_encode_ctrl_cb && enc_ctrl) {
+        q->set_encode_ctrl_cb(avctx, frame, enc_ctrl);
     }
 
     if ((avctx->codec_id == AV_CODEC_ID_H264 ||
@@ -2083,8 +2409,7 @@
     while (cur) {
         q->work_frames = cur->next;
         av_frame_free(&cur->frame);
-        free_encoder_ctrl_extparam(&cur->enc_ctrl);
-        free_encoder_ctrl_payloads(&cur->enc_ctrl);
+        free_encoder_ctrl(&cur->enc_ctrl);
         av_freep(&cur);
         cur = q->work_frames;
     }
--- a/third_party/ffmpeg/libavcodec/qsvenc.h
+++ b/third_party/ffmpeg/libavcodec/qsvenc.h
@@ -39,6 +39,7 @@
 #include "qsv_internal.h"
 
 #define QSV_HAVE_EXT_VP9_TILES QSV_VERSION_ATLEAST(1, 29)
+#define QSV_HAVE_EXT_AV1_PARAM QSV_VERSION_ATLEAST(2, 5)
 
 #if defined(_WIN32) || defined(__CYGWIN__)
 #define QSV_HAVE_AVBR   1
@@ -52,7 +53,7 @@
 
 #define QSV_COMMON_OPTS \
 { "async_depth", "Maximum processing parallelism", OFFSET(qsv.async_depth), AV_OPT_TYPE_INT, { .i64 = ASYNC_DEPTH_DEFAULT }, 1, INT_MAX, VE },                          \
-{ "preset", NULL, OFFSET(qsv.preset), AV_OPT_TYPE_INT, { .i64 = MFX_TARGETUSAGE_BALANCED }, MFX_TARGETUSAGE_BEST_QUALITY, MFX_TARGETUSAGE_BEST_SPEED,   VE, "preset" }, \
+{ "preset", NULL, OFFSET(qsv.preset), AV_OPT_TYPE_INT, { .i64 = MFX_TARGETUSAGE_UNKNOWN }, MFX_TARGETUSAGE_UNKNOWN, MFX_TARGETUSAGE_BEST_SPEED,   VE, "preset" },       \
 { "veryfast",    NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MFX_TARGETUSAGE_BEST_SPEED  },   INT_MIN, INT_MAX, VE, "preset" },                                                \
 { "faster",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MFX_TARGETUSAGE_6  },            INT_MIN, INT_MAX, VE, "preset" },                                                \
 { "fast",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MFX_TARGETUSAGE_5  },            INT_MIN, INT_MAX, VE, "preset" },                                                \
@@ -154,6 +155,10 @@
 #endif
     mfxExtHEVCTiles exthevctiles;
     mfxExtVP9Param  extvp9param;
+#if QSV_HAVE_EXT_AV1_PARAM
+    mfxExtAV1TileParam extav1tileparam;
+    mfxExtAV1BitstreamParam extav1bsparam;
+#endif
 
 #if QSV_HAVE_OPAQUE
     mfxExtOpaqueSurfaceAlloc opaque_alloc;
@@ -163,7 +168,7 @@
 
     mfxExtVideoSignalInfo extvsi;
 
-    mfxExtBuffer  *extparam_internal[5 + (QSV_HAVE_MF * 2)];
+    mfxExtBuffer  *extparam_internal[5 + (QSV_HAVE_MF * 2) + QSV_HAVE_EXT_AV1_PARAM * 2];
     int         nb_extparam_internal;
 
     mfxExtBuffer **extparam;
@@ -271,6 +276,15 @@
     int old_min_qp_b;
     // This is used for low_delay_brc reset
     int old_low_delay_brc;
+    // This is used for framerate reset
+    AVRational old_framerate;
+    // These are used for bitrate control reset
+    int old_bit_rate;
+    int old_rc_buffer_size;
+    int old_rc_initial_buffer_occupancy;
+    int old_rc_max_rate;
+    // This is used for SEI Timing reset
+    int old_pic_timing_sei;
 } QSVEncContext;
 
 int ff_qsv_enc_init(AVCodecContext *avctx, QSVEncContext *q);
--- a/third_party/ffmpeg/libavcodec/qsvenc_h264.c
+++ b/third_party/ffmpeg/libavcodec/qsvenc_h264.c
@@ -176,9 +176,8 @@
 static const FFCodecDefault qsv_enc_defaults[] = {
     { "b",         "1M"    },
     { "refs",      "0"     },
-    // same as the x264 default
-    { "g",         "250"   },
-    { "bf",        "3"     },
+    { "g",         "-1"    },
+    { "bf",        "-1"    },
     { "qmin",      "-1"    },
     { "qmax",      "-1"    },
     { "trellis",   "-1"    },
--- a/third_party/ffmpeg/libavcodec/qsvenc_hevc.c
+++ b/third_party/ffmpeg/libavcodec/qsvenc_hevc.c
@@ -26,6 +26,7 @@
 
 #include "libavutil/common.h"
 #include "libavutil/opt.h"
+#include "libavutil/mastering_display_metadata.h"
 
 #include "avcodec.h"
 #include "bytestream.h"
@@ -160,6 +161,83 @@
     return 0;
 }
 
+static int qsv_hevc_set_encode_ctrl(AVCodecContext *avctx,
+                                    const AVFrame *frame, mfxEncodeCtrl *enc_ctrl)
+{
+    QSVHEVCEncContext *q = avctx->priv_data;
+    AVFrameSideData *sd;
+
+    if (!frame || !QSV_RUNTIME_VERSION_ATLEAST(q->qsv.ver, 1, 25))
+        return 0;
+
+    sd = av_frame_get_side_data(frame, AV_FRAME_DATA_MASTERING_DISPLAY_METADATA);
+    if (sd) {
+        AVMasteringDisplayMetadata *mdm = (AVMasteringDisplayMetadata *)sd->data;
+
+        // SEI is needed when both the primaries and luminance are set
+        if (mdm->has_primaries && mdm->has_luminance) {
+            const int mapping[3] = {1, 2, 0};
+            const int chroma_den = 50000;
+            const int luma_den   = 10000;
+            int i;
+            mfxExtMasteringDisplayColourVolume *mdcv = av_mallocz(sizeof(mfxExtMasteringDisplayColourVolume));
+
+            if (!mdcv)
+                return AVERROR(ENOMEM);
+
+            mdcv->Header.BufferId = MFX_EXTBUFF_MASTERING_DISPLAY_COLOUR_VOLUME;
+            mdcv->Header.BufferSz = sizeof(*mdcv);
+
+            for (i = 0; i < 3; i++) {
+                const int j = mapping[i];
+
+                mdcv->DisplayPrimariesX[i] =
+                    FFMIN(lrint(chroma_den *
+                                av_q2d(mdm->display_primaries[j][0])),
+                          chroma_den);
+                mdcv->DisplayPrimariesY[i] =
+                    FFMIN(lrint(chroma_den *
+                                av_q2d(mdm->display_primaries[j][1])),
+                          chroma_den);
+            }
+
+            mdcv->WhitePointX =
+                FFMIN(lrint(chroma_den * av_q2d(mdm->white_point[0])),
+                      chroma_den);
+            mdcv->WhitePointY =
+                FFMIN(lrint(chroma_den * av_q2d(mdm->white_point[1])),
+                      chroma_den);
+
+            mdcv->MaxDisplayMasteringLuminance =
+                lrint(luma_den * av_q2d(mdm->max_luminance));
+            mdcv->MinDisplayMasteringLuminance =
+                FFMIN(lrint(luma_den * av_q2d(mdm->min_luminance)),
+                      mdcv->MaxDisplayMasteringLuminance);
+
+            enc_ctrl->ExtParam[enc_ctrl->NumExtParam++] = (mfxExtBuffer *)mdcv;
+        }
+    }
+
+    sd = av_frame_get_side_data(frame, AV_FRAME_DATA_CONTENT_LIGHT_LEVEL);
+    if (sd) {
+        AVContentLightMetadata *clm = (AVContentLightMetadata *)sd->data;
+        mfxExtContentLightLevelInfo * clli = av_mallocz(sizeof(mfxExtContentLightLevelInfo));
+
+        if (!clli)
+            return AVERROR(ENOMEM);
+
+        clli->Header.BufferId = MFX_EXTBUFF_CONTENT_LIGHT_LEVEL_INFO;
+        clli->Header.BufferSz = sizeof(*clli);
+
+        clli->MaxContentLightLevel          = FFMIN(clm->MaxCLL,  65535);
+        clli->MaxPicAverageLightLevel       = FFMIN(clm->MaxFALL, 65535);
+
+        enc_ctrl->ExtParam[enc_ctrl->NumExtParam++] = (mfxExtBuffer *)clli;
+    }
+
+    return 0;
+}
+
 static av_cold int qsv_enc_init(AVCodecContext *avctx)
 {
     QSVHEVCEncContext *q = avctx->priv_data;
@@ -189,6 +267,8 @@
     // HEVC and H264 meaning of the value is shifted by 1, make it consistent
     q->qsv.idr_interval++;
 
+    q->qsv.set_encode_ctrl_cb = qsv_hevc_set_encode_ctrl;
+
     ret = ff_qsv_enc_init(avctx, &q->qsv);
     if (ret < 0)
         return ret;
@@ -289,13 +369,11 @@
 static const FFCodecDefault qsv_enc_defaults[] = {
     { "b",         "1M"    },
     { "refs",      "0"     },
-    // same as the x264 default
-    { "g",         "248"   },
+    { "g",         "-1"    },
     { "bf",        "-1"    },
     { "qmin",      "-1"    },
     { "qmax",      "-1"    },
     { "trellis",   "-1"    },
-    { "flags",     "+cgop" },
     { NULL },
 };
 
@@ -311,12 +389,14 @@
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HYBRID,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_NV12,
                                                     AV_PIX_FMT_P010,
+                                                    AV_PIX_FMT_P012,
                                                     AV_PIX_FMT_YUYV422,
                                                     AV_PIX_FMT_Y210,
                                                     AV_PIX_FMT_QSV,
                                                     AV_PIX_FMT_BGRA,
                                                     AV_PIX_FMT_X2RGB10,
                                                     AV_PIX_FMT_VUYX,
+                                                    AV_PIX_FMT_XV30,
                                                     AV_PIX_FMT_NONE },
     .p.priv_class   = &class,
     .defaults       = qsv_enc_defaults,
--- a/third_party/ffmpeg/libavcodec/qsvenc_vp9.c
+++ b/third_party/ffmpeg/libavcodec/qsvenc_vp9.c
@@ -115,6 +115,7 @@
                                                     AV_PIX_FMT_P010,
                                                     AV_PIX_FMT_VUYX,
                                                     AV_PIX_FMT_QSV,
+                                                    AV_PIX_FMT_XV30,
                                                     AV_PIX_FMT_NONE },
     .p.priv_class   = &class,
     .defaults       = qsv_enc_defaults,
--- a/third_party/ffmpeg/libavcodec/ra144enc.c
+++ b/third_party/ffmpeg/libavcodec/ra144enc.c
@@ -549,8 +549,6 @@
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
     .p.supported_samplerates = (const int[]){ 8000, 0 },
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = (const uint64_t[]) { AV_CH_LAYOUT_MONO, 0 },
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO)
     .p.ch_layouts   = (const AVChannelLayout[]){ AV_CHANNEL_LAYOUT_MONO, { 0 } },
 };
--- a/third_party/ffmpeg/libavcodec/rl.c
+++ b/third_party/ffmpeg/libavcodec/rl.c
@@ -24,6 +24,23 @@
 
 #include "rl.h"
 
+av_cold void ff_rl_init_level_run(uint8_t max_level[MAX_LEVEL + 1],
+                                  uint8_t index_run[MAX_RUN + 1],
+                                  const uint8_t table_run[/* n */],
+                                  const uint8_t table_level[/* n*/],
+                                  int n)
+{
+    memset(index_run, n, MAX_RUN + 1);
+    for (int i = 0; i < n; i++) {
+        int run   = table_run[i];
+        int level = table_level[i];
+        if (index_run[run] == n)
+            index_run[run] = i;
+        if (level > max_level[run])
+            max_level[run] = level;
+    }
+}
+
 av_cold void ff_rl_init(RLTable *rl,
                         uint8_t static_store[2][2 * MAX_RUN + MAX_LEVEL + 3])
 {
--- a/third_party/ffmpeg/libavcodec/rl.h
+++ b/third_party/ffmpeg/libavcodec/rl.h
@@ -49,6 +49,16 @@
 } RLTable;
 
 /**
+ * Initialize max_level and index_run from table_run and table_level;
+ * this is equivalent to initializing RLTable.max_level[0] and
+ * RLTable.index_run[0] with ff_rl_init().
+ */
+void ff_rl_init_level_run(uint8_t max_level[MAX_LEVEL + 1],
+                          uint8_t index_run[MAX_RUN + 1],
+                          const uint8_t table_run[/* n */],
+                          const uint8_t table_level[/* n*/], int n);
+
+/**
  * Initialize index_run, max_level and max_run from n, last, table_vlc,
  * table_run and table_level.
  * @param static_store static uint8_t array[2][2*MAX_RUN + MAX_LEVEL + 3]
--- a/third_party/ffmpeg/libavcodec/rl2.c
+++ b/third_party/ffmpeg/libavcodec/rl2.c
@@ -57,25 +57,27 @@
  * @param video_base offset of the rle data inside the frame
  */
 static void rl2_rle_decode(Rl2Context *s, const uint8_t *in, int size,
-                               uint8_t *out, int stride, int video_base)
+                           uint8_t *out, ptrdiff_t stride, int video_base)
 {
     int base_x = video_base % s->avctx->width;
     int base_y = video_base / s->avctx->width;
-    int stride_adj = stride - s->avctx->width;
-    int i;
+    ptrdiff_t stride_adj = stride - s->avctx->width;
     const uint8_t *back_frame = s->back_frame;
     const uint8_t *in_end     = in + size;
-    const uint8_t *out_end    = out + stride * s->avctx->height;
+    const uint8_t *out_end    = out + stride * s->avctx->height - stride_adj;
     uint8_t *line_end;
 
     /** copy start of the background frame */
-    for (i = 0; i <= base_y; i++) {
-        if (s->back_frame)
+    if (s->back_frame) {
+        for (int i = 0; i <= base_y; i++) {
             memcpy(out, back_frame, s->avctx->width);
-        out        += stride;
-        back_frame += s->avctx->width;
+            out        += stride;
+            back_frame += s->avctx->width;
+        }
+        back_frame += base_x - s->avctx->width;
+    } else {
+        out += stride * (base_y + 1);
     }
-    back_frame += base_x - s->avctx->width;
     line_end    = out - stride_adj;
     out        += base_x - stride;
 
@@ -89,32 +91,47 @@
             len = *in++;
             if (!len)
                 break;
+            val &= 0x7F;
         }
 
-        if (len >= out_end - out)
-            break;
-
-        if (s->back_frame)
+        if (back_frame) {
+            if (!val) {
+                do {
+                    size_t copy = FFMIN(line_end - out, len);
+                    memcpy(out, back_frame, copy);
+                    out        += copy;
+                    back_frame += copy;
+                    len        -= copy;
+                    if (out == line_end) {
+                        if (out == out_end)
+                            return;
+                        out      += stride_adj;
+                        line_end += stride;
+                    }
+                } while (len > 0);
+                continue;
+            }
+            back_frame += len;
             val |= 0x80;
-        else
-            val &= ~0x80;
+        }
 
         while (len--) {
-            *out++ = (val == 0x80) ? *back_frame : val;
-            back_frame++;
+            *out++ = val;
             if (out == line_end) {
-                 out      += stride_adj;
-                 line_end += stride;
-                 if (len >= out_end - out)
-                     break;
+                if (out == out_end)
+                    return;
+                out      += stride_adj;
+                line_end += stride;
             }
         }
     }
 
     /** copy the rest from the background frame */
     if (s->back_frame) {
-        while (out < out_end) {
+        while (1) {
             memcpy(out, back_frame, line_end - out);
+            if (line_end == out_end)
+                break;
             back_frame += line_end - out;
             out         = line_end + stride_adj;
             line_end   += stride;
@@ -165,7 +182,9 @@
     back_size = avctx->extradata_size - EXTRADATA1_SIZE;
 
     if (back_size > 0) {
-        uint8_t *back_frame = av_mallocz(avctx->width*avctx->height);
+        /* The 254 are padding to ensure that pointer arithmetic stays within
+         * the buffer. */
+        uint8_t *back_frame = av_mallocz(avctx->width * avctx->height + 254);
         if (!back_frame)
             return AVERROR(ENOMEM);
         rl2_rle_decode(s, avctx->extradata + EXTRADATA1_SIZE, back_size,
--- a/third_party/ffmpeg/libavcodec/s302menc.c
+++ b/third_party/ffmpeg/libavcodec/s302menc.c
@@ -184,9 +184,4 @@
                                                             AV_SAMPLE_FMT_S16,
                                                             AV_SAMPLE_FMT_NONE },
     .p.supported_samplerates = (const int[]) { 48000, 0 },
- /* .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_STEREO,
-                                                  AV_CH_LAYOUT_QUAD,
-                                                  AV_CH_LAYOUT_5POINT1_BACK,
-                                                  AV_CH_LAYOUT_5POINT1_BACK | AV_CH_LAYOUT_STEREO_DOWNMIX,
-                                                  0 }, */
 };
--- a/third_party/ffmpeg/libavcodec/sbcdec.c
+++ b/third_party/ffmpeg/libavcodec/sbcdec.c
@@ -343,9 +343,6 @@
     SBCDecContext *sbc = avctx->priv_data;
     int ret, frame_length;
 
-    if (!sbc)
-        return AVERROR(EIO);
-
     frame_length = sbc_unpack_frame(avpkt->data, &sbc->frame, avpkt->size);
     if (frame_length <= 0)
         return frame_length;
@@ -374,10 +371,7 @@
     .init                  = sbc_decode_init,
     FF_CODEC_DECODE_CB(sbc_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_MONO,
-                                                  AV_CH_LAYOUT_STEREO, 0},
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO,
                                                          AV_CHANNEL_LAYOUT_STEREO,
                                                          { 0 } },
--- a/third_party/ffmpeg/libavcodec/sbcenc.c
+++ b/third_party/ffmpeg/libavcodec/sbcenc.c
@@ -352,10 +352,7 @@
     .priv_data_size        = sizeof(SBCEncContext),
     .init                  = sbc_encode_init,
     FF_CODEC_ENCODE_CB(sbc_encode_frame),
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_MONO,
-                                                  AV_CH_LAYOUT_STEREO, 0},
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS(AV_CH_LAYOUT_MONO, AV_CH_LAYOUT_STEREO)
     .p.ch_layouts          = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO,
                                                          AV_CHANNEL_LAYOUT_STEREO,
                                                          { 0 } },
--- a/third_party/ffmpeg/libavcodec/sgidec.c
+++ b/third_party/ffmpeg/libavcodec/sgidec.c
@@ -25,99 +25,85 @@
 #include "decode.h"
 #include "sgi.h"
 
-typedef struct SgiState {
-    AVCodecContext *avctx;
-    unsigned int width;
-    unsigned int height;
-    unsigned int depth;
-    unsigned int bytes_per_channel;
-    int linesize;
-    GetByteContext g;
-} SgiState;
-
 /**
  * Expand an RLE row into a channel.
- * @param s the current image state
+ * @param logctx a logcontext
  * @param out_buf Points to one line after the output buffer.
- * @param len length of out_buf in bytes
- * @param pixelstride pixel stride of input buffer
- * @return size of output in bytes, else return error code.
+ * @param g   GetByteContext used to read input from
+ * @param width length of out_buf in nb of elements
+ * @return nb of elements written, else return error code.
  */
-static int expand_rle_row8(SgiState *s, uint8_t *out_buf,
-                           int len, int pixelstride)
+static int expand_rle_row8(void *logctx, uint8_t *out_buf,
+                           GetByteContext *g, unsigned width)
 {
     unsigned char pixel, count;
     unsigned char *orig = out_buf;
-    uint8_t *out_end = out_buf + len;
+    uint8_t *out_end = out_buf + width;
 
     while (out_buf < out_end) {
-        if (bytestream2_get_bytes_left(&s->g) < 1)
+        if (bytestream2_get_bytes_left(g) < 1)
             return AVERROR_INVALIDDATA;
-        pixel = bytestream2_get_byteu(&s->g);
+        pixel = bytestream2_get_byteu(g);
         if (!(count = (pixel & 0x7f))) {
             break;
         }
 
         /* Check for buffer overflow. */
-        if (out_end - out_buf <= pixelstride * (count - 1)) {
-            av_log(s->avctx, AV_LOG_ERROR, "Invalid pixel count.\n");
+        if (out_end - out_buf < count) {
+            av_log(logctx, AV_LOG_ERROR, "Invalid pixel count.\n");
             return AVERROR_INVALIDDATA;
         }
 
         if (pixel & 0x80) {
-            while (count--) {
-                *out_buf = bytestream2_get_byte(&s->g);
-                out_buf += pixelstride;
-            }
+            while (count--)
+                *out_buf++ = bytestream2_get_byte(g);
         } else {
-            pixel = bytestream2_get_byte(&s->g);
+            pixel = bytestream2_get_byte(g);
 
-            while (count--) {
-                *out_buf = pixel;
-                out_buf += pixelstride;
-            }
+            while (count--)
+                *out_buf++ = pixel;
         }
     }
-    return (out_buf - orig) / pixelstride;
+    return out_buf - orig;
 }
 
-static int expand_rle_row16(SgiState *s, uint16_t *out_buf,
-                            int len, int pixelstride)
+static int expand_rle_row16(void *logctx, uint16_t *out_buf,
+                            GetByteContext *g, unsigned width)
 {
     unsigned short pixel;
     unsigned char count;
     unsigned short *orig = out_buf;
-    uint16_t *out_end = out_buf + len;
+    uint16_t *out_end = out_buf + width;
 
     while (out_buf < out_end) {
-        if (bytestream2_get_bytes_left(&s->g) < 2)
+        if (bytestream2_get_bytes_left(g) < 2)
             return AVERROR_INVALIDDATA;
-        pixel = bytestream2_get_be16u(&s->g);
+        pixel = bytestream2_get_be16u(g);
         if (!(count = (pixel & 0x7f)))
             break;
 
         /* Check for buffer overflow. */
-        if (out_end - out_buf <= pixelstride * (count - 1)) {
-            av_log(s->avctx, AV_LOG_ERROR, "Invalid pixel count.\n");
+        if (out_end - out_buf < count) {
+            av_log(logctx, AV_LOG_ERROR, "Invalid pixel count.\n");
             return AVERROR_INVALIDDATA;
         }
 
         if (pixel & 0x80) {
             while (count--) {
-                pixel = bytestream2_get_ne16(&s->g);
+                pixel = bytestream2_get_ne16(g);
                 AV_WN16A(out_buf, pixel);
-                out_buf += pixelstride;
+                out_buf++;
             }
         } else {
-            pixel = bytestream2_get_ne16(&s->g);
+            pixel = bytestream2_get_ne16(g);
 
             while (count--) {
                 AV_WN16A(out_buf, pixel);
-                out_buf += pixelstride;
+                out_buf++;
             }
         }
     }
-    return (out_buf - orig) / pixelstride;
+    return out_buf - orig;
 }
 
 
@@ -127,33 +113,34 @@
  * @param s the current image state
  * @return 0 if no error, else return error code.
  */
-static int read_rle_sgi(uint8_t *out_buf, SgiState *s)
+static int read_rle_sgi(void *logctx, uint8_t *out[4], ptrdiff_t stride[4],
+                        GetByteContext *g, unsigned width, int height,
+                        unsigned nb_components, unsigned bytes_per_channel)
 {
-    uint8_t *dest_row;
-    unsigned int len = s->height * s->depth * 4;
-    GetByteContext g_table = s->g;
-    unsigned int y, z;
+    unsigned int len = height * nb_components * 4;
+    GetByteContext g_table = *g;
     unsigned int start_offset;
-    int linesize, ret;
+    int ret;
 
     /* size of  RLE offset and length tables */
-    if (len * 2 > bytestream2_get_bytes_left(&s->g)) {
+    if (len * 2 > bytestream2_get_bytes_left(g)) {
         return AVERROR_INVALIDDATA;
     }
 
-    for (z = 0; z < s->depth; z++) {
-        dest_row = out_buf;
-        for (y = 0; y < s->height; y++) {
-            linesize = s->width * s->depth;
-            dest_row -= s->linesize;
+    for (unsigned z = 0; z < nb_components; z++) {
+        uint8_t *dest_row = out[z] + (height - 1) * stride[z];
+        while (1) {
             start_offset = bytestream2_get_be32(&g_table);
-            bytestream2_seek(&s->g, start_offset, SEEK_SET);
-            if (s->bytes_per_channel == 1)
-                ret = expand_rle_row8(s, dest_row + z, linesize, s->depth);
+            bytestream2_seek(g, start_offset, SEEK_SET);
+            if (bytes_per_channel == 1)
+                ret = expand_rle_row8(logctx, dest_row, g, width);
             else
-                ret = expand_rle_row16(s, (uint16_t *)dest_row + z, linesize, s->depth);
-            if (ret != s->width)
+                ret = expand_rle_row16(logctx, (uint16_t *)dest_row, g, width);
+            if (ret != width)
                 return AVERROR_INVALIDDATA;
+            if (dest_row == out[z])
+                break;
+            dest_row -= stride[z];
         }
     }
     return 0;
@@ -165,34 +152,23 @@
  * @param s the current image state
  * @return 0 if read success, else return error code.
  */
-static int read_uncompressed_sgi(unsigned char *out_buf, SgiState *s)
+static int read_uncompressed_sgi(uint8_t *const out[4], const ptrdiff_t stride[4],
+                                 GetByteContext *g, unsigned width, int height,
+                                 unsigned nb_components, unsigned bytes_per_channel)
 {
-    int x, y, z;
-    unsigned int offset = s->height * s->width * s->bytes_per_channel;
-    GetByteContext gp[4];
-    uint8_t *out_end;
+    unsigned rowsize = width * bytes_per_channel;
 
     /* Test buffer size. */
-    if (offset * s->depth > bytestream2_get_bytes_left(&s->g))
+    if (rowsize * (int64_t)height > bytestream2_get_bytes_left(g))
         return AVERROR_INVALIDDATA;
 
-    /* Create a reader for each plane */
-    for (z = 0; z < s->depth; z++) {
-        gp[z] = s->g;
-        bytestream2_skip(&gp[z], z * offset);
-    }
-
-    for (y = s->height - 1; y >= 0; y--) {
-        out_end = out_buf + (y * s->linesize);
-        if (s->bytes_per_channel == 1) {
-            for (x = s->width; x > 0; x--)
-                for (z = 0; z < s->depth; z++)
-                    *out_end++ = bytestream2_get_byteu(&gp[z]);
-        } else {
-            uint16_t *out16 = (uint16_t *)out_end;
-            for (x = s->width; x > 0; x--)
-                for (z = 0; z < s->depth; z++)
-                    *out16++ = bytestream2_get_ne16u(&gp[z]);
+    for (unsigned z = 0; z < nb_components; z++) {
+        uint8_t *cur_row = out[z] + (height - 1) * stride[z];
+        while (1) {
+            bytestream2_get_bufferu(g, cur_row, rowsize);
+            if (cur_row == out[z])
+                break;
+            cur_row -= stride[z];
         }
     }
     return 0;
@@ -201,31 +177,33 @@
 static int decode_frame(AVCodecContext *avctx, AVFrame *p,
                         int *got_frame, AVPacket *avpkt)
 {
-    SgiState *s = avctx->priv_data;
-    unsigned int dimension, rle;
+    GetByteContext g;
+    unsigned int bytes_per_channel, nb_components, dimension, rle, width;
+    uint8_t *out[4];
+    ptrdiff_t linesize[4];
+    int height;
     int ret = 0;
-    uint8_t *out_buf, *out_end;
 
-    bytestream2_init(&s->g, avpkt->data, avpkt->size);
-    if (bytestream2_get_bytes_left(&s->g) < SGI_HEADER_SIZE) {
+    bytestream2_init(&g, avpkt->data, avpkt->size);
+    if (bytestream2_get_bytes_left(&g) < SGI_HEADER_SIZE) {
         av_log(avctx, AV_LOG_ERROR, "buf_size too small (%d)\n", avpkt->size);
         return AVERROR_INVALIDDATA;
     }
 
     /* Test for SGI magic. */
-    if (bytestream2_get_be16u(&s->g) != SGI_MAGIC) {
+    if (bytestream2_get_be16u(&g) != SGI_MAGIC) {
         av_log(avctx, AV_LOG_ERROR, "bad magic number\n");
         return AVERROR_INVALIDDATA;
     }
 
-    rle                  = bytestream2_get_byteu(&s->g);
-    s->bytes_per_channel = bytestream2_get_byteu(&s->g);
-    dimension            = bytestream2_get_be16u(&s->g);
-    s->width             = bytestream2_get_be16u(&s->g);
-    s->height            = bytestream2_get_be16u(&s->g);
-    s->depth             = bytestream2_get_be16u(&s->g);
+    rle                  = bytestream2_get_byteu(&g);
+    bytes_per_channel    = bytestream2_get_byteu(&g);
+    dimension            = bytestream2_get_be16u(&g);
+    width                = bytestream2_get_be16u(&g);
+    height               = bytestream2_get_be16u(&g);
+    nb_components        = bytestream2_get_be16u(&g);
 
-    if (s->bytes_per_channel != 1 && s->bytes_per_channel != 2) {
+    if (bytes_per_channel != 1 && bytes_per_channel != 2) {
         av_log(avctx, AV_LOG_ERROR, "wrong channel number\n");
         return AVERROR_INVALIDDATA;
     }
@@ -236,38 +214,51 @@
         return AVERROR_INVALIDDATA;
     }
 
-    if (s->depth == SGI_GRAYSCALE) {
-        avctx->pix_fmt = s->bytes_per_channel == 2 ? AV_PIX_FMT_GRAY16BE : AV_PIX_FMT_GRAY8;
-    } else if (s->depth == SGI_RGB) {
-        avctx->pix_fmt = s->bytes_per_channel == 2 ? AV_PIX_FMT_RGB48BE : AV_PIX_FMT_RGB24;
-    } else if (s->depth == SGI_RGBA) {
-        avctx->pix_fmt = s->bytes_per_channel == 2 ? AV_PIX_FMT_RGBA64BE : AV_PIX_FMT_RGBA;
+    if (nb_components == SGI_GRAYSCALE) {
+        avctx->pix_fmt = bytes_per_channel == 2 ? AV_PIX_FMT_GRAY16BE : AV_PIX_FMT_GRAY8;
+    } else if (nb_components == SGI_RGB) {
+        avctx->pix_fmt = bytes_per_channel == 2 ? AV_PIX_FMT_GBRP16BE : AV_PIX_FMT_GBRP;
+    } else if (nb_components == SGI_RGBA) {
+        avctx->pix_fmt = bytes_per_channel == 2 ? AV_PIX_FMT_GBRAP16BE : AV_PIX_FMT_GBRAP;
     } else {
         av_log(avctx, AV_LOG_ERROR, "wrong picture format\n");
         return AVERROR_INVALIDDATA;
     }
 
-    ret = ff_set_dimensions(avctx, s->width, s->height);
+    ret = ff_set_dimensions(avctx, width, height);
     if (ret < 0)
         return ret;
 
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
         return ret;
 
+    switch (nb_components) {
+#define MAP(in_idx, out_idx) \
+    out[(in_idx)]      = p->data[(out_idx)]; \
+    linesize[(in_idx)] = p->linesize[(out_idx)]
+    case SGI_GRAYSCALE:
+        MAP(0, 0);
+        break;
+    case SGI_RGBA:
+        MAP(3, 3);
+        /* fallthrough */
+    case SGI_RGB:
+        MAP(0, 2);
+        MAP(1, 0);
+        MAP(2, 1);
+        break;
+    }
     p->pict_type = AV_PICTURE_TYPE_I;
     p->key_frame = 1;
-    out_buf = p->data[0];
-
-    out_end = out_buf + p->linesize[0] * s->height;
-
-    s->linesize = p->linesize[0];
 
     /* Skip header. */
-    bytestream2_seek(&s->g, SGI_HEADER_SIZE, SEEK_SET);
+    bytestream2_seek(&g, SGI_HEADER_SIZE, SEEK_SET);
     if (rle) {
-        ret = read_rle_sgi(out_end, s);
+        ret = read_rle_sgi(avctx, out, linesize, &g,
+                           width, height, nb_components, bytes_per_channel);
     } else {
-        ret = read_uncompressed_sgi(out_buf, s);
+        ret = read_uncompressed_sgi(out, linesize, &g,
+                                    width, height, nb_components, bytes_per_channel);
     }
     if (ret)
         return ret;
@@ -276,22 +267,11 @@
     return avpkt->size;
 }
 
-static av_cold int sgi_decode_init(AVCodecContext *avctx)
-{
-    SgiState *s = avctx->priv_data;
-
-    s->avctx = avctx;
-
-    return 0;
-}
-
 const FFCodec ff_sgi_decoder = {
     .p.name         = "sgi",
     CODEC_LONG_NAME("SGI image"),
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_SGI,
-    .priv_data_size = sizeof(SgiState),
     FF_CODEC_DECODE_CB(decode_frame),
-    .init           = sgi_decode_init,
     .p.capabilities = AV_CODEC_CAP_DR1,
 };
--- a/third_party/ffmpeg/libavcodec/snow.c
+++ b/third_party/ffmpeg/libavcodec/snow.c
@@ -23,7 +23,6 @@
 #include "avcodec.h"
 #include "decode.h"
 #include "encode.h"
-#include "me_cmp.h"
 #include "snow_dwt.h"
 #include "snow.h"
 #include "snowdata.h"
@@ -434,7 +433,6 @@
     s->max_ref_frames=1; //just make sure it's not an invalid value in case of no initial keyframe
     s->spatial_decomposition_count = 1;
 
-    ff_me_cmp_init(&s->mecc, avctx);
     ff_hpeldsp_init(&s->hdsp, avctx->flags);
     ff_videodsp_init(&s->vdsp, 8);
     ff_dwt_init(&s->dwt);
--- a/third_party/ffmpeg/libavcodec/snow_dwt.c
+++ b/third_party/ffmpeg/libavcodec/snow_dwt.c
@@ -778,10 +778,10 @@
 
     for (i = 0; i < h; i++) {
         for (j = 0; j < w; j += 4) {
-            tmp[32 * i + j + 0] = (pix1[j + 0] - pix2[j + 0]) << 4;
-            tmp[32 * i + j + 1] = (pix1[j + 1] - pix2[j + 1]) << 4;
-            tmp[32 * i + j + 2] = (pix1[j + 2] - pix2[j + 2]) << 4;
-            tmp[32 * i + j + 3] = (pix1[j + 3] - pix2[j + 3]) << 4;
+            tmp[32 * i + j + 0] = (pix1[j + 0] - pix2[j + 0]) * (1 << 4);
+            tmp[32 * i + j + 1] = (pix1[j + 1] - pix2[j + 1]) * (1 << 4);
+            tmp[32 * i + j + 2] = (pix1[j + 2] - pix2[j + 2]) * (1 << 4);
+            tmp[32 * i + j + 3] = (pix1[j + 3] - pix2[j + 3]) * (1 << 4);
         }
         pix1 += line_size;
         pix2 += line_size;
--- a/third_party/ffmpeg/libavcodec/snowdec.c
+++ b/third_party/ffmpeg/libavcodec/snowdec.c
@@ -662,6 +662,6 @@
     .init           = ff_snow_common_init,
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
-    .p.capabilities = AV_CODEC_CAP_DR1 /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,
+    .p.capabilities = AV_CODEC_CAP_DR1,
     .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
--- a/third_party/ffmpeg/libavcodec/snowenc.c
+++ b/third_party/ffmpeg/libavcodec/snowenc.c
@@ -26,6 +26,7 @@
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "encode.h"
+#include "me_cmp.h"
 #include "packet_internal.h"
 #include "snow_dwt.h"
 #include "snow.h"
@@ -66,6 +67,7 @@
     if ((ret = ff_snow_common_init(avctx)) < 0) {
         return ret;
     }
+    ff_me_cmp_init(&s->mecc, avctx);
     ff_mpegvideoencdsp_init(&s->mpvencdsp, avctx);
 
     ff_snow_alloc_blocks(s);
@@ -933,7 +935,7 @@
     av_assert2(mb_x < b_stride);
 
     index = (p0 + 31 * p1) & (ME_CACHE_SIZE-1);
-    value = s->me_cache_generation + (p0 >> 10) + (p1 << 6) + (block->ref << 12);
+    value = s->me_cache_generation + (p0 >> 10) + p1 * (1 << 6) + (block->ref << 12);
     if (s->me_cache[index] == value)
         return 0;
     s->me_cache[index] = value;
@@ -1814,7 +1816,7 @@
             if(s->qlog == LOSSLESS_QLOG){
                 for(y=0; y<h; y++){
                     for(x=0; x<w; x++){
-                        s->spatial_idwt_buffer[y*w + x]<<=FRAC_BITS;
+                        s->spatial_idwt_buffer[y*w + x] *= 1 << FRAC_BITS;
                     }
                 }
             }
--- a/third_party/ffmpeg/libavcodec/speedhq.c
+++ b/third_party/ffmpeg/libavcodec/speedhq.c
@@ -1,5 +1,5 @@
 /*
- * NewTek SpeedHQ codec
+ * NewTek SpeedHQ common data
  * Copyright 2017 Steinar H. Gunderson
  *
  * This file is part of FFmpeg.
@@ -19,51 +19,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-/**
- * @file
- * NewTek SpeedHQ decoder.
- */
-
-#define BITSTREAM_READER_LE
-
-#include "config_components.h"
-#include "libavutil/attributes.h"
-#include "libavutil/mem_internal.h"
-
-#include "avcodec.h"
-#include "blockdsp.h"
-#include "codec_internal.h"
-#include "decode.h"
-#include "get_bits.h"
-#include "idctdsp.h"
-#include "libavutil/thread.h"
-#include "mathops.h"
-#include "mpeg12dec.h"
-#include "mpeg12data.h"
-#include "mpeg12vlc.h"
-
-#define MAX_INDEX (64 - 1)
-
-/*
- * 5 bits makes for very small tables, with no more than two lookups needed
- * for the longest (10-bit) codes.
- */
-#define ALPHA_VLC_BITS 5
-
-typedef struct SHQContext {
-    AVCodecContext *avctx;
-    BlockDSPContext bdsp;
-    IDCTDSPContext idsp;
-    ScanTable intra_scantable;
-    int quant_matrix[64];
-    enum { SHQ_SUBSAMPLING_420, SHQ_SUBSAMPLING_422, SHQ_SUBSAMPLING_444 }
-        subsampling;
-    enum { SHQ_NO_ALPHA, SHQ_RLE_ALPHA, SHQ_DCT_ALPHA } alpha_type;
-} SHQContext;
-
+#include <stdint.h>
+#include "speedhq.h"
 
 /* AC codes: Very similar but not identical to MPEG-2. */
-static const uint16_t speedhq_vlc[123][2] = {
+const uint16_t ff_speedhq_vlc_table[SPEEDHQ_RL_NB_ELEMS + 2][2] = {
     {0x0001,  2}, {0x0003,  3}, {0x000E,  4}, {0x0007,  5},
     {0x0017,  5}, {0x0028,  6}, {0x0008,  6}, {0x006F,  7},
     {0x001F,  7}, {0x00C4,  8}, {0x0044,  8}, {0x005F,  8},
@@ -99,7 +59,7 @@
     {0x0006,  4}  /* EOB */
 };
 
-static const uint8_t speedhq_level[121] = {
+const uint8_t ff_speedhq_level[121] = {
      1,  2,  3,  4,  5,  6,  7,  8,
      9, 10, 11, 12, 13, 14, 15, 16,
     17, 18, 19, 20, 21, 22, 23, 24,
@@ -118,7 +78,7 @@
      1,
 };
 
-static const uint8_t speedhq_run[121] = {
+const uint8_t ff_speedhq_run[121] = {
      0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,
@@ -136,601 +96,3 @@
     23, 24, 25, 26, 27, 28, 29, 30,
     31,
 };
-
-RLTable ff_rl_speedhq = {
-    121,
-    121,
-    speedhq_vlc,
-    speedhq_run,
-    speedhq_level,
-};
-
-#if CONFIG_SPEEDHQ_DECODER
-/* NOTE: The first element is always 16, unscaled. */
-static const uint8_t unscaled_quant_matrix[64] = {
-    16, 16, 19, 22, 26, 27, 29, 34,
-    16, 16, 22, 24, 27, 29, 34, 37,
-    19, 22, 26, 27, 29, 34, 34, 38,
-    22, 22, 26, 27, 29, 34, 37, 40,
-    22, 26, 27, 29, 32, 35, 40, 48,
-    26, 27, 29, 32, 35, 40, 48, 58,
-    26, 27, 29, 34, 38, 46, 56, 69,
-    27, 29, 35, 38, 46, 56, 69, 83
-};
-
-static VLC dc_lum_vlc_le;
-static VLC dc_chroma_vlc_le;
-static VLC dc_alpha_run_vlc_le;
-static VLC dc_alpha_level_vlc_le;
-
-static inline int decode_dc_le(GetBitContext *gb, int component)
-{
-    int code, diff;
-
-    if (component == 0 || component == 3) {
-        code = get_vlc2(gb, dc_lum_vlc_le.table, DC_VLC_BITS, 2);
-    } else {
-        code = get_vlc2(gb, dc_chroma_vlc_le.table, DC_VLC_BITS, 2);
-    }
-    if (!code) {
-        diff = 0;
-    } else {
-        diff = get_xbits_le(gb, code);
-    }
-    return diff;
-}
-
-static inline int decode_alpha_block(const SHQContext *s, GetBitContext *gb, uint8_t last_alpha[16], uint8_t *dest, int linesize)
-{
-    uint8_t block[128];
-    int i = 0, x, y;
-
-    memset(block, 0, sizeof(block));
-
-    {
-        OPEN_READER(re, gb);
-
-        for ( ;; ) {
-            int run, level;
-
-            UPDATE_CACHE_LE(re, gb);
-            GET_VLC(run, re, gb, dc_alpha_run_vlc_le.table, ALPHA_VLC_BITS, 2);
-
-            if (run < 0) break;
-            i += run;
-            if (i >= 128)
-                return AVERROR_INVALIDDATA;
-
-            UPDATE_CACHE_LE(re, gb);
-            GET_VLC(level, re, gb, dc_alpha_level_vlc_le.table, ALPHA_VLC_BITS, 2);
-            block[i++] = level;
-        }
-
-        CLOSE_READER(re, gb);
-    }
-
-    for (y = 0; y < 8; y++) {
-        for (x = 0; x < 16; x++) {
-            last_alpha[x] -= block[y * 16 + x];
-        }
-        memcpy(dest, last_alpha, 16);
-        dest += linesize;
-    }
-
-    return 0;
-}
-
-static inline int decode_dct_block(const SHQContext *s, GetBitContext *gb, int last_dc[4], int component, uint8_t *dest, int linesize)
-{
-    const int *quant_matrix = s->quant_matrix;
-    const uint8_t *scantable = s->intra_scantable.permutated;
-    LOCAL_ALIGNED_32(int16_t, block, [64]);
-    int dc_offset;
-
-    s->bdsp.clear_block(block);
-
-    dc_offset = decode_dc_le(gb, component);
-    last_dc[component] -= dc_offset;  /* Note: Opposite of most codecs. */
-    block[scantable[0]] = last_dc[component];  /* quant_matrix[0] is always 16. */
-
-    /* Read AC coefficients. */
-    {
-        int i = 0;
-        OPEN_READER(re, gb);
-        for ( ;; ) {
-            int level, run;
-            UPDATE_CACHE_LE(re, gb);
-            GET_RL_VLC(level, run, re, gb, ff_rl_speedhq.rl_vlc[0],
-                       TEX_VLC_BITS, 2, 0);
-            if (level == 127) {
-                break;
-            } else if (level) {
-                i += run;
-                if (i > MAX_INDEX)
-                    return AVERROR_INVALIDDATA;
-                /* If next bit is 1, level = -level */
-                level = (level ^ SHOW_SBITS(re, gb, 1)) -
-                        SHOW_SBITS(re, gb, 1);
-                LAST_SKIP_BITS(re, gb, 1);
-            } else {
-                /* Escape. */
-#if MIN_CACHE_BITS < 6 + 6 + 12
-#error MIN_CACHE_BITS is too small for the escape code, add UPDATE_CACHE
-#endif
-                run = SHOW_UBITS(re, gb, 6) + 1;
-                SKIP_BITS(re, gb, 6);
-                level = SHOW_UBITS(re, gb, 12) - 2048;
-                LAST_SKIP_BITS(re, gb, 12);
-
-                i += run;
-                if (i > MAX_INDEX)
-                    return AVERROR_INVALIDDATA;
-            }
-
-            block[scantable[i]] = (level * quant_matrix[i]) >> 4;
-        }
-        CLOSE_READER(re, gb);
-    }
-
-    s->idsp.idct_put(dest, linesize, block);
-
-    return 0;
-}
-
-static int decode_speedhq_border(const SHQContext *s, GetBitContext *gb, AVFrame *frame, int field_number, int line_stride)
-{
-    int linesize_y  = frame->linesize[0] * line_stride;
-    int linesize_cb = frame->linesize[1] * line_stride;
-    int linesize_cr = frame->linesize[2] * line_stride;
-    int linesize_a;
-    int ret;
-
-    if (s->alpha_type != SHQ_NO_ALPHA)
-        linesize_a = frame->linesize[3] * line_stride;
-
-    for (int y = 0; y < frame->height; y += 16 * line_stride) {
-        int last_dc[4] = { 1024, 1024, 1024, 1024 };
-        uint8_t *dest_y, *dest_cb, *dest_cr, *dest_a;
-        uint8_t last_alpha[16];
-        int x = frame->width - 8;
-
-        dest_y = frame->data[0] + frame->linesize[0] * (y + field_number) + x;
-        if (s->subsampling == SHQ_SUBSAMPLING_420) {
-            dest_cb = frame->data[1] + frame->linesize[1] * (y/2 + field_number) + x / 2;
-            dest_cr = frame->data[2] + frame->linesize[2] * (y/2 + field_number) + x / 2;
-        } else {
-            av_assert2(s->subsampling == SHQ_SUBSAMPLING_422);
-            dest_cb = frame->data[1] + frame->linesize[1] * (y + field_number) + x / 2;
-            dest_cr = frame->data[2] + frame->linesize[2] * (y + field_number) + x / 2;
-        }
-        if (s->alpha_type != SHQ_NO_ALPHA) {
-            memset(last_alpha, 255, sizeof(last_alpha));
-            dest_a = frame->data[3] + frame->linesize[3] * (y + field_number) + x;
-        }
-
-        if ((ret = decode_dct_block(s, gb, last_dc, 0, dest_y, linesize_y)) < 0)
-            return ret;
-        if ((ret = decode_dct_block(s, gb, last_dc, 0, dest_y + 8, linesize_y)) < 0)
-            return ret;
-        if ((ret = decode_dct_block(s, gb, last_dc, 0, dest_y + 8 * linesize_y, linesize_y)) < 0)
-            return ret;
-        if ((ret = decode_dct_block(s, gb, last_dc, 0, dest_y + 8 * linesize_y + 8, linesize_y)) < 0)
-            return ret;
-        if ((ret = decode_dct_block(s, gb, last_dc, 1, dest_cb, linesize_cb)) < 0)
-            return ret;
-        if ((ret = decode_dct_block(s, gb, last_dc, 2, dest_cr, linesize_cr)) < 0)
-            return ret;
-
-        if (s->subsampling != SHQ_SUBSAMPLING_420) {
-            if ((ret = decode_dct_block(s, gb, last_dc, 1, dest_cb + 8 * linesize_cb, linesize_cb)) < 0)
-                return ret;
-            if ((ret = decode_dct_block(s, gb, last_dc, 2, dest_cr + 8 * linesize_cr, linesize_cr)) < 0)
-                return ret;
-        }
-
-        if (s->alpha_type == SHQ_RLE_ALPHA) {
-            /* Alpha coded using 16x8 RLE blocks. */
-            if ((ret = decode_alpha_block(s, gb, last_alpha, dest_a, linesize_a)) < 0)
-                return ret;
-            if ((ret = decode_alpha_block(s, gb, last_alpha, dest_a + 8 * linesize_a, linesize_a)) < 0)
-                return ret;
-        } else if (s->alpha_type == SHQ_DCT_ALPHA) {
-            /* Alpha encoded exactly like luma. */
-            if ((ret = decode_dct_block(s, gb, last_dc, 3, dest_a, linesize_a)) < 0)
-                return ret;
-            if ((ret = decode_dct_block(s, gb, last_dc, 3, dest_a + 8, linesize_a)) < 0)
-                return ret;
-            if ((ret = decode_dct_block(s, gb, last_dc, 3, dest_a + 8 * linesize_a, linesize_a)) < 0)
-                return ret;
-            if ((ret = decode_dct_block(s, gb, last_dc, 3, dest_a + 8 * linesize_a + 8, linesize_a)) < 0)
-                return ret;
-        }
-    }
-
-    return 0;
-}
-
-static int decode_speedhq_field(const SHQContext *s, const uint8_t *buf, int buf_size, AVFrame *frame, int field_number, int start, int end, int line_stride)
-{
-    int ret, slice_number, slice_offsets[5];
-    int linesize_y  = frame->linesize[0] * line_stride;
-    int linesize_cb = frame->linesize[1] * line_stride;
-    int linesize_cr = frame->linesize[2] * line_stride;
-    int linesize_a;
-    GetBitContext gb;
-
-    if (s->alpha_type != SHQ_NO_ALPHA)
-        linesize_a = frame->linesize[3] * line_stride;
-
-    if (end < start || end - start < 3 || end > buf_size)
-        return AVERROR_INVALIDDATA;
-
-    slice_offsets[0] = start;
-    slice_offsets[4] = end;
-    for (slice_number = 1; slice_number < 4; slice_number++) {
-        uint32_t last_offset, slice_len;
-
-        last_offset = slice_offsets[slice_number - 1];
-        slice_len = AV_RL24(buf + last_offset);
-        slice_offsets[slice_number] = last_offset + slice_len;
-
-        if (slice_len < 3 || slice_offsets[slice_number] > end - 3)
-            return AVERROR_INVALIDDATA;
-    }
-
-    for (slice_number = 0; slice_number < 4; slice_number++) {
-        uint32_t slice_begin, slice_end;
-        int x, y;
-
-        slice_begin = slice_offsets[slice_number];
-        slice_end = slice_offsets[slice_number + 1];
-
-        if ((ret = init_get_bits8(&gb, buf + slice_begin + 3, slice_end - slice_begin - 3)) < 0)
-            return ret;
-
-        for (y = slice_number * 16 * line_stride; y < frame->height; y += line_stride * 64) {
-            uint8_t *dest_y, *dest_cb, *dest_cr, *dest_a;
-            int last_dc[4] = { 1024, 1024, 1024, 1024 };
-            uint8_t last_alpha[16];
-
-            memset(last_alpha, 255, sizeof(last_alpha));
-
-            dest_y = frame->data[0] + frame->linesize[0] * (y + field_number);
-            if (s->subsampling == SHQ_SUBSAMPLING_420) {
-                dest_cb = frame->data[1] + frame->linesize[1] * (y/2 + field_number);
-                dest_cr = frame->data[2] + frame->linesize[2] * (y/2 + field_number);
-            } else {
-                dest_cb = frame->data[1] + frame->linesize[1] * (y + field_number);
-                dest_cr = frame->data[2] + frame->linesize[2] * (y + field_number);
-            }
-            if (s->alpha_type != SHQ_NO_ALPHA) {
-                dest_a = frame->data[3] + frame->linesize[3] * (y + field_number);
-            }
-
-            for (x = 0; x < frame->width - 8 * (s->subsampling != SHQ_SUBSAMPLING_444); x += 16) {
-                /* Decode the four luma blocks. */
-                if ((ret = decode_dct_block(s, &gb, last_dc, 0, dest_y, linesize_y)) < 0)
-                    return ret;
-                if ((ret = decode_dct_block(s, &gb, last_dc, 0, dest_y + 8, linesize_y)) < 0)
-                    return ret;
-                if ((ret = decode_dct_block(s, &gb, last_dc, 0, dest_y + 8 * linesize_y, linesize_y)) < 0)
-                    return ret;
-                if ((ret = decode_dct_block(s, &gb, last_dc, 0, dest_y + 8 * linesize_y + 8, linesize_y)) < 0)
-                    return ret;
-
-                /*
-                 * Decode the first chroma block. For 4:2:0, this is the only one;
-                 * for 4:2:2, it's the top block; for 4:4:4, it's the top-left block.
-                 */
-                if ((ret = decode_dct_block(s, &gb, last_dc, 1, dest_cb, linesize_cb)) < 0)
-                    return ret;
-                if ((ret = decode_dct_block(s, &gb, last_dc, 2, dest_cr, linesize_cr)) < 0)
-                    return ret;
-
-                if (s->subsampling != SHQ_SUBSAMPLING_420) {
-                    /* For 4:2:2, this is the bottom block; for 4:4:4, it's the bottom-left block. */
-                    if ((ret = decode_dct_block(s, &gb, last_dc, 1, dest_cb + 8 * linesize_cb, linesize_cb)) < 0)
-                        return ret;
-                    if ((ret = decode_dct_block(s, &gb, last_dc, 2, dest_cr + 8 * linesize_cr, linesize_cr)) < 0)
-                        return ret;
-
-                    if (s->subsampling == SHQ_SUBSAMPLING_444) {
-                        /* Top-right and bottom-right blocks. */
-                        if ((ret = decode_dct_block(s, &gb, last_dc, 1, dest_cb + 8, linesize_cb)) < 0)
-                            return ret;
-                        if ((ret = decode_dct_block(s, &gb, last_dc, 2, dest_cr + 8, linesize_cr)) < 0)
-                            return ret;
-                        if ((ret = decode_dct_block(s, &gb, last_dc, 1, dest_cb + 8 * linesize_cb + 8, linesize_cb)) < 0)
-                            return ret;
-                        if ((ret = decode_dct_block(s, &gb, last_dc, 2, dest_cr + 8 * linesize_cr + 8, linesize_cr)) < 0)
-                            return ret;
-
-                        dest_cb += 8;
-                        dest_cr += 8;
-                    }
-                }
-                dest_y += 16;
-                dest_cb += 8;
-                dest_cr += 8;
-
-                if (s->alpha_type == SHQ_RLE_ALPHA) {
-                    /* Alpha coded using 16x8 RLE blocks. */
-                    if ((ret = decode_alpha_block(s, &gb, last_alpha, dest_a, linesize_a)) < 0)
-                        return ret;
-                    if ((ret = decode_alpha_block(s, &gb, last_alpha, dest_a + 8 * linesize_a, linesize_a)) < 0)
-                        return ret;
-                    dest_a += 16;
-                } else if (s->alpha_type == SHQ_DCT_ALPHA) {
-                    /* Alpha encoded exactly like luma. */
-                    if ((ret = decode_dct_block(s, &gb, last_dc, 3, dest_a, linesize_a)) < 0)
-                        return ret;
-                    if ((ret = decode_dct_block(s, &gb, last_dc, 3, dest_a + 8, linesize_a)) < 0)
-                        return ret;
-                    if ((ret = decode_dct_block(s, &gb, last_dc, 3, dest_a + 8 * linesize_a, linesize_a)) < 0)
-                        return ret;
-                    if ((ret = decode_dct_block(s, &gb, last_dc, 3, dest_a + 8 * linesize_a + 8, linesize_a)) < 0)
-                        return ret;
-                    dest_a += 16;
-                }
-            }
-        }
-    }
-
-    if (s->subsampling != SHQ_SUBSAMPLING_444 && (frame->width & 15))
-        return decode_speedhq_border(s, &gb, frame, field_number, line_stride);
-
-    return 0;
-}
-
-static void compute_quant_matrix(int *output, int qscale)
-{
-    int i;
-    for (i = 0; i < 64; i++) output[i] = unscaled_quant_matrix[ff_zigzag_direct[i]] * qscale;
-}
-
-static int speedhq_decode_frame(AVCodecContext *avctx, AVFrame *frame,
-                                int *got_frame, AVPacket *avpkt)
-{
-    SHQContext * const s = avctx->priv_data;
-    const uint8_t *buf   = avpkt->data;
-    int buf_size         = avpkt->size;
-    uint8_t quality;
-    uint32_t second_field_offset;
-    int ret;
-
-    if (buf_size < 4 || avctx->width < 8 || avctx->width % 8 != 0)
-        return AVERROR_INVALIDDATA;
-
-    quality = buf[0];
-    if (quality >= 100) {
-        return AVERROR_INVALIDDATA;
-    }
-
-    compute_quant_matrix(s->quant_matrix, 100 - quality);
-
-    second_field_offset = AV_RL24(buf + 1);
-    if (second_field_offset >= buf_size - 3) {
-        return AVERROR_INVALIDDATA;
-    }
-
-    avctx->coded_width = FFALIGN(avctx->width, 16);
-    avctx->coded_height = FFALIGN(avctx->height, 16);
-
-    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
-        return ret;
-    }
-    frame->key_frame = 1;
-
-    if (second_field_offset == 4 || second_field_offset == (buf_size-4)) {
-        /*
-         * Overlapping first and second fields is used to signal
-         * encoding only a single field. In this case, "height"
-         * is ambiguous; it could mean either the height of the
-         * frame as a whole, or of the field. The former would make
-         * more sense for compatibility with legacy decoders,
-         * but this matches the convention used in NDI, which is
-         * the primary user of this trick.
-         */
-        if ((ret = decode_speedhq_field(s, buf, buf_size, frame, 0, 4, buf_size, 1)) < 0)
-            return ret;
-    } else {
-        if ((ret = decode_speedhq_field(s, buf, buf_size, frame, 0, 4, second_field_offset, 2)) < 0)
-            return ret;
-        if ((ret = decode_speedhq_field(s, buf, buf_size, frame, 1, second_field_offset, buf_size, 2)) < 0)
-            return ret;
-    }
-
-    *got_frame = 1;
-    return buf_size;
-}
-
-/*
- * Alpha VLC. Run and level are independently coded, and would be
- * outside the default limits for MAX_RUN/MAX_LEVEL, so we don't
- * bother with combining them into one table.
- */
-static av_cold void compute_alpha_vlcs(void)
-{
-    uint16_t run_code[134], level_code[266];
-    uint8_t run_bits[134], level_bits[266];
-    int16_t run_symbols[134], level_symbols[266];
-    int entry, i, sign;
-
-    /* Initialize VLC for alpha run. */
-    entry = 0;
-
-    /* 0 -> 0. */
-    run_code[entry] = 0;
-    run_bits[entry] = 1;
-    run_symbols[entry] = 0;
-    ++entry;
-
-    /* 10xx -> xx plus 1. */
-    for (i = 0; i < 4; ++i) {
-        run_code[entry] = (i << 2) | 1;
-        run_bits[entry] = 4;
-        run_symbols[entry] = i + 1;
-        ++entry;
-    }
-
-    /* 111xxxxxxx -> xxxxxxx. */
-    for (i = 0; i < 128; ++i) {
-        run_code[entry] = (i << 3) | 7;
-        run_bits[entry] = 10;
-        run_symbols[entry] = i;
-        ++entry;
-    }
-
-    /* 110 -> EOB. */
-    run_code[entry] = 3;
-    run_bits[entry] = 3;
-    run_symbols[entry] = -1;
-    ++entry;
-
-    av_assert0(entry == FF_ARRAY_ELEMS(run_code));
-
-    INIT_LE_VLC_SPARSE_STATIC(&dc_alpha_run_vlc_le, ALPHA_VLC_BITS,
-                              FF_ARRAY_ELEMS(run_code),
-                              run_bits, 1, 1,
-                              run_code, 2, 2,
-                              run_symbols, 2, 2, 160);
-
-    /* Initialize VLC for alpha level. */
-    entry = 0;
-
-    for (sign = 0; sign <= 1; ++sign) {
-        /* 1s -> -1 or +1 (depending on sign bit). */
-        level_code[entry] = (sign << 1) | 1;
-        level_bits[entry] = 2;
-        level_symbols[entry] = sign ? -1 : 1;
-        ++entry;
-
-        /* 01sxx -> xx plus 2 (2..5 or -2..-5, depending on sign bit). */
-        for (i = 0; i < 4; ++i) {
-            level_code[entry] = (i << 3) | (sign << 2) | 2;
-            level_bits[entry] = 5;
-            level_symbols[entry] = sign ? -(i + 2) : (i + 2);
-            ++entry;
-        }
-    }
-
-    /*
-     * 00xxxxxxxx -> xxxxxxxx, in two's complement. There are many codes
-     * here that would better be encoded in other ways (e.g. 0 would be
-     * encoded by increasing run, and +/- 1 would be encoded with a
-     * shorter code), but it doesn't hurt to allow everything.
-     */
-    for (i = 0; i < 256; ++i) {
-        level_code[entry] = i << 2;
-        level_bits[entry] = 10;
-        level_symbols[entry] = i;
-        ++entry;
-    }
-
-    av_assert0(entry == FF_ARRAY_ELEMS(level_code));
-
-    INIT_LE_VLC_SPARSE_STATIC(&dc_alpha_level_vlc_le, ALPHA_VLC_BITS,
-                              FF_ARRAY_ELEMS(level_code),
-                              level_bits, 1, 1,
-                              level_code, 2, 2,
-                              level_symbols, 2, 2, 288);
-}
-
-static av_cold void speedhq_static_init(void)
-{
-    /* Exactly the same as MPEG-2, except for a little-endian reader. */
-    INIT_CUSTOM_VLC_STATIC(&dc_lum_vlc_le, DC_VLC_BITS, 12,
-                           ff_mpeg12_vlc_dc_lum_bits, 1, 1,
-                           ff_mpeg12_vlc_dc_lum_code, 2, 2,
-                           INIT_VLC_OUTPUT_LE, 512);
-    INIT_CUSTOM_VLC_STATIC(&dc_chroma_vlc_le, DC_VLC_BITS, 12,
-                           ff_mpeg12_vlc_dc_chroma_bits, 1, 1,
-                           ff_mpeg12_vlc_dc_chroma_code, 2, 2,
-                           INIT_VLC_OUTPUT_LE, 514);
-
-    INIT_2D_VLC_RL(ff_rl_speedhq, 674, INIT_VLC_LE);
-
-    compute_alpha_vlcs();
-}
-
-static av_cold int speedhq_decode_init(AVCodecContext *avctx)
-{
-    int ret;
-    static AVOnce init_once = AV_ONCE_INIT;
-    SHQContext * const s = avctx->priv_data;
-
-    s->avctx = avctx;
-
-    ret = ff_thread_once(&init_once, speedhq_static_init);
-    if (ret)
-        return AVERROR_UNKNOWN;
-
-    ff_blockdsp_init(&s->bdsp);
-    ff_idctdsp_init(&s->idsp, avctx);
-    ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);
-
-    switch (avctx->codec_tag) {
-    case MKTAG('S', 'H', 'Q', '0'):
-        s->subsampling = SHQ_SUBSAMPLING_420;
-        s->alpha_type = SHQ_NO_ALPHA;
-        avctx->pix_fmt = AV_PIX_FMT_YUV420P;
-        break;
-    case MKTAG('S', 'H', 'Q', '1'):
-        s->subsampling = SHQ_SUBSAMPLING_420;
-        s->alpha_type = SHQ_RLE_ALPHA;
-        avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
-        break;
-    case MKTAG('S', 'H', 'Q', '2'):
-        s->subsampling = SHQ_SUBSAMPLING_422;
-        s->alpha_type = SHQ_NO_ALPHA;
-        avctx->pix_fmt = AV_PIX_FMT_YUV422P;
-        break;
-    case MKTAG('S', 'H', 'Q', '3'):
-        s->subsampling = SHQ_SUBSAMPLING_422;
-        s->alpha_type = SHQ_RLE_ALPHA;
-        avctx->pix_fmt = AV_PIX_FMT_YUVA422P;
-        break;
-    case MKTAG('S', 'H', 'Q', '4'):
-        s->subsampling = SHQ_SUBSAMPLING_444;
-        s->alpha_type = SHQ_NO_ALPHA;
-        avctx->pix_fmt = AV_PIX_FMT_YUV444P;
-        break;
-    case MKTAG('S', 'H', 'Q', '5'):
-        s->subsampling = SHQ_SUBSAMPLING_444;
-        s->alpha_type = SHQ_RLE_ALPHA;
-        avctx->pix_fmt = AV_PIX_FMT_YUVA444P;
-        break;
-    case MKTAG('S', 'H', 'Q', '7'):
-        s->subsampling = SHQ_SUBSAMPLING_422;
-        s->alpha_type = SHQ_DCT_ALPHA;
-        avctx->pix_fmt = AV_PIX_FMT_YUVA422P;
-        break;
-    case MKTAG('S', 'H', 'Q', '9'):
-        s->subsampling = SHQ_SUBSAMPLING_444;
-        s->alpha_type = SHQ_DCT_ALPHA;
-        avctx->pix_fmt = AV_PIX_FMT_YUVA444P;
-        break;
-    default:
-        av_log(avctx, AV_LOG_ERROR, "Unknown NewTek SpeedHQ FOURCC provided (%08X)\n",
-               avctx->codec_tag);
-        return AVERROR_INVALIDDATA;
-    }
-
-    /* This matches what NDI's RGB -> Y'CbCr 4:2:2 converter uses. */
-    avctx->colorspace = AVCOL_SPC_BT470BG;
-    avctx->chroma_sample_location = AVCHROMA_LOC_CENTER;
-
-    return 0;
-}
-
-const FFCodec ff_speedhq_decoder = {
-    .p.name         = "speedhq",
-    CODEC_LONG_NAME("NewTek SpeedHQ"),
-    .p.type         = AVMEDIA_TYPE_VIDEO,
-    .p.id           = AV_CODEC_ID_SPEEDHQ,
-    .priv_data_size = sizeof(SHQContext),
-    .init           = speedhq_decode_init,
-    FF_CODEC_DECODE_CB(speedhq_decode_frame),
-    .p.capabilities = AV_CODEC_CAP_DR1,
-};
-#endif /* CONFIG_SPEEDHQ_DECODER */
--- a/third_party/ffmpeg/libavcodec/speedhqenc.c
+++ b/third_party/ffmpeg/libavcodec/speedhqenc.c
@@ -27,20 +27,21 @@
  * SpeedHQ encoder.
  */
 
-#include "config_components.h"
-
 #include "libavutil/thread.h"
 
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "mpeg12data.h"
-#include "mpeg12enc.h"
+#include "mpeg12vlc.h"
 #include "mpegvideo.h"
+#include "mpegvideodata.h"
 #include "mpegvideoenc.h"
+#include "rl.h"
+#include "speedhq.h"
 #include "speedhqenc.h"
 
-extern RLTable ff_rl_speedhq;
-static uint8_t speedhq_static_rl_table_store[2][2*MAX_RUN + MAX_LEVEL + 3];
+static uint8_t speedhq_max_level[MAX_LEVEL + 1];
+static uint8_t speedhq_index_run[MAX_RUN   + 1];
 
 /* Exactly the same as MPEG-2, except little-endian. */
 static const uint16_t mpeg12_vlc_dc_lum_code_reversed[12] = {
@@ -65,7 +66,8 @@
 
 static av_cold void speedhq_init_static_data(void)
 {
-    ff_rl_init(&ff_rl_speedhq, speedhq_static_rl_table_store);
+    ff_rl_init_level_run(speedhq_max_level, speedhq_index_run,
+                         ff_speedhq_run, ff_speedhq_level, SPEEDHQ_RL_NB_ELEMS);
 
     /* build unified dc encoding tables */
     for (int i = -255; i < 256; i++) {
@@ -89,7 +91,8 @@
         speedhq_chr_dc_uni[i + 255] = bits + (code << 8);
     }
 
-    ff_mpeg1_init_uni_ac_vlc(&ff_rl_speedhq, uni_speedhq_ac_vlc_len);
+    ff_mpeg1_init_uni_ac_vlc(speedhq_max_level, speedhq_index_run,
+                             ff_speedhq_vlc_table, uni_speedhq_ac_vlc_len);
 }
 
 av_cold int ff_speedhq_encode_init(MpegEncContext *s)
@@ -111,6 +114,9 @@
     s->intra_chroma_ac_vlc_length      =
     s->intra_chroma_ac_vlc_last_length = uni_speedhq_ac_vlc_len;
 
+    s->y_dc_scale_table =
+    s->c_dc_scale_table = ff_mpeg2_dc_scale_table[3];
+
     switch (s->avctx->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
         s->avctx->codec_tag = MKTAG('S','H','Q','0');
@@ -217,14 +223,14 @@
             MASK_ABS(sign, alevel);
             sign &= 1;
 
-            if (alevel <= ff_rl_speedhq.max_level[0][run]) {
-                code = ff_rl_speedhq.index_run[0][run] + alevel - 1;
+            if (alevel <= speedhq_max_level[run]) {
+                code = speedhq_index_run[run] + alevel - 1;
                 /* store the VLC & sign at once */
-                put_bits_le(&s->pb, ff_rl_speedhq.table_vlc[code][1] + 1,
-                            ff_rl_speedhq.table_vlc[code][0] + (sign << ff_rl_speedhq.table_vlc[code][1]));
+                put_bits_le(&s->pb, ff_speedhq_vlc_table[code][1] + 1,
+                            ff_speedhq_vlc_table[code][0] | (sign << ff_speedhq_vlc_table[code][1]));
             } else {
                 /* escape seems to be pretty rare <5% so I do not optimize it;
-                 * the values correspond to ff_rl_speedhq.table_vlc[121] */
+                 * the values correspond to ff_speedhq_vlc_table[121] */
                 put_bits_le(&s->pb, 6, 32);
                 /* escape: only clip in this case */
                 put_bits_le(&s->pb, 6, run);
@@ -233,7 +239,7 @@
             last_non_zero = i;
         }
     }
-    /* end of block; the values correspond to ff_rl_speedhq.table_vlc[122] */
+    /* end of block; the values correspond to ff_speedhq_vlc_table[122] */
     put_bits_le(&s->pb, 4, 6);
 }
 
@@ -276,7 +282,6 @@
     return mb_y_order * 4 + slice_num;
 }
 
-#if CONFIG_SPEEDHQ_ENCODER
 const FFCodec ff_speedhq_encoder = {
     .p.name         = "speedhq",
     CODEC_LONG_NAME("NewTek SpeedHQ"),
@@ -293,4 +298,3 @@
         AV_PIX_FMT_NONE
     },
 };
-#endif
--- a/third_party/ffmpeg/libavcodec/speedhqenc.h
+++ b/third_party/ffmpeg/libavcodec/speedhqenc.h
@@ -31,10 +31,7 @@
 
 #include <stdint.h>
 
-#include "mjpeg.h"
-#include "mjpegenc_common.h"
 #include "mpegvideo.h"
-#include "put_bits.h"
 
 int  ff_speedhq_encode_init(MpegEncContext *s);
 void ff_speedhq_encode_close(MpegEncContext *s);
--- a/third_party/ffmpeg/libavcodec/speexdec.c
+++ b/third_party/ffmpeg/libavcodec/speexdec.c
@@ -1452,7 +1452,7 @@
             return AVERROR_INVALIDDATA;
 
         s->nb_channels = avctx->ch_layout.nb_channels;
-        if (s->nb_channels <= 0)
+        if (s->nb_channels <= 0 || s->nb_channels > 2)
             return AVERROR_INVALIDDATA;
 
         switch (s->rate) {
--- a/third_party/ffmpeg/libavcodec/startcode.c
+++ b/third_party/ffmpeg/libavcodec/startcode.c
@@ -25,6 +25,7 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
+#include "libavutil/intreadwrite.h"
 #include "startcode.h"
 #include "config.h"
 
@@ -38,14 +39,14 @@
      */
 #if HAVE_FAST_64BIT
     while (i < size &&
-            !((~*(const uint64_t *)(buf + i) &
-                    (*(const uint64_t *)(buf + i) - 0x0101010101010101ULL)) &
+            !((~AV_RN64(buf + i) &
+                    (AV_RN64(buf + i) - 0x0101010101010101ULL)) &
                     0x8080808080808080ULL))
         i += 8;
 #else
     while (i < size &&
-            !((~*(const uint32_t *)(buf + i) &
-                    (*(const uint32_t *)(buf + i) - 0x01010101U)) &
+            !((~AV_RN32(buf + i) &
+                    (AV_RN32(buf + i) - 0x01010101U)) &
                     0x80808080U))
         i += 4;
 #endif
--- a/third_party/ffmpeg/libavcodec/sunrast.c
+++ b/third_party/ffmpeg/libavcodec/sunrast.c
@@ -31,7 +31,8 @@
 {
     const uint8_t *buf       = avpkt->data;
     const uint8_t *buf_end   = avpkt->data + avpkt->size;
-    unsigned int w, h, depth, type, maptype, maplength, stride, x, y, len, alen;
+    unsigned int w, h, depth, type, maptype, maplength, x, y, len, alen;
+    ptrdiff_t stride;
     uint8_t *ptr, *ptr2 = NULL;
     const uint8_t *bufstart = buf;
     int ret;
@@ -141,7 +142,7 @@
 
     if (type == RT_BYTE_ENCODED) {
         int value, run;
-        uint8_t *end = ptr + h * stride;
+        uint8_t *end = ptr + (ptrdiff_t)h * stride;
 
         x = 0;
         while (ptr != end && buf < buf_end) {
--- a/third_party/ffmpeg/libavcodec/svq1.h
+++ b/third_party/ffmpeg/libavcodec/svq1.h
@@ -37,11 +37,21 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
+
 #define SVQ1_BLOCK_SKIP         0
 #define SVQ1_BLOCK_INTER        1
 #define SVQ1_BLOCK_INTER_4V     2
 #define SVQ1_BLOCK_INTRA        3
 
+#define SVQ1_BLOCK_SKIP_CODE    1
+#define SVQ1_BLOCK_SKIP_LEN     1
+#define SVQ1_BLOCK_INTER_CODE   1
+#define SVQ1_BLOCK_INTER_LEN    2
+#define SVQ1_BLOCK_INTRA_CODE   0
+#define SVQ1_BLOCK_INTRA_LEN    3
+
+FF_VISIBILITY_PUSH_HIDDEN
 extern const int8_t *const ff_svq1_inter_codebooks[6];
 extern const int8_t *const ff_svq1_intra_codebooks[6];
 
@@ -52,5 +62,6 @@
 extern const uint16_t ff_svq1_inter_mean_vlc[512][2];
 
 extern const uint16_t ff_svq1_frame_size_table[7][2];
+FF_VISIBILITY_POP_HIDDEN
 
 #endif /* AVCODEC_SVQ1_H */
--- a/third_party/ffmpeg/libavcodec/svq1enc.c
+++ b/third_party/ffmpeg/libavcodec/svq1enc.c
@@ -37,44 +37,99 @@
 #include "internal.h"
 #include "mpegutils.h"
 #include "packet_internal.h"
+#include "put_bits.h"
 #include "svq1.h"
-#include "svq1enc.h"
+#include "svq1encdsp.h"
 #include "svq1enc_cb.h"
+
 #include "libavutil/avassert.h"
+#include "libavutil/frame.h"
+#include "libavutil/mem_internal.h"
+
+// Workaround for GCC bug 102513
+#if AV_GCC_VERSION_AT_LEAST(10, 0) && AV_GCC_VERSION_AT_MOST(12, 0) \
+    && !defined(__clang__) && !defined(__INTEL_COMPILER)
+#pragma GCC optimize ("no-ipa-cp-clone")
+#endif
+
+typedef struct SVQ1EncContext {
+    /* FIXME: Needed for motion estimation, should not be used for anything
+     * else, the idea is to make the motion estimation eventually independent
+     * of MpegEncContext, so this will be removed then. */
+    MpegEncContext m;
+    AVCodecContext *avctx;
+    MECmpContext mecc;
+    HpelDSPContext hdsp;
+    AVFrame *current_picture;
+    AVFrame *last_picture;
+
+    /* Some compression statistics */
+    enum AVPictureType pict_type;
+    int quality;
+
+    /* why ooh why this sick breadth first order,
+     * everything is slower and more complex */
+    PutBitContext reorder_pb[6];
+
+    int frame_width;
+    int frame_height;
+
+    /* Y plane block dimensions */
+    int y_block_width;
+    int y_block_height;
 
+    /* U & V plane (C planes) block dimensions */
+    int c_block_width;
+    int c_block_height;
 
-static void svq1_write_header(SVQ1EncContext *s, int frame_type)
+    DECLARE_ALIGNED(16, int16_t, encoded_block_levels)[6][7][256];
+
+    uint16_t *mb_type;
+    uint32_t *dummy;
+    int16_t (*motion_val8[3])[2];
+    int16_t (*motion_val16[3])[2];
+
+    int64_t rd_total;
+
+    uint8_t *scratchbuf;
+
+    int motion_est;
+
+    SVQ1EncDSPContext svq1encdsp;
+} SVQ1EncContext;
+
+static void svq1_write_header(SVQ1EncContext *s, PutBitContext *pb, int frame_type)
 {
     int i;
 
     /* frame code */
-    put_bits(&s->pb, 22, 0x20);
+    put_bits(pb, 22, 0x20);
 
     /* temporal reference (sure hope this is a "don't care") */
-    put_bits(&s->pb, 8, 0x00);
+    put_bits(pb, 8, 0x00);
 
     /* frame type */
-    put_bits(&s->pb, 2, frame_type - 1);
+    put_bits(pb, 2, frame_type - 1);
 
     if (frame_type == AV_PICTURE_TYPE_I) {
         /* no checksum since frame code is 0x20 */
         /* no embedded string either */
         /* output 5 unknown bits (2 + 2 + 1) */
-        put_bits(&s->pb, 5, 2); /* 2 needed by quicktime decoder */
+        put_bits(pb, 5, 2); /* 2 needed by quicktime decoder */
 
         i = ff_match_2uint16((void*)ff_svq1_frame_size_table,
                              FF_ARRAY_ELEMS(ff_svq1_frame_size_table),
                              s->frame_width, s->frame_height);
-        put_bits(&s->pb, 3, i);
+        put_bits(pb, 3, i);
 
         if (i == 7) {
-            put_bits(&s->pb, 12, s->frame_width);
-            put_bits(&s->pb, 12, s->frame_height);
+            put_bits(pb, 12, s->frame_width);
+            put_bits(pb, 12, s->frame_height);
         }
     }
 
     /* no checksum or extra data (next 2 bits get 0) */
-    put_bits(&s->pb, 2, 0);
+    put_bits(pb, 2, 0);
 }
 
 #define QUALITY_THRESHOLD    100
@@ -154,7 +209,7 @@
                 int sqr, diff, score;
 
                 vector = codebook + stage * size * 16 + i * size;
-                sqr    = s->ssd_int8_vs_int16(vector, block[stage], size);
+                sqr    = s->svq1encdsp.ssd_int8_vs_int16(vector, block[stage], size);
                 diff   = block_sum[stage] - sum;
                 score  = sqr - (diff * (int64_t)diff >> (level + 3)); // FIXME: 64 bits slooow
                 if (score < best_vector_score) {
@@ -248,6 +303,7 @@
 }
 
 static int svq1_encode_plane(SVQ1EncContext *s, int plane,
+                             PutBitContext *pb,
                              const unsigned char *src_plane,
                              unsigned char *ref_plane,
                              unsigned char *decoded_plane,
@@ -375,7 +431,7 @@
             int score[4]     = { 0, 0, 0, 0 }, best;
             uint8_t *temp    = s->scratchbuf;
 
-            if (put_bytes_left(&s->pb, 0) < 3000) { // FIXME: check size
+            if (put_bytes_left(pb, 0) < 3000) { // FIXME: check size
                 av_log(s->avctx, AV_LOG_ERROR, "encoded frame too large\n");
                 return -1;
             }
@@ -390,9 +446,8 @@
                     init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],
                                   7 * 32);
                 if (s->pict_type == AV_PICTURE_TYPE_P) {
-                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];
-                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);
-                    score[0] = vlc[1] * lambda;
+                    put_bits(&s->reorder_pb[5], SVQ1_BLOCK_INTRA_LEN, SVQ1_BLOCK_INTRA_CODE);
+                    score[0] = SVQ1_BLOCK_INTRA_LEN * lambda;
                 }
                 score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,
                                          5, 64, lambda, 1);
@@ -406,7 +461,6 @@
             best = 0;
 
             if (s->pict_type == AV_PICTURE_TYPE_P) {
-                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];
                 int mx, my, pred_x, pred_y, dxy;
                 int16_t *motion_ptr;
 
@@ -417,7 +471,7 @@
                         init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],
                                       7 * 32);
 
-                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);
+                    put_bits(&s->reorder_pb[5], SVQ1_BLOCK_INTER_LEN, SVQ1_BLOCK_INTER_CODE);
 
                     s->m.pb = s->reorder_pb[5];
                     mx      = motion_ptr[0];
@@ -442,14 +496,13 @@
                                              decoded, stride, 5, 64, lambda, 0);
                     best      = score[1] <= score[0];
 
-                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];
                     score[2]  = s->mecc.sse[0](NULL, src + 16 * x, ref,
                                                stride, 16);
-                    score[2] += vlc[1] * lambda;
+                    score[2] += SVQ1_BLOCK_SKIP_LEN * lambda;
                     if (score[2] < score[best] && mx == 0 && my == 0) {
                         best = 2;
                         s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);
-                        put_bits(&s->pb, vlc[1], vlc[0]);
+                        put_bits(pb, SVQ1_BLOCK_SKIP_LEN, SVQ1_BLOCK_SKIP_CODE);
                     }
                 }
 
@@ -474,7 +527,7 @@
 
             if (best != 2)
             for (i = 5; i >= 0; i--)
-                ff_copy_bits(&s->pb, reorder_buffer[best][i],
+                ff_copy_bits(pb, reorder_buffer[best][i],
                                  count[best][i]);
             if (best == 0)
                 s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);
@@ -561,7 +614,7 @@
                                         s->y_block_height * sizeof(int16_t));
     s->dummy               = av_mallocz((s->y_block_width + 1) *
                                         s->y_block_height * sizeof(int32_t));
-    s->ssd_int8_vs_int16   = ssd_int8_vs_int16_c;
+    s->svq1encdsp.ssd_int8_vs_int16 = ssd_int8_vs_int16_c;
 
     if (!s->m.me.temp || !s->m.me.scratchpad || !s->m.me.map ||
         !s->m.me.score_map || !s->mb_type || !s->dummy) {
@@ -569,9 +622,9 @@
     }
 
 #if ARCH_PPC
-    ff_svq1enc_init_ppc(s);
+    ff_svq1enc_init_ppc(&s->svq1encdsp);
 #elif ARCH_X86
-    ff_svq1enc_init_x86(s);
+    ff_svq1enc_init_x86(&s->svq1encdsp);
 #endif
 
     ff_h263_encode_init(&s->m); // mv_penalty
@@ -583,6 +636,7 @@
                              const AVFrame *pict, int *got_packet)
 {
     SVQ1EncContext *const s = avctx->priv_data;
+    PutBitContext pb;
     int i, ret;
 
     ret = ff_alloc_packet(avctx, pkt, s->y_block_width * s->y_block_height *
@@ -613,8 +667,6 @@
 
     FFSWAP(AVFrame*, s->current_picture, s->last_picture);
 
-    init_put_bits(&s->pb, pkt->data, pkt->size);
-
     if (avctx->gop_size && (avctx->frame_number % avctx->gop_size))
         s->pict_type = AV_PICTURE_TYPE_P;
     else
@@ -623,9 +675,10 @@
 
     ff_side_data_set_encoder_stats(pkt, pict->quality, NULL, 0, s->pict_type);
 
-    svq1_write_header(s, s->pict_type);
+    init_put_bits(&pb, pkt->data, pkt->size);
+    svq1_write_header(s, &pb, s->pict_type);
     for (i = 0; i < 3; i++) {
-        int ret = svq1_encode_plane(s, i,
+        int ret = svq1_encode_plane(s, i, &pb,
                               pict->data[i],
                               s->last_picture->data[i],
                               s->current_picture->data[i],
@@ -645,13 +698,13 @@
         }
     }
 
-    // align_put_bits(&s->pb);
-    while (put_bits_count(&s->pb) & 31)
-        put_bits(&s->pb, 1, 0);
+    // align_put_bits(&pb);
+    while (put_bits_count(&pb) & 31)
+        put_bits(&pb, 1, 0);
 
-    flush_put_bits(&s->pb);
+    flush_put_bits(&pb);
 
-    pkt->size = put_bytes_output(&s->pb);
+    pkt->size = put_bytes_output(&pb);
     if (s->pict_type == AV_PICTURE_TYPE_I)
         pkt->flags |= AV_PKT_FLAG_KEY;
     *got_packet = 1;
--- a/third_party/ffmpeg/libavcodec/svq1enc.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * SVQ1 encoder
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_SVQ1ENC_H
-#define AVCODEC_SVQ1ENC_H
-
-#include <stdint.h>
-
-#include "libavutil/frame.h"
-#include "libavutil/mem_internal.h"
-
-#include "avcodec.h"
-#include "hpeldsp.h"
-#include "me_cmp.h"
-#include "mpegvideo.h"
-#include "put_bits.h"
-
-typedef struct SVQ1EncContext {
-    /* FIXME: Needed for motion estimation, should not be used for anything
-     * else, the idea is to make the motion estimation eventually independent
-     * of MpegEncContext, so this will be removed then. */
-    MpegEncContext m;
-    AVCodecContext *avctx;
-    MECmpContext mecc;
-    HpelDSPContext hdsp;
-    AVFrame *current_picture;
-    AVFrame *last_picture;
-    PutBitContext pb;
-
-    /* Some compression statistics */
-    enum AVPictureType pict_type;
-    int quality;
-
-    /* why ooh why this sick breadth first order,
-     * everything is slower and more complex */
-    PutBitContext reorder_pb[6];
-
-    int frame_width;
-    int frame_height;
-
-    /* Y plane block dimensions */
-    int y_block_width;
-    int y_block_height;
-
-    /* U & V plane (C planes) block dimensions */
-    int c_block_width;
-    int c_block_height;
-
-    DECLARE_ALIGNED(16, int16_t, encoded_block_levels)[6][7][256];
-
-    uint16_t *mb_type;
-    uint32_t *dummy;
-    int16_t (*motion_val8[3])[2];
-    int16_t (*motion_val16[3])[2];
-
-    int64_t rd_total;
-
-    uint8_t *scratchbuf;
-
-    int motion_est;
-
-    int (*ssd_int8_vs_int16)(const int8_t *pix1, const int16_t *pix2,
-                             intptr_t size);
-} SVQ1EncContext;
-
-void ff_svq1enc_init_ppc(SVQ1EncContext *c);
-void ff_svq1enc_init_x86(SVQ1EncContext *c);
-
-#endif /* AVCODEC_SVQ1ENC_H */
--- a/third_party/ffmpeg/libavcodec/tests/mpeg12framerate.c
+++ b/third_party/ffmpeg/libavcodec/tests/mpeg12framerate.c
@@ -16,6 +16,9 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <stddef.h>
+
+#include "libavutil/log.h"
 #include "libavcodec/mpeg12.h"
 #include "libavcodec/mpeg12data.h"
 
--- a/third_party/ffmpeg/libavcodec/tiff.c
+++ b/third_party/ffmpeg/libavcodec/tiff.c
@@ -33,6 +33,8 @@
 #include <lzma.h>
 #endif
 
+#include <float.h>
+
 #include "libavutil/attributes.h"
 #include "libavutil/error.h"
 #include "libavutil/intreadwrite.h"
@@ -82,8 +84,17 @@
     unsigned last_tag;
 
     int is_bayer;
+    int use_color_matrix;
     uint8_t pattern[4];
-    unsigned black_level;
+
+    float   analog_balance[4];
+    float   as_shot_neutral[4];
+    float   as_shot_white[4];
+    float   color_matrix[3][4];
+    float   camera_calibration[4][4];
+    float   premultiply[4];
+    float   black_level[4];
+
     unsigned white_level;
     uint16_t dng_lut[65536];
 
@@ -112,6 +123,8 @@
     TiffGeoTag *geotags;
 } TiffContext;
 
+static const float d65_white[3] = { 0.950456f, 1.f, 1.088754f };
+
 static void tiff_set_type(TiffContext *s, enum TiffType tiff_type) {
     if (s->tiff_type < tiff_type) // Prioritize higher-valued entries
         s->tiff_type = tiff_type;
@@ -277,29 +290,26 @@
  */
 static uint16_t av_always_inline dng_process_color16(uint16_t value,
                                                      const uint16_t *lut,
-                                                     uint16_t black_level,
+                                                     float black_level,
                                                      float scale_factor)
 {
     float value_norm;
 
     // Lookup table lookup
-    if (lut)
-        value = lut[value];
+    value = lut[value];
 
     // Black level subtraction
-    value = av_clip_uint16_c((unsigned)value - black_level);
-
     // Color scaling
-    value_norm = (float)value * scale_factor;
+    value_norm = ((float)value - black_level) * scale_factor;
 
-    value = av_clip_uint16_c(value_norm * 65535);
+    value = av_clip_uint16(lrintf(value_norm));
 
     return value;
 }
 
 static uint16_t av_always_inline dng_process_color8(uint16_t value,
                                                     const uint16_t *lut,
-                                                    uint16_t black_level,
+                                                    float black_level,
                                                     float scale_factor)
 {
     return dng_process_color16(value, lut, black_level, scale_factor) >> 8;
@@ -307,12 +317,18 @@
 
 static void av_always_inline dng_blit(TiffContext *s, uint8_t *dst, int dst_stride,
                                       const uint8_t *src, int src_stride, int width, int height,
-                                      int is_single_comp, int is_u16)
+                                      int is_single_comp, int is_u16, int odd_line)
 {
+    float scale_factor[4];
     int line, col;
-    float scale_factor;
 
-    scale_factor = 1.0f / (s->white_level - s->black_level);
+    if (s->is_bayer) {
+        for (int i = 0; i < 4; i++)
+            scale_factor[i] = s->premultiply[s->pattern[i]] * 65535.f / (s->white_level - s->black_level[i]);
+    } else {
+        for (int i = 0; i < 4; i++)
+            scale_factor[i] = 65535.f * s->premultiply[i] / (s->white_level - s->black_level[i]);
+    }
 
     if (is_single_comp) {
         if (!is_u16)
@@ -326,7 +342,7 @@
 
             /* Blit first half of input row row to initial row of output */
             for (col = 0; col < width; col++)
-                *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level, scale_factor);
+                *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level[col&1], scale_factor[col&1]);
 
             /* Advance the destination pointer by a row (source pointer remains in the same place) */
             dst += dst_stride * sizeof(uint16_t);
@@ -334,7 +350,7 @@
 
             /* Blit second half of input row row to next row of output */
             for (col = 0; col < width; col++)
-                *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level, scale_factor);
+                *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level[(col&1) + 2], scale_factor[(col&1) + 2]);
 
             dst += dst_stride * sizeof(uint16_t);
             src += src_stride * sizeof(uint16_t);
@@ -348,7 +364,9 @@
                 uint16_t *src_u16 = (uint16_t *)src;
 
                 for (col = 0; col < width; col++)
-                    *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level, scale_factor);
+                    *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut,
+                                                     s->black_level[(col&1) + 2 * ((line&1) + odd_line)],
+                                                     scale_factor[(col&1) + 2 * ((line&1) + odd_line)]);
 
                 dst += dst_stride * sizeof(uint16_t);
                 src += src_stride * sizeof(uint16_t);
@@ -359,7 +377,9 @@
                 const uint8_t *src_u8 = src;
 
                 for (col = 0; col < width; col++)
-                    *dst_u8++ = dng_process_color8(*src_u8++, s->dng_lut, s->black_level, scale_factor);
+                    *dst_u8++ = dng_process_color8(*src_u8++, s->dng_lut,
+                                                   s->black_level[(col&1) + 2 * ((line&1) + odd_line)],
+                                                   scale_factor[(col&1) + 2 * ((line&1) + odd_line)]);
 
                 dst += dst_stride;
                 src += src_stride;
@@ -713,7 +733,7 @@
              w,
              h,
              is_single_comp,
-             is_u16);
+             is_u16, 0);
 
     av_frame_unref(s->jpgframe);
 
@@ -893,7 +913,8 @@
                          elements,
                          1,
                          0, // single-component variation is only preset in JPEG-encoded DNGs
-                         is_u16);
+                         is_u16,
+                         (line + strip_start)&1);
             }
 
             src += width;
@@ -1027,14 +1048,14 @@
     int create_gray_palette = 0;
 
     // make sure there is no aliasing in the following switch
-    if (s->bpp >= 100 || s->bppcount >= 10) {
+    if (s->bpp > 128 || s->bppcount >= 10) {
         av_log(s->avctx, AV_LOG_ERROR,
                "Unsupported image parameters: bpp=%d, bppcount=%d\n",
                s->bpp, s->bppcount);
         return AVERROR_INVALIDDATA;
     }
 
-    switch (s->planar * 1000 + s->bpp * 10 + s->bppcount + s->is_bayer * 10000) {
+    switch (s->planar * 10000 + s->bpp * 10 + s->bppcount + s->is_bayer * 100000) {
     case 11:
         if (!s->palette_is_set) {
             s->avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;
@@ -1053,7 +1074,7 @@
     case 121:
         s->avctx->pix_fmt = AV_PIX_FMT_GRAY12;
         break;
-    case 10081:
+    case 100081:
         switch (AV_RL32(s->pattern)) {
         case 0x02010100:
             s->avctx->pix_fmt = AV_PIX_FMT_BAYER_RGGB8;
@@ -1073,10 +1094,10 @@
             return AVERROR_PATCHWELCOME;
         }
         break;
-    case 10101:
-    case 10121:
-    case 10141:
-    case 10161:
+    case 100101:
+    case 100121:
+    case 100141:
+    case 100161:
         switch (AV_RL32(s->pattern)) {
         case 0x02010100:
             s->avctx->pix_fmt = AV_PIX_FMT_BAYER_RGGB16;
@@ -1144,18 +1165,30 @@
     case 644:
         s->avctx->pix_fmt = s->le ? AV_PIX_FMT_RGBA64LE  : AV_PIX_FMT_RGBA64BE;
         break;
-    case 1243:
+    case 10243:
         s->avctx->pix_fmt = AV_PIX_FMT_GBRP;
         break;
-    case 1324:
+    case 10324:
         s->avctx->pix_fmt = AV_PIX_FMT_GBRAP;
         break;
-    case 1483:
+    case 10483:
         s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GBRP16LE : AV_PIX_FMT_GBRP16BE;
         break;
-    case 1644:
+    case 10644:
         s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GBRAP16LE : AV_PIX_FMT_GBRAP16BE;
         break;
+    case 963:
+        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_RGBF32LE : AV_PIX_FMT_RGBF32BE;
+        break;
+    case 1284:
+        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_RGBAF32LE : AV_PIX_FMT_RGBAF32BE;
+        break;
+    case 10963:
+        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GBRPF32LE : AV_PIX_FMT_GBRPF32BE;
+        break;
+    case 11284:
+        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GBRAPF32LE : AV_PIX_FMT_GBRAPF32BE;
+        break;
     default:
         av_log(s->avctx, AV_LOG_ERROR,
                "This format is not supported (bpp=%d, bppcount=%d)\n",
@@ -1178,6 +1211,10 @@
         if (ret < 0)
             return ret;
     }
+
+    if (s->avctx->skip_frame >= AVDISCARD_ALL)
+        return 0;
+
     if ((ret = ff_thread_get_buffer(s->avctx, frame, 0)) < 0)
         return ret;
     if (s->avctx->pix_fmt == AV_PIX_FMT_PAL8) {
@@ -1191,7 +1228,7 @@
                 pal[i] = 0xFFU << 24 | i * 255 / ((1<<s->bpp) - 1) * 0x010101;
         }
     }
-    return 0;
+    return 1;
 }
 
 static void set_sar(TiffContext *s, unsigned tag, unsigned num, unsigned den)
@@ -1414,29 +1451,43 @@
         else if (count > 1)
             s->sub_ifd = ff_tget(&s->gb, TIFF_LONG, s->le); /** Only get the first SubIFD */
         break;
+    case TIFF_GRAY_RESPONSE_CURVE:
     case DNG_LINEARIZATION_TABLE:
         if (count > FF_ARRAY_ELEMS(s->dng_lut))
             return AVERROR_INVALIDDATA;
         for (int i = 0; i < count; i++)
             s->dng_lut[i] = ff_tget(&s->gb, type, s->le);
+        s->white_level = s->dng_lut[count-1];
         break;
     case DNG_BLACK_LEVEL:
-        if (count > 1) {    /* Use the first value in the pattern (assume they're all the same) */
+        if (count > FF_ARRAY_ELEMS(s->black_level))
+            return AVERROR_INVALIDDATA;
+        s->black_level[0] = value / (float)value2;
+        for (int i = 0; i < count && count > 1; i++) {
             if (type == TIFF_RATIONAL) {
                 value  = ff_tget(&s->gb, TIFF_LONG, s->le);
                 value2 = ff_tget(&s->gb, TIFF_LONG, s->le);
                 if (!value2) {
-                    av_log(s->avctx, AV_LOG_WARNING, "Invalid black level denominator\n");
+                    av_log(s->avctx, AV_LOG_WARNING, "Invalid denominator\n");
                     value2 = 1;
                 }
 
-                s->black_level = value / value2;
-            } else
-                s->black_level = ff_tget(&s->gb, type, s->le);
-            av_log(s->avctx, AV_LOG_WARNING, "Assuming black level pattern values are identical\n");
-        } else {
-            s->black_level = value / value2;
+                s->black_level[i] = value / (float)value2;
+            } else if (type == TIFF_SRATIONAL) {
+                int value  = ff_tget(&s->gb, TIFF_LONG, s->le);
+                int value2 = ff_tget(&s->gb, TIFF_LONG, s->le);
+                if (!value2) {
+                    av_log(s->avctx, AV_LOG_WARNING, "Invalid denominator\n");
+                    value2 = 1;
+                }
+
+                s->black_level[i] = value / (float)value2;
+            } else {
+                s->black_level[i] = ff_tget(&s->gb, type, s->le);
+            }
         }
+        for (int i = count; i < 4 && count > 0; i++)
+            s->black_level[i] = s->black_level[count - 1];
         break;
     case DNG_WHITE_LEVEL:
         s->white_level = value;
@@ -1716,6 +1767,84 @@
             tiff_set_type(s, TIFF_TYPE_DNG);
         }
         break;
+    case DNG_ANALOG_BALANCE:
+        if (type != TIFF_RATIONAL)
+            break;
+
+        for (int i = 0; i < 3; i++) {
+            value  = ff_tget(&s->gb, TIFF_LONG, s->le);
+            value2 = ff_tget(&s->gb, TIFF_LONG, s->le);
+            if (!value2) {
+                av_log(s->avctx, AV_LOG_WARNING, "Invalid denominator\n");
+                value2 = 1;
+            }
+
+            s->analog_balance[i] = value / (float)value2;
+        }
+        break;
+    case DNG_AS_SHOT_NEUTRAL:
+        if (type != TIFF_RATIONAL)
+            break;
+
+        for (int i = 0; i < 3; i++) {
+            value  = ff_tget(&s->gb, TIFF_LONG, s->le);
+            value2 = ff_tget(&s->gb, TIFF_LONG, s->le);
+            if (!value2) {
+                av_log(s->avctx, AV_LOG_WARNING, "Invalid denominator\n");
+                value2 = 1;
+            }
+
+            s->as_shot_neutral[i] = value / (float)value2;
+        }
+        break;
+    case DNG_AS_SHOT_WHITE_XY:
+        if (type != TIFF_RATIONAL)
+            break;
+
+        for (int i = 0; i < 2; i++) {
+            value  = ff_tget(&s->gb, TIFF_LONG, s->le);
+            value2 = ff_tget(&s->gb, TIFF_LONG, s->le);
+            if (!value2) {
+                av_log(s->avctx, AV_LOG_WARNING, "Invalid denominator\n");
+                value2 = 1;
+            }
+
+            s->as_shot_white[i] = value / (float)value2;
+        }
+        s->as_shot_white[2] = 1.f - s->as_shot_white[0] - s->as_shot_white[1];
+        for (int i = 0; i < 3; i++) {
+            s->as_shot_white[i] /= d65_white[i];
+        }
+        break;
+    case DNG_COLOR_MATRIX1:
+    case DNG_COLOR_MATRIX2:
+        for (int i = 0; i < 3; i++) {
+            for (int j = 0; j < 3; j++) {
+                int value  = ff_tget(&s->gb, TIFF_LONG, s->le);
+                int value2 = ff_tget(&s->gb, TIFF_LONG, s->le);
+                if (!value2) {
+                    av_log(s->avctx, AV_LOG_WARNING, "Invalid denominator\n");
+                    value2 = 1;
+                }
+                s->color_matrix[i][j] = value / (float)value2;
+            }
+            s->use_color_matrix = 1;
+        }
+        break;
+    case DNG_CAMERA_CALIBRATION1:
+    case DNG_CAMERA_CALIBRATION2:
+        for (int i = 0; i < 3; i++) {
+            for (int j = 0; j < 3; j++) {
+                int value  = ff_tget(&s->gb, TIFF_LONG, s->le);
+                int value2 = ff_tget(&s->gb, TIFF_LONG, s->le);
+                if (!value2) {
+                    av_log(s->avctx, AV_LOG_WARNING, "Invalid denominator\n");
+                    value2 = 1;
+                }
+                s->camera_calibration[i][j] = value / (float)value2;
+            }
+        }
+        break;
     case CINEMADNG_TIME_CODES:
     case CINEMADNG_FRAME_RATE:
     case CINEMADNG_T_STOP:
@@ -1732,7 +1861,7 @@
         }
     }
 end:
-    if (s->bpp > 64U) {
+    if (s->bpp > 128U) {
         av_log(s->avctx, AV_LOG_ERROR,
                 "This format is not supported (bpp=%d, %d components)\n",
                 s->bpp, count);
@@ -1743,6 +1872,36 @@
     return 0;
 }
 
+static const float xyz2rgb[3][3] = {
+    { 0.412453f, 0.357580f, 0.180423f },
+    { 0.212671f, 0.715160f, 0.072169f },
+    { 0.019334f, 0.119193f, 0.950227f },
+};
+
+static void camera_xyz_coeff(TiffContext *s,
+                             float rgb2cam[3][4],
+                             double cam2xyz[4][3])
+{
+    double cam2rgb[4][3], num;
+    int i, j, k;
+
+    for (i = 0; i < 3; i++) {
+        for (j = 0; j < 3; j++) {
+            cam2rgb[i][j] = 0.;
+            for (k = 0; k < 3; k++)
+                cam2rgb[i][j] += cam2xyz[i][k] * xyz2rgb[k][j];
+        }
+    }
+
+    for (i = 0; i < 3; i++) {
+        for (num = j = 0; j < 3; j++)
+            num += cam2rgb[i][j];
+        for (j = 0; j < 3; j++)
+            cam2rgb[i][j] /= num;
+        s->premultiply[i] = 1.f / num;
+    }
+}
+
 static int decode_frame(AVCodecContext *avctx, AVFrame *p,
                         int *got_frame, AVPacket *avpkt)
 {
@@ -1772,6 +1931,7 @@
     // TIFF_BPP is not a required tag and defaults to 1
 
     s->tiff_type   = TIFF_TYPE_TIFF;
+    s->use_color_matrix = 0;
 again:
     s->is_thumbnail = 0;
     s->bppcount    = s->bpp = 1;
@@ -1788,6 +1948,25 @@
     for (i = 0; i < 65536; i++)
         s->dng_lut[i] = i;
 
+    for (i = 0; i < FF_ARRAY_ELEMS(s->black_level); i++)
+        s->black_level[i] = 0.f;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(s->as_shot_neutral); i++)
+        s->as_shot_neutral[i] = 0.f;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(s->as_shot_white); i++)
+        s->as_shot_white[i] = 1.f;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(s->analog_balance); i++)
+        s->analog_balance[i] = 1.f;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(s->premultiply); i++)
+        s->premultiply[i] = 1.f;
+
+    for (i = 0; i < 4; i++)
+        for (j = 0; j < 4; j++)
+            s->camera_calibration[i][j] = i == j;
+
     free_geotags(s);
 
     // Reset these offsets so we can tell if they were set this frame
@@ -1860,8 +2039,37 @@
     }
 
     if (is_dng) {
+        double cam2xyz[4][3];
+        float cmatrix[3][4];
+        float pmin = FLT_MAX;
         int bps;
 
+        for (i = 0; i < 3; i++) {
+            for (j = 0; j < 3; j++)
+                s->camera_calibration[i][j] *= s->analog_balance[i];
+        }
+
+        if (!s->use_color_matrix) {
+            for (i = 0; i < 3; i++)
+                s->premultiply[i] /= s->camera_calibration[i][i];
+        } else {
+            for (int c = 0; c < 3; c++) {
+                for (i = 0; i < 3; i++) {
+                    cam2xyz[c][i] = 0.;
+                    for (j = 0; j < 3; j++)
+                        cam2xyz[c][i] += s->camera_calibration[c][j] * s->color_matrix[j][i] * s->as_shot_white[i];
+                }
+            }
+
+            camera_xyz_coeff(s, cmatrix, cam2xyz);
+        }
+
+        for (int c = 0; c < 3; c++)
+            pmin = fminf(pmin, s->premultiply[c]);
+
+        for (int c = 0; c < 3; c++)
+            s->premultiply[c] /= pmin;
+
         if (s->bpp % s->bppcount)
             return AVERROR_INVALIDDATA;
         bps = s->bpp / s->bppcount;
@@ -1871,9 +2079,9 @@
         if (s->white_level == 0)
             s->white_level = (1LL << bps) - 1; /* Default value as per the spec */
 
-        if (s->white_level <= s->black_level) {
-            av_log(avctx, AV_LOG_ERROR, "BlackLevel (%"PRId32") must be less than WhiteLevel (%"PRId32")\n",
-                s->black_level, s->white_level);
+        if (s->white_level <= s->black_level[0]) {
+            av_log(avctx, AV_LOG_ERROR, "BlackLevel (%g) must be less than WhiteLevel (%"PRId32")\n",
+                s->black_level[0], s->white_level);
             return AVERROR_INVALIDDATA;
         }
 
@@ -1897,7 +2105,7 @@
     }
 
     /* now we have the data and may start decoding */
-    if ((ret = init_image(s, p)) < 0)
+    if ((ret = init_image(s, p)) <= 0)
         return ret;
 
     if (!s->is_tiled || has_strip_bits) {
@@ -2190,6 +2398,7 @@
     .close          = tiff_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_ICC_PROFILES,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_ICC_PROFILES |
+                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .p.priv_class   = &tiff_decoder_class,
 };
--- a/third_party/ffmpeg/libavcodec/tiff.h
+++ b/third_party/ffmpeg/libavcodec/tiff.h
@@ -66,6 +66,7 @@
     TIFF_PAGE_NAME          = 0x11D,
     TIFF_XPOS               = 0x11E,
     TIFF_YPOS               = 0x11F,
+    TIFF_GRAY_RESPONSE_CURVE= 0x123,
     TIFF_T4OPTIONS          = 0x124,
     TIFF_T6OPTIONS,
     TIFF_RES_UNIT           = 0x128,
@@ -105,6 +106,13 @@
     DNG_LINEARIZATION_TABLE = 0xC618,
     DNG_BLACK_LEVEL         = 0xC61A,
     DNG_WHITE_LEVEL         = 0xC61D,
+    DNG_COLOR_MATRIX1       = 0xC621,
+    DNG_COLOR_MATRIX2       = 0xC622,
+    DNG_CAMERA_CALIBRATION1 = 0xC623,
+    DNG_CAMERA_CALIBRATION2 = 0xC624,
+    DNG_ANALOG_BALANCE      = 0xC627,
+    DNG_AS_SHOT_NEUTRAL     = 0xC628,
+    DNG_AS_SHOT_WHITE_XY    = 0xC629,
 };
 
 /** list of CinemaDNG tags */
--- a/third_party/ffmpeg/libavcodec/utils.c
+++ b/third_party/ffmpeg/libavcodec/utils.c
@@ -353,29 +353,17 @@
     align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
     *width              = FFALIGN(*width, align);
 }
-
+#if FF_API_AVCODEC_CHROMA_POS
 int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
 {
-    if (pos <= AVCHROMA_LOC_UNSPECIFIED || pos >= AVCHROMA_LOC_NB)
-        return AVERROR(EINVAL);
-    pos--;
-
-    *xpos = (pos&1) * 128;
-    *ypos = ((pos>>1)^(pos<4)) * 128;
-
-    return 0;
+    return av_chroma_location_enum_to_pos(xpos, ypos, pos);
 }
 
 enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos)
 {
-    int pos, xout, yout;
-
-    for (pos = AVCHROMA_LOC_UNSPECIFIED + 1; pos < AVCHROMA_LOC_NB; pos++) {
-        if (avcodec_enum_to_chroma_pos(&xout, &yout, pos) == 0 && xout == xpos && yout == ypos)
-            return pos;
-    }
-    return AVCHROMA_LOC_UNSPECIFIED;
+    return av_chroma_location_pos_to_enum(xpos, ypos);
 }
+#endif
 
 int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,
                              enum AVSampleFormat sample_fmt, const uint8_t *buf,
@@ -639,6 +627,7 @@
     case AV_CODEC_ID_MP2:
     case AV_CODEC_ID_MUSEPACK7:    return 1152;
     case AV_CODEC_ID_AC3:          return 1536;
+    case AV_CODEC_ID_FTR:          return 1024;
     }
 
     if (sr > 0) {
--- a/third_party/ffmpeg/libavcodec/vaapi_mpeg4.c
+++ b/third_party/ffmpeg/libavcodec/vaapi_mpeg4.c
@@ -66,7 +66,7 @@
             .interlaced                   = !s->progressive_sequence,
             .obmc_disable                 = 1,
             .sprite_enable                = ctx->vol_sprite_usage,
-            .sprite_warping_accuracy      = s->sprite_warping_accuracy,
+            .sprite_warping_accuracy      = ctx->sprite_warping_accuracy,
             .quant_type                   = s->mpeg_quant,
             .quarter_sample               = s->quarter_sample,
             .data_partitioned             = s->data_partitioning,
--- a/third_party/ffmpeg/libavcodec/vaapi_vc1.c
+++ b/third_party/ffmpeg/libavcodec/vaapi_vc1.c
@@ -457,8 +457,6 @@
     if (ret < 0)
         goto fail;
 
-    ff_mpeg_draw_horiz_band(s, 0, s->avctx->height);
-
 fail:
     return ret;
 }
--- a/third_party/ffmpeg/libavcodec/vc1_block.c
+++ b/third_party/ffmpeg/libavcodec/vc1_block.c
@@ -2640,15 +2640,9 @@
             v->left_blk_idx = (v->left_blk_idx + 1) % (v->end_mb_x + 2);
             v->cur_blk_idx = (v->cur_blk_idx + 1) % (v->end_mb_x + 2);
         }
-        if (!v->s.loop_filter)
-            ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);
-        else if (s->mb_y)
-            ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);
 
         s->first_slice_line = 0;
     }
-    if (v->s.loop_filter)
-        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);
 
     /* This is intentionally mb_height and not end_mb_y - unlike in advanced
      * profile, these only differ are when decoding MSS2 rectangles. */
@@ -2786,15 +2780,9 @@
             inc_blk_idx(v->left_blk_idx);
             inc_blk_idx(v->cur_blk_idx);
         }
-        if (!v->s.loop_filter)
-            ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);
-        else if (s->mb_y)
-            ff_mpeg_draw_horiz_band(s, (s->mb_y-1) * 16, 16);
         s->first_slice_line = 0;
     }
 
-    if (v->s.loop_filter)
-        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);
     ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,
                     (s->end_mb_y << v->field_mode) - 1, ER_MB_END);
     return 0;
@@ -2882,12 +2870,8 @@
         memmove(v->luma_mv_base,
                 v->luma_mv - s->mb_stride,
                 sizeof(v->luma_mv_base[0]) * 2 * s->mb_stride);
-        if (s->mb_y != s->start_mb_y)
-            ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);
         s->first_slice_line = 0;
     }
-    if (s->end_mb_y >= s->start_mb_y)
-        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);
     ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,
                     (s->end_mb_y << v->field_mode) - 1, ER_MB_END);
 }
@@ -2964,14 +2948,8 @@
         memmove(v->is_intra_base,
                 v->is_intra - s->mb_stride,
                 sizeof(v->is_intra_base[0]) * 2 * s->mb_stride);
-        if (!v->s.loop_filter)
-            ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);
-        else if (s->mb_y)
-            ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);
         s->first_slice_line = 0;
     }
-    if (v->s.loop_filter)
-        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);
     ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,
                     (s->end_mb_y << v->field_mode) - 1, ER_MB_END);
 }
@@ -2992,7 +2970,6 @@
         memcpy(s->dest[0], s->last_picture.f->data[0] + s->mb_y * 16 * s->linesize,   s->linesize   * 16);
         memcpy(s->dest[1], s->last_picture.f->data[1] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);
         memcpy(s->dest[2], s->last_picture.f->data[2] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);
-        ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);
         s->first_slice_line = 0;
     }
     s->pict_type = AV_PICTURE_TYPE_P;
--- a/third_party/ffmpeg/libavcodec/vc2enc.c
+++ b/third_party/ffmpeg/libavcodec/vc2enc.c
@@ -233,7 +233,7 @@
 
     align_put_bits(&s->pb);
 
-    cur_pos = put_bits_count(&s->pb) >> 3;
+    cur_pos = put_bytes_count(&s->pb, 0);
 
     /* Magic string */
     ff_put_string(&s->pb, "BBCD", 0);
@@ -746,7 +746,7 @@
     /* Luma + 2 Chroma planes */
     for (p = 0; p < 3; p++) {
         int bytes_start, bytes_len, pad_s, pad_c;
-        bytes_start = put_bits_count(pb) >> 3;
+        bytes_start = put_bytes_count(pb, 0);
         put_bits(pb, 8, 0);
         for (level = 0; level < s->wavelet_depth; level++) {
             for (orientation = !!level; orientation < 4; orientation++) {
@@ -755,10 +755,10 @@
                                quants[level][orientation]);
             }
         }
-        align_put_bits(pb);
-        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;
+        flush_put_bits(pb);
+        bytes_len = put_bytes_output(pb) - bytes_start - 1;
         if (p == 2) {
-            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);
+            int len_diff = slice_bytes_max - put_bytes_output(pb);
             pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;
             pad_c = (pad_s*s->size_scaler) - bytes_len;
         } else {
@@ -766,7 +766,6 @@
             pad_c = (pad_s*s->size_scaler) - bytes_len;
         }
         pb->buf[bytes_start] = pad_s;
-        flush_put_bits(pb);
         /* vc2-reference uses that padding that decodes to '0' coeffs */
         memset(put_bits_ptr(pb), 0xFF, pad_c);
         skip_put_bytes(pb, pad_c);
--- a/third_party/ffmpeg/libavcodec/vc2enc_dwt.c
+++ b/third_party/ffmpeg/libavcodec/vc2enc_dwt.c
@@ -151,7 +151,7 @@
      */
     for (y = 0; y < synth_height; y++) {
         for (x = 0; x < synth_width; x++)
-            synthl[x] = datal[x] << 1;
+            synthl[x] = datal[x] * 2;
         synthl += synth_width;
         datal  += stride;
     }
@@ -223,9 +223,8 @@
     /* Horizontal synthesis. */
     for (y = 0; y < synth_height; y++) {
         for (x = 0; x < synth_width; x += 2) {
-            synthl[y*synth_width + x + 1] = (datal[y*stride + x + 1] << s) -
-                                            (datal[y*stride + x] << s);
-            synthl[y*synth_width + x] = (datal[y*stride + x + 0] << s) +
+            synthl[y*synth_width + x + 1] = (datal[y*stride + x + 1] - datal[y*stride + x]) * (1 << s);
+            synthl[y*synth_width + x] = datal[y*stride + x + 0] * (1 << s) +
                                         ((synthl[y*synth_width + x + 1] + 1) >> 1);
         }
     }
--- a/third_party/ffmpeg/libavcodec/vdpau.h
+++ b/third_party/ffmpeg/libavcodec/vdpau.h
@@ -152,6 +152,6 @@
  */
 AVVDPAUContext *av_vdpau_alloc_context(void);
 
-/* @}*/
+/** @} */
 
 #endif /* AVCODEC_VDPAU_H */
--- a/third_party/ffmpeg/libavcodec/version.h
+++ b/third_party/ffmpeg/libavcodec/version.h
@@ -29,7 +29,7 @@
 
 #include "version_major.h"
 
-#define LIBAVCODEC_VERSION_MINOR  44
+#define LIBAVCODEC_VERSION_MINOR  51
 #define LIBAVCODEC_VERSION_MICRO 100
 
 #define LIBAVCODEC_VERSION_INT  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, \
--- a/third_party/ffmpeg/libavcodec/version_major.h
+++ b/third_party/ffmpeg/libavcodec/version_major.h
@@ -52,5 +52,6 @@
 #define FF_API_SVTAV1_OPTS         (LIBAVCODEC_VERSION_MAJOR < 60)
 #define FF_API_AYUV_CODECID        (LIBAVCODEC_VERSION_MAJOR < 60)
 #define FF_API_VT_OUTPUT_CALLBACK  (LIBAVCODEC_VERSION_MAJOR < 60)
+#define FF_API_AVCODEC_CHROMA_POS  (LIBAVCODEC_VERSION_MAJOR < 60)
 
 #endif /* AVCODEC_VERSION_MAJOR_H */
--- a/third_party/ffmpeg/libavcodec/videotoolbox.h
+++ b/third_party/ffmpeg/libavcodec/videotoolbox.h
@@ -29,6 +29,15 @@
  * Public libavcodec Videotoolbox header.
  */
 
+/**
+ * @defgroup lavc_codec_hwaccel_videotoolbox VideoToolbox Decoder
+ * @ingroup lavc_codec_hwaccel
+ *
+ * Hardware accelerated decoding using VideoToolbox on Apple Platforms
+ *
+ * @{
+ */
+
 #include <stdint.h>
 
 #define Picture QuickdrawPicture
--- a/third_party/ffmpeg/libavcodec/vorbis.c
+++ b/third_party/ffmpeg/libavcodec/vorbis.c
@@ -30,6 +30,7 @@
 
 #include "avcodec.h"
 #include "vorbis.h"
+#include "vorbis_data.h"
 
 
 /* Helper functions */
--- a/third_party/ffmpeg/libavcodec/vorbis.h
+++ b/third_party/ffmpeg/libavcodec/vorbis.h
@@ -21,15 +21,9 @@
 #ifndef AVCODEC_VORBIS_H
 #define AVCODEC_VORBIS_H
 
-#include "avcodec.h"
+#include <stdint.h>
 
-extern const float ff_vorbis_floor1_inverse_db_table[256];
-extern const float * const ff_vorbis_vwin[8];
-extern const uint8_t ff_vorbis_channel_layout_offsets[8][8];
-#if FF_API_OLD_CHANNEL_LAYOUT
-extern const uint64_t ff_vorbis_channel_layouts[9];
-#endif
-extern const AVChannelLayout ff_vorbis_ch_layouts[9];
+#include "avcodec.h"
 
 typedef struct vorbis_floor1_entry {
     uint16_t x;
--- a/third_party/ffmpeg/libavcodec/vorbis_data.c
+++ b/third_party/ffmpeg/libavcodec/vorbis_data.c
@@ -21,7 +21,7 @@
 #include "libavutil/channel_layout.h"
 #include "libavutil/mem_internal.h"
 
-#include "vorbis.h"
+#include "vorbis_data.h"
 
 const uint8_t ff_vorbis_channel_layout_offsets[8][8] = {
     { 0 },
--- a/third_party/ffmpeg/libavcodec/vorbisdec.c
+++ b/third_party/ffmpeg/libavcodec/vorbisdec.c
@@ -40,6 +40,7 @@
 #include "get_bits.h"
 #include "vorbis.h"
 #include "vorbisdsp.h"
+#include "vorbis_data.h"
 #include "xiph.h"
 
 #define V_NB_BITS 8
@@ -1876,9 +1877,7 @@
     .flush           = vorbis_decode_flush,
     .p.capabilities  = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    .p.channel_layouts = ff_vorbis_channel_layouts,
-#endif
+    CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(ff_vorbis_channel_layouts)
     .p.ch_layouts    = ff_vorbis_ch_layouts,
     .p.sample_fmts   = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                        AV_SAMPLE_FMT_NONE },
--- a/third_party/ffmpeg/libavcodec/vorbisdsp.c
+++ b/third_party/ffmpeg/libavcodec/vorbisdsp.c
@@ -53,6 +53,8 @@
     ff_vorbisdsp_init_arm(dsp);
 #elif ARCH_PPC
     ff_vorbisdsp_init_ppc(dsp);
+#elif ARCH_RISCV
+    ff_vorbisdsp_init_riscv(dsp);
 #elif ARCH_X86
     ff_vorbisdsp_init_x86(dsp);
 #endif
--- a/third_party/ffmpeg/libavcodec/vorbisdsp.h
+++ b/third_party/ffmpeg/libavcodec/vorbisdsp.h
@@ -34,5 +34,6 @@
 void ff_vorbisdsp_init_x86(VorbisDSPContext *dsp);
 void ff_vorbisdsp_init_arm(VorbisDSPContext *dsp);
 void ff_vorbisdsp_init_ppc(VorbisDSPContext *dsp);
+void ff_vorbisdsp_init_riscv(VorbisDSPContext *dsp);
 
 #endif /* AVCODEC_VORBISDSP_H */
--- a/third_party/ffmpeg/libavcodec/vorbisenc.c
+++ b/third_party/ffmpeg/libavcodec/vorbisenc.c
@@ -33,6 +33,7 @@
 #include "fft.h"
 #include "mathops.h"
 #include "vorbis.h"
+#include "vorbis_data.h"
 #include "vorbis_enc_data.h"
 
 #include "audio_frame_queue.h"
--- a/third_party/ffmpeg/libavcodec/vp3.c
+++ b/third_party/ffmpeg/libavcodec/vp3.c
@@ -43,6 +43,7 @@
 #include "decode.h"
 #include "get_bits.h"
 #include "hpeldsp.h"
+#include "jpegquanttables.h"
 #include "mathops.h"
 #include "thread.h"
 #include "threadframe.h"
@@ -2418,7 +2419,7 @@
             s->coded_dc_scale_factor[1][i] = s->version < 2 ? vp31_dc_scale_factor[i] : vp4_uv_dc_scale_factor[i];
             s->coded_ac_scale_factor[i] = s->version < 2 ? vp31_ac_scale_factor[i] : vp4_ac_scale_factor[i];
             s->base_matrix[0][i]        = s->version < 2 ? vp31_intra_y_dequant[i] : vp4_generic_dequant[i];
-            s->base_matrix[1][i]        = s->version < 2 ? vp31_intra_c_dequant[i] : vp4_generic_dequant[i];
+            s->base_matrix[1][i]        = s->version < 2 ? ff_mjpeg_std_chrominance_quant_tbl[i] : vp4_generic_dequant[i];
             s->base_matrix[2][i]        = s->version < 2 ? vp31_inter_dequant[i]   : vp4_generic_dequant[i];
             s->filter_limit_values[i]   = s->version < 2 ? vp31_filter_limit_values[i] : vp4_filter_limit_values[i];
         }
--- a/third_party/ffmpeg/libavcodec/vp3data.h
+++ b/third_party/ffmpeg/libavcodec/vp3data.h
@@ -25,7 +25,7 @@
 #include <stdlib.h>
 
 /* these coefficients dequantize intraframe Y plane coefficients
- * (note: same as JPEG) */
+ * (note: almost the same as JPEG) */
 static const uint8_t vp31_intra_y_dequant[64] = {
     16, 11, 10, 16,  24,  40,  51,  61,
     12, 12, 14, 19,  26,  58,  60,  55,
@@ -37,19 +37,6 @@
     72, 92, 95, 98, 112, 100, 103,  99
 };
 
-/* these coefficients dequantize intraframe C plane coefficients
- * (note: same as JPEG) */
-static const uint8_t vp31_intra_c_dequant[64] = {
-    17, 18, 24, 47, 99, 99, 99, 99,
-    18, 21, 26, 66, 99, 99, 99, 99,
-    24, 26, 56, 99, 99, 99, 99, 99,
-    47, 66, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99,
-    99, 99, 99, 99, 99, 99, 99, 99
-};
-
 /* these coefficients dequantize interframe coefficients (all planes) */
 static const uint8_t vp31_inter_dequant[64] = {
     16, 16, 16, 20, 24, 28,  32,  40,
--- a/third_party/ffmpeg/libavcodec/vp8.c
+++ b/third_party/ffmpeg/libavcodec/vp8.c
@@ -132,7 +132,7 @@
 }
 
 #if CONFIG_VP8_DECODER
-static int vp8_ref_frame(VP8Context *s, VP8Frame *dst, VP8Frame *src)
+static int vp8_ref_frame(VP8Context *s, VP8Frame *dst, const VP8Frame *src)
 {
     int ret;
 
@@ -508,7 +508,7 @@
     s->update_altref = ref_to_update(s, update_altref, VP8_FRAME_ALTREF);
 }
 
-static void copy_chroma(AVFrame *dst, AVFrame *src, int width, int height)
+static void copy_chroma(AVFrame *dst, const AVFrame *src, int width, int height)
 {
     int i, j;
 
@@ -542,7 +542,8 @@
     if (!s->keyframe && (alpha || beta)) {
         int width  = s->mb_width * 16;
         int height = s->mb_height * 16;
-        AVFrame *src, *dst;
+        const AVFrame *src;
+        AVFrame *dst;
 
         if (!s->framep[VP8_FRAME_PREVIOUS] ||
             !s->framep[VP8_FRAME_GOLDEN]) {
@@ -550,8 +551,8 @@
             return AVERROR_INVALIDDATA;
         }
 
-        dst =
-        src = s->framep[VP8_FRAME_PREVIOUS]->tf.f;
+        src =
+        dst = s->framep[VP8_FRAME_PREVIOUS]->tf.f;
 
         /* preserve the golden frame, write a new previous frame */
         if (s->framep[VP8_FRAME_GOLDEN] == s->framep[VP8_FRAME_PREVIOUS]) {
@@ -877,7 +878,7 @@
 }
 
 static av_always_inline
-void clamp_mv(VP8mvbounds *s, VP8mv *dst, const VP8mv *src)
+void clamp_mv(const VP8mvbounds *s, VP8mv *dst, const VP8mv *src)
 {
     dst->x = av_clip(src->x, av_clip(s->mv_min.x, INT16_MIN, INT16_MAX),
                              av_clip(s->mv_max.x, INT16_MIN, INT16_MAX));
@@ -944,18 +945,18 @@
  * @returns the number of motion vectors parsed (2, 4 or 16)
  */
 static av_always_inline
-int decode_splitmvs(VP8Context *s, VPXRangeCoder *c, VP8Macroblock *mb,
+int decode_splitmvs(const VP8Context *s, VPXRangeCoder *c, VP8Macroblock *mb,
                     int layout, int is_vp7)
 {
     int part_idx;
     int n, num;
-    VP8Macroblock *top_mb;
-    VP8Macroblock *left_mb = &mb[-1];
+    const VP8Macroblock *top_mb;
+    const VP8Macroblock *left_mb = &mb[-1];
     const uint8_t *mbsplits_left = vp8_mbsplits[left_mb->partitioning];
     const uint8_t *mbsplits_top, *mbsplits_cur, *firstidx;
-    VP8mv *top_mv;
-    VP8mv *left_mv = left_mb->bmv;
-    VP8mv *cur_mv  = mb->bmv;
+    const VP8mv *top_mv;
+    const VP8mv *left_mv = left_mb->bmv;
+    const VP8mv *cur_mv  = mb->bmv;
 
     if (!layout) // layout is inlined, s->mb_layout is not
         top_mb = &mb[2];
@@ -1048,7 +1049,6 @@
 void vp7_decode_mvs(VP8Context *s, VP8Macroblock *mb,
                     int mb_x, int mb_y, int layout)
 {
-    VP8Macroblock *mb_edge[12];
     enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR };
     enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };
     int idx = CNT_ZERO;
@@ -1067,11 +1067,11 @@
 
         if (vp7_calculate_mb_offset(mb_x, mb_y, s->mb_width, pred->xoffset,
                                     pred->yoffset, !s->profile, &edge_x, &edge_y)) {
-            VP8Macroblock *edge = mb_edge[i] = (s->mb_layout == 1)
-                                             ? s->macroblocks_base + 1 + edge_x +
-                                               (s->mb_width + 1) * (edge_y + 1)
-                                             : s->macroblocks + edge_x +
-                                               (s->mb_height - edge_y - 1) * 2;
+            const VP8Macroblock *edge = (s->mb_layout == 1)
+                                      ? s->macroblocks_base + 1 + edge_x +
+                                        (s->mb_width + 1) * (edge_y + 1)
+                                      : s->macroblocks + edge_x +
+                                        (s->mb_height - edge_y - 1) * 2;
             uint32_t mv = AV_RN32A(get_bmv_ptr(edge, vp7_mv_pred[i].subblock));
             if (mv) {
                 if (AV_RN32A(&near_mv[CNT_NEAREST])) {
@@ -1136,7 +1136,7 @@
 }
 
 static av_always_inline
-void vp8_decode_mvs(VP8Context *s, VP8mvbounds *mv_bounds, VP8Macroblock *mb,
+void vp8_decode_mvs(VP8Context *s, const VP8mvbounds *mv_bounds, VP8Macroblock *mb,
                     int mb_x, int mb_y, int layout)
 {
     VP8Macroblock *mb_edge[3] = { 0      /* top */,
@@ -1146,7 +1146,7 @@
     enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };
     int idx = CNT_ZERO;
     int cur_sign_bias = s->sign_bias[mb->ref_frame];
-    int8_t *sign_bias = s->sign_bias;
+    const int8_t *sign_bias = s->sign_bias;
     VP8mv near_mv[4];
     uint8_t cnt[4] = { 0 };
     VPXRangeCoder *c = &s->c;
@@ -1166,7 +1166,7 @@
     /* Process MB on top, left and top-left */
 #define MV_EDGE_CHECK(n)                                                      \
     {                                                                         \
-        VP8Macroblock *edge = mb_edge[n];                                     \
+        const VP8Macroblock *edge = mb_edge[n];                               \
         int edge_ref = edge->ref_frame;                                       \
         if (edge_ref != VP8_FRAME_CURRENT) {                                 \
             uint32_t mv = AV_RN32A(&edge->mv);                                \
@@ -1271,7 +1271,7 @@
 }
 
 static av_always_inline
-void decode_mb_mode(VP8Context *s, VP8mvbounds *mv_bounds,
+void decode_mb_mode(VP8Context *s, const VP8mvbounds *mv_bounds,
                     VP8Macroblock *mb, int mb_x, int mb_y,
                     uint8_t *segment, const uint8_t *ref, int layout, int is_vp7)
 {
@@ -1366,7 +1366,7 @@
 static av_always_inline
 int decode_block_coeffs_internal(VPXRangeCoder *r, int16_t block[16],
                                  uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
-                                 int i, uint8_t *token_prob, int16_t qmul[2],
+                                 int i, const uint8_t *token_prob, const int16_t qmul[2],
                                  const uint8_t scan[16], int vp7)
 {
     VPXRangeCoder c = *r;
@@ -1449,8 +1449,8 @@
 static int vp7_decode_block_coeffs_internal(VPXRangeCoder *r,
                                             int16_t block[16],
                                             uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
-                                            int i, uint8_t *token_prob,
-                                            int16_t qmul[2],
+                                            int i, const uint8_t *token_prob,
+                                            const int16_t qmul[2],
                                             const uint8_t scan[16])
 {
     return decode_block_coeffs_internal(r, block, probs, i,
@@ -1461,8 +1461,8 @@
 static int vp8_decode_block_coeffs_internal(VPXRangeCoder *r,
                                             int16_t block[16],
                                             uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
-                                            int i, uint8_t *token_prob,
-                                            int16_t qmul[2])
+                                            int i, const uint8_t *token_prob,
+                                            const int16_t qmul[2])
 {
     return decode_block_coeffs_internal(r, block, probs, i,
                                         token_prob, qmul, ff_zigzag_scan, IS_VP8);
@@ -1485,10 +1485,10 @@
 static av_always_inline
 int decode_block_coeffs(VPXRangeCoder *c, int16_t block[16],
                         uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
-                        int i, int zero_nhood, int16_t qmul[2],
+                        int i, int zero_nhood, const int16_t qmul[2],
                         const uint8_t scan[16], int vp7)
 {
-    uint8_t *token_prob = probs[i][zero_nhood];
+    const uint8_t *token_prob = probs[i][zero_nhood];
     if (!vpx_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB
         return 0;
     return vp7 ? vp7_decode_block_coeffs_internal(c, block, probs, i,
@@ -1573,8 +1573,8 @@
 }
 
 static av_always_inline
-void backup_mb_border(uint8_t *top_border, uint8_t *src_y,
-                      uint8_t *src_cb, uint8_t *src_cr,
+void backup_mb_border(uint8_t *top_border, const uint8_t *src_y,
+                      const uint8_t *src_cb, const uint8_t *src_cr,
                       ptrdiff_t linesize, ptrdiff_t uvlinesize, int simple)
 {
     AV_COPY128(top_border, src_y + 15 * linesize);
@@ -1699,7 +1699,7 @@
 }
 
 static av_always_inline
-void intra_predict(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3],
+void intra_predict(VP8Context *s, VP8ThreadData *td, uint8_t *const dst[3],
                    VP8Macroblock *mb, int mb_x, int mb_y, int is_vp7)
 {
     int x, y, mode, nnz;
@@ -1717,14 +1717,14 @@
         s->hpc.pred16x16[mode](dst[0], s->linesize);
     } else {
         uint8_t *ptr = dst[0];
-        uint8_t *intra4x4 = mb->intra4x4_pred_mode_mb;
+        const uint8_t *intra4x4 = mb->intra4x4_pred_mode_mb;
         const uint8_t lo = is_vp7 ? 128 : 127;
         const uint8_t hi = is_vp7 ? 128 : 129;
-        uint8_t tr_top[4] = { lo, lo, lo, lo };
+        const uint8_t tr_top[4] = { lo, lo, lo, lo };
 
         // all blocks on the right edge of the macroblock use bottom edge
         // the top macroblock for their topright edge
-        uint8_t *tr_right = ptr - s->linesize + 16;
+        const uint8_t *tr_right = ptr - s->linesize + 16;
 
         // if we're on the right edge of the frame, said edge is extended
         // from the top macroblock
@@ -1737,7 +1737,7 @@
             AV_ZERO128(td->non_zero_count_cache);
 
         for (y = 0; y < 4; y++) {
-            uint8_t *topright = ptr + 4 - s->linesize;
+            const uint8_t *topright = ptr + 4 - s->linesize;
             for (x = 0; x < 4; x++) {
                 int copy = 0;
                 ptrdiff_t linesize = s->linesize;
@@ -1843,7 +1843,7 @@
                  int width, int height, ptrdiff_t linesize,
                  vp8_mc_func mc_func[3][3])
 {
-    uint8_t *src = ref->f->data[0];
+    const uint8_t *src = ref->f->data[0];
 
     if (AV_RN32A(mv)) {
         ptrdiff_t src_linesize = linesize;
@@ -1901,7 +1901,7 @@
                    int width, int height, ptrdiff_t linesize,
                    vp8_mc_func mc_func[3][3])
 {
-    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];
+    const uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];
 
     if (AV_RN32A(mv)) {
         int mx = mv->x & 7, mx_idx = subpel_idx[0][mx];
@@ -1945,10 +1945,10 @@
 }
 
 static av_always_inline
-void vp8_mc_part(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3],
-                 ThreadFrame *ref_frame, int x_off, int y_off,
+void vp8_mc_part(VP8Context *s, VP8ThreadData *td, uint8_t *const dst[3],
+                 const ThreadFrame *ref_frame, int x_off, int y_off,
                  int bx_off, int by_off, int block_w, int block_h,
-                 int width, int height, VP8mv *mv)
+                 int width, int height, const VP8mv *mv)
 {
     VP8mv uvmv = *mv;
 
@@ -1983,8 +1983,8 @@
 /* Fetch pixels for estimated mv 4 macroblocks ahead.
  * Optimized for 64-byte cache lines. Inspired by ffh264 prefetch_motion. */
 static av_always_inline
-void prefetch_motion(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,
-                     int mb_xy, int ref)
+void prefetch_motion(const VP8Context *s, const VP8Macroblock *mb,
+                     int mb_x, int mb_y, int mb_xy, int ref)
 {
     /* Don't prefetch refs that haven't been used very often this frame. */
     if (s->ref_count[ref - 1] > (mb_xy >> 5)) {
@@ -2006,13 +2006,13 @@
  * Apply motion vectors to prediction buffer, chapter 18.
  */
 static av_always_inline
-void inter_predict(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3],
+void inter_predict(VP8Context *s, VP8ThreadData *td, uint8_t *const dst[3],
                    VP8Macroblock *mb, int mb_x, int mb_y)
 {
     int x_off = mb_x << 4, y_off = mb_y << 4;
     int width = 16 * s->mb_width, height = 16 * s->mb_height;
-    ThreadFrame *ref = &s->framep[mb->ref_frame]->tf;
-    VP8mv *bmv = mb->bmv;
+    const ThreadFrame *ref = &s->framep[mb->ref_frame]->tf;
+    const VP8mv *bmv = mb->bmv;
 
     switch (mb->partitioning) {
     case VP8_SPLITMVMODE_NONE:
@@ -2090,7 +2090,8 @@
 }
 
 static av_always_inline
-void idct_mb(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3], VP8Macroblock *mb)
+void idct_mb(VP8Context *s, VP8ThreadData *td, uint8_t *const dst[3],
+             const VP8Macroblock *mb)
 {
     int x, y, ch;
 
@@ -2152,7 +2153,7 @@
 }
 
 static av_always_inline
-void filter_level_for_mb(VP8Context *s, VP8Macroblock *mb,
+void filter_level_for_mb(const VP8Context *s, const VP8Macroblock *mb,
                          VP8FilterStrength *f, int is_vp7)
 {
     int interior_limit, filter_level;
@@ -2185,7 +2186,7 @@
 }
 
 static av_always_inline
-void filter_mb(VP8Context *s, uint8_t *dst[3], VP8FilterStrength *f,
+void filter_mb(const VP8Context *s, uint8_t *const dst[3], const VP8FilterStrength *f,
                int mb_x, int mb_y, int is_vp7)
 {
     int mbedge_lim, bedge_lim_y, bedge_lim_uv, hev_thresh;
@@ -2272,7 +2273,7 @@
 }
 
 static av_always_inline
-void filter_mb_simple(VP8Context *s, uint8_t *dst, VP8FilterStrength *f,
+void filter_mb_simple(const VP8Context *s, uint8_t *dst, const VP8FilterStrength *f,
                       int mb_x, int mb_y)
 {
     int mbedge_lim, bedge_lim;
@@ -2307,7 +2308,7 @@
 #define MARGIN (16 << 2)
 static av_always_inline
 int vp78_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *curframe,
-                                    VP8Frame *prev_frame, int is_vp7)
+                            const VP8Frame *prev_frame, int is_vp7)
 {
     VP8Context *s = avctx->priv_data;
     int mb_x, mb_y;
@@ -2344,13 +2345,13 @@
 }
 
 static int vp7_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *cur_frame,
-                                   VP8Frame *prev_frame)
+                                  const VP8Frame *prev_frame)
 {
     return vp78_decode_mv_mb_modes(avctx, cur_frame, prev_frame, IS_VP7);
 }
 
 static int vp8_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *cur_frame,
-                                   VP8Frame *prev_frame)
+                                  const VP8Frame *prev_frame)
 {
     return vp78_decode_mv_mb_modes(avctx, cur_frame, prev_frame, IS_VP8);
 }
@@ -2564,7 +2565,7 @@
         next_td = &s->thread_data[(jobnr + 1) % num_jobs];
 
     for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb++) {
-        VP8FilterStrength *f = &td->filter_strength[mb_x];
+        const VP8FilterStrength *f = &td->filter_strength[mb_x];
         if (prev_td != td)
             check_thread_pos(td, prev_td,
                              (mb_x + 1) + (s->mb_width + 3), mb_y - 1);
--- a/third_party/ffmpeg/libavcodec/wmalosslessdec.c
+++ b/third_party/ffmpeg/libavcodec/wmalosslessdec.c
@@ -1192,16 +1192,15 @@
 
     s->frame->nb_samples = 0;
 
-    if (!buf_size && s->num_saved_bits > get_bits_count(&s->gb)) {
+    if (!buf_size) {
         s->packet_done = 0;
+        if (s->num_saved_bits <= get_bits_count(&s->gb))
+            return 0;
         if (!decode_frame(s))
             s->num_saved_bits = 0;
     } else if (s->packet_done || s->packet_loss) {
         s->packet_done = 0;
 
-        if (!buf_size)
-            return 0;
-
         s->next_packet_start = buf_size - FFMIN(avctx->block_align, buf_size);
         buf_size             = FFMIN(avctx->block_align, buf_size);
         s->buf_bit_size      = buf_size << 3;
@@ -1299,7 +1298,7 @@
 
     s->packet_offset = get_bits_count(gb) & 7;
 
-    return (s->packet_loss) ? AVERROR_INVALIDDATA : buf_size ? get_bits_count(gb) >> 3 : 0;
+    return (s->packet_loss) ? AVERROR_INVALIDDATA : get_bits_count(gb) >> 3;
 }
 
 static void flush(AVCodecContext *avctx)
--- a/third_party/ffmpeg/libavcodec/wmavoice.c
+++ b/third_party/ffmpeg/libavcodec/wmavoice.c
@@ -1900,6 +1900,8 @@
 {
     WMAVoiceContext *s = ctx->priv_data;
     GetBitContext *gb = &s->gb;
+    const uint8_t *buf = avpkt->data;
+    uint8_t dummy[1];
     int size, res, pos;
 
     /* Packets are sometimes a multiple of ctx->block_align, with a packet
@@ -1908,7 +1910,10 @@
      * in a single "muxer" packet, so we artificially emulate that by
      * capping the packet size at ctx->block_align. */
     for (size = avpkt->size; size > ctx->block_align; size -= ctx->block_align);
-    init_get_bits8(&s->gb, avpkt->data, size);
+    buf = size ? buf : dummy;
+    res = init_get_bits8(&s->gb, buf, size);
+    if (res < 0)
+        return res;
 
     /* size == ctx->block_align is used to indicate whether we are dealing with
      * a new packet or a packet of which we already read the packet header
@@ -1931,7 +1936,7 @@
             if (cnt + s->spillover_nbits > avpkt->size * 8) {
                 s->spillover_nbits = avpkt->size * 8 - cnt;
             }
-            copy_bits(&s->pb, avpkt->data, size, gb, s->spillover_nbits);
+            copy_bits(&s->pb, buf, size, gb, s->spillover_nbits);
             flush_put_bits(&s->pb);
             s->sframe_cache_size += s->spillover_nbits;
             if ((res = synth_superframe(ctx, frame, got_frame_ptr)) == 0 &&
@@ -1968,7 +1973,7 @@
     } else if ((s->sframe_cache_size = pos) > 0) {
         /* ... cache it for spillover in next packet */
         init_put_bits(&s->pb, s->sframe_cache, SFRAME_CACHE_MAXSIZE);
-        copy_bits(&s->pb, avpkt->data, size, gb, s->sframe_cache_size);
+        copy_bits(&s->pb, buf, size, gb, s->sframe_cache_size);
         // FIXME bad - just copy bytes as whole and add use the
         // skip_bits_next field
     }
--- a/third_party/ffmpeg/libavcodec/wmv2.c
+++ b/third_party/ffmpeg/libavcodec/wmv2.c
@@ -36,12 +36,12 @@
                                   w->wdsp.idct_perm);
     ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,
                       ff_wmv1_scantable[1]);
-    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable,
-                      ff_wmv1_scantable[2]);
-    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable,
-                      ff_wmv1_scantable[3]);
     ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,
                       ff_wmv1_scantable[0]);
+    ff_permute_scantable(s->permutated_intra_h_scantable, ff_wmv1_scantable[2],
+                         s->idsp.idct_permutation);
+    ff_permute_scantable(s->permutated_intra_v_scantable, ff_wmv1_scantable[3],
+                         s->idsp.idct_permutation);
     s->idsp.idct_put = w->wdsp.idct_put;
     s->idsp.idct_add = w->wdsp.idct_add;
     s->idsp.idct     = NULL;
--- a/third_party/ffmpeg/libavcodec/wmv2dec.c
+++ b/third_party/ffmpeg/libavcodec/wmv2dec.c
@@ -52,7 +52,6 @@
     int per_mb_rl_bit;
     int skip_type;
 
-    ScanTable abt_scantable[2];
     DECLARE_ALIGNED(32, int16_t, abt_block2)[6][64];
 } WMV2DecContext;
 
@@ -425,9 +424,7 @@
     w->abt_type_table[n] = w->abt_type;
 
     if (w->abt_type) {
-//        const uint8_t *scantable = w->abt_scantable[w->abt_type - 1].permutated;
-        const uint8_t *scantable = w->abt_scantable[w->abt_type - 1].scantable;
-//        const uint8_t *scantable = w->abt_type - 1 ? w->abt_scantable[1].permutated : w->abt_scantable[0].scantable;
+        const uint8_t *scantable = w->abt_type == 1 ? ff_wmv2_scantableA : ff_wmv2_scantableB;
 
         sub_cbp = sub_cbp_table[decode012(&s->gb)];
 
@@ -577,10 +574,6 @@
         return ret;
 
     ff_wmv2_common_init(s);
-    ff_init_scantable(s->idsp.idct_permutation, &w->abt_scantable[0],
-                      ff_wmv2_scantableA);
-    ff_init_scantable(s->idsp.idct_permutation, &w->abt_scantable[1],
-                      ff_wmv2_scantableB);
 
     return ff_intrax8_common_init(avctx, &w->x8,
                                   w->s.block, w->s.block_last_index,
--- a/third_party/ffmpeg/libavcodec/wmv2enc.c
+++ b/third_party/ffmpeg/libavcodec/wmv2enc.c
@@ -29,6 +29,8 @@
 #include "wmv2.h"
 #include "wmv2enc.h"
 
+#define WMV2_EXTRADATA_SIZE 4
+
 typedef struct WMV2EncContext {
     MSMPEG4EncContext msmpeg4;
     WMV2Context common;
@@ -49,7 +51,7 @@
     PutBitContext pb;
     int code;
 
-    init_put_bits(&pb, s->avctx->extradata, s->avctx->extradata_size);
+    init_put_bits(&pb, s->avctx->extradata, WMV2_EXTRADATA_SIZE);
 
     put_bits(&pb, 5, s->avctx->time_base.den / s->avctx->time_base.num); // yes 29.97 -> 29
     put_bits(&pb, 11, FFMIN(s->bit_rate / 1024, 2047));
@@ -80,7 +82,7 @@
 
     ff_wmv2_common_init(s);
 
-    avctx->extradata_size = 4;
+    avctx->extradata_size = WMV2_EXTRADATA_SIZE;
     avctx->extradata      = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
     if (!avctx->extradata)
         return AVERROR(ENOMEM);
--- a/third_party/ffmpeg/libavcodec/x86/Makefile
+++ b/third_party/ffmpeg/libavcodec/x86/Makefile
@@ -27,8 +27,7 @@
 OBJS-$(CONFIG_MDCT15)                  += x86/mdct15_init.o
 OBJS-$(CONFIG_ME_CMP)                  += x86/me_cmp_init.o
 OBJS-$(CONFIG_MPEGAUDIODSP)            += x86/mpegaudiodsp.o
-OBJS-$(CONFIG_MPEGVIDEO)               += x86/mpegvideo.o              \
-                                          x86/mpegvideodsp.o
+OBJS-$(CONFIG_MPEGVIDEO)               += x86/mpegvideo.o
 OBJS-$(CONFIG_MPEGVIDEOENC)            += x86/mpegvideoenc.o           \
                                           x86/mpegvideoencdsp_init.o
 OBJS-$(CONFIG_PIXBLOCKDSP)             += x86/pixblockdsp_init.o
@@ -62,7 +61,7 @@
 OBJS-$(CONFIG_JPEG2000_DECODER)        += x86/jpeg2000dsp_init.o
 OBJS-$(CONFIG_LSCR_DECODER)            += x86/pngdsp_init.o
 OBJS-$(CONFIG_MLP_DECODER)             += x86/mlpdsp_init.o
-OBJS-$(CONFIG_MPEG4_DECODER)           += x86/xvididct_init.o
+OBJS-$(CONFIG_MPEG4_DECODER)           += x86/mpeg4videodsp.o x86/xvididct_init.o
 OBJS-$(CONFIG_PNG_DECODER)             += x86/pngdsp_init.o
 OBJS-$(CONFIG_PRORES_DECODER)          += x86/proresdsp_init.o
 OBJS-$(CONFIG_PRORES_LGPL_DECODER)     += x86/proresdsp_init.o
--- a/third_party/ffmpeg/libavcodec/x86/ac3dsp_init.c
+++ b/third_party/ffmpeg/libavcodec/x86/ac3dsp_init.c
@@ -33,7 +33,7 @@
 void ff_ac3_extract_exponents_sse2 (uint8_t *exp, int32_t *coef, int nb_coefs);
 void ff_ac3_extract_exponents_ssse3(uint8_t *exp, int32_t *coef, int nb_coefs);
 
-av_cold void ff_ac3dsp_init_x86(AC3DSPContext *c, int bit_exact)
+av_cold void ff_ac3dsp_init_x86(AC3DSPContext *c)
 {
     int cpu_flags = av_get_cpu_flags();
 
--- a/third_party/ffmpeg/libavcodec/x86/dirac_dwt_init.c
+++ b/third_party/ffmpeg/libavcodec/x86/dirac_dwt_init.c
@@ -165,23 +165,23 @@
 
     switch (type) {
     case DWT_DIRAC_DD9_7:
-        d->vertical_compose_l0 = (void*)vertical_compose53iL0_sse2;
-        d->vertical_compose_h0 = (void*)vertical_compose_dd97iH0_sse2;
+        d->vertical_compose_l0.tap3 = vertical_compose53iL0_sse2;
+        d->vertical_compose_h0.tap5 = vertical_compose_dd97iH0_sse2;
         break;
     case DWT_DIRAC_LEGALL5_3:
-        d->vertical_compose_l0 = (void*)vertical_compose53iL0_sse2;
-        d->vertical_compose_h0 = (void*)vertical_compose_dirac53iH0_sse2;
+        d->vertical_compose_l0.tap3 = vertical_compose53iL0_sse2;
+        d->vertical_compose_h0.tap3 = vertical_compose_dirac53iH0_sse2;
         break;
     case DWT_DIRAC_DD13_7:
-        d->vertical_compose_l0 = (void*)vertical_compose_dd137iL0_sse2;
-        d->vertical_compose_h0 = (void*)vertical_compose_dd97iH0_sse2;
+        d->vertical_compose_l0.tap5 = vertical_compose_dd137iL0_sse2;
+        d->vertical_compose_h0.tap5 = vertical_compose_dd97iH0_sse2;
         break;
     case DWT_DIRAC_HAAR0:
-        d->vertical_compose   = (void*)vertical_compose_haar_sse2;
+        d->vertical_compose   = vertical_compose_haar_sse2;
         d->horizontal_compose = horizontal_compose_haar0i_sse2;
         break;
     case DWT_DIRAC_HAAR1:
-        d->vertical_compose   = (void*)vertical_compose_haar_sse2;
+        d->vertical_compose   = vertical_compose_haar_sse2;
         d->horizontal_compose = horizontal_compose_haar1i_sse2;
         break;
     }
--- a/third_party/ffmpeg/libavcodec/x86/huffyuvencdsp_init.c
+++ b/third_party/ffmpeg/libavcodec/x86/huffyuvencdsp_init.c
@@ -35,10 +35,10 @@
 void ff_sub_hfyu_median_pred_int16_mmxext(uint16_t *dst, const uint16_t *src1, const uint16_t *src2,
                                           unsigned mask, int w, int *left, int *left_top);
 
-av_cold void ff_huffyuvencdsp_init_x86(HuffYUVEncDSPContext *c, AVCodecContext *avctx)
+av_cold void ff_huffyuvencdsp_init_x86(HuffYUVEncDSPContext *c, enum AVPixelFormat pix_fmt)
 {
     av_unused int cpu_flags = av_get_cpu_flags();
-    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(avctx->pix_fmt);
+    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(pix_fmt);
 
     if (EXTERNAL_MMXEXT(cpu_flags) && pix_desc && pix_desc->comp[0].depth<16) {
         c->sub_hfyu_median_pred_int16 = ff_sub_hfyu_median_pred_int16_mmxext;
--- a/third_party/ffmpeg/libavcodec/x86/lpc.asm
+++ b/third_party/ffmpeg/libavcodec/x86/lpc.asm
@@ -36,9 +36,8 @@
 
 %macro APPLY_WELCH_FN 0
 cglobal lpc_apply_welch_window, 3, 5, 8, data, len, out, off1, off2
-    movsxdifnidn lenq, lend
     cmp lenq, 0
-    je .end
+    je .end_e
     cmp lenq, 2
     je .two
     cmp lenq, 1
@@ -80,11 +79,12 @@
 
 .loop_o:
     movapd m1, m6
-    mulpd m2, m0, m0
-    subpd m1, m2
 %if cpuflag(avx2)
+    fnmaddpd m1, m0, m0, m1
     vpermpd m2, m1, q0123
 %else
+    mulpd m2, m0, m0
+    subpd m1, m2
     shufpd m2, m1, m1, 01b
 %endif
 
@@ -105,7 +105,7 @@
 
     add lend, (mmsize/4 - 1)
     cmp lend, 0
-    je .end
+    je .end_o
     sub lenq, (mmsize/4 - 1)
 
 .scalar_o:
@@ -117,8 +117,12 @@
 
 .loop_o_scalar:
     movapd xm1, xm6
+%if cpuflag(avx2)
+    fnmaddpd xm1, xm0, xm0, xm1
+%else
     mulpd xm2, xm0, xm0
     subpd xm1, xm2
+%endif
 
     cvtdq2pd xm3, [dataq + off1q]
     cvtdq2pd xm4, [dataq + off2q]
@@ -136,6 +140,10 @@
 
     sub lenq, 2
     jg .loop_o_scalar
+
+.end_o:
+    xorpd xm3, xm3
+    movlpd [outq + off1q*2], xm3
     RET
 
 .even:
@@ -171,8 +179,12 @@
 
 .loop_e:
     movapd m1, m6
+%if cpuflag(avx2)
+    fnmaddpd m1, m0, m0, m1
+%else
     mulpd m2, m0, m0
     subpd m1, m2
+%endif
 %if cpuflag(avx2)
     vpermpd m2, m1, q0123
 %else
@@ -207,8 +219,12 @@
 
 .loop_e_scalar:
     movapd xm1, xm6
+%if cpuflag(avx2)
+    fnmaddpd xm1, xm0, xm0, xm1
+%else
     mulpd xm2, xm0, xm0
     subpd xm1, xm2
+%endif
 
     cvtdq2pd xm3, [dataq + off1q]
     cvtdq2pd xm4, [dataq + off2q]
@@ -234,7 +250,7 @@
 .one:
     xorpd xm0, xm0
     movhpd [outq], xm0
-.end:
+.end_e:
     RET
 %endmacro
 
--- a/third_party/ffmpeg/libavcodec/x86/lpc_init.c
+++ b/third_party/ffmpeg/libavcodec/x86/lpc_init.c
@@ -24,16 +24,16 @@
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/lpc.h"
 
-void ff_lpc_apply_welch_window_sse2(const int32_t *data, int len,
+void ff_lpc_apply_welch_window_sse2(const int32_t *data, ptrdiff_t len,
                                     double *w_data);
-void ff_lpc_apply_welch_window_avx2(const int32_t *data, int len,
+void ff_lpc_apply_welch_window_avx2(const int32_t *data, ptrdiff_t len,
                                     double *w_data);
 
 DECLARE_ASM_CONST(16, double, pd_1)[2] = { 1.0, 1.0 };
 
 #if HAVE_SSE2_INLINE
 
-static void lpc_compute_autocorr_sse2(const double *data, int len, int lag,
+static void lpc_compute_autocorr_sse2(const double *data, ptrdiff_t len, int lag,
                                       double *autoc)
 {
     int j;
--- a/third_party/ffmpeg/libavcodec/x86/mpegvideodsp.c
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "config.h"
-#include "libavutil/attributes.h"
-#include "libavutil/cpu.h"
-#include "libavutil/x86/cpu.h"
-#include "libavcodec/mpegvideodsp.h"
-#include "libavcodec/videodsp.h"
-
-#if HAVE_INLINE_ASM
-
-static void gmc_mmx(uint8_t *dst, const uint8_t *src,
-                    int stride, int h, int ox, int oy,
-                    int dxx, int dxy, int dyx, int dyy,
-                    int shift, int r, int width, int height)
-{
-    const int w    = 8;
-    const int ix   = ox  >> (16 + shift);
-    const int iy   = oy  >> (16 + shift);
-    const int oxs  = ox  >> 4;
-    const int oys  = oy  >> 4;
-    const int dxxs = dxx >> 4;
-    const int dxys = dxy >> 4;
-    const int dyxs = dyx >> 4;
-    const int dyys = dyy >> 4;
-    const uint16_t r4[4]   = { r, r, r, r };
-    const uint16_t dxy4[4] = { dxys, dxys, dxys, dxys };
-    const uint16_t dyy4[4] = { dyys, dyys, dyys, dyys };
-    const uint64_t shift2  = 2 * shift;
-#define MAX_STRIDE 4096U
-#define MAX_H 8U
-    uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];
-    int x, y;
-
-    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);
-    const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);
-    const int dxh = dxy * (h - 1);
-    const int dyw = dyx * (w - 1);
-    int need_emu  =  (unsigned) ix >= width  - w || width < w ||
-                     (unsigned) iy >= height - h || height< h
-                     ;
-
-    if ( // non-constant fullpel offset (3% of blocks)
-        ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |
-         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||
-        // uses more than 16 bits of subpel mv (only at huge resolution)
-        (dxx | dxy | dyx | dyy) & 15 ||
-        (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {
-        // FIXME could still use mmx for some of the rows
-        ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,
-                 shift, r, width, height);
-        return;
-    }
-
-    src += ix + iy * stride;
-    if (need_emu) {
-        ff_emulated_edge_mc_8(edge_buf, src, stride, stride, w + 1, h + 1, ix, iy, width, height);
-        src = edge_buf;
-    }
-
-    __asm__ volatile (
-        "movd         %0, %%mm6         \n\t"
-        "pxor      %%mm7, %%mm7         \n\t"
-        "punpcklwd %%mm6, %%mm6         \n\t"
-        "punpcklwd %%mm6, %%mm6         \n\t"
-        :: "r" (1 << shift));
-
-    for (x = 0; x < w; x += 4) {
-        uint16_t dx4[4] = { oxs - dxys + dxxs * (x + 0),
-                            oxs - dxys + dxxs * (x + 1),
-                            oxs - dxys + dxxs * (x + 2),
-                            oxs - dxys + dxxs * (x + 3) };
-        uint16_t dy4[4] = { oys - dyys + dyxs * (x + 0),
-                            oys - dyys + dyxs * (x + 1),
-                            oys - dyys + dyxs * (x + 2),
-                            oys - dyys + dyxs * (x + 3) };
-
-        for (y = 0; y < h; y++) {
-            __asm__ volatile (
-                "movq      %0, %%mm4    \n\t"
-                "movq      %1, %%mm5    \n\t"
-                "paddw     %2, %%mm4    \n\t"
-                "paddw     %3, %%mm5    \n\t"
-                "movq   %%mm4, %0       \n\t"
-                "movq   %%mm5, %1       \n\t"
-                "psrlw    $12, %%mm4    \n\t"
-                "psrlw    $12, %%mm5    \n\t"
-                : "+m" (*dx4), "+m" (*dy4)
-                : "m" (*dxy4), "m" (*dyy4));
-
-            __asm__ volatile (
-                "movq      %%mm6, %%mm2 \n\t"
-                "movq      %%mm6, %%mm1 \n\t"
-                "psubw     %%mm4, %%mm2 \n\t"
-                "psubw     %%mm5, %%mm1 \n\t"
-                "movq      %%mm2, %%mm0 \n\t"
-                "movq      %%mm4, %%mm3 \n\t"
-                "pmullw    %%mm1, %%mm0 \n\t" // (s - dx) * (s - dy)
-                "pmullw    %%mm5, %%mm3 \n\t" // dx * dy
-                "pmullw    %%mm5, %%mm2 \n\t" // (s - dx) * dy
-                "pmullw    %%mm4, %%mm1 \n\t" // dx * (s - dy)
-
-                "movd         %4, %%mm5 \n\t"
-                "movd         %3, %%mm4 \n\t"
-                "punpcklbw %%mm7, %%mm5 \n\t"
-                "punpcklbw %%mm7, %%mm4 \n\t"
-                "pmullw    %%mm5, %%mm3 \n\t" // src[1, 1] * dx * dy
-                "pmullw    %%mm4, %%mm2 \n\t" // src[0, 1] * (s - dx) * dy
-
-                "movd         %2, %%mm5 \n\t"
-                "movd         %1, %%mm4 \n\t"
-                "punpcklbw %%mm7, %%mm5 \n\t"
-                "punpcklbw %%mm7, %%mm4 \n\t"
-                "pmullw    %%mm5, %%mm1 \n\t" // src[1, 0] * dx * (s - dy)
-                "pmullw    %%mm4, %%mm0 \n\t" // src[0, 0] * (s - dx) * (s - dy)
-                "paddw        %5, %%mm1 \n\t"
-                "paddw     %%mm3, %%mm2 \n\t"
-                "paddw     %%mm1, %%mm0 \n\t"
-                "paddw     %%mm2, %%mm0 \n\t"
-
-                "psrlw        %6, %%mm0 \n\t"
-                "packuswb  %%mm0, %%mm0 \n\t"
-                "movd      %%mm0, %0    \n\t"
-
-                : "=m" (dst[x + y * stride])
-                : "m" (src[0]), "m" (src[1]),
-                  "m" (src[stride]), "m" (src[stride + 1]),
-                  "m" (*r4), "m" (shift2));
-            src += stride;
-        }
-        src += 4 - h * stride;
-    }
-}
-
-#endif /* HAVE_INLINE_ASM */
-
-av_cold void ff_mpegvideodsp_init_x86(MpegVideoDSPContext *c)
-{
-#if HAVE_INLINE_ASM
-    int cpu_flags = av_get_cpu_flags();
-
-    if (INLINE_MMX(cpu_flags))
-        c->gmc = gmc_mmx;
-#endif /* HAVE_INLINE_ASM */
-}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/x86/mpeg4videodsp.c
@@ -0,0 +1,161 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavutil/x86/cpu.h"
+#include "libavcodec/mpeg4videodsp.h"
+#include "libavcodec/videodsp.h"
+
+#if HAVE_INLINE_ASM
+
+static void gmc_mmx(uint8_t *dst, const uint8_t *src,
+                    int stride, int h, int ox, int oy,
+                    int dxx, int dxy, int dyx, int dyy,
+                    int shift, int r, int width, int height)
+{
+    const int w    = 8;
+    const int ix   = ox  >> (16 + shift);
+    const int iy   = oy  >> (16 + shift);
+    const int oxs  = ox  >> 4;
+    const int oys  = oy  >> 4;
+    const int dxxs = dxx >> 4;
+    const int dxys = dxy >> 4;
+    const int dyxs = dyx >> 4;
+    const int dyys = dyy >> 4;
+    const uint16_t r4[4]   = { r, r, r, r };
+    const uint16_t dxy4[4] = { dxys, dxys, dxys, dxys };
+    const uint16_t dyy4[4] = { dyys, dyys, dyys, dyys };
+    const uint64_t shift2  = 2 * shift;
+#define MAX_STRIDE 4096U
+#define MAX_H 8U
+    uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];
+    int x, y;
+
+    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);
+    const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);
+    const int dxh = dxy * (h - 1);
+    const int dyw = dyx * (w - 1);
+    int need_emu  =  (unsigned) ix >= width  - w || width < w ||
+                     (unsigned) iy >= height - h || height< h
+                     ;
+
+    if ( // non-constant fullpel offset (3% of blocks)
+        ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |
+         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||
+        // uses more than 16 bits of subpel mv (only at huge resolution)
+        (dxx | dxy | dyx | dyy) & 15 ||
+        (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {
+        // FIXME could still use mmx for some of the rows
+        ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,
+                 shift, r, width, height);
+        return;
+    }
+
+    src += ix + iy * stride;
+    if (need_emu) {
+        ff_emulated_edge_mc_8(edge_buf, src, stride, stride, w + 1, h + 1, ix, iy, width, height);
+        src = edge_buf;
+    }
+
+    __asm__ volatile (
+        "movd         %0, %%mm6         \n\t"
+        "pxor      %%mm7, %%mm7         \n\t"
+        "punpcklwd %%mm6, %%mm6         \n\t"
+        "punpcklwd %%mm6, %%mm6         \n\t"
+        :: "r" (1 << shift));
+
+    for (x = 0; x < w; x += 4) {
+        uint16_t dx4[4] = { oxs - dxys + dxxs * (x + 0),
+                            oxs - dxys + dxxs * (x + 1),
+                            oxs - dxys + dxxs * (x + 2),
+                            oxs - dxys + dxxs * (x + 3) };
+        uint16_t dy4[4] = { oys - dyys + dyxs * (x + 0),
+                            oys - dyys + dyxs * (x + 1),
+                            oys - dyys + dyxs * (x + 2),
+                            oys - dyys + dyxs * (x + 3) };
+
+        for (y = 0; y < h; y++) {
+            __asm__ volatile (
+                "movq      %0, %%mm4    \n\t"
+                "movq      %1, %%mm5    \n\t"
+                "paddw     %2, %%mm4    \n\t"
+                "paddw     %3, %%mm5    \n\t"
+                "movq   %%mm4, %0       \n\t"
+                "movq   %%mm5, %1       \n\t"
+                "psrlw    $12, %%mm4    \n\t"
+                "psrlw    $12, %%mm5    \n\t"
+                : "+m" (*dx4), "+m" (*dy4)
+                : "m" (*dxy4), "m" (*dyy4));
+
+            __asm__ volatile (
+                "movq      %%mm6, %%mm2 \n\t"
+                "movq      %%mm6, %%mm1 \n\t"
+                "psubw     %%mm4, %%mm2 \n\t"
+                "psubw     %%mm5, %%mm1 \n\t"
+                "movq      %%mm2, %%mm0 \n\t"
+                "movq      %%mm4, %%mm3 \n\t"
+                "pmullw    %%mm1, %%mm0 \n\t" // (s - dx) * (s - dy)
+                "pmullw    %%mm5, %%mm3 \n\t" // dx * dy
+                "pmullw    %%mm5, %%mm2 \n\t" // (s - dx) * dy
+                "pmullw    %%mm4, %%mm1 \n\t" // dx * (s - dy)
+
+                "movd         %4, %%mm5 \n\t"
+                "movd         %3, %%mm4 \n\t"
+                "punpcklbw %%mm7, %%mm5 \n\t"
+                "punpcklbw %%mm7, %%mm4 \n\t"
+                "pmullw    %%mm5, %%mm3 \n\t" // src[1, 1] * dx * dy
+                "pmullw    %%mm4, %%mm2 \n\t" // src[0, 1] * (s - dx) * dy
+
+                "movd         %2, %%mm5 \n\t"
+                "movd         %1, %%mm4 \n\t"
+                "punpcklbw %%mm7, %%mm5 \n\t"
+                "punpcklbw %%mm7, %%mm4 \n\t"
+                "pmullw    %%mm5, %%mm1 \n\t" // src[1, 0] * dx * (s - dy)
+                "pmullw    %%mm4, %%mm0 \n\t" // src[0, 0] * (s - dx) * (s - dy)
+                "paddw        %5, %%mm1 \n\t"
+                "paddw     %%mm3, %%mm2 \n\t"
+                "paddw     %%mm1, %%mm0 \n\t"
+                "paddw     %%mm2, %%mm0 \n\t"
+
+                "psrlw        %6, %%mm0 \n\t"
+                "packuswb  %%mm0, %%mm0 \n\t"
+                "movd      %%mm0, %0    \n\t"
+
+                : "=m" (dst[x + y * stride])
+                : "m" (src[0]), "m" (src[1]),
+                  "m" (src[stride]), "m" (src[stride + 1]),
+                  "m" (*r4), "m" (shift2));
+            src += stride;
+        }
+        src += 4 - h * stride;
+    }
+}
+
+#endif /* HAVE_INLINE_ASM */
+
+av_cold void ff_mpeg4videodsp_init_x86(Mpeg4VideoDSPContext *c)
+{
+#if HAVE_INLINE_ASM
+    int cpu_flags = av_get_cpu_flags();
+
+    if (INLINE_MMX(cpu_flags))
+        c->gmc = gmc_mmx;
+#endif /* HAVE_INLINE_ASM */
+}
--- a/third_party/ffmpeg/libavcodec/x86/simple_idct.asm
+++ b/third_party/ffmpeg/libavcodec/x86/simple_idct.asm
@@ -25,9 +25,9 @@
 
 %include "libavutil/x86/x86util.asm"
 
-%if ARCH_X86_32
 SECTION_RODATA
 
+%if ARCH_X86_32
 cextern pb_80
 
 wm1010: dw 0, 0xffff, 0, 0xffff
--- a/third_party/ffmpeg/libavcodec/x86/svq1enc_init.c
+++ b/third_party/ffmpeg/libavcodec/x86/svq1enc_init.c
@@ -22,12 +22,12 @@
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
 #include "libavutil/x86/cpu.h"
-#include "libavcodec/svq1enc.h"
+#include "libavcodec/svq1encdsp.h"
 
 int ff_ssd_int8_vs_int16_sse2(const int8_t *pix1, const int16_t *pix2,
                               intptr_t size);
 
-av_cold void ff_svq1enc_init_x86(SVQ1EncContext *c)
+av_cold void ff_svq1enc_init_x86(SVQ1EncDSPContext *c)
 {
     int cpu_flags = av_get_cpu_flags();
 
--- a/third_party/ffmpeg/libavcodec/xbmdec.c
+++ b/third_party/ffmpeg/libavcodec/xbmdec.c
@@ -82,6 +82,9 @@
     if ((ret = ff_set_dimensions(avctx, width, height)) < 0)
         return ret;
 
+    if (avctx->skip_frame >= AVDISCARD_ALL)
+        return avpkt->size;
+
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
         return ret;
 
@@ -141,5 +144,6 @@
     .p.type       = AVMEDIA_TYPE_VIDEO,
     .p.id         = AV_CODEC_ID_XBM,
     .p.capabilities = AV_CODEC_CAP_DR1,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(xbm_decode_frame),
 };
--- a/third_party/ffmpeg/libavcodec/xpmdec.c
+++ b/third_party/ffmpeg/libavcodec/xpmdec.c
@@ -360,6 +360,9 @@
     if (end - ptr < 1)
         return AVERROR_INVALIDDATA;
 
+    if (avctx->skip_frame >= AVDISCARD_ALL)
+        return avpkt->size;
+
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
         return ret;
 
@@ -443,5 +446,6 @@
     .p.capabilities = AV_CODEC_CAP_DR1,
     .priv_data_size = sizeof(XPMDecContext),
     .close          = xpm_decode_close,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(xpm_decode_frame),
 };
--- a/third_party/ffmpeg/libavcodec/xwddec.c
+++ b/third_party/ffmpeg/libavcodec/xwddec.c
@@ -32,8 +32,6 @@
 static int xwd_decode_frame(AVCodecContext *avctx, AVFrame *p,
                             int *got_frame, AVPacket *avpkt)
 {
-    const uint8_t *buf = avpkt->data;
-    int i, ret, buf_size = avpkt->size;
     uint32_t version, header_size, vclass, ncolors;
     uint32_t xoffset, be, bpp, lsize, rsize;
     uint32_t pixformat, pixdepth, bunit, bitorder, bpad;
@@ -41,11 +39,12 @@
     uint8_t *ptr;
     int width, height;
     GetByteContext gb;
+    int ret;
 
-    if (buf_size < XWD_HEADER_SIZE)
+    if (avpkt->size < XWD_HEADER_SIZE)
         return AVERROR_INVALIDDATA;
 
-    bytestream2_init(&gb, buf, buf_size);
+    bytestream2_init(&gb, avpkt->data, avpkt->size);
     header_size = bytestream2_get_be32u(&gb);
 
     version = bytestream2_get_be32u(&gb);
@@ -54,7 +53,7 @@
         return AVERROR_INVALIDDATA;
     }
 
-    if (buf_size < header_size || header_size < XWD_HEADER_SIZE) {
+    if (avpkt->size < header_size || header_size < XWD_HEADER_SIZE) {
         av_log(avctx, AV_LOG_ERROR, "invalid header size\n");
         return AVERROR_INVALIDDATA;
     }
@@ -211,6 +210,9 @@
         return AVERROR_PATCHWELCOME;
     }
 
+    if (avctx->skip_frame >= AVDISCARD_ALL)
+        return avpkt->size;
+
     if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
         return ret;
 
@@ -221,8 +223,7 @@
         uint32_t *dst = (uint32_t *)p->data[1];
         uint8_t red, green, blue;
 
-        for (i = 0; i < ncolors; i++) {
-
+        for (int i = 0; i < ncolors; i++) {
             bytestream2_skipu(&gb, 4); // skip colormap entry number
             red    = bytestream2_get_byteu(&gb);
             bytestream2_skipu(&gb, 1);
@@ -236,7 +237,7 @@
     }
 
     ptr = p->data[0];
-    for (i = 0; i < avctx->height; i++) {
+    for (int i = 0; i < avctx->height; i++) {
         bytestream2_get_bufferu(&gb, ptr, rsize);
         bytestream2_skipu(&gb, lsize - rsize);
         ptr += p->linesize[0];
@@ -244,7 +245,7 @@
 
     *got_frame       = 1;
 
-    return buf_size;
+    return avpkt->size;
 }
 
 const FFCodec ff_xwd_decoder = {
@@ -253,5 +254,6 @@
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_XWD,
     .p.capabilities = AV_CODEC_CAP_DR1,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     FF_CODEC_DECODE_CB(xwd_decode_frame),
 };
--- a/third_party/ffmpeg/libavcodec/ylc.c
+++ b/third_party/ffmpeg/libavcodec/ylc.c
@@ -18,21 +18,17 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 
 #define YLC_VLC_BITS 10
 
-#include "libavutil/imgutils.h"
-#include "libavutil/internal.h"
 #include "libavutil/intreadwrite.h"
 #include "libavutil/mem.h"
+#include "libavutil/pixfmt.h"
 #include "avcodec.h"
 #include "bswapdsp.h"
 #include "codec_internal.h"
 #include "get_bits.h"
-#include "huffyuvdsp.h"
 #include "thread.h"
 #include "unary.h"
 
--- a/third_party/ffmpeg/libavcodec/zerocodec.c
+++ b/third_party/ffmpeg/libavcodec/zerocodec.c
@@ -84,11 +84,12 @@
             return AVERROR_INVALIDDATA;
         }
 
-        if (!(avpkt->flags & AV_PKT_FLAG_KEY))
+        if (!(avpkt->flags & AV_PKT_FLAG_KEY)) {
             for (j = 0; j < avctx->width << 1; j++)
                 dst[j] += prev[j] & -!dst[j];
+            prev -= prev_pic->linesize[0];
+        }
 
-        prev -= prev_pic->linesize[0];
         dst  -= pic->linesize[0];
     }
 
--- a/third_party/ffmpeg/libavdevice/avdevice.h
+++ b/third_party/ffmpeg/libavdevice/avdevice.h
@@ -494,7 +494,7 @@
 /**
  * Convenient function to free result of avdevice_list_devices().
  *
- * @param devices device list to be freed.
+ * @param device_list device list to be freed.
  */
 void avdevice_free_list_devices(AVDeviceInfoList **device_list);
 
--- a/third_party/ffmpeg/libavdevice/jack.c
+++ b/third_party/ffmpeg/libavdevice/jack.c
@@ -29,7 +29,6 @@
 #include "libavutil/fifo.h"
 #include "libavutil/opt.h"
 #include "libavutil/time.h"
-#include "libavcodec/avcodec.h"
 #include "libavformat/avformat.h"
 #include "libavformat/internal.h"
 #include "timefilter.h"
--- a/third_party/ffmpeg/libavdevice/v4l2.c
+++ b/third_party/ffmpeg/libavdevice/v4l2.c
@@ -38,6 +38,7 @@
 #include "libavutil/parseutils.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/time.h"
+#include "libavcodec/avcodec.h"
 #include "libavcodec/codec_desc.h"
 #include "libavformat/demux.h"
 #include "libavformat/internal.h"
--- a/third_party/ffmpeg/libavfilter/af_adynamicequalizer.c
+++ b/third_party/ffmpeg/libavfilter/af_adynamicequalizer.c
@@ -34,13 +34,12 @@
     double ratio;
     double range;
     double makeup;
-    double knee;
-    double slew;
     double attack;
     double release;
     double attack_coef;
     double release_coef;
     int mode;
+    int direction;
     int type;
 
     AVFrame *state;
@@ -55,6 +54,12 @@
     if (!s->state)
         return AVERROR(ENOMEM);
 
+    for (int ch = 0; ch < inlink->ch_layout.nb_channels; ch++) {
+        double *state = (double *)s->state->extended_data[ch];
+
+        state[4] = 1.;
+    }
+
     return 0;
 }
 
@@ -71,69 +76,6 @@
     return m[0] * v0 + m[1] * v1 + m[2] * v2;
 }
 
-static inline double from_dB(double x)
-{
-    return exp(0.05 * x * M_LN10);
-}
-
-static inline double to_dB(double x)
-{
-    return 20. * log10(x);
-}
-
-static inline double sqr(double x)
-{
-    return x * x;
-}
-
-static double get_gain(double in, double srate, double makeup,
-                       double aattack, double iratio, double knee, double range,
-                       double thresdb, double slewfactor, double *state,
-                       double attack_coeff, double release_coeff, double nc)
-{
-    double width = (6. * knee) + 0.01;
-    double cdb = 0.;
-    double Lgain = 1.;
-    double Lxg, Lxl, Lyg, Lyl, Ly1;
-    double checkwidth = 0.;
-    double slewwidth = 1.8;
-    int attslew = 0;
-
-    Lyg = 0.;
-    Lxg = to_dB(fabs(in) + DBL_EPSILON);
-
-    Lyg = Lxg + (iratio - 1.) * sqr(Lxg - thresdb + width * .5) / (2. * width);
-
-    checkwidth = 2. * fabs(Lxg - thresdb);
-    if (2. * (Lxg - thresdb) < -width) {
-        Lyg = Lxg;
-    } else if (checkwidth <= width) {
-        Lyg = thresdb + (Lxg - thresdb) * iratio;
-        if (checkwidth <= slewwidth) {
-            if (Lyg >= state[2])
-                attslew = 1;
-        }
-    } else if (2. * (Lxg - thresdb) > width) {
-        Lyg = thresdb + (Lxg - thresdb) * iratio;
-    }
-
-    attack_coeff = attslew ? aattack : attack_coeff;
-
-    Lxl = Lxg - Lyg;
-
-    Ly1 = fmax(Lxl, release_coeff * state[1] +(1. - release_coeff) * Lxl);
-    Lyl = attack_coeff * state[0] + (1. - attack_coeff) * Ly1;
-
-    cdb = -Lyl;
-    Lgain = from_dB(nc * fmin(cdb - makeup, range));
-
-    state[0] = Lyl;
-    state[1] = Ly1;
-    state[2] = Lyg;
-
-    return Lgain;
-}
-
 typedef struct ThreadData {
     AVFrame *in, *out;
 } ThreadData;
@@ -146,25 +88,24 @@
     AVFrame *out = td->out;
     const double sample_rate = in->sample_rate;
     const double makeup = s->makeup;
-    const double iratio = 1. / s->ratio;
+    const double ratio = s->ratio;
     const double range = s->range;
     const double dfrequency = fmin(s->dfrequency, sample_rate * 0.5);
     const double tfrequency = fmin(s->tfrequency, sample_rate * 0.5);
-    const double threshold = to_dB(s->threshold + DBL_EPSILON);
+    const double threshold = s->threshold;
     const double release = s->release_coef;
+    const double irelease = 1. - release;
     const double attack = s->attack_coef;
+    const double iattack = 1. - attack;
     const double dqfactor = s->dqfactor;
     const double tqfactor = s->tqfactor;
     const double fg = tan(M_PI * tfrequency / sample_rate);
     const double dg = tan(M_PI * dfrequency / sample_rate);
     const int start = (in->ch_layout.nb_channels * jobnr) / nb_jobs;
     const int end = (in->ch_layout.nb_channels * (jobnr+1)) / nb_jobs;
+    const int direction = s->direction;
     const int mode = s->mode;
     const int type = s->type;
-    const double knee = s->knee;
-    const double slew = s->slew;
-    const double aattack = exp(-1000. / ((s->attack + 2.0 * (slew - 1.)) * sample_rate));
-    const double nc = mode == 0 ? 1. : -1.;
     double da[3], dm[3];
 
     {
@@ -175,7 +116,7 @@
         da[2] = dg * da[1];
 
         dm[0] = 0.;
-        dm[1] = 1.;
+        dm[1] = k;
         dm[2] = 0.;
     }
 
@@ -192,46 +133,63 @@
             detect = listen = get_svf(src[n], dm, da, state);
             detect = fabs(detect);
 
-            gain = get_gain(detect, sample_rate, makeup,
-                            aattack, iratio, knee, range, threshold, slew,
-                            &state[4], attack, release, nc);
-
-            switch (type) {
-            case 0:
-                k = 1. / (tqfactor * gain);
-
-                fa[0] = 1. / (1. + fg * (fg + k));
-                fa[1] = fg * fa[0];
-                fa[2] = fg * fa[1];
-
-                fm[0] = 1.;
-                fm[1] = k * (gain * gain - 1.);
-                fm[2] = 0.;
-                break;
-            case 1:
-                k = 1. / tqfactor;
-                g = fg / sqrt(gain);
-
-                fa[0] = 1. / (1. + g * (g + k));
-                fa[1] = g * fa[0];
-                fa[2] = g * fa[1];
-
-                fm[0] = 1.;
-                fm[1] = k * (gain - 1.);
-                fm[2] = gain * gain - 1.;
-                break;
-            case 2:
-                k = 1. / tqfactor;
-                g = fg / sqrt(gain);
-
-                fa[0] = 1. / (1. + g * (g + k));
-                fa[1] = g * fa[0];
-                fa[2] = g * fa[1];
-
-                fm[0] = gain * gain;
-                fm[1] = k * (1. - gain) * gain;
-                fm[2] = 1. - gain * gain;
-                break;
+            if (direction == 0 && mode == 0 && detect < threshold)
+                detect = 1. / av_clipd(1. + makeup + (threshold - detect) * ratio, 1., range);
+            else if (direction == 0 && mode == 1 && detect < threshold)
+                detect = av_clipd(1. + makeup + (threshold - detect) * ratio, 1., range);
+            else if (direction == 1 && mode == 0 && detect > threshold)
+                detect = 1. / av_clipd(1. + makeup + (detect - threshold) * ratio, 1., range);
+            else if (direction == 1 && mode == 1 && detect > threshold)
+                detect = av_clipd(1. + makeup + (detect - threshold) * ratio, 1., range);
+            else
+                detect = 1.;
+
+            if (detect < state[4]) {
+                detect = iattack * detect + attack * state[4];
+            } else {
+                detect = irelease * detect + release * state[4];
+            }
+
+            if (state[4] != detect || n == 0) {
+                state[4] = gain = detect;
+
+                switch (type) {
+                case 0:
+                    k = 1. / (tqfactor * gain);
+
+                    fa[0] = 1. / (1. + fg * (fg + k));
+                    fa[1] = fg * fa[0];
+                    fa[2] = fg * fa[1];
+
+                    fm[0] = 1.;
+                    fm[1] = k * (gain * gain - 1.);
+                    fm[2] = 0.;
+                    break;
+                case 1:
+                    k = 1. / tqfactor;
+                    g = fg / sqrt(gain);
+
+                    fa[0] = 1. / (1. + g * (g + k));
+                    fa[1] = g * fa[0];
+                    fa[2] = g * fa[1];
+
+                    fm[0] = 1.;
+                    fm[1] = k * (gain - 1.);
+                    fm[2] = gain * gain - 1.;
+                    break;
+                case 2:
+                    k = 1. / tqfactor;
+                    g = fg / sqrt(gain);
+
+                    fa[0] = 1. / (1. + g * (g + k));
+                    fa[1] = g * fa[0];
+                    fa[2] = g * fa[1];
+
+                    fm[0] = gain * gain;
+                    fm[1] = k * (1. - gain) * gain;
+                    fm[2] = 1. - gain * gain;
+                    break;
+                }
             }
 
             v = get_svf(src[n], fm, fa, &state[2]);
@@ -298,11 +256,9 @@
     { "tqfactor",   "set target Q factor",     OFFSET(tqfactor),   AV_OPT_TYPE_DOUBLE, {.dbl=1},    0.001, 1000,    FLAGS },
     { "attack",     "set attack duration",     OFFSET(attack),     AV_OPT_TYPE_DOUBLE, {.dbl=20},       1, 2000,    FLAGS },
     { "release",    "set release duration",    OFFSET(release),    AV_OPT_TYPE_DOUBLE, {.dbl=200},      1, 2000,    FLAGS },
-    { "knee",       "set knee factor",         OFFSET(knee),       AV_OPT_TYPE_DOUBLE, {.dbl=1},        0, 8,       FLAGS },
-    { "ratio",      "set ratio factor",        OFFSET(ratio),      AV_OPT_TYPE_DOUBLE, {.dbl=1},        1, 20,      FLAGS },
-    { "makeup",     "set makeup gain",         OFFSET(makeup),     AV_OPT_TYPE_DOUBLE, {.dbl=0},        0, 30,      FLAGS },
-    { "range",      "set max gain",            OFFSET(range),      AV_OPT_TYPE_DOUBLE, {.dbl=0},        0, 200,     FLAGS },
-    { "slew",       "set slew factor",         OFFSET(slew),       AV_OPT_TYPE_DOUBLE, {.dbl=1},        1, 200,     FLAGS },
+    { "ratio",      "set ratio factor",        OFFSET(ratio),      AV_OPT_TYPE_DOUBLE, {.dbl=1},        0, 30,      FLAGS },
+    { "makeup",     "set makeup gain",         OFFSET(makeup),     AV_OPT_TYPE_DOUBLE, {.dbl=0},        0, 100,     FLAGS },
+    { "range",      "set max gain",            OFFSET(range),      AV_OPT_TYPE_DOUBLE, {.dbl=50},       1, 200,     FLAGS },
     { "mode",       "set mode",                OFFSET(mode),       AV_OPT_TYPE_INT,    {.i64=0},       -1, 1,       FLAGS, "mode" },
     {   "listen",   0,                         0,                  AV_OPT_TYPE_CONST,  {.i64=-1},       0, 0,       FLAGS, "mode" },
     {   "cut",      0,                         0,                  AV_OPT_TYPE_CONST,  {.i64=0},        0, 0,       FLAGS, "mode" },
@@ -311,6 +267,9 @@
     {   "bell",     0,                         0,                  AV_OPT_TYPE_CONST,  {.i64=0},        0, 0,       FLAGS, "type" },
     {   "lowshelf", 0,                         0,                  AV_OPT_TYPE_CONST,  {.i64=1},        0, 0,       FLAGS, "type" },
     {   "highshelf",0,                         0,                  AV_OPT_TYPE_CONST,  {.i64=2},        0, 0,       FLAGS, "type" },
+    { "direction",  "set direction",           OFFSET(direction),  AV_OPT_TYPE_INT,    {.i64=0},        0, 1,       FLAGS, "direction" },
+    {   "downward", 0,                         0,                  AV_OPT_TYPE_CONST,  {.i64=0},        0, 0,       FLAGS, "direction" },
+    {   "upward",   0,                         0,                  AV_OPT_TYPE_CONST,  {.i64=1},        0, 0,       FLAGS, "direction" },
     { NULL }
 };
 
--- a/third_party/ffmpeg/libavfilter/af_aspectralstats.c
+++ b/third_party/ffmpeg/libavfilter/af_aspectralstats.c
@@ -29,6 +29,22 @@
 #include "internal.h"
 #include "window_func.h"
 
+#define MEASURE_ALL       UINT_MAX
+#define MEASURE_NONE      0
+#define MEASURE_MEAN     (1 <<  0)
+#define MEASURE_VARIANCE (1 <<  1)
+#define MEASURE_CENTROID (1 <<  2)
+#define MEASURE_SPREAD   (1 <<  3)
+#define MEASURE_SKEWNESS (1 <<  4)
+#define MEASURE_KURTOSIS (1 <<  5)
+#define MEASURE_ENTROPY  (1 <<  6)
+#define MEASURE_FLATNESS (1 <<  7)
+#define MEASURE_CREST    (1 <<  8)
+#define MEASURE_FLUX     (1 <<  9)
+#define MEASURE_SLOPE    (1 << 10)
+#define MEASURE_DECREASE (1 << 11)
+#define MEASURE_ROLLOFF  (1 << 12)
+
 typedef struct ChannelSpectralStats {
     float mean;
     float variance;
@@ -47,6 +63,7 @@
 
 typedef struct AudioSpectralStatsContext {
     const AVClass *class;
+    unsigned measure;
     int win_size;
     int win_func;
     float overlap;
@@ -70,6 +87,22 @@
     { "win_size", "set the window size", OFFSET(win_size), AV_OPT_TYPE_INT, {.i64=2048}, 32, 65536, A },
     WIN_FUNC_OPTION("win_func", OFFSET(win_func), A, WFUNC_HANNING),
     { "overlap", "set window overlap", OFFSET(overlap), AV_OPT_TYPE_FLOAT, {.dbl=0.5}, 0,  1, A },
+    { "measure", "select the parameters which are measured", OFFSET(measure), AV_OPT_TYPE_FLAGS, {.i64=MEASURE_ALL}, 0, UINT_MAX, A, "measure" },
+    { "none",     "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_NONE    }, 0, 0, A, "measure" },
+    { "all",      "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_ALL     }, 0, 0, A, "measure" },
+    { "mean",     "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_MEAN    }, 0, 0, A, "measure" },
+    { "variance", "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_VARIANCE}, 0, 0, A, "measure" },
+    { "centroid", "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_CENTROID}, 0, 0, A, "measure" },
+    { "spread",   "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_SPREAD  }, 0, 0, A, "measure" },
+    { "skewness", "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_SKEWNESS}, 0, 0, A, "measure" },
+    { "kurtosis", "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_KURTOSIS}, 0, 0, A, "measure" },
+    { "entropy",  "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_ENTROPY }, 0, 0, A, "measure" },
+    { "flatness", "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_FLATNESS}, 0, 0, A, "measure" },
+    { "crest",    "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_CREST   }, 0, 0, A, "measure" },
+    { "flux",     "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_FLUX    }, 0, 0, A, "measure" },
+    { "slope",    "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_SLOPE   }, 0, 0, A, "measure" },
+    { "decrease", "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_DECREASE}, 0, 0, A, "measure" },
+    { "rolloff",  "", 0, AV_OPT_TYPE_CONST, {.i64=MEASURE_ROLLOFF }, 0, 0, A, "measure" },
     { NULL }
 };
 
@@ -166,19 +199,32 @@
     for (int ch = 0; ch < s->nb_channels; ch++) {
         ChannelSpectralStats *stats = &s->stats[ch];
 
-        set_meta(metadata, ch + 1, "mean",     "%g", stats->mean);
-        set_meta(metadata, ch + 1, "variance", "%g", stats->variance);
-        set_meta(metadata, ch + 1, "centroid", "%g", stats->centroid);
-        set_meta(metadata, ch + 1, "spread",   "%g", stats->spread);
-        set_meta(metadata, ch + 1, "skewness", "%g", stats->skewness);
-        set_meta(metadata, ch + 1, "kurtosis", "%g", stats->kurtosis);
-        set_meta(metadata, ch + 1, "entropy",  "%g", stats->entropy);
-        set_meta(metadata, ch + 1, "flatness", "%g", stats->flatness);
-        set_meta(metadata, ch + 1, "crest",    "%g", stats->crest);
-        set_meta(metadata, ch + 1, "flux",     "%g", stats->flux);
-        set_meta(metadata, ch + 1, "slope",    "%g", stats->slope);
-        set_meta(metadata, ch + 1, "decrease", "%g", stats->decrease);
-        set_meta(metadata, ch + 1, "rolloff",  "%g", stats->rolloff);
+        if (s->measure & MEASURE_MEAN)
+            set_meta(metadata, ch + 1, "mean",     "%g", stats->mean);
+        if (s->measure & MEASURE_VARIANCE)
+            set_meta(metadata, ch + 1, "variance", "%g", stats->variance);
+        if (s->measure & MEASURE_CENTROID)
+            set_meta(metadata, ch + 1, "centroid", "%g", stats->centroid);
+        if (s->measure & MEASURE_SPREAD)
+            set_meta(metadata, ch + 1, "spread",   "%g", stats->spread);
+        if (s->measure & MEASURE_SKEWNESS)
+            set_meta(metadata, ch + 1, "skewness", "%g", stats->skewness);
+        if (s->measure & MEASURE_KURTOSIS)
+            set_meta(metadata, ch + 1, "kurtosis", "%g", stats->kurtosis);
+        if (s->measure & MEASURE_ENTROPY)
+            set_meta(metadata, ch + 1, "entropy",  "%g", stats->entropy);
+        if (s->measure & MEASURE_FLATNESS)
+            set_meta(metadata, ch + 1, "flatness", "%g", stats->flatness);
+        if (s->measure & MEASURE_CREST)
+            set_meta(metadata, ch + 1, "crest",    "%g", stats->crest);
+        if (s->measure & MEASURE_FLUX)
+            set_meta(metadata, ch + 1, "flux",     "%g", stats->flux);
+        if (s->measure & MEASURE_SLOPE)
+            set_meta(metadata, ch + 1, "slope",    "%g", stats->slope);
+        if (s->measure & MEASURE_DECREASE)
+            set_meta(metadata, ch + 1, "decrease", "%g", stats->decrease);
+        if (s->measure & MEASURE_ROLLOFF)
+            set_meta(metadata, ch + 1, "rolloff",  "%g", stats->rolloff);
     }
 }
 
@@ -424,19 +470,32 @@
         for (int n = 0; n < s->win_size / 2; n++)
             magnitude[n] = hypotf(fft_out[n].re, fft_out[n].im);
 
-        stats->mean     = spectral_mean(magnitude, s->win_size / 2, in->sample_rate / 2);
-        stats->variance = spectral_variance(magnitude, s->win_size / 2, in->sample_rate / 2, stats->mean);
-        stats->centroid = spectral_centroid(magnitude, s->win_size / 2, in->sample_rate / 2);
-        stats->spread   = spectral_spread(magnitude, s->win_size / 2, in->sample_rate / 2, stats->centroid);
-        stats->skewness = spectral_skewness(magnitude, s->win_size / 2, in->sample_rate / 2, stats->centroid, stats->spread);
-        stats->kurtosis = spectral_kurtosis(magnitude, s->win_size / 2, in->sample_rate / 2, stats->centroid, stats->spread);
-        stats->entropy  = spectral_entropy(magnitude, s->win_size / 2, in->sample_rate / 2);
-        stats->flatness = spectral_flatness(magnitude, s->win_size / 2, in->sample_rate / 2);
-        stats->crest    = spectral_crest(magnitude, s->win_size / 2, in->sample_rate / 2);
-        stats->flux     = spectral_flux(magnitude, prev_magnitude, s->win_size / 2, in->sample_rate / 2);
-        stats->slope    = spectral_slope(magnitude, s->win_size / 2, in->sample_rate / 2);
-        stats->decrease = spectral_decrease(magnitude, s->win_size / 2, in->sample_rate / 2);
-        stats->rolloff  = spectral_rolloff(magnitude, s->win_size / 2, in->sample_rate / 2);
+        if (s->measure & (MEASURE_MEAN | MEASURE_VARIANCE))
+            stats->mean     = spectral_mean(magnitude, s->win_size / 2, in->sample_rate / 2);
+        if (s->measure & MEASURE_VARIANCE)
+            stats->variance = spectral_variance(magnitude, s->win_size / 2, in->sample_rate / 2, stats->mean);
+        if (s->measure & (MEASURE_SPREAD | MEASURE_KURTOSIS | MEASURE_SKEWNESS | MEASURE_CENTROID))
+            stats->centroid = spectral_centroid(magnitude, s->win_size / 2, in->sample_rate / 2);
+        if (s->measure & (MEASURE_SPREAD | MEASURE_KURTOSIS | MEASURE_SKEWNESS))
+            stats->spread   = spectral_spread(magnitude, s->win_size / 2, in->sample_rate / 2, stats->centroid);
+        if (s->measure & MEASURE_SKEWNESS)
+            stats->skewness = spectral_skewness(magnitude, s->win_size / 2, in->sample_rate / 2, stats->centroid, stats->spread);
+        if (s->measure & MEASURE_KURTOSIS)
+            stats->kurtosis = spectral_kurtosis(magnitude, s->win_size / 2, in->sample_rate / 2, stats->centroid, stats->spread);
+        if (s->measure & MEASURE_ENTROPY)
+            stats->entropy  = spectral_entropy(magnitude, s->win_size / 2, in->sample_rate / 2);
+        if (s->measure & MEASURE_FLATNESS)
+            stats->flatness = spectral_flatness(magnitude, s->win_size / 2, in->sample_rate / 2);
+        if (s->measure & MEASURE_CREST)
+            stats->crest    = spectral_crest(magnitude, s->win_size / 2, in->sample_rate / 2);
+        if (s->measure & MEASURE_FLUX)
+            stats->flux     = spectral_flux(magnitude, prev_magnitude, s->win_size / 2, in->sample_rate / 2);
+        if (s->measure & MEASURE_SLOPE)
+            stats->slope    = spectral_slope(magnitude, s->win_size / 2, in->sample_rate / 2);
+        if (s->measure & MEASURE_DECREASE)
+            stats->decrease = spectral_decrease(magnitude, s->win_size / 2, in->sample_rate / 2);
+        if (s->measure & MEASURE_ROLLOFF)
+            stats->rolloff  = spectral_rolloff(magnitude, s->win_size / 2, in->sample_rate / 2);
 
         memcpy(prev_magnitude, magnitude, s->win_size * sizeof(float));
     }
--- a/third_party/ffmpeg/libavfilter/af_biquads.c
+++ b/third_party/ffmpeg/libavfilter/af_biquads.c
@@ -729,7 +729,7 @@
         a[1] = g * a[0];
         a[2] = g * a[1];
         m[0] = 0.;
-        m[1] = s->csg ? 1. : 2.;
+        m[1] = s->csg ? 1. : k;
         m[2] = 0.;
         break;
     case bandreject:
--- a/third_party/ffmpeg/libavfilter/avf_ahistogram.c
+++ b/third_party/ffmpeg/libavfilter/avf_ahistogram.c
@@ -245,6 +245,7 @@
         memset(s->out->data[3] + n * s->out->linesize[0], 0, w);
     }
     s->out->pts = av_rescale_q(in->pts, inlink->time_base, outlink->time_base);
+    s->out->duration = 1;
 
     s->first = s->frame_count;
 
--- a/third_party/ffmpeg/libavfilter/avf_aphasemeter.c
+++ b/third_party/ffmpeg/libavfilter/avf_aphasemeter.c
@@ -327,6 +327,8 @@
         AVFrame *clone;
 
         s->out->pts = in->pts;
+        s->out->duration = av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);
+
         clone = av_frame_clone(s->out);
         if (!clone)
             return AVERROR(ENOMEM);
--- a/third_party/ffmpeg/libavfilter/avf_avectorscope.c
+++ b/third_party/ffmpeg/libavfilter/avf_avectorscope.c
@@ -275,6 +275,7 @@
             memset(s->outpicref->data[0] + i * s->outpicref->linesize[0], 0, outlink->w * 4);
     }
     s->outpicref->pts = av_rescale_q(insamples->pts, inlink->time_base, outlink->time_base);
+    s->outpicref->duration = 1;
 
     av_frame_make_writable(s->outpicref);
     ff_filter_execute(ctx, fade, NULL, NULL, FFMIN(outlink->h, ff_filter_get_nb_threads(ctx)));
--- a/third_party/ffmpeg/libavfilter/avf_showcqt.c
+++ b/third_party/ffmpeg/libavfilter/avf_showcqt.c
@@ -1187,6 +1187,7 @@
             UPDATE_TIME(s->sono_time);
         }
         out->pts = s->next_pts;
+        out->duration = PTS_STEP;
         s->next_pts += PTS_STEP;
     }
     s->sono_count = (s->sono_count + 1) % s->count;
--- a/third_party/ffmpeg/libavfilter/avf_showfreqs.c
+++ b/third_party/ffmpeg/libavfilter/avf_showfreqs.c
@@ -469,6 +469,7 @@
 
     av_free(colors);
     out->pts = s->pts;
+    out->duration = 1;
     out->sample_aspect_ratio = (AVRational){1,1};
     return ff_filter_frame(outlink, out);
 }
--- a/third_party/ffmpeg/libavfilter/avf_showspatial.c
+++ b/third_party/ffmpeg/libavfilter/avf_showspatial.c
@@ -62,6 +62,8 @@
     { "win_size", "set window size", OFFSET(win_size), AV_OPT_TYPE_INT, {.i64 = 4096}, 1024, 65536, FLAGS },
     WIN_FUNC_OPTION("win_func", OFFSET(win_func), FLAGS, WFUNC_HANNING),
     { "overlap", "set window overlap", OFFSET(overlap), AV_OPT_TYPE_FLOAT, {.dbl=0.5}, 0, 1, FLAGS },
+    { "rate", "set video rate", OFFSET(frame_rate), AV_OPT_TYPE_VIDEO_RATE, {.str="25"}, 0, INT_MAX, FLAGS },
+    { "r",    "set video rate", OFFSET(frame_rate), AV_OPT_TYPE_VIDEO_RATE, {.str="25"}, 0, INT_MAX, FLAGS },
     { NULL }
 };
 
@@ -187,6 +189,7 @@
         }
     }
 
+    outlink->frame_rate = s->frame_rate;
     outlink->time_base = av_inv_q(outlink->frame_rate);
 
     av_audio_fifo_free(s->fifo);
@@ -253,6 +256,7 @@
     }
 
     outpicref->pts = av_rescale_q(insamples->pts, inlink->time_base, outlink->time_base);
+    outpicref->duration = 1;
 
     return ff_filter_frame(outlink, outpicref);
 }
--- a/third_party/ffmpeg/libavfilter/avfilter.h
+++ b/third_party/ffmpeg/libavfilter/avfilter.h
@@ -313,13 +313,20 @@
          * and outputs are fixed), shortly before the format negotiation. This
          * callback may be called more than once.
          *
-         * This callback must set AVFilterLink.outcfg.formats on every input link
-         * and AVFilterLink.incfg.formats on every output link to a list of
-         * pixel/sample formats that the filter supports on that link. For audio
-         * links, this filter must also set @ref AVFilterLink.incfg.samplerates
-         * "in_samplerates" / @ref AVFilterLink.outcfg.samplerates "out_samplerates"
-         * and @ref AVFilterLink.incfg.channel_layouts "in_channel_layouts" /
-         * @ref AVFilterLink.outcfg.channel_layouts "out_channel_layouts" analogously.
+         * This callback must set ::AVFilterLink's
+         * @ref AVFilterFormatsConfig.formats "outcfg.formats"
+         * on every input link and
+         * @ref AVFilterFormatsConfig.formats "incfg.formats"
+         * on every output link to a list of pixel/sample formats that the filter
+         * supports on that link.
+         * For audio links, this filter must also set
+         * @ref AVFilterFormatsConfig.samplerates "incfg.samplerates"
+         *  /
+         * @ref AVFilterFormatsConfig.samplerates "outcfg.samplerates"
+         * and @ref AVFilterFormatsConfig.channel_layouts "incfg.channel_layouts"
+         *  /
+         * @ref AVFilterFormatsConfig.channel_layouts "outcfg.channel_layouts"
+         * analogously.
          *
          * This callback must never be NULL if the union is in this state.
          *
--- a/third_party/ffmpeg/libavfilter/f_drawgraph.c
+++ b/third_party/ffmpeg/libavfilter/f_drawgraph.c
@@ -168,7 +168,7 @@
     AVDictionaryEntry *e;
     AVFrame *out = s->out;
     AVFrame *clone = NULL;
-    int64_t in_pts, out_pts;
+    int64_t in_pts, out_pts, in_duration;
     int i;
 
     if (s->slide == 4 && s->nb_values >= s->values_size[0] / sizeof(float)) {
@@ -320,6 +320,7 @@
     s->x++;
 
     in_pts = in->pts;
+    in_duration = in->duration;
 
     av_frame_free(&in);
 
@@ -336,6 +337,7 @@
         return AVERROR(ENOMEM);
 
     clone->pts = s->prev_pts = out_pts;
+    clone->duration = av_rescale_q(in_duration, inlink->time_base, outlink->time_base);
     return ff_filter_frame(outlink, clone);
 }
 
--- a/third_party/ffmpeg/libavfilter/scale_eval.c
+++ b/third_party/ffmpeg/libavfilter/scale_eval.c
@@ -148,14 +148,17 @@
      * dimensions so that it is not divisible by the set factors anymore
      * unless force_divisible_by is defined as well */
     if (force_original_aspect_ratio) {
-        int tmp_w = av_rescale(h, inlink->w, inlink->h);
-        int tmp_h = av_rescale(w, inlink->h, inlink->w);
+        // Including force_divisible_by here rounds to the nearest multiple of it.
+        int tmp_w = av_rescale(h, inlink->w, inlink->h * (int64_t)force_divisible_by)
+                    * force_divisible_by;
+        int tmp_h = av_rescale(w, inlink->h, inlink->w * (int64_t)force_divisible_by)
+                    * force_divisible_by;
 
         if (force_original_aspect_ratio == 1) {
              w = FFMIN(tmp_w, w);
              h = FFMIN(tmp_h, h);
              if (force_divisible_by > 1) {
-                 // round down
+                 // round down in case provided w or h is not divisible.
                  w = w / force_divisible_by * force_divisible_by;
                  h = h / force_divisible_by * force_divisible_by;
              }
@@ -163,7 +166,7 @@
              w = FFMAX(tmp_w, w);
              h = FFMAX(tmp_h, h);
              if (force_divisible_by > 1) {
-                 // round up
+                 // round up in case provided w or h is not divisible.
                  w = (w + force_divisible_by - 1) / force_divisible_by * force_divisible_by;
                  h = (h + force_divisible_by - 1) / force_divisible_by * force_divisible_by;
              }
--- a/third_party/ffmpeg/libavfilter/scale_eval.h
+++ b/third_party/ffmpeg/libavfilter/scale_eval.h
@@ -38,7 +38,8 @@
  * Transform evaluated width and height obtained from ff_scale_eval_dimensions
  * into actual target width and height for scaling. Adjustment can occur if one
  * or both of the evaluated values are of the form '-n' or if
- * force_original_aspect_ratio is set.
+ * force_original_aspect_ratio is set. force_divisible_by is used only when
+ * force_original_aspect_ratio is set and must be at least 1.
  *
  * Returns 0.
  */
--- a/third_party/ffmpeg/libavfilter/settb.c
+++ b/third_party/ffmpeg/libavfilter/settb.c
@@ -128,6 +128,7 @@
     AVFilterLink *outlink = ctx->outputs[0];
 
     frame->pts = rescale_pts(inlink, outlink, frame->pts);
+    frame->duration = av_rescale_q(frame->duration, inlink->time_base, outlink->time_base);
 
     return ff_filter_frame(outlink, frame);
 }
--- a/third_party/ffmpeg/libavfilter/src_avsynctest.c
+++ b/third_party/ffmpeg/libavfilter/src_avsynctest.c
@@ -348,6 +348,7 @@
     }
 
     out->pts = s->vpts++;
+    out->duration = 1;
 
     return ff_filter_frame(outlink, out);
 }
--- a/third_party/ffmpeg/libavfilter/version.h
+++ b/third_party/ffmpeg/libavfilter/version.h
@@ -32,7 +32,7 @@
 #include "version_major.h"
 
 #define LIBAVFILTER_VERSION_MINOR  49
-#define LIBAVFILTER_VERSION_MICRO 100
+#define LIBAVFILTER_VERSION_MICRO 101
 
 
 #define LIBAVFILTER_VERSION_INT AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, \
--- a/third_party/ffmpeg/libavfilter/vf_chromakey.c
+++ b/third_party/ffmpeg/libavfilter/vf_chromakey.c
@@ -348,7 +348,7 @@
 
 static const AVOption chromakey_options[] = {
     { "color", "set the chromakey key color", OFFSET(chromakey_rgba), AV_OPT_TYPE_COLOR, { .str = "black" }, 0, 0, FLAGS },
-    { "similarity", "set the chromakey similarity value", OFFSET(similarity), AV_OPT_TYPE_FLOAT, { .dbl = 0.01 }, 0.01, 1.0, FLAGS },
+    { "similarity", "set the chromakey similarity value", OFFSET(similarity), AV_OPT_TYPE_FLOAT, { .dbl = 0.01 }, 0.00001, 1.0, FLAGS },
     { "blend", "set the chromakey key blend value", OFFSET(blend), AV_OPT_TYPE_FLOAT, { .dbl = 0.0 }, 0.0, 1.0, FLAGS },
     { "yuv", "color parameter is in yuv instead of rgb", OFFSET(is_yuv), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, FLAGS },
     { NULL }
@@ -381,7 +381,7 @@
 
 static const AVOption chromahold_options[] = {
     { "color", "set the chromahold key color", OFFSET(chromakey_rgba), AV_OPT_TYPE_COLOR, { .str = "black" }, 0, 0, FLAGS },
-    { "similarity", "set the chromahold similarity value", OFFSET(similarity), AV_OPT_TYPE_FLOAT, { .dbl = 0.01 }, 0.01, 1.0, FLAGS },
+    { "similarity", "set the chromahold similarity value", OFFSET(similarity), AV_OPT_TYPE_FLOAT, { .dbl = 0.01 }, 0.00001, 1.0, FLAGS },
     { "blend", "set the chromahold blend value", OFFSET(blend), AV_OPT_TYPE_FLOAT, { .dbl = 0.0 }, 0.0, 1.0, FLAGS },
     { "yuv", "color parameter is in yuv instead of rgb", OFFSET(is_yuv), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, FLAGS },
     { NULL }
--- a/third_party/ffmpeg/libavfilter/vf_colorkey.c
+++ b/third_party/ffmpeg/libavfilter/vf_colorkey.c
@@ -217,7 +217,7 @@
 
 static const AVOption colorkey_options[] = {
     { "color", "set the colorkey key color", OFFSET(colorkey_rgba), AV_OPT_TYPE_COLOR, { .str = "black" }, 0, 0, FLAGS },
-    { "similarity", "set the colorkey similarity value", OFFSET(similarity), AV_OPT_TYPE_FLOAT, { .dbl = 0.01 }, 0.01, 1.0, FLAGS },
+    { "similarity", "set the colorkey similarity value", OFFSET(similarity), AV_OPT_TYPE_FLOAT, { .dbl = 0.01 }, 0.00001, 1.0, FLAGS },
     { "blend", "set the colorkey key blend value", OFFSET(blend), AV_OPT_TYPE_FLOAT, { .dbl = 0.0 }, 0.0, 1.0, FLAGS },
     { NULL }
 };
@@ -241,7 +241,7 @@
 
 static const AVOption colorhold_options[] = {
     { "color", "set the colorhold key color", OFFSET(colorkey_rgba), AV_OPT_TYPE_COLOR, { .str = "black" }, 0, 0, FLAGS },
-    { "similarity", "set the colorhold similarity value", OFFSET(similarity), AV_OPT_TYPE_FLOAT, { .dbl = 0.01 }, 0.01, 1.0, FLAGS },
+    { "similarity", "set the colorhold similarity value", OFFSET(similarity), AV_OPT_TYPE_FLOAT, { .dbl = 0.01 }, 0.00001, 1.0, FLAGS },
     { "blend", "set the colorhold blend value", OFFSET(blend), AV_OPT_TYPE_FLOAT, { .dbl = 0.0 }, 0.0, 1.0, FLAGS },
     { NULL }
 };
--- a/third_party/ffmpeg/libavfilter/vf_coreimage.m
+++ b/third_party/ffmpeg/libavfilter/vf_coreimage.m
@@ -300,6 +300,7 @@
     }
 
     frame->pts                 = ctx->pts;
+    frame->duration            = 1;
     frame->key_frame           = 1;
     frame->interlaced_frame    = 0;
     frame->pict_type           = AV_PICTURE_TYPE_I;
--- a/third_party/ffmpeg/libavfilter/vf_curves.c
+++ b/third_party/ffmpeg/libavfilter/vf_curves.c
@@ -58,6 +58,12 @@
     NB_PRESETS,
 };
 
+enum interp {
+    INTERP_NATURAL,
+    INTERP_PCHIP,
+    NB_INTERPS,
+};
+
 typedef struct CurvesContext {
     const AVClass *class;
     int preset;
@@ -73,6 +79,7 @@
     int is_16bit;
     int depth;
     int parsed_psfile;
+    int interp;
 
     int (*filter_slice)(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs);
 } CurvesContext;
@@ -107,6 +114,9 @@
     { "all",   "set points coordinates for all components", OFFSET(comp_points_str_all), AV_OPT_TYPE_STRING, {.str=NULL}, .flags = FLAGS },
     { "psfile", "set Photoshop curves file name", OFFSET(psfile), AV_OPT_TYPE_STRING, {.str=NULL}, .flags = FLAGS },
     { "plot", "save Gnuplot script of the curves in specified file", OFFSET(plot_filename), AV_OPT_TYPE_STRING, {.str=NULL}, .flags = FLAGS },
+    { "interp", "specify the kind of interpolation", OFFSET(interp), AV_OPT_TYPE_INT, {.i64=INTERP_NATURAL}, INTERP_NATURAL, NB_INTERPS-1, FLAGS, "interp_name" },
+        { "natural", "natural cubic spline", 0, AV_OPT_TYPE_CONST, {.i64=INTERP_NATURAL}, 0, 0, FLAGS, "interp_name" },
+        { "pchip",   "monotonically cubic interpolation", 0, AV_OPT_TYPE_CONST, {.i64=INTERP_PCHIP},   0, 0, FLAGS, "interp_name" },
     { NULL }
 };
 
@@ -336,21 +346,239 @@
     av_free(h);
     av_free(r);
     return ret;
+
+}
+
+#define SIGN(x) (x > 0.0 ? 1 : x < 0.0 ? -1 : 0)
+
+/**
+ * Evalaute the derivative of an edge endpoint
+ *
+ * @param h0 input interval of the interval closest to the edge
+ * @param h1 input interval of the interval next to the closest
+ * @param m0 linear slope of the interval closest to the edge
+ * @param m1 linear slope of the intervalnext to the closest
+ * @return edge endpoint derivative
+ *
+ * Based on scipy.interpolate._edge_case()
+ *    https://github.com/scipy/scipy/blob/2e5883ef7af4f5ed4a5b80a1759a45e43163bf3f/scipy/interpolate/_cubic.py#L239
+ *    which is a python implementation of the special case endpoints, as suggested in
+ *    Cleve Moler, Numerical Computing with MATLAB, Chap 3.6 (pchiptx.m)
+*/
+static double pchip_edge_case(double h0, double h1, double m0, double m1)
+{
+    int mask, mask2;
+    double d;
+
+    d = ((2 * h0 + h1) * m0 - h0 * m1) / (h0 + h1);
+
+    mask = SIGN(d) != SIGN(m0);
+    mask2 = (SIGN(m0) != SIGN(m1)) && (fabs(d) > 3. * fabs(m0));
+
+    if (mask) d = 0.0;
+    else if (mask2) d = 3.0 * m0;
+
+    return d;
+}
+
+/**
+ * Evalaute the piecewise polynomial derivatives at endpoints
+ *
+ * @param n input interval of the interval closest to the edge
+ * @param hk input intervals
+ * @param mk linear slopes over intervals
+ * @param dk endpoint derivatives (output)
+ * @return 0 success
+ *
+ * Based on scipy.interpolate._find_derivatives()
+ *    https://github.com/scipy/scipy/blob/2e5883ef7af4f5ed4a5b80a1759a45e43163bf3f/scipy/interpolate/_cubic.py#L254
+*/
+
+static int pchip_find_derivatives(const int n, const double *hk, const double *mk, double *dk)
+{
+    int ret = 0;
+    const int m = n - 1;
+    int8_t *smk;
+
+    smk = av_malloc(n);
+    if (!smk) {
+        ret = AVERROR(ENOMEM);
+        goto end;
+    }
+
+    /* smk = sgn(mk) */
+    for (int i = 0; i < n; i++) smk[i] = SIGN(mk[i]);
+
+    /* check the strict monotonicity */
+    for (int i = 0; i < m; i++) {
+        int8_t condition = (smk[i + 1] != smk[i]) || (mk[i + 1] == 0) || (mk[i] == 0);
+        if (condition) {
+            dk[i + 1] = 0.0;
+        } else {
+            double w1 = 2 * hk[i + 1] + hk[i];
+            double w2 = hk[i + 1] + 2 * hk[i];
+            dk[i + 1] = (w1 + w2) / (w1 / mk[i] + w2 / mk[i + 1]);
+        }
+    }
+
+    dk[0] = pchip_edge_case(hk[0], hk[1], mk[0], mk[1]);
+    dk[n] = pchip_edge_case(hk[n - 1], hk[n - 2], mk[n - 1], mk[n - 2]);
+
+end:
+    av_free(smk);
+
+    return ret;
 }
 
-#define DECLARE_INTERPOLATE_FUNC(nbits)                                     \
-static int interpolate##nbits(void *log_ctx, uint16_t *y,                   \
-                              const struct keypoint *points)                \
-{                                                                           \
-    return interpolate(log_ctx, y, points, nbits);                          \
+/**
+ * Evalaute half of the cubic hermite interpolation expression, wrt one interval endpoint
+ *
+ * @param x normalized input value at the endpoint
+ * @param f output value at the endpoint
+ * @param d derivative at the endpoint: normalized to the interval, and properly sign adjusted
+ * @return half of the interpolated value
+*/
+static inline double interp_cubic_hermite_half(const double x, const double f,
+                                               const double d)
+{
+    double x2 = x * x, x3 = x2 * x;
+    return f * (3.0 * x2 - 2.0 * x3) + d * (x3 - x2);
+}
+
+/**
+ * Prepare the lookup table by piecewise monotonic cubic interpolation (PCHIP)
+ *
+ * @param log_ctx for logging
+ * @param y output lookup table (output)
+ * @param points user-defined control points/endpoints
+ * @param nbits bitdepth
+ * @return 0 success
+ *
+ * References:
+ *    [1] F. N. Fritsch and J. Butland, A method for constructing local monotone piecewise
+ *        cubic interpolants, SIAM J. Sci. Comput., 5(2), 300-304 (1984). DOI:10.1137/0905021.
+ *    [2] scipy.interpolate: https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.html
+*/
+static inline int interpolate_pchip(void *log_ctx, uint16_t *y,
+                                    const struct keypoint *points, int nbits)
+{
+    const struct keypoint *point = points;
+    const int lut_size = 1<<nbits;
+    const int n = get_nb_points(points); // number of endpoints
+    double *xi, *fi, *di, *hi, *mi;
+    const int scale = lut_size - 1; // white value
+    uint16_t x; /* input index/value */
+    int ret = 0;
+
+    /* no change for n = 0 or 1 */
+    if (n == 0) {
+        /* no points, no change */
+        for (int i = 0; i < lut_size; i++) y[i] = i;
+        return 0;
+    }
+
+    if (n == 1) {
+        /* 1 point - 1 color everywhere */
+        const uint16_t yval = CLIP(point->y * scale);
+        for (int i = 0; i < lut_size; i++) y[i] = yval;
+        return 0;
+    }
+
+    xi = av_calloc(3*n + 2*(n-1), sizeof(double)); /* output values at interval endpoints */
+    if (!xi) {
+        ret = AVERROR(ENOMEM);
+        goto end;
+    }
+
+    fi = xi + n;     /* output values at inteval endpoints */
+    di = fi + n;     /* output slope wrt normalized input at interval endpoints */
+    hi = di + n;     /* interval widths */
+    mi = hi + n - 1; /* linear slope over intervals */
+
+    /* scale endpoints and store them in a contiguous memory block */
+    for (int i = 0; i < n; i++) {
+        xi[i] = point->x * scale;
+        fi[i] = point->y * scale;
+        point = point->next;
+    }
+
+    /* h(i) = x(i+1) - x(i); mi(i) = (f(i+1)-f(i))/h(i) */
+    for (int i = 0; i < n - 1; i++) {
+        const double val = (xi[i+1]-xi[i]);
+        hi[i] = val;
+        mi[i] = (fi[i+1]-fi[i]) / val;
+    }
+
+    if (n == 2) {
+        /* edge case, use linear interpolation */
+        const double m = mi[0], b = fi[0] - xi[0]*m;
+        for (int i = 0; i < lut_size; i++) y[i] = CLIP(i*m + b);
+        goto end;
+    }
+
+    /* compute the derivatives at the endpoints*/
+    ret = pchip_find_derivatives(n-1, hi, mi, di);
+    if (ret)
+        goto end;
+
+    /* interpolate/extrapolate */
+    x = 0;
+    if (xi[0] > 0) {
+        /* below first endpoint, use the first endpoint value*/
+        const double xi0 = xi[0];
+        const double yi0 = fi[0];
+        const uint16_t yval = CLIP(yi0);
+        for (; x < xi0; x++) {
+            y[x] = yval;
+            av_log(log_ctx, AV_LOG_TRACE, "f(%f)=%f -> y[%d]=%d\n", xi0, yi0, x, y[x]);
+        }
+        av_log(log_ctx, AV_LOG_DEBUG, "Interval -1: [0, %d] -> %d\n", x - 1, yval);
+    }
+
+    /* for each interval */
+    for (int i = 0, x0 = x; i < n-1; i++, x0 = x) {
+        const double xi0 = xi[i];     /* start-of-interval input value */
+        const double xi1 = xi[i + 1]; /* end-of-interval input value */
+        const double h = hi[i];       /* interval width */
+        const double f0 = fi[i];      /* start-of-interval output value */
+        const double f1 = fi[i + 1];  /* end-of-interval output value */
+        const double d0 = di[i];      /* start-of-interval derivative */
+        const double d1 = di[i + 1];  /* end-of-interval derivative */
+
+        /* fill the lut over the interval */
+        for (; x < xi1; x++) { /* safe not to check j < lut_size */
+            const double xx = (x - xi0) / h; /* normalize input */
+            const double yy = interp_cubic_hermite_half(1 - xx, f0, -h * d0)
+                            + interp_cubic_hermite_half(xx, f1, h * d1);
+            y[x] = CLIP(yy);
+            av_log(log_ctx, AV_LOG_TRACE, "f(%f)=%f -> y[%d]=%d\n", xx, yy, x, y[x]);
+        }
+
+        if (x > x0)
+            av_log(log_ctx, AV_LOG_DEBUG, "Interval %d: [%d, %d] -> [%d, %d]\n",
+                                                    i, x0, x-1, y[x0], y[x-1]);
+        else
+            av_log(log_ctx, AV_LOG_DEBUG, "Interval %d: empty\n", i);
+    }
+
+    if (x && x < lut_size) {
+        /* above the last endpoint, use the last endpoint value*/
+        const double xi1 = xi[n - 1];
+        const double yi1 = fi[n - 1];
+        const uint16_t yval = CLIP(yi1);
+        av_log(log_ctx, AV_LOG_DEBUG, "Interval %d: [%d, %d] -> %d\n",
+                                                n-1, x, lut_size - 1, yval);
+        for (; x && x < lut_size; x++) { /* loop until int overflow */
+            y[x] = yval;
+            av_log(log_ctx, AV_LOG_TRACE, "f(%f)=%f -> y[%d]=%d\n", xi1, yi1, x, yval);
+        }
+    }
+
+end:
+    av_free(xi);
+    return ret;
 }
 
-DECLARE_INTERPOLATE_FUNC(8)
-DECLARE_INTERPOLATE_FUNC(9)
-DECLARE_INTERPOLATE_FUNC(10)
-DECLARE_INTERPOLATE_FUNC(12)
-DECLARE_INTERPOLATE_FUNC(14)
-DECLARE_INTERPOLATE_FUNC(16)
 
 static int parse_psfile(AVFilterContext *ctx, const char *fname)
 {
@@ -651,14 +879,10 @@
         ret = parse_points_str(ctx, comp_points + i, curves->comp_points_str[i], curves->lut_size);
         if (ret < 0)
             return ret;
-        switch (curves->depth) {
-        case  8: ret = interpolate8 (ctx, curves->graph[i], comp_points[i]); break;
-        case  9: ret = interpolate9 (ctx, curves->graph[i], comp_points[i]); break;
-        case 10: ret = interpolate10(ctx, curves->graph[i], comp_points[i]); break;
-        case 12: ret = interpolate12(ctx, curves->graph[i], comp_points[i]); break;
-        case 14: ret = interpolate14(ctx, curves->graph[i], comp_points[i]); break;
-        case 16: ret = interpolate16(ctx, curves->graph[i], comp_points[i]); break;
-        }
+        if (curves->interp == INTERP_PCHIP)
+            ret = interpolate_pchip(ctx, curves->graph[i], comp_points[i], curves->depth);
+        else
+            ret = interpolate(ctx, curves->graph[i], comp_points[i], curves->depth);
         if (ret < 0)
             return ret;
     }
@@ -735,7 +959,7 @@
 
     if (!strcmp(cmd, "plot")) {
         curves->saved_plot = 0;
-    } else if (!strcmp(cmd, "all") || !strcmp(cmd, "preset") || !strcmp(cmd, "psfile")) {
+    } else if (!strcmp(cmd, "all") || !strcmp(cmd, "preset") || !strcmp(cmd, "psfile")  || !strcmp(cmd, "interp")) {
         if (!strcmp(cmd, "psfile"))
             curves->parsed_psfile = 0;
         av_freep(&curves->comp_points_str_all);
--- a/third_party/ffmpeg/libavfilter/vf_decimate.c
+++ b/third_party/ffmpeg/libavfilter/vf_decimate.c
@@ -43,7 +43,6 @@
     AVFrame *last;          ///< last frame from the previous queue
     AVFrame **clean_src;    ///< frame queue for the clean source
     int got_frame[2];       ///< frame request flag for each input stream
-    AVRational ts_unit;     ///< timestamp units for the output frames
     int64_t last_pts;       ///< last output timestamp
     int64_t start_pts;      ///< base for output timestamps
     uint32_t eof;           ///< bitmask for end of stream
@@ -213,6 +212,7 @@
     /* push all frames except the drop */
     ret = 0;
     for (i = 0; i < dm->cycle && dm->queue[i].frame; i++) {
+        AVRational in_tb = ctx->inputs[INPUT_MAIN]->time_base;
         if (i == drop) {
             if (dm->ppsrc)
                 av_frame_free(&dm->clean_src[i]);
@@ -221,7 +221,8 @@
             AVFrame *frame = dm->queue[i].frame;
             dm->queue[i].frame = NULL;
             if (frame->pts != AV_NOPTS_VALUE && dm->start_pts == AV_NOPTS_VALUE)
-                dm->start_pts = frame->pts;
+                dm->start_pts = av_rescale_q(frame->pts, in_tb, outlink->time_base);
+
             if (dm->ppsrc) {
                 av_frame_free(&frame);
                 frame = dm->clean_src[i];
@@ -229,8 +230,9 @@
                     continue;
                 dm->clean_src[i] = NULL;
             }
-            frame->pts = av_rescale_q(outlink->frame_count_in, dm->ts_unit, (AVRational){1,1}) +
+            frame->pts = outlink->frame_count_in +
                          (dm->start_pts == AV_NOPTS_VALUE ? 0 : dm->start_pts);
+            frame->duration = 1;
             dm->last_pts = frame->pts;
             ret = ff_filter_frame(outlink, frame);
             if (ret < 0)
@@ -404,7 +406,7 @@
     fps = av_mul_q(fps, (AVRational){dm->cycle - 1, dm->cycle});
     av_log(ctx, AV_LOG_VERBOSE, "FPS: %d/%d -> %d/%d\n",
            inlink->frame_rate.num, inlink->frame_rate.den, fps.num, fps.den);
-    outlink->time_base  = inlink->time_base;
+    outlink->time_base  = av_inv_q(fps);
     outlink->frame_rate = fps;
     outlink->sample_aspect_ratio = inlink->sample_aspect_ratio;
     if (dm->ppsrc) {
@@ -414,7 +416,6 @@
         outlink->w = inlink->w;
         outlink->h = inlink->h;
     }
-    dm->ts_unit = av_inv_q(av_mul_q(fps, outlink->time_base));
     return 0;
 }
 
--- a/third_party/ffmpeg/libavfilter/vf_deinterlace_qsv.c
+++ b/third_party/ffmpeg/libavfilter/vf_deinterlace_qsv.c
@@ -516,6 +516,11 @@
         out->pts++;
     s->last_pts = out->pts;
 
+    if (outlink->frame_rate.num && outlink->frame_rate.den)
+        out->duration = av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);
+    else
+        out->duration = 0;
+
     ret = ff_filter_frame(outlink, out);
     if (ret < 0)
         return ret;
--- a/third_party/ffmpeg/libavfilter/vf_estdif.c
+++ b/third_party/ffmpeg/libavfilter/vf_estdif.c
@@ -48,7 +48,6 @@
     int max;
     int nb_planes;
     int nb_threads;
-    int64_t pts;
     AVFrame *prev;
 
     void (*interpolate)(struct ESTDIFContext *s, uint8_t *dst,
@@ -433,7 +432,7 @@
     return 0;
 }
 
-static int filter(AVFilterContext *ctx, int is_second, AVFrame *in)
+static int filter(AVFilterContext *ctx, AVFrame *in, int64_t pts, int64_t duration)
 {
     ESTDIFContext *s = ctx->priv;
     AVFilterLink *outlink = ctx->outputs[0];
@@ -445,7 +444,8 @@
         return AVERROR(ENOMEM);
     av_frame_copy_props(out, in);
     out->interlaced_frame = 0;
-    out->pts = s->pts;
+    out->pts = pts;
+    out->duration = duration;
 
     td.out = out; td.in = in;
     ff_filter_execute(ctx, deinterlace_slice, &td, NULL,
@@ -504,21 +504,21 @@
 
     if ((s->deint && !s->prev->interlaced_frame) || ctx->is_disabled) {
         s->prev->pts *= 2;
+        s->prev->duration *= 2;
         ret = ff_filter_frame(ctx->outputs[0], s->prev);
         s->prev = in;
         return ret;
     }
 
-    s->pts = s->prev->pts * 2;
-    ret = filter(ctx, 0, s->prev);
+    ret = filter(ctx, s->prev, s->prev->pts * 2,
+                 s->prev->duration * (s->mode ? 1 : 2));
     if (ret < 0 || s->mode == 0) {
         av_frame_free(&s->prev);
         s->prev = in;
         return ret;
     }
 
-    s->pts = s->prev->pts + in->pts;
-    ret = filter(ctx, 1, s->prev);
+    ret = filter(ctx, s->prev, s->prev->pts + in->pts, in->duration);
     av_frame_free(&s->prev);
     s->prev = in;
     return ret;
--- a/third_party/ffmpeg/libavfilter/vf_extractplanes.c
+++ b/third_party/ffmpeg/libavfilter/vf_extractplanes.c
@@ -124,6 +124,7 @@
 
 #define FLOAT_FORMATS(suf)                                     \
         AV_PIX_FMT_GRAYF32##suf,                               \
+        AV_PIX_FMT_RGBF32##suf, AV_PIX_FMT_RGBAF32##suf,       \
         AV_PIX_FMT_GBRPF32##suf, AV_PIX_FMT_GBRAPF32##suf      \
 
 static int query_formats(AVFilterContext *ctx)
@@ -284,6 +285,14 @@
                 dst[x * 2 + 1] = src[x * step + comp * 2 + 1];
             }
             break;
+        case 4:
+            for (x = 0; x < width; x++) {
+                dst[x * 4    ] = src[x * step + comp * 4    ];
+                dst[x * 4 + 1] = src[x * step + comp * 4 + 1];
+                dst[x * 4 + 2] = src[x * step + comp * 4 + 2];
+                dst[x * 4 + 3] = src[x * step + comp * 4 + 3];
+            }
+            break;
         }
         dst += dst_linesize;
         src += src_linesize;
--- a/third_party/ffmpeg/libavfilter/vf_fftdnoiz.c
+++ b/third_party/ffmpeg/libavfilter/vf_fftdnoiz.c
@@ -308,6 +308,7 @@
         dst_out += data_linesize;
     }
 
+    dst = dst_out;
     for (int i = rh; i < block; i++) {
         for (int j = 0; j < block; j++) {
             dst[j].re = ddst[j].re;
@@ -347,8 +348,8 @@
     AVComplexFloat *hdata = p->hdata[jobnr];
     AVComplexFloat *hdata_out = p->hdata_out[jobnr];
     AVComplexFloat *vdata_out = p->vdata_out[jobnr];
-    const int rw = FFMIN(size, width  - x * size + hoverlap);
-    const int rh = FFMIN(size, height - y * size + hoverlap);
+    const int rw = FFMIN(size, width  - x * size);
+    const int rh = FFMIN(size, height - y * size);
     AVComplexFloat *hdst, *vdst = vdata_out, *hdst_out = hdata_out;
     float *bsrc = buffer;
 
--- a/third_party/ffmpeg/libavfilter/vf_fps.c
+++ b/third_party/ffmpeg/libavfilter/vf_fps.c
@@ -291,6 +291,7 @@
         // Make sure Closed Captions will not be duplicated
         av_frame_remove_side_data(s->frames[0], AV_FRAME_DATA_A53_CC);
         frame->pts = s->next_pts++;
+        frame->duration = 1;
 
         av_log(ctx, AV_LOG_DEBUG, "Writing frame with pts %"PRId64" to pts %"PRId64"\n",
                s->frames[0]->pts, frame->pts);
--- a/third_party/ffmpeg/libavfilter/vf_framepack.c
+++ b/third_party/ffmpeg/libavfilter/vf_framepack.c
@@ -329,8 +329,10 @@
 
         for (i = 0; i < 2; i++) {
             // set correct timestamps
-            if (pts != AV_NOPTS_VALUE)
+            if (pts != AV_NOPTS_VALUE) {
                 s->input_views[i]->pts = i == 0 ? pts * 2 : pts * 2 + av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);
+                s->input_views[i]->duration = av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);
+            }
 
             // set stereo3d side data
             stereo = av_stereo3d_create_side_data(s->input_views[i]);
--- a/third_party/ffmpeg/libavfilter/vf_frei0r.c
+++ b/third_party/ffmpeg/libavfilter/vf_frei0r.c
@@ -488,6 +488,7 @@
 
     frame->sample_aspect_ratio = (AVRational) {1, 1};
     frame->pts = s->pts++;
+    frame->duration = 1;
 
     s->update(s->instance, av_rescale_q(frame->pts, s->time_base, (AVRational){1,1000}),
                    NULL, (uint32_t *)frame->data[0]);
--- a/third_party/ffmpeg/libavfilter/vf_maskedthreshold.c
+++ b/third_party/ffmpeg/libavfilter/vf_maskedthreshold.c
@@ -32,6 +32,7 @@
 
     int threshold;
     int planes;
+    int mode;
 
     int linesize[4];
     int planewidth[4], planeheight[4];
@@ -43,15 +44,19 @@
 } MaskedThresholdContext;
 
 #define OFFSET(x) offsetof(MaskedThresholdContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_RUNTIME_PARAM
+#define TFLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_RUNTIME_PARAM
+#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
 
 typedef struct ThreadData {
     AVFrame *src, *ref, *dst;
 } ThreadData;
 
 static const AVOption maskedthreshold_options[] = {
-    { "threshold", "set threshold", OFFSET(threshold), AV_OPT_TYPE_INT, {.i64=1},   0, UINT16_MAX, FLAGS },
-    { "planes",    "set planes",    OFFSET(planes),    AV_OPT_TYPE_INT, {.i64=0xF}, 0, 0xF,        FLAGS },
+    { "threshold", "set threshold", OFFSET(threshold), AV_OPT_TYPE_INT, {.i64=1},   0, UINT16_MAX, TFLAGS },
+    { "planes",    "set planes",    OFFSET(planes),    AV_OPT_TYPE_INT, {.i64=0xF}, 0, 0xF,        TFLAGS },
+    { "mode",      "set mode",      OFFSET(mode),      AV_OPT_TYPE_INT, {.i64=0},   0, 1,          FLAGS, "mode" },
+    { "abs",       "",              0,                 AV_OPT_TYPE_CONST, {.i64=0}, 0, 0,          FLAGS, "mode" },
+    { "diff",      "",              0,                 AV_OPT_TYPE_CONST, {.i64=1}, 0, 0,          FLAGS, "mode" },
     { NULL }
 };
 
@@ -77,13 +82,29 @@
     AV_PIX_FMT_NONE
 };
 
-static void threshold8(const uint8_t *src, const uint8_t *ref, uint8_t *dst, int threshold, int w)
+static void threshold8_diff(const uint8_t *src, const uint8_t *ref, uint8_t *dst, int threshold, int w)
+{
+    for (int x = 0; x < w; x++)
+        dst[x] = (ref[x] - src[x] <= threshold) ? FFMAX(ref[x] - threshold, 0): src[x];
+}
+
+static void threshold8_abs(const uint8_t *src, const uint8_t *ref, uint8_t *dst, int threshold, int w)
 {
     for (int x = 0; x < w; x++)
         dst[x] = FFABS(src[x] - ref[x]) <= threshold ? src[x] : ref[x];
 }
 
-static void threshold16(const uint8_t *ssrc, const uint8_t *rref, uint8_t *ddst, int threshold, int w)
+static void threshold16_diff(const uint8_t *ssrc, const uint8_t *rref, uint8_t *ddst, int threshold, int w)
+{
+    const uint16_t *src = (const uint16_t *)ssrc;
+    const uint16_t *ref = (const uint16_t *)rref;
+    uint16_t *dst = (uint16_t *)ddst;
+
+    for (int x = 0; x < w; x++)
+        dst[x] = (ref[x] - src[x] <= threshold) ? FFMAX(ref[x] - threshold, 0): src[x];
+}
+
+static void threshold16_abs(const uint8_t *ssrc, const uint8_t *rref, uint8_t *ddst, int threshold, int w)
 {
     const uint16_t *src = (const uint16_t *)ssrc;
     const uint16_t *ref = (const uint16_t *)rref;
@@ -115,9 +136,9 @@
     s->depth = desc->comp[0].depth;
 
     if (desc->comp[0].depth == 8)
-        s->maskedthreshold = threshold8;
+        s->maskedthreshold = s->mode ? threshold8_diff : threshold8_abs;
     else
-        s->maskedthreshold = threshold16;
+        s->maskedthreshold = s->mode ? threshold16_diff : threshold16_abs;
 
     return 0;
 }
--- a/third_party/ffmpeg/libavfilter/vf_minterpolate.c
+++ b/third_party/ffmpeg/libavfilter/vf_minterpolate.c
@@ -1189,6 +1189,7 @@
 
         av_frame_copy_props(avf_out, mi_ctx->frames[NB_FRAMES - 1].avf);
         avf_out->pts = mi_ctx->out_pts++;
+        avf_out->duration = 1;
 
         interpolate(inlink, avf_out);
 
--- a/third_party/ffmpeg/libavfilter/vf_rotate.c
+++ b/third_party/ffmpeg/libavfilter/vf_rotate.c
@@ -258,8 +258,8 @@
 {
     int int_x = av_clip(x>>16, 0, max_x);
     int int_y = av_clip(y>>16, 0, max_y);
-    int frac_x = x&0xFFFF;
-    int frac_y = y&0xFFFF;
+    int64_t frac_x = x&0xFFFF;
+    int64_t frac_y = y&0xFFFF;
     int i;
     int int_x1 = FFMIN(int_x+1, max_x);
     int int_y1 = FFMIN(int_y+1, max_y);
@@ -269,10 +269,10 @@
         int s01 = AV_RL16(&src[src_linestep * int_x1 + i + src_linesize * int_y ]);
         int s10 = AV_RL16(&src[src_linestep * int_x  + i + src_linesize * int_y1]);
         int s11 = AV_RL16(&src[src_linestep * int_x1 + i + src_linesize * int_y1]);
-        int s0 = (((1<<16) - frac_x)*s00 + frac_x*s01);
-        int s1 = (((1<<16) - frac_x)*s10 + frac_x*s11);
+        int64_t s0 = (((1<<16) - frac_x)*s00 + frac_x*s01);
+        int64_t s1 = (((1<<16) - frac_x)*s10 + frac_x*s11);
 
-        AV_WL16(&dst_color[i], ((int64_t)((1<<16) - frac_y)*s0 + (int64_t)frac_y*s1) >> 32);
+        AV_WL16(&dst_color[i], (((1<<16) - frac_y)*s0 + frac_y*s1) >> 32);
     }
 
     return dst_color;
--- a/third_party/ffmpeg/libavfilter/vf_threshold_init.h
+++ b/third_party/ffmpeg/libavfilter/vf_threshold_init.h
@@ -38,7 +38,7 @@
 {
     for (int y = 0; y < h; y++) {
         for (int x = 0; x < w; x++)
-            out[x] = in[x] < threshold[x] ? min[x] : max[x];
+            out[x] = in[x] <= threshold[x] ? min[x] : max[x];
 
         in        += ilinesize;
         threshold += tlinesize;
@@ -64,7 +64,7 @@
 
     for (int y = 0; y < h; y++) {
         for (int x = 0; x < w; x++)
-            out[x] = in[x] < threshold[x] ? min[x] : max[x];
+            out[x] = in[x] <= threshold[x] ? min[x] : max[x];
 
         in        += ilinesize / 2;
         threshold += tlinesize / 2;
--- a/third_party/ffmpeg/libavfilter/vf_tinterlace.c
+++ b/third_party/ffmpeg/libavfilter/vf_tinterlace.c
@@ -510,6 +510,7 @@
     }
 
     out->pts = av_rescale_q(out->pts, tinterlace->preout_time_base, outlink->time_base);
+    out->duration = av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);
     ret = ff_filter_frame(outlink, out);
 
     return ret;
--- a/third_party/ffmpeg/libavfilter/window_func.h
+++ b/third_party/ffmpeg/libavfilter/window_func.h
@@ -31,7 +31,7 @@
                       WFUNC_BHARRIS, WFUNC_BNUTTALL, WFUNC_SINE, WFUNC_NUTTALL,
                       WFUNC_BHANN, WFUNC_LANCZOS, WFUNC_GAUSS, WFUNC_TUKEY,
                       WFUNC_DOLPH, WFUNC_CAUCHY, WFUNC_PARZEN, WFUNC_POISSON,
-                      WFUNC_BOHMAN,
+                      WFUNC_BOHMAN, WFUNC_KAISER,
                       NB_WFUNC };
 
 #define WIN_FUNC_OPTION(win_func_opt_name, win_func_offset, flag, default_window_func)                              \
@@ -56,7 +56,22 @@
         { "cauchy",   "Cauchy",           0, AV_OPT_TYPE_CONST, {.i64=WFUNC_CAUCHY},   0, 0, flag, "win_func" }, \
         { "parzen",   "Parzen",           0, AV_OPT_TYPE_CONST, {.i64=WFUNC_PARZEN},   0, 0, flag, "win_func" }, \
         { "poisson",  "Poisson",          0, AV_OPT_TYPE_CONST, {.i64=WFUNC_POISSON},  0, 0, flag, "win_func" }, \
-        { "bohman",   "Bohman",           0, AV_OPT_TYPE_CONST, {.i64=WFUNC_BOHMAN},   0, 0, flag, "win_func" }
+        { "bohman",   "Bohman",           0, AV_OPT_TYPE_CONST, {.i64=WFUNC_BOHMAN},   0, 0, flag, "win_func" }, \
+        { "kaiser",   "Kaiser",           0, AV_OPT_TYPE_CONST, {.i64=WFUNC_KAISER},   0, 0, flag, "win_func" }
+
+static inline double get_i0(double x)
+{
+    double y = 1.0, prev = 1.0, i = 1.0;
+
+    while (fabs(prev) > 1e-20) {
+        double summand = prev * x * x / (4 * i * i);
+        y += summand;
+        prev = summand;
+        i++;
+    }
+
+    return y;
+}
 
 static inline void generate_window_func(float *lut, int N, int win_func,
                                         float *overlap)
@@ -216,6 +231,14 @@
         }
         *overlap = 0.75;
         break;
+    case WFUNC_KAISER:
+        for (n = 0; n < N; n++) {
+            double x = 2.0 / (double)(N - 1);
+
+            lut[n] = get_i0(12. * sqrt(1. - SQR(n * x - 1.))) / get_i0(12.);
+        }
+        *overlap = 0.75;
+        break;
     default:
         av_assert0(0);
     }
--- a/third_party/ffmpeg/libavfilter/x86/vf_threshold.asm
+++ b/third_party/ffmpeg/libavfilter/x86/vf_threshold.asm
@@ -22,15 +22,10 @@
 
 %include "libavutil/x86/x86util.asm"
 
-SECTION_RODATA
-
-pb_128: times 16 db 128
-pb_128_0 : times 8 db 0, 128
-
 SECTION .text
 
-;%1 depth (8 or 16) ; %2 b or w ; %3 constant
-%macro THRESHOLD 3
+;%1 depth (8 or 16) ; %2 b or w
+%macro THRESHOLD 2
 %if ARCH_X86_64
 cglobal threshold%1, 10, 13, 5, in, threshold, min, max, out, ilinesize, tlinesize, flinesize, slinesize, olinesize, w, h, x
     mov             wd, dword wm
@@ -45,7 +40,6 @@
 %define     olinesizeq  r9mp
 %define             hd  r11mp
 %endif
-    VBROADCASTI128  m4, [%3]
 %if %1 == 16
     add             wq, wq ; w *= 2 (16 bits instead of 8)
 %endif
@@ -63,9 +57,8 @@
         movu            m0, [thresholdq + xq]
         movu            m2, [minq + xq]
         movu            m3, [maxq + xq]
-        pxor            m0, m4
-        pxor            m1, m4
-        pcmpgt%2        m0, m1
+        pminu%2         m0, m1
+        pcmpeq%2        m0, m1
         PBLENDVB        m3, m2, m0
         movu   [outq + xq], m3
         add             xq, mmsize
@@ -82,11 +75,11 @@
 %endmacro
 
 INIT_XMM sse4
-THRESHOLD 8, b, pb_128
-THRESHOLD 16, w, pb_128_0
+THRESHOLD 8, b
+THRESHOLD 16, w
 
 %if HAVE_AVX2_EXTERNAL
 INIT_YMM avx2
-THRESHOLD 8, b, pb_128
-THRESHOLD 16, w, pb_128_0
+THRESHOLD 8, b
+THRESHOLD 16, w
 %endif
--- a/third_party/ffmpeg/libavformat/Makefile
+++ b/third_party/ffmpeg/libavformat/Makefile
@@ -101,6 +101,7 @@
 OBJS-$(CONFIG_AMRWB_DEMUXER)             += amr.o rawdec.o
 OBJS-$(CONFIG_AMV_MUXER)                 += amvenc.o
 OBJS-$(CONFIG_ANM_DEMUXER)               += anm.o
+OBJS-$(CONFIG_APAC_DEMUXER)              += apac.o rawdec.o
 OBJS-$(CONFIG_APC_DEMUXER)               += apc.o
 OBJS-$(CONFIG_APE_DEMUXER)               += ape.o apetag.o img2.o
 OBJS-$(CONFIG_APM_DEMUXER)               += apm.o
--- a/third_party/ffmpeg/libavformat/adtsenc.c
+++ b/third_party/ffmpeg/libavformat/adtsenc.c
@@ -26,6 +26,7 @@
 #include "libavcodec/codec_par.h"
 #include "libavcodec/packet.h"
 #include "libavcodec/mpeg4audio.h"
+#include "libavcodec/mpeg4audio_copy_pce.h"
 #include "libavutil/opt.h"
 #include "avformat.h"
 #include "apetag.h"
--- a/third_party/ffmpeg/libavformat/allformats.c
+++ b/third_party/ffmpeg/libavformat/allformats.c
@@ -52,6 +52,7 @@
 extern const AVInputFormat  ff_amrwb_demuxer;
 extern const AVOutputFormat ff_amv_muxer;
 extern const AVInputFormat  ff_anm_demuxer;
+extern const AVInputFormat  ff_apac_demuxer;
 extern const AVInputFormat  ff_apc_demuxer;
 extern const AVInputFormat  ff_ape_demuxer;
 extern const AVInputFormat  ff_apm_demuxer;
--- /dev/null
+++ b/third_party/ffmpeg/libavformat/apac.c
@@ -0,0 +1,86 @@
+/*
+ * APAC demuxer
+ * Copyright (c) 2022 Paul B Mahol
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/intreadwrite.h"
+#include "avformat.h"
+#include "demux.h"
+#include "internal.h"
+#include "rawdec.h"
+
+static int apac_probe(const AVProbeData *p)
+{
+    if (AV_RB32(p->buf) == MKBETAG('A','P','A','C') &&
+        AV_RB32(p->buf + 8) == MKBETAG('P','R','O','F') &&
+        AV_RB32(p->buf + 12) == MKBETAG('N','A','D',' '))
+        return AVPROBE_SCORE_MAX;
+
+    return 0;
+}
+
+static int apac_read_header(AVFormatContext *s)
+{
+    AVIOContext *pb = s->pb;
+    uint32_t chunk_size;
+    AVStream *st;
+    int64_t pos;
+
+    avio_skip(pb, 16);
+    chunk_size = avio_rl32(pb);
+    avio_skip(pb, chunk_size);
+    if (avio_rb32(pb) != MKBETAG('P','F','M','T'))
+        return AVERROR_INVALIDDATA;
+    chunk_size = avio_rl32(pb);
+    pos = avio_tell(pb);
+    avio_skip(pb, 2);
+    st = avformat_new_stream(s, NULL);
+    if (!st)
+        return AVERROR(ENOMEM);
+    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;
+    st->codecpar->codec_id    = AV_CODEC_ID_APAC;
+    st->codecpar->ch_layout.nb_channels = avio_rl16(pb);
+    st->codecpar->sample_rate = avio_rl32(pb);
+    if (st->codecpar->ch_layout.nb_channels <= 0 ||
+        st->codecpar->ch_layout.nb_channels >  2 ||
+        st->codecpar->sample_rate <= 0)
+        return AVERROR_INVALIDDATA;
+    avio_skip(pb, 2);
+    st->codecpar->bits_per_coded_sample = avio_rl16(pb);
+    avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);
+    avio_skip(pb, (chunk_size + pos) - avio_tell(pb) + (chunk_size & 1));
+    if (avio_rb32(pb) != MKBETAG('P','A','D',' '))
+        return AVERROR_INVALIDDATA;
+    avio_skip(pb, 4);
+
+    return 0;
+}
+
+const AVInputFormat ff_apac_demuxer = {
+    .name           = "apac",
+    .long_name      = NULL_IF_CONFIG_SMALL("raw APAC"),
+    .read_probe     = apac_probe,
+    .read_header    = apac_read_header,
+    .read_packet    = ff_raw_read_partial_packet,
+    .extensions     = "apc",
+    .flags          = AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK | AVFMT_NOTIMESTAMPS,
+    .raw_codec_id   = AV_CODEC_ID_APAC,
+    .priv_data_size = sizeof(FFRawDemuxerContext),
+    .priv_class     = &ff_raw_demuxer_class,
+};
--- a/third_party/ffmpeg/libavformat/ape.c
+++ b/third_party/ffmpeg/libavformat/ape.c
@@ -298,6 +298,8 @@
             ape->frames[i].pos  -= ape->frames[i].skip;
             ape->frames[i].size += ape->frames[i].skip;
         }
+        if (ape->frames[i].size > INT_MAX - 3)
+            return AVERROR_INVALIDDATA;
         ape->frames[i].size = (ape->frames[i].size + 3) & ~3;
     }
     if (ape->fileversion < 3810) {
--- a/third_party/ffmpeg/libavformat/apm.c
+++ b/third_party/ffmpeg/libavformat/apm.c
@@ -148,7 +148,7 @@
     par->codec_id              = AV_CODEC_ID_ADPCM_IMA_APM;
     par->format                = AV_SAMPLE_FMT_S16;
     par->bit_rate              = par->ch_layout.nb_channels *
-                                 par->sample_rate *
+                                 (int64_t)par->sample_rate *
                                  par->bits_per_coded_sample;
 
     if ((ret = avio_read(s->pb, buf, APM_FILE_EXTRADATA_SIZE)) < 0)
--- a/third_party/ffmpeg/libavformat/asfdec_o.c
+++ b/third_party/ffmpeg/libavformat/asfdec_o.c
@@ -888,6 +888,8 @@
             av_log(s, AV_LOG_ERROR, "Skipping failed in asf_read_simple_index.\n");
             return offset;
         }
+        if (asf->first_packet_offset > INT64_MAX - asf->packet_size * pkt_num)
+            return AVERROR_INVALIDDATA;
         if (prev_pkt_num != pkt_num) {
             av_add_index_entry(st, asf->first_packet_offset + asf->packet_size *
                                pkt_num, av_rescale(interval, i, 10000),
@@ -1242,6 +1244,8 @@
     unsigned char error_flags, len_flags, pay_flags;
 
     asf->packet_offset = avio_tell(pb);
+    if (asf->packet_offset > INT64_MAX/2)
+        asf->packet_offset = 0;
     error_flags = avio_r8(pb); // read Error Correction Flags
     if (error_flags & ASF_PACKET_FLAG_ERROR_CORRECTION_PRESENT) {
         if (!(error_flags & ASF_ERROR_CORRECTION_LENGTH_TYPE)) {
--- a/third_party/ffmpeg/libavformat/asfenc.c
+++ b/third_party/ffmpeg/libavformat/asfenc.c
@@ -25,6 +25,7 @@
 #include "libavutil/dict.h"
 #include "libavutil/mathematics.h"
 #include "libavutil/opt.h"
+#include "libavcodec/codec_desc.h"
 #include "avformat.h"
 #include "avlanguage.h"
 #include "avio_internal.h"
--- a/third_party/ffmpeg/libavformat/async.c
+++ b/third_party/ffmpeg/libavformat/async.c
@@ -144,8 +144,14 @@
 
 static int ring_write(RingBuffer *ring, URLContext *h, size_t size)
 {
+    int ret;
+
     av_assert2(size <= ring_space(ring));
-    return av_fifo_write_from_cb(ring->fifo, wrapped_url_read, h, &size);
+    ret = av_fifo_write_from_cb(ring->fifo, wrapped_url_read, h, &size);
+    if (ret < 0)
+        return ret;
+
+    return size;
 }
 
 static int ring_size_of_read_back(RingBuffer *ring)
@@ -183,6 +189,8 @@
     int           ret  = 0;
     int64_t       seek_ret;
 
+    ff_thread_setname("async");
+
     while (1) {
         int fifo_space, to_copy;
 
--- a/third_party/ffmpeg/libavformat/av1dec.c
+++ b/third_party/ffmpeg/libavformat/av1dec.c
@@ -19,11 +19,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "config.h"
 #include "config_components.h"
 
 #include "libavutil/common.h"
 #include "libavutil/opt.h"
+#include "libavcodec/avcodec.h"
 #include "libavcodec/av1_parse.h"
 #include "libavcodec/bsf.h"
 #include "avformat.h"
--- a/third_party/ffmpeg/libavformat/avformat.h
+++ b/third_party/ffmpeg/libavformat/avformat.h
@@ -1902,8 +1902,8 @@
 /**
  * Iterate over all registered demuxers.
  *
- * @param opaque a pointer where libavformat will store the iteration state. Must
- *               point to NULL to start the iteration.
+ * @param opaque a pointer where libavformat will store the iteration state.
+ *               Must point to NULL to start the iteration.
  *
  * @return the next registered demuxer or NULL when the iteration is
  *         finished
@@ -1961,12 +1961,13 @@
 /**
  * Wrap an existing array as stream side data.
  *
- * @param st stream
+ * @param st   stream
  * @param type side information type
  * @param data the side data array. It must be allocated with the av_malloc()
  *             family of functions. The ownership of the data is transferred to
  *             st.
  * @param size side information size
+ *
  * @return zero on success, a negative AVERROR code on failure. On failure,
  *         the stream is unchanged and the data remains owned by the caller.
  */
@@ -1977,8 +1978,9 @@
  * Allocate new information from stream.
  *
  * @param stream stream
- * @param type desired side information type
- * @param size side information size
+ * @param type   desired side information type
+ * @param size   side information size
+ *
  * @return pointer to fresh allocated data or NULL otherwise
  */
 uint8_t *av_stream_new_side_data(AVStream *stream,
@@ -1987,9 +1989,10 @@
  * Get side information from stream.
  *
  * @param stream stream
- * @param type desired side information type
- * @param size If supplied, *size will be set to the size of the side data
- *             or to zero if the desired side data is not present.
+ * @param type   desired side information type
+ * @param size   If supplied, *size will be set to the size of the side data
+ *               or to zero if the desired side data is not present.
+ *
  * @return pointer to data if present or NULL otherwise
  */
 uint8_t *av_stream_get_side_data(const AVStream *stream,
@@ -2007,16 +2010,17 @@
  * avformat_free_context() can be used to free the context and
  * everything allocated by the framework within it.
  *
- * @param *ctx is set to the created format context, or to NULL in
- * case of failure
- * @param oformat format to use for allocating the context, if NULL
- * format_name and filename are used instead
- * @param format_name the name of output format to use for allocating the
- * context, if NULL filename is used instead
- * @param filename the name of the filename to use for allocating the
- * context, may be NULL
- * @return >= 0 in case of success, a negative AVERROR code in case of
- * failure
+ * @param ctx           pointee is set to the created format context,
+ *                      or to NULL in case of failure
+ * @param oformat       format to use for allocating the context, if NULL
+ *                      format_name and filename are used instead
+ * @param format_name   the name of output format to use for allocating the
+ *                      context, if NULL filename is used instead
+ * @param filename      the name of the filename to use for allocating the
+ *                      context, may be NULL
+ *
+ * @return  >= 0 in case of success, a negative AVERROR code in case of
+ *          failure
  */
 int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat,
                                    const char *format_name, const char *filename);
@@ -2071,15 +2075,16 @@
  * attempt is made. When the maximum probe size is reached, the input format
  * with the highest score is returned.
  *
- * @param pb the bytestream to probe
- * @param fmt the input format is put here
- * @param url the url of the stream
- * @param logctx the log context
- * @param offset the offset within the bytestream to probe from
+ * @param pb             the bytestream to probe
+ * @param fmt            the input format is put here
+ * @param url            the url of the stream
+ * @param logctx         the log context
+ * @param offset         the offset within the bytestream to probe from
  * @param max_probe_size the maximum probe buffer size (zero for default)
+ *
  * @return the score in case of success, a negative value corresponding to an
  *         the maximal score is AVPROBE_SCORE_MAX
- * AVERROR code otherwise
+ *         AVERROR code otherwise
  */
 int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt,
                            const char *url, void *logctx,
@@ -2096,16 +2101,19 @@
  * Open an input stream and read the header. The codecs are not opened.
  * The stream must be closed with avformat_close_input().
  *
- * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).
- *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this
- *           function and written into ps.
- *           Note that a user-supplied AVFormatContext will be freed on failure.
- * @param url URL of the stream to open.
- * @param fmt If non-NULL, this parameter forces a specific input format.
- *            Otherwise the format is autodetected.
- * @param options  A dictionary filled with AVFormatContext and demuxer-private options.
- *                 On return this parameter will be destroyed and replaced with a dict containing
- *                 options that were not found. May be NULL.
+ * @param ps       Pointer to user-supplied AVFormatContext (allocated by
+ *                 avformat_alloc_context). May be a pointer to NULL, in
+ *                 which case an AVFormatContext is allocated by this
+ *                 function and written into ps.
+ *                 Note that a user-supplied AVFormatContext will be freed
+ *                 on failure.
+ * @param url      URL of the stream to open.
+ * @param fmt      If non-NULL, this parameter forces a specific input format.
+ *                 Otherwise the format is autodetected.
+ * @param options  A dictionary filled with AVFormatContext and demuxer-private
+ *                 options.
+ *                 On return this parameter will be destroyed and replaced with
+ *                 a dict containing options that were not found. May be NULL.
  *
  * @return 0 on success, a negative AVERROR on failure.
  *
@@ -2144,6 +2152,7 @@
  * @param last  the last found program, the search will start after this
  *              program, or from the beginning if it is NULL
  * @param s     stream index
+ *
  * @return the next program which belongs to s, NULL if no program is found or
  *         the last program is not among the programs of ic.
  */
@@ -2168,10 +2177,12 @@
  * @param decoder_ret       if non-NULL, returns the decoder for the
  *                          selected stream
  * @param flags             flags; none are currently defined
+ *
  * @return  the non-negative stream number in case of success,
  *          AVERROR_STREAM_NOT_FOUND if no stream with the requested type
  *          could be found,
  *          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
+ *
  * @note  If av_find_best_stream returns successfully and decoder_ret is not
  *        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
  */
@@ -2215,13 +2226,14 @@
  * Seek to the keyframe at timestamp.
  * 'timestamp' in 'stream_index'.
  *
- * @param s media file handle
- * @param stream_index If stream_index is (-1), a default
- * stream is selected, and timestamp is automatically converted
- * from AV_TIME_BASE units to the stream specific time_base.
- * @param timestamp Timestamp in AVStream.time_base units
- *        or, if no stream is specified, in AV_TIME_BASE units.
- * @param flags flags which select direction and seeking mode
+ * @param s            media file handle
+ * @param stream_index If stream_index is (-1), a default stream is selected,
+ *                     and timestamp is automatically converted from
+ *                     AV_TIME_BASE units to the stream specific time_base.
+ * @param timestamp    Timestamp in AVStream.time_base units or, if no stream
+ *                     is specified, in AV_TIME_BASE units.
+ * @param flags        flags which select direction and seeking mode
+ *
  * @return >= 0 on success
  */
 int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp,
@@ -2243,12 +2255,12 @@
  * keyframes (this may not be supported by all demuxers).
  * If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.
  *
- * @param s media file handle
+ * @param s            media file handle
  * @param stream_index index of the stream which is used as time base reference
- * @param min_ts smallest acceptable timestamp
- * @param ts target timestamp
- * @param max_ts largest acceptable timestamp
- * @param flags flags
+ * @param min_ts       smallest acceptable timestamp
+ * @param ts           target timestamp
+ * @param max_ts       largest acceptable timestamp
+ * @param flags        flags
  * @return >=0 on success, error code otherwise
  *
  * @note This is part of the new seek API which is still under construction.
@@ -2312,16 +2324,22 @@
  * Allocate the stream private data and write the stream header to
  * an output media file.
  *
- * @param s Media file handle, must be allocated with avformat_alloc_context().
- *          Its oformat field must be set to the desired output format;
- *          Its pb field must be set to an already opened AVIOContext.
- * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
- *                 On return this parameter will be destroyed and replaced with a dict containing
- *                 options that were not found. May be NULL.
- *
- * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,
- *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,
- *         negative AVERROR on failure.
+ * @param s        Media file handle, must be allocated with
+ *                 avformat_alloc_context().
+ *                 Its \ref AVFormatContext.oformat "oformat" field must be set
+ *                 to the desired output format;
+ *                 Its \ref AVFormatContext.pb "pb" field must be set to an
+ *                 already opened ::AVIOContext.
+ * @param options  An ::AVDictionary filled with AVFormatContext and
+ *                 muxer-private options.
+ *                 On return this parameter will be destroyed and replaced with
+ *                 a dict containing options that were not found. May be NULL.
+ *
+ * @retval AVSTREAM_INIT_IN_WRITE_HEADER On success, if the codec had not already been
+ *                                       fully initialized in avformat_init_output().
+ * @retval AVSTREAM_INIT_IN_INIT_OUTPUT  On success, if the codec had already been fully
+ *                                       initialized in avformat_init_output().
+ * @retval AVERROR                       A negative AVERROR on failure.
  *
  * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.
  */
@@ -2330,20 +2348,26 @@
 
 /**
  * Allocate the stream private data and initialize the codec, but do not write the header.
- * May optionally be used before avformat_write_header to initialize stream parameters
+ * May optionally be used before avformat_write_header() to initialize stream parameters
  * before actually writing the header.
- * If using this function, do not pass the same options to avformat_write_header.
+ * If using this function, do not pass the same options to avformat_write_header().
  *
- * @param s Media file handle, must be allocated with avformat_alloc_context().
- *          Its oformat field must be set to the desired output format;
- *          Its pb field must be set to an already opened AVIOContext.
- * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
- *                 On return this parameter will be destroyed and replaced with a dict containing
- *                 options that were not found. May be NULL.
- *
- * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,
- *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,
- *         negative AVERROR on failure.
+ * @param s        Media file handle, must be allocated with
+ *                 avformat_alloc_context().
+ *                 Its \ref AVFormatContext.oformat "oformat" field must be set
+ *                 to the desired output format;
+ *                 Its \ref AVFormatContext.pb "pb" field must be set to an
+ *                 already opened ::AVIOContext.
+ * @param options  An ::AVDictionary filled with AVFormatContext and
+ *                 muxer-private options.
+ *                 On return this parameter will be destroyed and replaced with
+ *                 a dict containing options that were not found. May be NULL.
+ *
+ * @retval AVSTREAM_INIT_IN_WRITE_HEADER On success, if the codec requires
+ *                                       avformat_write_header to fully initialize.
+ * @retval AVSTREAM_INIT_IN_INIT_OUTPUT  On success, if the codec has been fully
+ *                                       initialized.
+ * @retval AVERROR                       Anegative AVERROR on failure.
  *
  * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.
  */
@@ -2488,11 +2512,11 @@
  * there is no match.
  *
  * @param short_name if non-NULL checks if short_name matches with the
- * names of the registered formats
- * @param filename if non-NULL checks if filename terminates with the
- * extensions of the registered formats
- * @param mime_type if non-NULL checks if mime_type matches with the
- * MIME type of the registered formats
+ *                   names of the registered formats
+ * @param filename   if non-NULL checks if filename terminates with the
+ *                   extensions of the registered formats
+ * @param mime_type  if non-NULL checks if mime_type matches with the
+ *                   MIME type of the registered formats
  */
 const AVOutputFormat *av_guess_format(const char *short_name,
                                       const char *filename,
@@ -2516,9 +2540,11 @@
  *                   time_base units
  * @param[out] wall  absolute time when that packet whas output,
  *                   in microsecond
- * @return  0 if OK, AVERROR(ENOSYS) if the format does not support it
- * Note: some formats or devices may not allow to measure dts and wall
- * atomically.
+ * @retval  0               Success
+ * @retval  AVERROR(ENOSYS) The format does not support it
+ *
+ * @note Some formats or devices may not allow to measure dts and wall
+ *       atomically.
  */
 int av_get_output_timestamp(struct AVFormatContext *s, int stream,
                             int64_t *dts, int64_t *wall);
@@ -2660,7 +2686,7 @@
  * Get the AVIndexEntry corresponding to the given timestamp.
  *
  * @param st          Stream containing the requested AVIndexEntry.
- * @param timestamp   Timestamp to retrieve the index entry for.
+ * @param wanted_timestamp   Timestamp to retrieve the index entry for.
  * @param flags       If AVSEEK_FLAG_BACKWARD then the returned entry will correspond
  *                    to the timestamp which is <= the requested one, if backward
  *                    is 0, then it will be >=
--- a/third_party/ffmpeg/libavformat/avidec.c
+++ b/third_party/ffmpeg/libavformat/avidec.c
@@ -923,6 +923,7 @@
                         ast->dshow_block_align = 0;
                     }
                     if ((st->codecpar->codec_id == AV_CODEC_ID_AAC  ||
+                         st->codecpar->codec_id == AV_CODEC_ID_FTR  ||
                          st->codecpar->codec_id == AV_CODEC_ID_FLAC ||
                          st->codecpar->codec_id == AV_CODEC_ID_MP2 ) && ast->dshow_block_align <= 4 && ast->dshow_block_align) {
                         av_log(s, AV_LOG_DEBUG, "overriding invalid dshow_block_align of %d\n", ast->dshow_block_align);
--- a/third_party/ffmpeg/libavformat/avio.c
+++ b/third_party/ffmpeg/libavformat/avio.c
@@ -528,6 +528,12 @@
     return ret;
 }
 
+#if !FF_API_AVIODIRCONTEXT
+struct AVIODirContext {
+    struct URLContext *url_context;
+};
+#endif
+
 int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options)
 {
     URLContext *h = NULL;
--- a/third_party/ffmpeg/libavformat/avio.h
+++ b/third_party/ffmpeg/libavformat/avio.h
@@ -101,9 +101,13 @@
     int64_t filemode;                     /**< Unix file mode, -1 if unknown. */
 } AVIODirEntry;
 
+#if FF_API_AVIODIRCONTEXT
 typedef struct AVIODirContext {
     struct URLContext *url_context;
 } AVIODirContext;
+#else
+typedef struct AVIODirContext AVIODirContext;
+#endif
 
 /**
  * Different data types that can be returned via the AVIO
@@ -464,6 +468,7 @@
  *
  * Zero-length ranges are omitted from the output.
  *
+ * @param s    the AVIOContext
  * @param time the stream time the current bytestream pos corresponds to
  *             (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not
  *             applicable
--- a/third_party/ffmpeg/libavformat/aviobuf.c
+++ b/third_party/ffmpeg/libavformat/aviobuf.c
@@ -231,12 +231,14 @@
 
 void avio_write(AVIOContext *s, const unsigned char *buf, int size)
 {
+    if (size <= 0)
+        return;
     if (s->direct && !s->update_checksum) {
         avio_flush(s);
         writeout(s, buf, size);
         return;
     }
-    while (size > 0) {
+    do {
         int len = FFMIN(s->buf_end - s->buf_ptr, size);
         memcpy(s->buf_ptr, buf, len);
         s->buf_ptr += len;
@@ -246,7 +248,7 @@
 
         buf += len;
         size -= len;
-    }
+    } while (size > 0);
 }
 
 void avio_flush(AVIOContext *s)
--- a/third_party/ffmpeg/libavformat/cafdec.c
+++ b/third_party/ffmpeg/libavformat/cafdec.c
@@ -387,7 +387,7 @@
 
 found_data:
     if (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {
-        if (caf->data_size > 0)
+        if (caf->data_size > 0 && caf->data_size / caf->bytes_per_packet < INT64_MAX / caf->frames_per_packet)
             st->nb_frames = (caf->data_size / caf->bytes_per_packet) * caf->frames_per_packet;
     } else if (ffstream(st)->nb_index_entries && st->duration > 0) {
         if (st->codecpar->sample_rate && caf->data_size / st->duration > INT64_MAX / st->codecpar->sample_rate / 8) {
--- a/third_party/ffmpeg/libavformat/cafenc.c
+++ b/third_party/ffmpeg/libavformat/cafenc.c
@@ -53,7 +53,11 @@
     }
 }
 
-static uint32_t samples_per_packet(enum AVCodecID codec_id, int channels, int block_align) {
+static uint32_t samples_per_packet(const AVCodecParameters *par) {
+    enum AVCodecID codec_id = par->codec_id;
+    int channels = par->ch_layout.nb_channels, block_align = par->block_align;
+    int frame_size = par->frame_size, sample_rate = par->sample_rate;
+
     switch (codec_id) {
     case AV_CODEC_ID_PCM_S8:
     case AV_CODEC_ID_PCM_S16LE:
@@ -83,6 +87,8 @@
         return 320;
     case AV_CODEC_ID_MP1:
         return 384;
+    case AV_CODEC_ID_OPUS:
+        return frame_size * 48000 / sample_rate;
     case AV_CODEC_ID_MP2:
     case AV_CODEC_ID_MP3:
         return 1152;
@@ -110,7 +116,7 @@
     AVDictionaryEntry *t = NULL;
     unsigned int codec_tag = ff_codec_get_tag(ff_codec_caf_tags, par->codec_id);
     int64_t chunk_size = 0;
-    int frame_size = par->frame_size;
+    int frame_size = par->frame_size, sample_rate = par->sample_rate;
 
     if (s->nb_streams != 1) {
         av_log(s, AV_LOG_ERROR, "CAF files have exactly one stream\n");
@@ -139,7 +145,10 @@
     }
 
     if (par->codec_id != AV_CODEC_ID_MP3 || frame_size != 576)
-        frame_size = samples_per_packet(par->codec_id, par->ch_layout.nb_channels, par->block_align);
+        frame_size = samples_per_packet(par);
+
+    if (par->codec_id == AV_CODEC_ID_OPUS)
+        sample_rate = 48000;
 
     ffio_wfourcc(pb, "caff"); //< mFileType
     avio_wb16(pb, 1);         //< mFileVersion
@@ -147,7 +156,7 @@
 
     ffio_wfourcc(pb, "desc");                         //< Audio Description chunk
     avio_wb64(pb, 32);                                //< mChunkSize
-    avio_wb64(pb, av_double2int(par->sample_rate));   //< mSampleRate
+    avio_wb64(pb, av_double2int(sample_rate));        //< mSampleRate
     avio_wl32(pb, codec_tag);                         //< mFormatID
     avio_wb32(pb, codec_flags(par->codec_id));        //< mFormatFlags
     avio_wb32(pb, par->block_align);                  //< mBytesPerPacket
@@ -248,7 +257,7 @@
         avio_seek(pb, caf->data, SEEK_SET);
         avio_wb64(pb, file_size - caf->data - 8);
         if (!par->block_align) {
-            int packet_size = samples_per_packet(par->codec_id, par->ch_layout.nb_channels, par->block_align);
+            int packet_size = samples_per_packet(par);
             if (!packet_size) {
                 packet_size = st->duration / (caf->packets - 1);
                 avio_seek(pb, FRAME_SIZE_OFFSET, SEEK_SET);
--- a/third_party/ffmpeg/libavformat/concatdec.c
+++ b/third_party/ffmpeg/libavformat/concatdec.c
@@ -25,6 +25,7 @@
 #include "libavutil/opt.h"
 #include "libavutil/parseutils.h"
 #include "libavutil/timestamp.h"
+#include "libavcodec/codec_desc.h"
 #include "libavcodec/bsf.h"
 #include "avformat.h"
 #include "avio_internal.h"
--- a/third_party/ffmpeg/libavformat/dashenc.c
+++ b/third_party/ffmpeg/libavformat/dashenc.c
@@ -38,6 +38,8 @@
 #include "libavutil/time.h"
 #include "libavutil/time_internal.h"
 
+#include "libavcodec/avcodec.h"
+
 #include "av1.h"
 #include "avc.h"
 #include "avformat.h"
--- a/third_party/ffmpeg/libavformat/demux.c
+++ b/third_party/ffmpeg/libavformat/demux.c
@@ -34,6 +34,7 @@
 #include "libavutil/time.h"
 #include "libavutil/timestamp.h"
 
+#include "libavcodec/avcodec.h"
 #include "libavcodec/bsf.h"
 #include "libavcodec/internal.h"
 #include "libavcodec/packet_internal.h"
--- a/third_party/ffmpeg/libavformat/dhav.c
+++ b/third_party/ffmpeg/libavformat/dhav.c
@@ -242,7 +242,7 @@
     avio_seek(s->pb, avio_size(s->pb) - 8, SEEK_SET);
     while (avio_tell(s->pb) > 12 && max_interations--) {
         if (avio_rl32(s->pb) == MKTAG('d','h','a','v')) {
-            int seek_back = avio_rl32(s->pb);
+            int64_t seek_back = avio_rl32(s->pb);
 
             avio_seek(s->pb, -seek_back, SEEK_CUR);
             read_chunk(s);
--- a/third_party/ffmpeg/libavformat/dump.c
+++ b/third_party/ffmpeg/libavformat/dump.c
@@ -30,12 +30,13 @@
 #include "libavutil/dovi_meta.h"
 #include "libavutil/mathematics.h"
 #include "libavutil/opt.h"
-#include "libavutil/avstring.h"
 #include "libavutil/replaygain.h"
 #include "libavutil/spherical.h"
 #include "libavutil/stereo3d.h"
 #include "libavutil/timecode.h"
 
+#include "libavcodec/avcodec.h"
+
 #include "avformat.h"
 #include "internal.h"
 
--- a/third_party/ffmpeg/libavformat/dxa.c
+++ b/third_party/ffmpeg/libavformat/dxa.c
@@ -118,9 +118,12 @@
             if(tag == MKTAG('d', 'a', 't', 'a')) break;
             avio_skip(pb, fsize);
         }
-        c->bpc = (fsize + c->frames - 1) / c->frames;
-        if(ast->codecpar->block_align)
+        c->bpc = (fsize + (int64_t)c->frames - 1) / c->frames;
+        if(ast->codecpar->block_align) {
+            if (c->bpc > INT_MAX - ast->codecpar->block_align + 1)
+                return AVERROR_INVALIDDATA;
             c->bpc = ((c->bpc + ast->codecpar->block_align - 1) / ast->codecpar->block_align) * ast->codecpar->block_align;
+        }
         c->bytes_left = fsize;
         c->wavpos = avio_tell(pb);
         avio_seek(pb, c->vidpos, SEEK_SET);
--- a/third_party/ffmpeg/libavformat/fifo.c
+++ b/third_party/ffmpeg/libavformat/fifo.c
@@ -432,6 +432,8 @@
     fifo_thread_ctx.avf = avf;
     fifo_thread_ctx.last_received_dts = AV_NOPTS_VALUE;
 
+    ff_thread_setname("fifo-consumer");
+
     while (1) {
         uint8_t just_flushed = 0;
 
--- a/third_party/ffmpeg/libavformat/flacdec.c
+++ b/third_party/ffmpeg/libavformat/flacdec.c
@@ -20,6 +20,7 @@
  */
 
 #include "libavutil/channel_layout.h"
+#include "libavcodec/avcodec.h"
 #include "libavcodec/bytestream.h"
 #include "libavcodec/flac.h"
 #include "avformat.h"
--- a/third_party/ffmpeg/libavformat/flvdec.c
+++ b/third_party/ffmpeg/libavformat/flvdec.c
@@ -66,7 +66,7 @@
     uint8_t resync_buffer[2*RESYNC_BUFFER_SIZE];
 
     int broken_sizes;
-    int sum_flv_tag_size;
+    int64_t sum_flv_tag_size;
 
     int last_keyframe_stream_index;
     int keyframe_count;
@@ -1032,7 +1032,7 @@
     type = (avio_r8(s->pb) & 0x1F);
     orig_size =
     size = avio_rb24(s->pb);
-    flv->sum_flv_tag_size += size + 11;
+    flv->sum_flv_tag_size += size + 11LL;
     dts  = avio_rb24(s->pb);
     dts |= (unsigned)avio_r8(s->pb) << 24;
     av_log(s, AV_LOG_TRACE, "type:%d, size:%d, last:%d, dts:%"PRId64" pos:%"PRId64"\n", type, size, last, dts, avio_tell(s->pb));
@@ -1332,7 +1332,7 @@
             !avio_feof(s->pb) &&
             (last != orig_size || !last) && last != flv->sum_flv_tag_size &&
             !flv->broken_sizes) {
-            av_log(s, AV_LOG_ERROR, "Packet mismatch %d %d %d\n", last, orig_size + 11, flv->sum_flv_tag_size);
+            av_log(s, AV_LOG_ERROR, "Packet mismatch %d %d %"PRId64"\n", last, orig_size + 11, flv->sum_flv_tag_size);
             avio_seek(s->pb, pos + 1, SEEK_SET);
             ret = resync(s);
             av_packet_unref(pkt);
--- a/third_party/ffmpeg/libavformat/flvenc.c
+++ b/third_party/ffmpeg/libavformat/flvenc.c
@@ -24,6 +24,7 @@
 #include "libavutil/intfloat.h"
 #include "libavutil/avassert.h"
 #include "libavutil/mathematics.h"
+#include "libavcodec/codec_desc.h"
 #include "libavcodec/mpeg4audio.h"
 #include "avio.h"
 #include "avc.h"
--- a/third_party/ffmpeg/libavformat/genh.c
+++ b/third_party/ffmpeg/libavformat/genh.c
@@ -78,6 +78,8 @@
     case  0: st->codecpar->codec_id = AV_CODEC_ID_ADPCM_PSX;        break;
     case  1:
     case 11: st->codecpar->bits_per_coded_sample = 4;
+             if (st->codecpar->ch_layout.nb_channels > INT_MAX / 36)
+                return AVERROR_INVALIDDATA;
              st->codecpar->block_align = 36 * st->codecpar->ch_layout.nb_channels;
              st->codecpar->codec_id = AV_CODEC_ID_ADPCM_IMA_WAV;    break;
     case  2: st->codecpar->codec_id = AV_CODEC_ID_ADPCM_DTK;        break;
--- a/third_party/ffmpeg/libavformat/hevc.c
+++ b/third_party/ffmpeg/libavformat/hevc.c
@@ -848,15 +848,15 @@
         if (array->numNalus == 0)
             continue;
 
-        av_log(NULL, AV_LOG_TRACE, "array_completeness[%"PRIu8"]:               %"PRIu8"\n",
+        av_log(NULL, AV_LOG_TRACE, "array_completeness[%u]:               %"PRIu8"\n",
                j, array->array_completeness);
-        av_log(NULL, AV_LOG_TRACE, "NAL_unit_type[%"PRIu8"]:                    %"PRIu8"\n",
+        av_log(NULL, AV_LOG_TRACE, "NAL_unit_type[%u]:                    %"PRIu8"\n",
                j, array->NAL_unit_type);
-        av_log(NULL, AV_LOG_TRACE, "numNalus[%"PRIu8"]:                         %"PRIu16"\n",
+        av_log(NULL, AV_LOG_TRACE, "numNalus[%u]:                         %"PRIu16"\n",
                j, array->numNalus);
         for (unsigned k = 0; k < array->numNalus; k++)
             av_log(NULL, AV_LOG_TRACE,
-                    "nalUnitLength[%"PRIu8"][%"PRIu16"]:                 %"PRIu16"\n",
+                    "nalUnitLength[%u][%u]:                 %"PRIu16"\n",
                    j, k, array->nalUnitLength[k]);
         j++;
     }
--- a/third_party/ffmpeg/libavformat/hls.c
+++ b/third_party/ffmpeg/libavformat/hls.c
@@ -1527,7 +1527,7 @@
                 return AVERROR_EOF;
             }
         } else {
-            av_log(v->parent, AV_LOG_WARNING, "maybe the m3u8 list sequence have been wraped.\n");
+            av_log(v->parent, AV_LOG_WARNING, "The m3u8 list sequence may have been wrapped.\n");
         }
         if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {
             if (v->finished)
--- a/third_party/ffmpeg/libavformat/hlsenc.c
+++ b/third_party/ffmpeg/libavformat/hlsenc.c
@@ -43,6 +43,8 @@
 #include "libavutil/time.h"
 #include "libavutil/time_internal.h"
 
+#include "libavcodec/avcodec.h"
+
 #include "avformat.h"
 #include "avio_internal.h"
 #include "avc.h"
--- a/third_party/ffmpeg/libavformat/imfdec.c
+++ b/third_party/ffmpeg/libavformat/imfdec.c
@@ -686,8 +686,11 @@
 {
     IMFContext *c = s->priv_data;
     IMFVirtualTrackPlaybackCtx *track;
-
     AVRational minimum_timestamp = av_make_q(INT32_MAX, 1);
+
+    if (!c->track_count)
+        return NULL;
+
     for (uint32_t i = c->track_count; i > 0; i--) {
         av_log(s, AV_LOG_TRACE, "Compare track %d timestamp " AVRATIONAL_FORMAT
                " to minimum " AVRATIONAL_FORMAT
@@ -702,8 +705,6 @@
         }
     }
 
-    av_log(s, AV_LOG_DEBUG, "Found next track to read: %d (timestamp: %lf / %lf)\n",
-           track->index, av_q2d(track->current_timestamp), av_q2d(minimum_timestamp));
     return track;
 }
 
@@ -766,6 +767,14 @@
 
     track = get_next_track_with_minimum_timestamp(s);
 
+    if (!track) {
+        av_log(s, AV_LOG_ERROR, "No track found for playback\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    av_log(s, AV_LOG_DEBUG, "Found track %d to read at timestamp %lf\n",
+           track->index, av_q2d(track->current_timestamp));
+
     ret = get_resource_context_for_timestamp(s, track, &resource);
     if (ret)
         return ret;
--- a/third_party/ffmpeg/libavformat/internal.h
+++ b/third_party/ffmpeg/libavformat/internal.h
@@ -23,7 +23,6 @@
 
 #include <stdint.h>
 
-#include "libavcodec/avcodec.h"
 #include "libavcodec/packet_internal.h"
 
 #include "avformat.h"
@@ -221,7 +220,7 @@
     /**
      * The codec context used by avformat_find_stream_info, the parser, etc.
      */
-    AVCodecContext *avctx;
+    struct AVCodecContext *avctx;
     /**
      * 1 if avctx has been initialized with the values from the codec parameters
      */
--- a/third_party/ffmpeg/libavformat/isom_tags.c
+++ b/third_party/ffmpeg/libavformat/isom_tags.c
@@ -274,6 +274,13 @@
 
     { AV_CODEC_ID_RAWVIDEO, MKTAG('B', 'G', 'G', 'R') }, /* ASC Bayer BGGR */
 
+    { AV_CODEC_ID_MEDIA100, MKTAG('6', '0', '1', 'N') },
+    { AV_CODEC_ID_MEDIA100, MKTAG('6', '0', '1', 'P') },
+    { AV_CODEC_ID_MEDIA100, MKTAG('d', 't', 'n', 't') },
+    { AV_CODEC_ID_MEDIA100, MKTAG('d', 't', 'N', 'T') },
+    { AV_CODEC_ID_MEDIA100, MKTAG('d', 't', 'p', 'a') },
+    { AV_CODEC_ID_MEDIA100, MKTAG('d', 't', 'P', 'A') },
+
     { AV_CODEC_ID_NONE, 0 },
 };
 
--- a/third_party/ffmpeg/libavformat/jacosubdec.c
+++ b/third_party/ffmpeg/libavformat/jacosubdec.c
@@ -144,7 +144,7 @@
     ret = 0;
     switch (n) {
     case 4:
-        ret = sign * (((int64_t)a*3600 + b*60 + c) * timeres + d);
+        ret = sign * (((int64_t)a*3600 + (int64_t)b*60 + c) * timeres + d);
         break;
     case 3:
         ret = sign * ((         (int64_t)a*60 + b) * timeres + c);
--- a/third_party/ffmpeg/libavformat/latmenc.c
+++ b/third_party/ffmpeg/libavformat/latmenc.c
@@ -25,6 +25,7 @@
 #include "libavcodec/codec_par.h"
 #include "libavcodec/packet.h"
 #include "libavcodec/mpeg4audio.h"
+#include "libavcodec/mpeg4audio_copy_pce.h"
 #include "libavutil/opt.h"
 #include "avformat.h"
 #include "internal.h"
--- a/third_party/ffmpeg/libavformat/matroskadec.c
+++ b/third_party/ffmpeg/libavformat/matroskadec.c
@@ -48,6 +48,7 @@
 #include "libavutil/mastering_display_metadata.h"
 #include "libavutil/mathematics.h"
 #include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
 #include "libavutil/time_internal.h"
 #include "libavutil/spherical.h"
 
@@ -2190,8 +2191,8 @@
         color->chroma_siting_horz  < MATROSKA_COLOUR_CHROMASITINGHORZ_NB &&
         color->chroma_siting_vert  < MATROSKA_COLOUR_CHROMASITINGVERT_NB) {
         st->codecpar->chroma_location =
-            avcodec_chroma_pos_to_enum((color->chroma_siting_horz - 1) << 7,
-                                       (color->chroma_siting_vert - 1) << 7);
+            av_chroma_location_pos_to_enum((color->chroma_siting_horz - 1) << 7,
+                                           (color->chroma_siting_vert - 1) << 7);
     }
     if (color->max_cll && color->max_fall) {
         size_t size = 0;
@@ -4027,7 +4028,8 @@
 
 /* This function searches all the Cues and returns the CueDesc corresponding to
  * the timestamp ts. Returned CueDesc will be such that start_time_ns <= ts <
- * end_time_ns. All 4 fields will be set to -1 if ts >= file's duration.
+ * end_time_ns. All 4 fields will be set to -1 if ts >= file's duration or
+ * if an error occurred.
  */
 static CueDesc get_cue_desc(AVFormatContext *s, int64_t ts, int64_t cues_start) {
     MatroskaDemuxContext *matroska = s->priv_data;
@@ -4046,6 +4048,8 @@
         }
     }
     --i;
+    if (index_entries[i].timestamp > matroska->duration)
+        return (CueDesc) {-1, -1, -1, -1};
     cue_desc.start_time_ns = index_entries[i].timestamp * matroska->time_scale;
     cue_desc.start_offset = index_entries[i].pos - matroska->segment_start;
     if (i != nb_index_entries - 1) {
--- a/third_party/ffmpeg/libavformat/matroskaenc.c
+++ b/third_party/ffmpeg/libavformat/matroskaenc.c
@@ -51,12 +51,14 @@
 #include "libavutil/mathematics.h"
 #include "libavutil/opt.h"
 #include "libavutil/parseutils.h"
+#include "libavutil/pixdesc.h"
 #include "libavutil/random_seed.h"
 #include "libavutil/rational.h"
 #include "libavutil/samplefmt.h"
 #include "libavutil/stereo3d.h"
 
 #include "libavcodec/av1.h"
+#include "libavcodec/codec_desc.h"
 #include "libavcodec/xiph.h"
 #include "libavcodec/mpeg4audio.h"
 
@@ -1322,7 +1324,7 @@
         par->chroma_location <= AVCHROMA_LOC_TOP) {
         int xpos, ypos;
 
-        avcodec_enum_to_chroma_pos(&xpos, &ypos, par->chroma_location);
+        av_chroma_location_enum_to_pos(&xpos, &ypos, par->chroma_location);
         ebml_writer_add_uint(writer, MATROSKA_ID_VIDEOCOLORCHROMASITINGHORZ,
                              (xpos >> 7) + 1);
         ebml_writer_add_uint(writer, MATROSKA_ID_VIDEOCOLORCHROMASITINGVERT,
--- a/third_party/ffmpeg/libavformat/mj2kdec.c
+++ b/third_party/ffmpeg/libavformat/mj2kdec.c
@@ -19,13 +19,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "config_components.h"
-
 #include "libavutil/intreadwrite.h"
 #include "avformat.h"
 #include "rawdec.h"
 
-#if CONFIG_MJPEG_2000_DEMUXER
 static int mjpeg2000_probe(const AVProbeData *p)
 {
     const uint8_t *b = p->buf;
@@ -53,4 +50,3 @@
     return 0;
 }
 FF_DEF_RAWVIDEO_DEMUXER2(mjpeg_2000, "raw MJPEG 2000 video", mjpeg2000_probe, "j2k", AV_CODEC_ID_JPEG2000, AVFMT_GENERIC_INDEX|AVFMT_NOTIMESTAMPS)
-#endif
--- a/third_party/ffmpeg/libavformat/movenc.c
+++ b/third_party/ffmpeg/libavformat/movenc.c
@@ -2179,6 +2179,16 @@
     return update_size(pb, pos);
 }
 
+static int mov_write_aux_tag(AVIOContext *pb, const char *aux_type)
+{
+    int64_t pos = avio_tell(pb);
+    avio_wb32(pb, 0); /* size */
+    ffio_wfourcc(pb, aux_type);
+    avio_wb32(pb, 0); /* Version & flags */
+    avio_write(pb, "urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\0", 44);
+    return update_size(pb, pos);
+}
+
 static int mov_write_video_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)
 {
     int ret = AVERROR_BUG;
@@ -2363,8 +2373,11 @@
     if (avid)
         avio_wb32(pb, 0);
 
-    if (track->mode == MODE_AVIF)
+    if (track->mode == MODE_AVIF) {
         mov_write_ccst_tag(pb);
+        if (s->nb_streams > 0 && track == &mov->tracks[1])
+            mov_write_aux_tag(pb, "auxi");
+    }
 
     return update_size(pb, pos);
 }
@@ -3044,16 +3057,6 @@
     return update_size(pb, pos);
 }
 
-static int mov_write_auxC_tag(AVIOContext *pb)
-{
-    int64_t pos = avio_tell(pb);
-    avio_wb32(pb, 0); /* size */
-    ffio_wfourcc(pb, "auxC");
-    avio_wb32(pb, 0); /* Version & flags */
-    avio_write(pb, "urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\0", 44);
-    return update_size(pb, pos);
-}
-
 static int mov_write_ipco_tag(AVIOContext *pb, MOVMuxContext *mov, AVFormatContext *s)
 {
     int64_t pos = avio_tell(pb);
@@ -3066,7 +3069,7 @@
         if (!i)
             mov_write_colr_tag(pb, &mov->tracks[0], 0);
         else
-            mov_write_auxC_tag(pb);
+            mov_write_aux_tag(pb, "auxC");
     }
     return update_size(pb, pos);
 }
--- a/third_party/ffmpeg/libavformat/mp3dec.c
+++ b/third_party/ffmpeg/libavformat/mp3dec.c
@@ -418,18 +418,11 @@
             ffio_ensure_seekback(s->pb, i + 1024 + 4);
         frame_size = check(s->pb, off + i, &header);
         if (frame_size > 0) {
-            ret = avio_seek(s->pb, off, SEEK_SET);
-            if (ret < 0)
-                return ret;
             ffio_ensure_seekback(s->pb, i + 1024 + frame_size + 4);
             ret = check(s->pb, off + i + frame_size, &header2);
             if (ret >= 0 &&
                 (header & MP3_MASK) == (header2 & MP3_MASK))
             {
-                av_log(s, i > 0 ? AV_LOG_INFO : AV_LOG_VERBOSE, "Skipping %d bytes of junk at %"PRId64".\n", i, off);
-                ret = avio_seek(s->pb, off + i, SEEK_SET);
-                if (ret < 0)
-                    return ret;
                 break;
             } else if (ret == CHECK_SEEK_FAILED) {
                 av_log(s, AV_LOG_ERROR, "Invalid frame size (%d): Could not seek to %"PRId64".\n", frame_size, off + i + frame_size);
@@ -439,12 +432,16 @@
             av_log(s, AV_LOG_ERROR, "Failed to read frame size: Could not seek to %"PRId64".\n", (int64_t) (i + 1024 + frame_size + 4));
             return AVERROR(EINVAL);
         }
-        ret = avio_seek(s->pb, off, SEEK_SET);
-        if (ret < 0)
-            return ret;
     }
+    if (i == 64 * 1024) {
+        off = avio_seek(s->pb, off, SEEK_SET);
+    } else {
+        av_log(s, i > 0 ? AV_LOG_INFO : AV_LOG_VERBOSE, "Skipping %d bytes of junk at %"PRId64".\n", i, off);
+        off = avio_seek(s->pb, off + i, SEEK_SET);
+    }
+    if (off < 0)
+        return off;
 
-    off = avio_tell(s->pb);
     // the seek index is relative to the end of the xing vbr headers
     for (int i = 0; i < sti->nb_index_entries; i++)
         sti->index_entries[i].pos += off;
--- a/third_party/ffmpeg/libavformat/mpegts.c
+++ b/third_party/ffmpeg/libavformat/mpegts.c
@@ -32,6 +32,7 @@
 #include "libavutil/opt.h"
 #include "libavutil/avassert.h"
 #include "libavutil/dovi_meta.h"
+#include "libavcodec/avcodec.h"
 #include "libavcodec/bytestream.h"
 #include "libavcodec/get_bits.h"
 #include "libavcodec/opus.h"
--- a/third_party/ffmpeg/libavformat/mpegtsenc.c
+++ b/third_party/ffmpeg/libavformat/mpegtsenc.c
@@ -28,6 +28,7 @@
 #include "libavutil/opt.h"
 
 #include "libavcodec/ac3_parser_internal.h"
+#include "libavcodec/avcodec.h"
 #include "libavcodec/startcode.h"
 
 #include "avformat.h"
@@ -111,6 +112,7 @@
 #define MPEGTS_FLAG_SYSTEM_B        0x08
 #define MPEGTS_FLAG_DISCONT         0x10
 #define MPEGTS_FLAG_NIT             0x20
+#define MPEGTS_FLAG_OMIT_RAI        0x40
     int flags;
     int copyts;
     int tables_version;
@@ -1565,7 +1567,8 @@
             q = get_ts_payload_start(buf);
             ts_st->discontinuity = 0;
         }
-        if (key && is_start && pts != AV_NOPTS_VALUE &&
+        if (!(ts->flags & MPEGTS_FLAG_OMIT_RAI) &&
+            key && is_start && pts != AV_NOPTS_VALUE &&
             !is_dvb_teletext /* adaptation+payload forbidden for teletext (ETSI EN 300 472 V1.3.1 4.1) */) {
             // set Random Access for key frames
             if (ts_st->pcr_period)
@@ -2281,6 +2284,8 @@
       0, AV_OPT_TYPE_CONST, { .i64 = MPEGTS_FLAG_DISCONT }, 0, INT_MAX, ENC, "mpegts_flags" },
     { "nit", "Enable NIT transmission",
       0, AV_OPT_TYPE_CONST, { .i64 = MPEGTS_FLAG_NIT}, 0, INT_MAX, ENC, "mpegts_flags" },
+    { "omit_rai", "Disable writing of random access indicator",
+      0, AV_OPT_TYPE_CONST, { .i64 = MPEGTS_FLAG_OMIT_RAI }, 0, INT_MAX, ENC, "mpegts_flags" },
     { "mpegts_copyts", "don't offset dts/pts", OFFSET(copyts), AV_OPT_TYPE_BOOL, { .i64 = -1 }, -1, 1, ENC },
     { "tables_version", "set PAT, PMT, SDT and NIT version", OFFSET(tables_version), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 31, ENC },
     { "omit_video_pes_length", "Omit the PES packet length for video packets",
--- a/third_party/ffmpeg/libavformat/mux.c
+++ b/third_party/ffmpeg/libavformat/mux.c
@@ -144,10 +144,11 @@
     return ret;
 }
 
-static int validate_codec_tag(AVFormatContext *s, AVStream *st)
+static int validate_codec_tag(const AVFormatContext *s, const AVStream *st)
 {
     const AVCodecTag *avctag;
     enum AVCodecID id = AV_CODEC_ID_NONE;
+    unsigned uppercase_tag = ff_toupper4(st->codecpar->codec_tag);
     int64_t tag  = -1;
 
     /**
@@ -159,7 +160,7 @@
     for (int n = 0; s->oformat->codec_tag[n]; n++) {
         avctag = s->oformat->codec_tag[n];
         while (avctag->id != AV_CODEC_ID_NONE) {
-            if (ff_toupper4(avctag->tag) == ff_toupper4(st->codecpar->codec_tag)) {
+            if (ff_toupper4(avctag->tag) == uppercase_tag) {
                 id = avctag->id;
                 if (id == st->codecpar->codec_id)
                     return 1;
--- a/third_party/ffmpeg/libavformat/mxfdec.c
+++ b/third_party/ffmpeg/libavformat/mxfdec.c
@@ -521,7 +521,7 @@
     int did, sdid, data_length;
     int i, ret;
 
-    if (count != 1)
+    if (count > 1)
         av_log(s, AV_LOG_WARNING, "unsupported multiple ANC packets (%d) per KLV packet\n", count);
 
     for (i = 0; i < count; i++) {
@@ -3737,7 +3737,7 @@
 
         PRINT_KEY(s, "read header", klv.key);
         av_log(s, AV_LOG_TRACE, "size %"PRIu64" offset %#"PRIx64"\n", klv.length, klv.offset);
-        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||
+        if (mxf_match_uid(klv.key, mxf_encrypted_triplet_key, sizeof(mxf_encrypted_triplet_key)) ||
             IS_KLV_KEY(klv.key, mxf_essence_element_key) ||
             IS_KLV_KEY(klv.key, mxf_canopus_essence_element_key) ||
             IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||
@@ -3983,7 +3983,7 @@
             pos = klv.next_klv - klv.length;
             PRINT_KEY(s, "read packet", klv.key);
             av_log(s, AV_LOG_TRACE, "size %"PRIu64" offset %#"PRIx64"\n", klv.length, klv.offset);
-            if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key)) {
+            if (mxf_match_uid(klv.key, mxf_encrypted_triplet_key, sizeof(mxf_encrypted_triplet_key))) {
                 ret = mxf_decrypt_triplet(s, pkt, &klv);
                 if (ret < 0) {
                     av_log(s, AV_LOG_ERROR, "invalid encoded triplet\n");
--- a/third_party/ffmpeg/libavformat/mxfenc.c
+++ b/third_party/ffmpeg/libavformat/mxfenc.c
@@ -47,6 +47,7 @@
 #include "libavutil/mastering_display_metadata.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/time_internal.h"
+#include "libavcodec/avcodec.h"
 #include "libavcodec/golomb.h"
 #include "libavcodec/h264.h"
 #include "libavcodec/packet_internal.h"
--- a/third_party/ffmpeg/libavformat/nutdec.c
+++ b/third_party/ffmpeg/libavformat/nutdec.c
@@ -245,6 +245,11 @@
     for (i = 0; i < 256;) {
         int tmp_flags  = ffio_read_varlen(bc);
         int tmp_fields = ffio_read_varlen(bc);
+        if (tmp_fields < 0) {
+            av_log(s, AV_LOG_ERROR, "fields %d is invalid\n", tmp_fields);
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
 
         if (tmp_fields > 0)
             tmp_pts = get_s(bc);
@@ -1127,7 +1132,6 @@
         }
         sm_size = avio_tell(bc) - pkt->pos;
         size      -= sm_size;
-        pkt->size -= sm_size;
     }
 
     ret = avio_read(bc, pkt->data + nut->header_len[header_idx], size);
--- a/third_party/ffmpeg/libavformat/oggparseflac.c
+++ b/third_party/ffmpeg/libavformat/oggparseflac.c
@@ -19,6 +19,7 @@
  */
 
 #include <stdlib.h>
+#include "libavcodec/avcodec.h"
 #include "libavcodec/get_bits.h"
 #include "libavcodec/flac.h"
 #include "avformat.h"
--- a/third_party/ffmpeg/libavformat/rawdec.c
+++ b/third_party/ffmpeg/libavformat/rawdec.c
@@ -24,12 +24,10 @@
 
 #include "avformat.h"
 #include "internal.h"
-#include "avio_internal.h"
 #include "rawdec.h"
 #include "libavutil/opt.h"
-#include "libavutil/parseutils.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/intreadwrite.h"
+
+#include "libavcodec/avcodec.h"
 
 #define RAW_PACKET_SIZE 1024
 
--- a/third_party/ffmpeg/libavformat/riff.c
+++ b/third_party/ffmpeg/libavformat/riff.c
@@ -499,6 +499,8 @@
     { AV_CODEC_ID_MVHA,         MKTAG('M', 'V', 'H', 'A') },
     { AV_CODEC_ID_MV30,         MKTAG('M', 'V', '3', '0') },
     { AV_CODEC_ID_NOTCHLC,      MKTAG('n', 'l', 'c', '1') },
+    { AV_CODEC_ID_VQC,          MKTAG('V', 'Q', 'C', '1') },
+    { AV_CODEC_ID_VQC,          MKTAG('V', 'Q', 'C', '2') },
     { AV_CODEC_ID_NONE,         0 }
 };
 
@@ -558,6 +560,7 @@
     { AV_CODEC_ID_WMALOSSLESS,     0x0163 },
     { AV_CODEC_ID_XMA1,            0x0165 },
     { AV_CODEC_ID_XMA2,            0x0166 },
+    { AV_CODEC_ID_FTR,             0x0180 },
     { AV_CODEC_ID_ADPCM_CT,        0x0200 },
     { AV_CODEC_ID_DVAUDIO,         0x0215 },
     { AV_CODEC_ID_DVAUDIO,         0x0216 },
@@ -584,8 +587,10 @@
     { AV_CODEC_ID_PCM_MULAW,       0x6c75 },
     { AV_CODEC_ID_AAC,             0x706d },
     { AV_CODEC_ID_AAC,             0x4143 },
+    { AV_CODEC_ID_FTR,             0x4180 },
     { AV_CODEC_ID_XAN_DPCM,        0x594a },
     { AV_CODEC_ID_G729,            0x729A },
+    { AV_CODEC_ID_FTR,             0x8180 },
     { AV_CODEC_ID_G723_1,          0xA100 }, /* Comverse Infosys Ltd. G723 1 */
     { AV_CODEC_ID_AAC,             0xA106 },
     { AV_CODEC_ID_SPEEX,           0xA109 },
--- a/third_party/ffmpeg/libavformat/riffenc.c
+++ b/third_party/ffmpeg/libavformat/riffenc.c
@@ -23,7 +23,6 @@
 #include "libavutil/dict.h"
 #include "libavutil/log.h"
 #include "libavutil/mathematics.h"
-#include "libavcodec/avcodec.h"
 #include "libavcodec/bytestream.h"
 #include "avformat.h"
 #include "avio_internal.h"
--- a/third_party/ffmpeg/libavformat/rmdec.c
+++ b/third_party/ffmpeg/libavformat/rmdec.c
@@ -563,6 +563,8 @@
     }
 
     tag_size = avio_rb32(pb);
+    if (tag_size < 0)
+        return AVERROR_INVALIDDATA;
     avio_skip(pb, tag_size - 8);
 
     for(;;) {
--- a/third_party/ffmpeg/libavformat/rpl.c
+++ b/third_party/ffmpeg/libavformat/rpl.c
@@ -279,7 +279,7 @@
     error |= read_line(pb, line, sizeof(line));  // size of "helpful" sprite
     if (vst) {
         error |= read_line(pb, line, sizeof(line));  // offset to key frame list
-        vst->duration = number_of_chunks * rpl->frames_per_chunk;
+        vst->duration = number_of_chunks * (int64_t)rpl->frames_per_chunk;
     }
 
     // Read the index
--- a/third_party/ffmpeg/libavformat/rtsp.c
+++ b/third_party/ffmpeg/libavformat/rtsp.c
@@ -32,6 +32,7 @@
 #include "libavutil/dict.h"
 #include "libavutil/opt.h"
 #include "libavutil/time.h"
+#include "libavcodec/codec_desc.h"
 #include "avformat.h"
 #include "avio_internal.h"
 
--- a/third_party/ffmpeg/libavformat/sbgdec.c
+++ b/third_party/ffmpeg/libavformat/sbgdec.c
@@ -1317,6 +1317,8 @@
 
     /* Pseudo event before the first one */
     ev0 = s->events[s->nb_events - 1];
+    if (av_sat_sub64(ev0.ts_int, period) != (uint64_t)ev0.ts_int - period)
+        return AVERROR_INVALIDDATA;
     ev0.ts_int   -= period;
     ev0.ts_trans -= period;
     ev0.ts_next  -= period;
@@ -1478,7 +1480,7 @@
     int ret;
 
     ts = ffstream(avf->streams[0])->cur_dts;
-    end_ts = ts + avf->streams[0]->codecpar->frame_size;
+    end_ts = av_sat_add64(ts, avf->streams[0]->codecpar->frame_size);
     if (avf->streams[0]->duration != AV_NOPTS_VALUE)
         end_ts = FFMIN(avf->streams[0]->start_time + avf->streams[0]->duration,
                        end_ts);
--- a/third_party/ffmpeg/libavformat/sdsdec.c
+++ b/third_party/ffmpeg/libavformat/sdsdec.c
@@ -112,7 +112,7 @@
     st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
     st->codecpar->ch_layout.nb_channels = 1;
     st->codecpar->sample_rate = sample_period ? 1000000000 / sample_period : 16000;
-    st->duration = (avio_size(pb) - 21) / (127) * s->size / 4;
+    st->duration = av_rescale((avio_size(pb) - 21) / 127,  s->size, 4);
 
     avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);
 
--- a/third_party/ffmpeg/libavformat/seek.c
+++ b/third_party/ffmpeg/libavformat/seek.c
@@ -25,6 +25,8 @@
 #include "libavutil/mathematics.h"
 #include "libavutil/timestamp.h"
 
+#include "libavcodec/avcodec.h"
+
 #include "avformat.h"
 #include "avio_internal.h"
 #include "demux.h"
--- a/third_party/ffmpeg/libavformat/spdifdec.c
+++ b/third_party/ffmpeg/libavformat/spdifdec.c
@@ -226,7 +226,7 @@
     if (!s->bit_rate && s->streams[0]->codecpar->sample_rate)
         /* stream bitrate matches 16-bit stereo PCM bitrate for currently
            supported codecs */
-        s->bit_rate = 2 * 16 * s->streams[0]->codecpar->sample_rate;
+        s->bit_rate = 2 * 16LL * s->streams[0]->codecpar->sample_rate;
 
     return 0;
 }
--- a/third_party/ffmpeg/libavformat/udp.c
+++ b/third_party/ffmpeg/libavformat/udp.c
@@ -487,6 +487,8 @@
     UDPContext *s = h->priv_data;
     int old_cancelstate;
 
+    ff_thread_setname("udp-rx");
+
     pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &old_cancelstate);
     pthread_mutex_lock(&s->mutex);
     if (ff_socket_nonblock(s->udp_fd, 0) < 0) {
@@ -552,6 +554,8 @@
     int64_t burst_interval = s->bitrate ? (s->burst_bits * 1000000 / s->bitrate) : 0;
     int64_t max_delay = s->bitrate ?  ((int64_t)h->max_packet_size * 8 * 1000000 / s->bitrate + 1) : 0;
 
+    ff_thread_setname("udp-tx");
+
     pthread_mutex_lock(&s->mutex);
 
     if (ff_socket_nonblock(s->udp_fd, 0) < 0) {
--- a/third_party/ffmpeg/libavformat/version.h
+++ b/third_party/ffmpeg/libavformat/version.h
@@ -31,8 +31,8 @@
 
 #include "version_major.h"
 
-#define LIBAVFORMAT_VERSION_MINOR  32
-#define LIBAVFORMAT_VERSION_MICRO 100
+#define LIBAVFORMAT_VERSION_MINOR  34
+#define LIBAVFORMAT_VERSION_MICRO 101
 
 #define LIBAVFORMAT_VERSION_INT AV_VERSION_INT(LIBAVFORMAT_VERSION_MAJOR, \
                                                LIBAVFORMAT_VERSION_MINOR, \
--- a/third_party/ffmpeg/libavformat/version_major.h
+++ b/third_party/ffmpeg/libavformat/version_major.h
@@ -47,6 +47,7 @@
 #define FF_HLS_TS_OPTIONS               (LIBAVFORMAT_VERSION_MAJOR < 60)
 #define FF_API_AVSTREAM_CLASS           (LIBAVFORMAT_VERSION_MAJOR > 59)
 #define FF_API_GET_END_PTS              (LIBAVFORMAT_VERSION_MAJOR < 60)
+#define FF_API_AVIODIRCONTEXT           (LIBAVFORMAT_VERSION_MAJOR < 60)
 
 
 #define FF_API_R_FRAME_RATE            1
--- a/third_party/ffmpeg/libavformat/vividas.c
+++ b/third_party/ffmpeg/libavformat/vividas.c
@@ -683,6 +683,7 @@
 
     if (viv->sb_entries[viv->current_sb_entry].flag == 0) {
         uint64_t v_size = ffio_read_varlen(pb);
+        int last = 0, last_start;
 
         if (!viv->num_audio)
             return AVERROR_INVALIDDATA;
@@ -706,12 +707,18 @@
 
             if (i > 0 && start == 0)
                 break;
+            if (start < last)
+                return AVERROR_INVALIDDATA;
 
             viv->n_audio_subpackets = i + 1;
+            last =
             viv->audio_subpackets[i].start = start;
             viv->audio_subpackets[i].pcm_bytes = pcm_bytes;
         }
+        last_start =
         viv->audio_subpackets[viv->n_audio_subpackets].start = (int)(off - avio_tell(pb));
+        if (last_start < last)
+            return AVERROR_INVALIDDATA;
         viv->current_audio_subpacket = 0;
 
     } else {
--- a/third_party/ffmpeg/libavformat/xwma.c
+++ b/third_party/ffmpeg/libavformat/xwma.c
@@ -278,7 +278,7 @@
          * the total duration using the average bits per sample and the
          * total data length.
          */
-        st->duration = (size<<3) * st->codecpar->sample_rate / st->codecpar->bit_rate;
+        st->duration = av_rescale((size<<3), st->codecpar->sample_rate, st->codecpar->bit_rate);
     }
 
 fail:
--- a/third_party/ffmpeg/libavformat/yuv4mpegdec.c
+++ b/third_party/ffmpeg/libavformat/yuv4mpegdec.c
@@ -27,7 +27,7 @@
 #include "yuv4mpeg.h"
 
 /* Header size increased to allow room for optional flags */
-#define MAX_YUV4_HEADER 96
+#define MAX_YUV4_HEADER 128
 #define MAX_FRAME_HEADER 80
 
 static int yuv4_read_header(AVFormatContext *s)
--- a/third_party/ffmpeg/libavutil/aarch64/tx_float_neon.S
+++ b/third_party/ffmpeg/libavutil/aarch64/tx_float_neon.S
@@ -866,10 +866,10 @@
 
 .macro FFT32_FN name, no_perm
 function ff_tx_fft32_\name\()_neon, export=1
-        stp             d8,  d9,  [sp, #-16]
-        stp             d10, d11, [sp, #-32]
-        stp             d12, d13, [sp, #-48]
-        stp             d14, d15, [sp, #-64]
+        stp             d14, d15, [sp, #-16*4]!
+        stp             d8,  d9,  [sp, #16*3]
+        stp             d10, d11, [sp, #16*2]
+        stp             d12, d13, [sp, #16]
 
         LOAD_SUBADD
         SETUP_SR_RECOMB 32, x7, x8, x9
@@ -911,10 +911,10 @@
         zip2            v31.2d, v11.2d, v15.2d
         st1             { v28.4s, v29.4s, v30.4s, v31.4s }, [x1]
 
-        ldp             d14, d15, [sp, #-64]
-        ldp             d12, d13, [sp, #-48]
-        ldp             d10, d11, [sp, #-32]
-        ldp             d8,  d9,  [sp, #-16]
+        ldp             d12, d13, [sp, #16]
+        ldp             d10, d11, [sp, #16*2]
+        ldp             d8,  d9,  [sp, #16*3]
+        ldp             d14, d15, [sp], #16*4
 
         ret
 endfunc
@@ -966,12 +966,12 @@
 
 .macro FFT_SPLIT_RADIX_FN name, no_perm
 function ff_tx_fft_sr_\name\()_neon, export=1
-        stp             d8,  d9,  [sp, #-16]!
-        stp             d10, d11, [sp, #-16]!
-        stp             d12, d13, [sp, #-16]!
-        stp             d14, d15, [sp, #-16]!
-        stp             x19, x20, [sp, #-16]!
-        stp             x21, x22, [sp, #-16]!
+        stp             x21, x22, [sp, #-16*6]!
+        stp             d8,  d9,  [sp, #16*5]
+        stp             d10, d11, [sp, #16*4]
+        stp             d12, d13, [sp, #16*3]
+        stp             d14, d15, [sp, #16*2]
+        stp             x19, x20, [sp, #16]
 
         ldr             w19, [x0, #0] // global target
         mov             w20, w19      // local length
@@ -1185,12 +1185,12 @@
         subs            w19, w19, #32*4
         b.gt            0b
 
-        ldp             x21, x22, [sp], #16
-        ldp             x19, x20, [sp], #16
-        ldp             d14, d15, [sp], #16
-        ldp             d12, d13, [sp], #16
-        ldp             d10, d11, [sp], #16
-        ldp             d8,  d9,  [sp], #16
+        ldp             x19, x20, [sp, #16]
+        ldp             d14, d15, [sp, #16*2]
+        ldp             d12, d13, [sp, #16*3]
+        ldp             d10, d11, [sp, #16*4]
+        ldp             d8,  d9,  [sp, #16*5]
+        ldp             x21, x22, [sp], #16*6
 
         ret
 
@@ -1279,12 +1279,12 @@
         zip2            v7.2d, v15.2d, v23.2d
         st1             {  v4.4s,  v5.4s,  v6.4s,  v7.4s }, [x15]
 
-        ldp             x21, x22, [sp], #16
-        ldp             x19, x20, [sp], #16
-        ldp             d14, d15, [sp], #16
-        ldp             d12, d13, [sp], #16
-        ldp             d10, d11, [sp], #16
-        ldp             d8,  d9,  [sp], #16
+        ldp             x19, x20, [sp, #16]
+        ldp             d14, d15, [sp, #16*2]
+        ldp             d12, d13, [sp, #16*3]
+        ldp             d10, d11, [sp, #16*4]
+        ldp             d8,  d9,  [sp, #16*5]
+        ldp             x21, x22, [sp], #16*6
 
         ret
 endfunc
--- a/third_party/ffmpeg/libavutil/aes.c
+++ b/third_party/ffmpeg/libavutil/aes.c
@@ -80,25 +80,27 @@
 
 static void subshift(av_aes_block s0[2], int s, const uint8_t *box)
 {
-    av_aes_block *s1 = (av_aes_block *) (s0[0].u8 - s);
-    av_aes_block *s3 = (av_aes_block *) (s0[0].u8 + s);
+    unsigned char *s1_dst = (unsigned char*)s0[0].u8 + 3 - s;
+    const unsigned char *s1_src = s1_dst + sizeof(*s0);
+    unsigned char *s3_dst = (unsigned char*)s0[0].u8 + s + 1;
+    const unsigned char *s3_src = s3_dst + sizeof(*s0);
 
     s0[0].u8[ 0] = box[s0[1].u8[ 0]];
     s0[0].u8[ 4] = box[s0[1].u8[ 4]];
     s0[0].u8[ 8] = box[s0[1].u8[ 8]];
     s0[0].u8[12] = box[s0[1].u8[12]];
-    s1[0].u8[ 3] = box[s1[1].u8[ 7]];
-    s1[0].u8[ 7] = box[s1[1].u8[11]];
-    s1[0].u8[11] = box[s1[1].u8[15]];
-    s1[0].u8[15] = box[s1[1].u8[ 3]];
+    s1_dst[ 0] = box[s1_src[ 4]];
+    s1_dst[ 4] = box[s1_src[ 8]];
+    s1_dst[ 8] = box[s1_src[12]];
+    s1_dst[12] = box[s1_src[ 0]];
     s0[0].u8[ 2] = box[s0[1].u8[10]];
     s0[0].u8[10] = box[s0[1].u8[ 2]];
     s0[0].u8[ 6] = box[s0[1].u8[14]];
     s0[0].u8[14] = box[s0[1].u8[ 6]];
-    s3[0].u8[ 1] = box[s3[1].u8[13]];
-    s3[0].u8[13] = box[s3[1].u8[ 9]];
-    s3[0].u8[ 9] = box[s3[1].u8[ 5]];
-    s3[0].u8[ 5] = box[s3[1].u8[ 1]];
+    s3_dst[ 0] = box[s3_src[12]];
+    s3_dst[12] = box[s3_src[ 8]];
+    s3_dst[ 8] = box[s3_src[ 4]];
+    s3_dst[ 4] = box[s3_src[ 0]];
 }
 
 static inline int mix_core(uint32_t multbl[][256], int a, int b, int c, int d)
@@ -251,7 +253,7 @@
                     tk[j][i] ^= sbox[tk[j - 1][i]];
         }
 
-        memcpy(a->round_key[0].u8 + t, tk, KC * 4);
+        memcpy((unsigned char*)a->round_key + t, tk, KC * 4);
     }
 
     if (decrypt) {
--- a/third_party/ffmpeg/libavutil/aes.h
+++ b/third_party/ffmpeg/libavutil/aes.h
@@ -42,6 +42,9 @@
 
 /**
  * Initialize an AVAES context.
+ *
+ * @param a The AVAES context
+ * @param key Pointer to the key
  * @param key_bits 128, 192 or 256
  * @param decrypt 0 for encryption, 1 for decryption
  */
@@ -49,9 +52,11 @@
 
 /**
  * Encrypt or decrypt a buffer using a previously initialized context.
- * @param count number of 16 byte blocks
+ *
+ * @param a The AVAES context
  * @param dst destination array, can be equal to src
  * @param src source array, can be equal to dst
+ * @param count number of 16 byte blocks
  * @param iv initialization vector for CBC mode, if NULL then ECB will be used
  * @param decrypt 0 for encryption, 1 for decryption
  */
--- a/third_party/ffmpeg/libavutil/aes_ctr.h
+++ b/third_party/ffmpeg/libavutil/aes_ctr.h
@@ -22,6 +22,12 @@
 #ifndef AVUTIL_AES_CTR_H
 #define AVUTIL_AES_CTR_H
 
+/**
+ * @defgroup lavu_aes_ctr AES-CTR
+ * @ingroup lavu_crypto
+ * @{
+ */
+
 #include <stdint.h>
 
 #include "attributes.h"
@@ -38,17 +44,23 @@
 
 /**
  * Initialize an AVAESCTR context.
+ *
+ * @param a The AVAESCTR context to initialize
  * @param key encryption key, must have a length of AES_CTR_KEY_SIZE
  */
 int av_aes_ctr_init(struct AVAESCTR *a, const uint8_t *key);
 
 /**
  * Release an AVAESCTR context.
+ *
+ * @param a The AVAESCTR context
  */
 void av_aes_ctr_free(struct AVAESCTR *a);
 
 /**
  * Process a buffer using a previously initialized context.
+ *
+ * @param a The AVAESCTR context
  * @param dst destination array, can be equal to src
  * @param src source array, can be equal to dst
  * @param size the size of src and dst
--- a/third_party/ffmpeg/libavutil/attributes_internal.h
+++ b/third_party/ffmpeg/libavutil/attributes_internal.h
@@ -23,8 +23,12 @@
 
 #if (AV_GCC_VERSION_AT_LEAST(4,0) || defined(__clang__)) && (defined(__ELF__) || defined(__MACH__))
 #    define attribute_visibility_hidden __attribute__((visibility("hidden")))
+#    define FF_VISIBILITY_PUSH_HIDDEN   _Pragma("GCC visibility push(hidden)")
+#    define FF_VISIBILITY_POP_HIDDEN    _Pragma("GCC visibility pop")
 #else
 #    define attribute_visibility_hidden
+#    define FF_VISIBILITY_PUSH_HIDDEN
+#    define FF_VISIBILITY_POP_HIDDEN
 #endif
 
 #endif /* AVUTIL_ATTRIBUTES_INTERNAL_H */
--- a/third_party/ffmpeg/libavutil/avstring.h
+++ b/third_party/ffmpeg/libavutil/avstring.h
@@ -135,6 +135,7 @@
 /**
  * Get the count of continuous non zero chars starting from the beginning.
  *
+ * @param s   the string whose length to count
  * @param len maximum number of characters to check in the string, that
  *            is the maximum value which is returned by the function
  */
--- a/third_party/ffmpeg/libavutil/bprint.h
+++ b/third_party/ffmpeg/libavutil/bprint.h
@@ -18,6 +18,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+/**
+ * @file
+ * @ingroup lavu_avbprint
+ * AVBPrint public header
+ */
+
 #ifndef AVUTIL_BPRINT_H
 #define AVUTIL_BPRINT_H
 
@@ -27,6 +33,14 @@
 #include "avstring.h"
 
 /**
+ * @defgroup lavu_avbprint AVBPrint
+ * @ingroup lavu_data
+ *
+ * A buffer to print data progressively
+ * @{
+ */
+
+/**
  * Define a structure with extra padding to a fixed size
  * This helps ensuring binary compatibility with future versions.
  */
@@ -48,14 +62,14 @@
  * Small buffers are kept in the structure itself, and thus require no
  * memory allocation at all (unless the contents of the buffer is needed
  * after the structure goes out of scope). This is almost as lightweight as
- * declaring a local "char buf[512]".
+ * declaring a local `char buf[512]`.
  *
  * The length of the string can go beyond the allocated size: the buffer is
  * then truncated, but the functions still keep account of the actual total
  * length.
  *
- * In other words, buf->len can be greater than buf->size and records the
- * total length of what would have been to the buffer if there had been
+ * In other words, AVBPrint.len can be greater than AVBPrint.size and records
+ * the total length of what would have been to the buffer if there had been
  * enough memory.
  *
  * Append operations do not need to be tested for failure: if a memory
@@ -63,20 +77,17 @@
  * is still updated. This situation can be tested with
  * av_bprint_is_complete().
  *
- * The size_max field determines several possible behaviours:
- *
- * size_max = -1 (= UINT_MAX) or any large value will let the buffer be
- * reallocated as necessary, with an amortized linear cost.
- *
- * size_max = 0 prevents writing anything to the buffer: only the total
- * length is computed. The write operations can then possibly be repeated in
- * a buffer with exactly the necessary size
- * (using size_init = size_max = len + 1).
- *
- * size_max = 1 is automatically replaced by the exact size available in the
- * structure itself, thus ensuring no dynamic memory allocation. The
- * internal buffer is large enough to hold a reasonable paragraph of text,
- * such as the current paragraph.
+ * The AVBPrint.size_max field determines several possible behaviours:
+ * - `size_max = -1` (= `UINT_MAX`) or any large value will let the buffer be
+ *   reallocated as necessary, with an amortized linear cost.
+ * - `size_max = 0` prevents writing anything to the buffer: only the total
+ *   length is computed. The write operations can then possibly be repeated in
+ *   a buffer with exactly the necessary size
+ *   (using `size_init = size_max = len + 1`).
+ * - `size_max = 1` is automatically replaced by the exact size available in the
+ *   structure itself, thus ensuring no dynamic memory allocation. The
+ *   internal buffer is large enough to hold a reasonable paragraph of text,
+ *   such as the current paragraph.
  */
 
 FF_PAD_STRUCTURE(AVBPrint, 1024,
@@ -88,12 +99,31 @@
 )
 
 /**
+ * @name Max size special values
  * Convenience macros for special values for av_bprint_init() size_max
  * parameter.
+ * @{
+ */
+
+/**
+ * Buffer will be reallocated as necessary, with an amortized linear cost.
  */
 #define AV_BPRINT_SIZE_UNLIMITED  ((unsigned)-1)
+/**
+ * Use the exact size available in the AVBPrint structure itself.
+ *
+ * Thus ensuring no dynamic memory allocation. The internal buffer is large
+ * enough to hold a reasonable paragraph of text, such as the current paragraph.
+ */
 #define AV_BPRINT_SIZE_AUTOMATIC  1
+/**
+ * Do not write anything to the buffer, only calculate the total length.
+ *
+ * The write operations can then possibly be repeated in a buffer with
+ * exactly the necessary size (using `size_init = size_max = AVBPrint.len + 1`).
+ */
 #define AV_BPRINT_SIZE_COUNT_ONLY 0
+/** @} */
 
 /**
  * Init a print buffer.
@@ -101,12 +131,12 @@
  * @param buf        buffer to init
  * @param size_init  initial size (including the final 0)
  * @param size_max   maximum size;
- *                   0 means do not write anything, just count the length;
- *                   1 is replaced by the maximum value for automatic storage;
- *                   any large value means that the internal buffer will be
- *                   reallocated as needed up to that limit; -1 is converted to
- *                   UINT_MAX, the largest limit possible.
- *                   Check also AV_BPRINT_SIZE_* macros.
+ *                   - `0` means do not write anything, just count the length
+ *                   - `1` is replaced by the maximum value for automatic storage
+ *                       any large value means that the internal buffer will be
+ *                       reallocated as needed up to that limit
+ *                   - `-1` is converted to `UINT_MAX`, the largest limit possible.
+ *                   Check also `AV_BPRINT_SIZE_*` macros.
  */
 void av_bprint_init(AVBPrint *buf, unsigned size_init, unsigned size_max);
 
@@ -216,4 +246,6 @@
 void av_bprint_escape(AVBPrint *dstbuf, const char *src, const char *special_chars,
                       enum AVEscapeMode mode, int flags);
 
+/** @} */
+
 #endif /* AVUTIL_BPRINT_H */
--- a/third_party/ffmpeg/libavutil/camellia.h
+++ b/third_party/ffmpeg/libavutil/camellia.h
@@ -59,7 +59,7 @@
   * @param dst destination array, can be equal to src
   * @param src source array, can be equal to dst
   * @param count number of 16 byte blocks
-  * @paran iv initialization vector for CBC mode, NULL for ECB mode
+  * @param iv initialization vector for CBC mode, NULL for ECB mode
   * @param decrypt 0 for encryption, 1 for decryption
  */
 void av_camellia_crypt(struct AVCAMELLIA *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t* iv, int decrypt);
--- a/third_party/ffmpeg/libavutil/channel_layout.h
+++ b/third_party/ffmpeg/libavutil/channel_layout.h
@@ -30,11 +30,17 @@
 
 /**
  * @file
- * audio channel layout utility functions
+ * @ingroup lavu_audio_channels
+ * Public libavutil channel layout APIs header.
  */
 
+
 /**
- * @addtogroup lavu_audio
+ * @defgroup lavu_audio_channels Audio channels
+ * @ingroup lavu_audio
+ *
+ * Audio channel layout utility functions
+ *
  * @{
  */
 
@@ -84,9 +90,9 @@
      * Range of channels between AV_CHAN_AMBISONIC_BASE and
      * AV_CHAN_AMBISONIC_END represent Ambisonic components using the ACN system.
      *
-     * Given a channel id <i> between AV_CHAN_AMBISONIC_BASE and
-     * AV_CHAN_AMBISONIC_END (inclusive), the ACN index of the channel <n> is
-     * <n> = <i> - AV_CHAN_AMBISONIC_BASE.
+     * Given a channel id `<i>` between AV_CHAN_AMBISONIC_BASE and
+     * AV_CHAN_AMBISONIC_END (inclusive), the ACN index of the channel `<n>` is
+     * `<n> = <i> - AV_CHAN_AMBISONIC_BASE`.
      *
      * @note these values are only used for AV_CHANNEL_ORDER_CUSTOM channel
      * orderings, the AV_CHANNEL_ORDER_AMBISONIC ordering orders the channels
@@ -266,8 +272,11 @@
  * A channel layout here is defined as a set of channels ordered in a specific
  * way (unless the channel order is AV_CHANNEL_ORDER_UNSPEC, in which case an
  * AVChannelLayout carries only the channel count).
+ * All orders may be treated as if they were AV_CHANNEL_ORDER_UNSPEC by
+ * ignoring everything but the channel count, as long as av_channel_layout_check()
+ * considers they are valid.
  *
- * Unlike most structures in Libav, sizeof(AVChannelLayout) is a part of the
+ * Unlike most structures in FFmpeg, sizeof(AVChannelLayout) is a part of the
  * public ABI and may be used by the caller. E.g. it may be allocated on stack
  * or embedded in caller-defined structs.
  *
@@ -290,9 +299,6 @@
 typedef struct AVChannelLayout {
     /**
      * Channel order used in this layout.
-     * Any value not defined in the AVChannelOrder enum in a layout that
-     * av_channel_layout_check() doesn't reject must be treated as if it was
-     * AV_CHANNEL_ORDER_UNSPEC.
      * This is a mandatory field.
      */
     enum AVChannelOrder order;
@@ -353,6 +359,10 @@
 #define AV_CHANNEL_LAYOUT_MASK(nb, m) \
     { .order = AV_CHANNEL_ORDER_NATIVE, .nb_channels = (nb), .u = { .mask = (m) }}
 
+/**
+ * @name Common pre-defined channel layouts
+ * @{
+ */
 #define AV_CHANNEL_LAYOUT_MONO              AV_CHANNEL_LAYOUT_MASK(1,  AV_CH_LAYOUT_MONO)
 #define AV_CHANNEL_LAYOUT_STEREO            AV_CHANNEL_LAYOUT_MASK(2,  AV_CH_LAYOUT_STEREO)
 #define AV_CHANNEL_LAYOUT_2POINT1           AV_CHANNEL_LAYOUT_MASK(3,  AV_CH_LAYOUT_2POINT1)
@@ -384,11 +394,17 @@
 #define AV_CHANNEL_LAYOUT_22POINT2          AV_CHANNEL_LAYOUT_MASK(24, AV_CH_LAYOUT_22POINT2)
 #define AV_CHANNEL_LAYOUT_AMBISONIC_FIRST_ORDER \
     { .order = AV_CHANNEL_ORDER_AMBISONIC, .nb_channels = 4, .u = { .mask = 0 }}
+/** @} */
 
 struct AVBPrint;
 
 #if FF_API_OLD_CHANNEL_LAYOUT
 /**
+ * @name Deprecated Functions
+ * @{
+ */
+
+/**
  * Return a channel layout id that matches name, or 0 if no match is found.
  *
  * name can be one or several of the following notations,
@@ -432,6 +448,8 @@
  *
  * @param buf put here the string containing the channel layout
  * @param buf_size size in bytes of the buffer
+ * @param nb_channels number of channels
+ * @param channel_layout channel layout bitset
  * @deprecated use av_channel_layout_describe()
  */
 attribute_deprecated
@@ -462,6 +480,7 @@
 /**
  * Get the index of a channel in channel_layout.
  *
+ * @param channel_layout channel layout bitset
  * @param channel a channel layout describing exactly one channel which must be
  *                present in channel_layout.
  *
@@ -514,6 +533,9 @@
 attribute_deprecated
 int av_get_standard_channel_layout(unsigned index, uint64_t *layout,
                                    const char **name);
+/**
+ * @}
+ */
 #endif
 
 /**
@@ -522,6 +544,7 @@
  *
  * @param buf pre-allocated buffer where to put the generated string
  * @param buf_size size in bytes of the buffer.
+ * @param channel the AVChannel whose name to get
  * @return amount of bytes needed to hold the output string, or a negative AVERROR
  *         on failure. If the returned value is bigger than buf_size, then the
  *         string was truncated.
@@ -540,6 +563,7 @@
  *
  * @param buf pre-allocated buffer where to put the generated string
  * @param buf_size size in bytes of the buffer.
+ * @param channel the AVChannel whose description to get
  * @return amount of bytes needed to hold the output string, or a negative AVERROR
  *         on failure. If the returned value is bigger than buf_size, then the
  *         string was truncated.
@@ -596,7 +620,7 @@
 /**
  * Get the default channel layout for a given number of channels.
  *
- * @param channel_layout the layout structure to be initialized
+ * @param ch_layout the layout structure to be initialized
  * @param nb_channels number of channels
  */
 void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels);
@@ -661,6 +685,7 @@
  * Get the channel with the given index in a channel layout.
  *
  * @param channel_layout input channel layout
+ * @param idx index of the channel
  * @return channel with the index idx in channel_layout on success or
  *         AV_CHAN_NONE on failure (if idx is not valid or the channel order is
  *         unspecified)
@@ -673,6 +698,7 @@
  * channels are found, only the first match will be returned.
  *
  * @param channel_layout input channel layout
+ * @param channel the channel whose index to obtain
  * @return index of channel in channel_layout on success or a negative number if
  *         channel is not present in channel_layout.
  */
@@ -687,6 +713,7 @@
  * @ref av_channel_from_string().
  *
  * @param channel_layout input channel layout
+ * @param name string describing the channel whose index to obtain
  * @return a channel index described by the given string, or a negative AVERROR
  *         value.
  */
@@ -700,6 +727,7 @@
  * @ref av_channel_from_string().
  *
  * @param channel_layout input channel layout
+ * @param name string describing the channel to obtain
  * @return a channel described by the given string in channel_layout on success
  *         or AV_CHAN_NONE on failure (if the string is not valid or the channel
  *         order is unspecified)
@@ -746,7 +774,6 @@
 
 /**
  * @}
- * @}
  */
 
 #endif /* AVUTIL_CHANNEL_LAYOUT_H */
--- a/third_party/ffmpeg/libavutil/cpu.c
+++ b/third_party/ffmpeg/libavutil/cpu.c
@@ -62,6 +62,8 @@
     return ff_get_cpu_flags_arm();
 #elif ARCH_PPC
     return ff_get_cpu_flags_ppc();
+#elif ARCH_RISCV
+    return ff_get_cpu_flags_riscv();
 #elif ARCH_X86
     return ff_get_cpu_flags_x86();
 #elif ARCH_LOONGARCH
@@ -178,6 +180,15 @@
 #elif ARCH_LOONGARCH
         { "lsx",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_LSX      },    .unit = "flags" },
         { "lasx",     NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_LASX     },    .unit = "flags" },
+#elif ARCH_RISCV
+        { "rvi",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVI      },    .unit = "flags" },
+        { "rvf",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVF      },    .unit = "flags" },
+        { "rvd",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVD      },    .unit = "flags" },
+        { "rvv-i32",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVV_I32 },     .unit = "flags" },
+        { "rvv-f32",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVV_F32 },     .unit = "flags" },
+        { "rvv-i64",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVV_I64 },     .unit = "flags" },
+        { "rvv",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVV_F64 },     .unit = "flags" },
+        { "rvb-basic",NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVB_BASIC },   .unit = "flags" },
 #endif
         { NULL },
     };
--- a/third_party/ffmpeg/libavutil/cpu.h
+++ b/third_party/ffmpeg/libavutil/cpu.h
@@ -78,6 +78,16 @@
 #define AV_CPU_FLAG_LSX          (1 << 0)
 #define AV_CPU_FLAG_LASX         (1 << 1)
 
+// RISC-V extensions
+#define AV_CPU_FLAG_RVI          (1 << 0) ///< I (full GPR bank)
+#define AV_CPU_FLAG_RVF          (1 << 1) ///< F (single precision FP)
+#define AV_CPU_FLAG_RVD          (1 << 2) ///< D (double precision FP)
+#define AV_CPU_FLAG_RVV_I32      (1 << 3) ///< Vectors of 8/16/32-bit int's */
+#define AV_CPU_FLAG_RVV_F32      (1 << 4) ///< Vectors of float's */
+#define AV_CPU_FLAG_RVV_I64      (1 << 5) ///< Vectors of 64-bit int's */
+#define AV_CPU_FLAG_RVV_F64      (1 << 6) ///< Vectors of double's
+#define AV_CPU_FLAG_RVB_BASIC    (1 << 7) ///< Basic bit-manipulations
+
 /**
  * Return the flags which specify extensions supported by the CPU.
  * The returned value is affected by av_force_cpu_flags() if that was used
--- a/third_party/ffmpeg/libavutil/cpu_internal.h
+++ b/third_party/ffmpeg/libavutil/cpu_internal.h
@@ -48,6 +48,7 @@
 int ff_get_cpu_flags_aarch64(void);
 int ff_get_cpu_flags_arm(void);
 int ff_get_cpu_flags_ppc(void);
+int ff_get_cpu_flags_riscv(void);
 int ff_get_cpu_flags_x86(void);
 int ff_get_cpu_flags_loongarch(void);
 
--- a/third_party/ffmpeg/libavutil/crc.h
+++ b/third_party/ffmpeg/libavutil/crc.h
@@ -84,7 +84,10 @@
 
 /**
  * Calculate the CRC of a block.
+ * @param ctx initialized AVCRC array (see av_crc_init())
  * @param crc CRC of previous blocks if any or initial value for CRC
+ * @param buffer buffer whose CRC to calculate
+ * @param length length of the buffer
  * @return CRC updated with the data from the given block
  *
  * @see av_crc_init() "le" parameter
--- a/third_party/ffmpeg/libavutil/csp.h
+++ b/third_party/ffmpeg/libavutil/csp.h
@@ -24,9 +24,14 @@
 #include "rational.h"
 
 /**
- * @file Colorspace value utility functions for libavutil.
+ * @file
+ * Colorspace value utility functions for libavutil.
+ * @ingroup lavu_math_csp
  * @author Ronald S. Bultje <rsbultje@gmail.com>
  * @author Leo Izen <leo.izen@gmail.com>
+ */
+
+/**
  * @defgroup lavu_math_csp Colorspace Utility
  * @ingroup lavu_math
  * @{
--- a/third_party/ffmpeg/libavutil/des.h
+++ b/third_party/ffmpeg/libavutil/des.h
@@ -43,6 +43,8 @@
 /**
  * @brief Initializes an AVDES context.
  *
+ * @param d pointer to a AVDES structure to initialize
+ * @param key pointer to the key to use
  * @param key_bits must be 64 or 192
  * @param decrypt 0 for encryption/CBC-MAC, 1 for decryption
  * @return zero on success, negative value otherwise
@@ -52,9 +54,10 @@
 /**
  * @brief Encrypts / decrypts using the DES algorithm.
  *
- * @param count number of 8 byte blocks
+ * @param d pointer to the AVDES structure
  * @param dst destination array, can be equal to src, must be 8-byte aligned
  * @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL
+ * @param count number of 8 byte blocks
  * @param iv initialization vector for CBC mode, if NULL then ECB will be used,
  *           must be 8-byte aligned
  * @param decrypt 0 for encryption, 1 for decryption
@@ -64,9 +67,10 @@
 /**
  * @brief Calculates CBC-MAC using the DES algorithm.
  *
- * @param count number of 8 byte blocks
+ * @param d pointer to the AVDES structure
  * @param dst destination array, can be equal to src, must be 8-byte aligned
  * @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL
+ * @param count number of 8 byte blocks
  */
 void av_des_mac(struct AVDES *d, uint8_t *dst, const uint8_t *src, int count);
 
--- a/third_party/ffmpeg/libavutil/detection_bbox.h
+++ b/third_party/ffmpeg/libavutil/detection_bbox.h
@@ -93,6 +93,7 @@
  * AVDetectionBBox, and initializes the variables.
  * Can be freed with a normal av_free() call.
  *
+ * @param nb_bboxes number of AVDetectionBBox structures to allocate
  * @param out_size if non-NULL, the size in bytes of the resulting data array is
  * written here.
  */
--- a/third_party/ffmpeg/libavutil/display.h
+++ b/third_party/ffmpeg/libavutil/display.h
@@ -20,6 +20,7 @@
 
 /**
  * @file
+ * @ingroup lavu_video_display
  * Display matrix
  */
 
@@ -29,15 +30,9 @@
 #include <stdint.h>
 
 /**
- * @addtogroup lavu_video
- * @{
- *
  * @defgroup lavu_video_display Display transformation matrix functions
- * @{
- */
-
-/**
- * @addtogroup lavu_video_display
+ * @ingroup lavu_video
+ *
  * The display transformation matrix specifies an affine transformation that
  * should be applied to video frames for correct presentation. It is compatible
  * with the matrices stored in the ISO/IEC 14496-12 container format.
@@ -71,6 +66,8 @@
  *   q' = (b * p + d * q + y) / z;
  *   z  =  u * p + v * q + w
  * @endcode
+ *
+ * @{
  */
 
 /**
@@ -90,8 +87,8 @@
  * Initialize a transformation matrix describing a pure clockwise
  * rotation by the specified angle (in degrees).
  *
- * @param matrix an allocated transformation matrix (will be fully overwritten
- *               by this function)
+ * @param[out] matrix a transformation matrix (will be fully overwritten
+ *                    by this function)
  * @param angle rotation angle in degrees.
  */
 void av_display_rotation_set(int32_t matrix[9], double angle);
@@ -99,7 +96,7 @@
 /**
  * Flip the input matrix horizontally and/or vertically.
  *
- * @param matrix an allocated transformation matrix
+ * @param[in,out] matrix a transformation matrix
  * @param hflip whether the matrix should be flipped horizontally
  * @param vflip whether the matrix should be flipped vertically
  */
@@ -107,7 +104,6 @@
 
 /**
  * @}
- * @}
  */
 
 #endif /* AVUTIL_DISPLAY_H */
--- a/third_party/ffmpeg/libavutil/eval.h
+++ b/third_party/ffmpeg/libavutil/eval.h
@@ -42,6 +42,7 @@
  * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
  * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
  * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
+ * @param log_offset log level offset, can be used to silence error messages
  * @param log_ctx parent logging context
  * @return >= 0 in case of success, a negative value corresponding to an
  * AVERROR code otherwise
@@ -65,6 +66,7 @@
  * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
  * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
  * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
+ * @param log_offset log level offset, can be used to silence error messages
  * @param log_ctx parent logging context
  * @return >= 0 in case of success, a negative value corresponding to an
  * AVERROR code otherwise
@@ -78,6 +80,7 @@
 /**
  * Evaluate a previously parsed expression.
  *
+ * @param e the AVExpr to evaluate
  * @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names
  * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
  * @return the value of the expression
@@ -87,6 +90,7 @@
 /**
  * Track the presence of variables and their number of occurrences in a parsed expression
  *
+ * @param e the AVExpr to track variables in
  * @param counter a zero-initialized array where the count of each variable will be stored
  * @param size size of array
  * @return 0 on success, a negative value indicates that no expression or array was passed
@@ -98,6 +102,7 @@
  * Track the presence of user provided functions and their number of occurrences
  * in a parsed expression.
  *
+ * @param e the AVExpr to track user provided functions in
  * @param counter a zero-initialized array where the count of each function will be stored
  *                if you passed 5 functions with 2 arguments to av_expr_parse()
  *                then for arg=2 this will use upto 5 entries.
--- a/third_party/ffmpeg/libavutil/file.h
+++ b/third_party/ffmpeg/libavutil/file.h
@@ -39,6 +39,9 @@
  * case *bufptr will be set to NULL and *size will be set to 0.
  * The returned buffer must be released with av_file_unmap().
  *
+ * @param filename path to the file
+ * @param[out] bufptr pointee is set to the mapped or allocated buffer
+ * @param[out] size pointee is set to the size in bytes of the buffer
  * @param log_offset loglevel offset used for logging
  * @param log_ctx context used for logging
  * @return a non negative number in case of success, a negative value
@@ -51,6 +54,7 @@
 /**
  * Unmap or free the buffer bufptr created by av_file_map().
  *
+ * @param bufptr the buffer previously created with av_file_map()
  * @param size size in bytes of bufptr, must be the same as returned
  * by av_file_map()
  */
--- a/third_party/ffmpeg/libavutil/fixed_dsp.c
+++ b/third_party/ffmpeg/libavutil/fixed_dsp.c
@@ -135,7 +135,7 @@
     return (int)(p >> 31);
 }
 
-static void butterflies_fixed_c(int *v1s, int *v2, int len)
+static void butterflies_fixed_c(int *av_restrict v1s, int *av_restrict v2, int len)
 {
     int i;
     unsigned int *v1 = v1s;
@@ -162,7 +162,9 @@
     fdsp->butterflies_fixed = butterflies_fixed_c;
     fdsp->scalarproduct_fixed = scalarproduct_fixed_c;
 
-#if ARCH_X86
+#if ARCH_RISCV
+    ff_fixed_dsp_init_riscv(fdsp);
+#elif ARCH_X86
     ff_fixed_dsp_init_x86(fdsp);
 #endif
 
--- a/third_party/ffmpeg/libavutil/fixed_dsp.h
+++ b/third_party/ffmpeg/libavutil/fixed_dsp.h
@@ -161,6 +161,7 @@
  */
 AVFixedDSPContext * avpriv_alloc_fixed_dsp(int strict);
 
+void ff_fixed_dsp_init_riscv(AVFixedDSPContext *fdsp);
 void ff_fixed_dsp_init_x86(AVFixedDSPContext *fdsp);
 
 /**
--- a/third_party/ffmpeg/libavutil/float_dsp.c
+++ b/third_party/ffmpeg/libavutil/float_dsp.c
@@ -156,6 +156,8 @@
     ff_float_dsp_init_arm(fdsp);
 #elif ARCH_PPC
     ff_float_dsp_init_ppc(fdsp, bit_exact);
+#elif ARCH_RISCV
+    ff_float_dsp_init_riscv(fdsp);
 #elif ARCH_X86
     ff_float_dsp_init_x86(fdsp);
 #elif ARCH_MIPS
--- a/third_party/ffmpeg/libavutil/float_dsp.h
+++ b/third_party/ffmpeg/libavutil/float_dsp.h
@@ -205,6 +205,7 @@
 void ff_float_dsp_init_aarch64(AVFloatDSPContext *fdsp);
 void ff_float_dsp_init_arm(AVFloatDSPContext *fdsp);
 void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int strict);
+void ff_float_dsp_init_riscv(AVFloatDSPContext *fdsp);
 void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp);
 void ff_float_dsp_init_mips(AVFloatDSPContext *fdsp);
 
--- a/third_party/ffmpeg/libavutil/frame.h
+++ b/third_party/ffmpeg/libavutil/frame.h
@@ -864,6 +864,7 @@
 /**
  * Get the buffer reference a given data plane is stored in.
  *
+ * @param frame the frame to get the plane's buffer from
  * @param plane index of the data plane of interest in frame->extended_data.
  *
  * @return the buffer reference that contains the plane or NULL if the input
--- a/third_party/ffmpeg/libavutil/hwcontext.h
+++ b/third_party/ffmpeg/libavutil/hwcontext.h
@@ -249,7 +249,7 @@
 /**
  * Iterate over supported device types.
  *
- * @param type AV_HWDEVICE_TYPE_NONE initially, then the previous type
+ * @param prev AV_HWDEVICE_TYPE_NONE initially, then the previous type
  *             returned by this function in subsequent iterations.
  * @return The next usable device type from enum AVHWDeviceType, or
  *         AV_HWDEVICE_TYPE_NONE if there are no more.
@@ -591,6 +591,7 @@
  *
  * @param derived_frame_ctx  On success, a reference to the newly created
  *                           AVHWFramesContext.
+ * @param format             The AVPixelFormat for the derived context.
  * @param derived_device_ctx A reference to the device to create the new
  *                           AVHWFramesContext on.
  * @param source_frame_ctx   A reference to an existing AVHWFramesContext
--- a/third_party/ffmpeg/libavutil/hwcontext_qsv.c
+++ b/third_party/ffmpeg/libavutil/hwcontext_qsv.c
@@ -109,20 +109,39 @@
 static const struct {
     enum AVPixelFormat pix_fmt;
     uint32_t           fourcc;
+    uint16_t           mfx_shift;
 } supported_pixel_formats[] = {
-    { AV_PIX_FMT_NV12, MFX_FOURCC_NV12 },
-    { AV_PIX_FMT_BGRA, MFX_FOURCC_RGB4 },
-    { AV_PIX_FMT_P010, MFX_FOURCC_P010 },
-    { AV_PIX_FMT_PAL8, MFX_FOURCC_P8   },
+    { AV_PIX_FMT_NV12, MFX_FOURCC_NV12, 0 },
+    { AV_PIX_FMT_BGRA, MFX_FOURCC_RGB4, 0 },
+    { AV_PIX_FMT_P010, MFX_FOURCC_P010, 1 },
+    { AV_PIX_FMT_PAL8, MFX_FOURCC_P8,   0 },
 #if CONFIG_VAAPI
     { AV_PIX_FMT_YUYV422,
-                       MFX_FOURCC_YUY2 },
+                       MFX_FOURCC_YUY2, 0 },
     { AV_PIX_FMT_Y210,
-                       MFX_FOURCC_Y210 },
+                       MFX_FOURCC_Y210, 1 },
     // VUYX is used for VAAPI child device,
     // the SDK only delares support for AYUV
     { AV_PIX_FMT_VUYX,
-                       MFX_FOURCC_AYUV },
+                       MFX_FOURCC_AYUV, 0 },
+    // XV30 is used for VAAPI child device,
+    // the SDK only delares support for Y410
+    { AV_PIX_FMT_XV30,
+                       MFX_FOURCC_Y410, 0 },
+#if QSV_VERSION_ATLEAST(1, 31)
+    // P012 is used for VAAPI child device,
+    // the SDK only delares support for P016
+    { AV_PIX_FMT_P012,
+                       MFX_FOURCC_P016, 1 },
+    // Y212 is used for VAAPI child device,
+    // the SDK only delares support for Y216
+    { AV_PIX_FMT_Y212,
+                       MFX_FOURCC_Y216, 1 },
+    // XV36 is used for VAAPI child device,
+    // the SDK only delares support for Y416
+    { AV_PIX_FMT_XV36,
+                       MFX_FOURCC_Y416, 1 },
+#endif
 #endif
 };
 
@@ -170,6 +189,16 @@
     return 0;
 }
 
+static uint16_t qsv_shift_from_pix_fmt(enum AVPixelFormat pix_fmt)
+{
+    for (int i = 0; i < FF_ARRAY_ELEMS(supported_pixel_formats); i++) {
+        if (supported_pixel_formats[i].pix_fmt == pix_fmt)
+            return supported_pixel_formats[i].mfx_shift;
+    }
+
+    return 0;
+}
+
 #if CONFIG_D3D11VA
 static uint32_t qsv_get_d3d11va_bind_flags(int mem_type)
 {
@@ -503,7 +532,7 @@
 
     surf->Info.BitDepthLuma   = desc->comp[0].depth;
     surf->Info.BitDepthChroma = desc->comp[0].depth;
-    surf->Info.Shift          = desc->comp[0].depth > 8;
+    surf->Info.Shift          = qsv_shift_from_pix_fmt(ctx->sw_format);
 
     if (desc->log2_chroma_w && desc->log2_chroma_h)
         surf->Info.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;
@@ -1478,6 +1507,7 @@
     switch (frame->format) {
     case AV_PIX_FMT_NV12:
     case AV_PIX_FMT_P010:
+    case AV_PIX_FMT_P012:
         surface->Data.Y  = frame->data[0];
         surface->Data.UV = frame->data[1];
         break;
@@ -1502,6 +1532,7 @@
         break;
 
     case AV_PIX_FMT_Y210:
+    case AV_PIX_FMT_Y212:
         surface->Data.Y16 = (mfxU16 *)frame->data[0];
         surface->Data.U16 = (mfxU16 *)frame->data[0] + 1;
         surface->Data.V16 = (mfxU16 *)frame->data[0] + 3;
@@ -1514,6 +1545,17 @@
         // use the value from the frame.
         surface->Data.A = frame->data[0] + 3;
         break;
+    case AV_PIX_FMT_XV30:
+        surface->Data.U = frame->data[0];
+        break;
+    case AV_PIX_FMT_XV36:
+        surface->Data.U = frame->data[0];
+        surface->Data.Y = frame->data[0] + 2;
+        surface->Data.V = frame->data[0] + 4;
+        // Only set Data.A to a valid address, the SDK doesn't
+        // use the value from the frame.
+        surface->Data.A = frame->data[0] + 6;
+        break;
 #endif
     default:
         return MFX_ERR_UNSUPPORTED;
--- a/third_party/ffmpeg/libavutil/hwcontext_vaapi.c
+++ b/third_party/ffmpeg/libavutil/hwcontext_vaapi.c
@@ -1511,7 +1511,7 @@
         goto fail_derived;
     }
 
-    av_log(hwfc, AV_LOG_DEBUG, "DRM PRIME fd is %ld.\n",
+    av_log(hwfc, AV_LOG_DEBUG, "DRM PRIME fd is %"PRIdPTR".\n",
            mapping->buffer_info.handle);
 
     mapping->drm_desc.nb_objects = 1;
--- a/third_party/ffmpeg/libavutil/imgutils.h
+++ b/third_party/ffmpeg/libavutil/imgutils.h
@@ -48,6 +48,7 @@
  * component in the plane with the max pixel step.
  * @param max_pixstep_comps an array which is filled with the component
  * for each plane which has the max pixel step. May be NULL.
+ * @param pixdesc the AVPixFmtDescriptor for the image, describing its format
  */
 void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4],
                                 const AVPixFmtDescriptor *pixdesc);
@@ -65,6 +66,8 @@
  * width width.
  *
  * @param linesizes array to be filled with the linesize for each plane
+ * @param pix_fmt the AVPixelFormat of the image
+ * @param width width of the image in pixels
  * @return >= 0 in case of success, a negative error code otherwise
  */
 int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width);
@@ -73,6 +76,8 @@
  * Fill plane sizes for an image with pixel format pix_fmt and height height.
  *
  * @param size the array to be filled with the size of each image plane
+ * @param pix_fmt the AVPixelFormat of the image
+ * @param height height of the image in pixels
  * @param linesizes the array containing the linesize for each
  *        plane, should be filled by av_image_fill_linesizes()
  * @return >= 0 in case of success, a negative error code otherwise
@@ -88,6 +93,8 @@
  * height height.
  *
  * @param data pointers array to be filled with the pointer for each image plane
+ * @param pix_fmt the AVPixelFormat of the image
+ * @param height height of the image in pixels
  * @param ptr the pointer to a buffer which will contain the image
  * @param linesizes the array containing the linesize for each
  * plane, should be filled by av_image_fill_linesizes()
@@ -103,6 +110,11 @@
  * The allocated image buffer has to be freed by using
  * av_freep(&pointers[0]).
  *
+ * @param pointers array to be filled with the pointer for each image plane
+ * @param linesizes the array filled with the linesize for each plane
+ * @param w width of the image in pixels
+ * @param h height of the image in pixels
+ * @param pix_fmt the AVPixelFormat of the image
  * @param align the value to use for buffer size alignment
  * @return the size in bytes required for the image buffer, a negative
  * error code in case of failure
@@ -119,8 +131,11 @@
  * bytewidth must be contained by both absolute values of dst_linesize
  * and src_linesize, otherwise the function behavior is undefined.
  *
+ * @param dst          destination plane to copy to
  * @param dst_linesize linesize for the image plane in dst
+ * @param src          source plane to copy from
  * @param src_linesize linesize for the image plane in src
+ * @param height       height (number of lines) of the plane
  */
 void av_image_copy_plane(uint8_t       *dst, int dst_linesize,
                          const uint8_t *src, int src_linesize,
@@ -147,8 +162,13 @@
 /**
  * Copy image in src_data to dst_data.
  *
+ * @param dst_data      destination image data buffer to copy to
  * @param dst_linesizes linesizes for the image in dst_data
+ * @param src_data      source image data buffer to copy from
  * @param src_linesizes linesizes for the image in src_data
+ * @param pix_fmt       the AVPixelFormat of the image
+ * @param width         width of the image in pixels
+ * @param height        height of the image in pixels
  */
 void av_image_copy(uint8_t *dst_data[4], int dst_linesizes[4],
                    const uint8_t *src_data[4], const int src_linesizes[4],
--- a/third_party/ffmpeg/libavutil/integer.c
+++ b/third_party/ffmpeg/libavutil/integer.c
@@ -103,8 +103,8 @@
     for(i=0; i<AV_INTEGER_SIZE; i++){
         unsigned int index= i + (s>>4);
         unsigned int v=0;
-        if(index+1<AV_INTEGER_SIZE) v = a.v[index+1]<<16;
-        if(index  <AV_INTEGER_SIZE) v+= a.v[index  ];
+        if (index + 1 < AV_INTEGER_SIZE) v  = a.v[index + 1] * (1U << 16);
+        if (index     < AV_INTEGER_SIZE) v |= a.v[index];
         out.v[i]= v >> (s&15);
     }
     return out;
@@ -158,11 +158,9 @@
 }
 
 int64_t av_i2int(AVInteger a){
-    int i;
-    int64_t out=(int8_t)a.v[AV_INTEGER_SIZE-1];
+    uint64_t out = a.v[3];
 
-    for(i= AV_INTEGER_SIZE-2; i>=0; i--){
-        out = (out<<16) + a.v[i];
-    }
+    for (int i = 2; i >= 0; i--)
+        out = (out << 16) | a.v[i];
     return out;
 }
--- a/third_party/ffmpeg/libavutil/internal.h
+++ b/third_party/ffmpeg/libavutil/internal.h
@@ -197,6 +197,4 @@
     return x;
 }
 
-void ff_check_pixfmt_descriptors(void);
-
 #endif /* AVUTIL_INTERNAL_H */
--- a/third_party/ffmpeg/libavutil/lfg.h
+++ b/third_party/ffmpeg/libavutil/lfg.h
@@ -27,7 +27,7 @@
 /**
  * Context structure for the Lagged Fibonacci PRNG.
  * The exact layout, types and content of this struct may change and should
- * not be accessed directly. Only its sizeof() is guaranteed to stay the same
+ * not be accessed directly. Only its `sizeof()` is guaranteed to stay the same
  * to allow easy instanciation.
  */
 typedef struct AVLFG {
@@ -40,7 +40,7 @@
 /**
  * Seed the state of the ALFG using binary data.
  *
- * Return value: 0 on success, negative value (AVERROR) on failure.
+ * @return 0 on success, negative value (AVERROR) on failure.
  */
 int av_lfg_init_from_data(AVLFG *c, const uint8_t *data, unsigned int length);
 
@@ -73,6 +73,7 @@
  * Get the next two numbers generated by a Box-Muller Gaussian
  * generator using the random numbers issued by lfg.
  *
+ * @param lfg pointer to the contex structure
  * @param out array where the two generated numbers are placed
  */
 void av_bmg_get(AVLFG *lfg, double out[2]);
--- a/third_party/ffmpeg/libavutil/mathematics.h
+++ b/third_party/ffmpeg/libavutil/mathematics.h
@@ -111,7 +111,8 @@
 /**
  * Compute the greatest common divisor of two integer operands.
  *
- * @param a,b Operands
+ * @param a Operand
+ * @param b Operand
  * @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;
  * if a == 0 and b == 0, returns 0.
  */
@@ -186,7 +187,8 @@
  * av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)
  * @endcode
  *
- * @param a,b Operands
+ * @param a Operand
+ * @param b Operand
  * @param mod Divisor; must be a power of 2
  * @return
  *         - a negative value if `a % mod < b % mod`
--- a/third_party/ffmpeg/libavutil/mem.h
+++ b/third_party/ffmpeg/libavutil/mem.h
@@ -667,7 +667,8 @@
 /**
  * Multiply two `size_t` values checking for overflow.
  *
- * @param[in]  a,b Operands of multiplication
+ * @param[in]  a   Operand of multiplication
+ * @param[in]  b   Operand of multiplication
  * @param[out] r   Pointer to the result of the operation
  * @return 0 on success, AVERROR(EINVAL) on overflow
  */
--- a/third_party/ffmpeg/libavutil/parseutils.h
+++ b/third_party/ffmpeg/libavutil/parseutils.h
@@ -79,6 +79,8 @@
 /**
  * Put the RGBA values that correspond to color_string in rgba_color.
  *
+ * @param rgba_color 4-elements array of uint8_t values, where the respective
+ * red, green, blue and alpha component values are written.
  * @param color_string a string specifying a color. It can be the name of
  * a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,
  * possibly followed by "@" and a string representing the alpha
@@ -92,6 +94,8 @@
  * @param slen length of the initial part of color_string containing the
  * color. It can be set to -1 if color_string is a null terminated string
  * containing nothing else than the color.
+ * @param log_ctx a pointer to an arbitrary struct of which the first field
+ * is a pointer to an AVClass struct (used for av_log()). Can be NULL.
  * @return >= 0 in case of success, a negative value in case of
  * failure (for example if color_string cannot be parsed).
  */
@@ -106,7 +110,7 @@
  * av_parse_color().
  *
  * @param color_idx index of the requested color, starting from 0
- * @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB
+ * @param rgb      if not NULL, will point to a 3-elements array with the color value in RGB
  * @return the color name string or NULL if color_idx is not in the array
  */
 const char *av_get_known_color_name(int color_idx, const uint8_t **rgb);
@@ -162,19 +166,19 @@
  * by the standard strptime().
  *
  * The supported input field descriptors are listed below.
- * - %H: the hour as a decimal number, using a 24-hour clock, in the
+ * - `%%H`: the hour as a decimal number, using a 24-hour clock, in the
  *   range '00' through '23'
- * - %J: hours as a decimal number, in the range '0' through INT_MAX
- * - %M: the minute as a decimal number, using a 24-hour clock, in the
+ * - `%%J`: hours as a decimal number, in the range '0' through INT_MAX
+ * - `%%M`: the minute as a decimal number, using a 24-hour clock, in the
  *   range '00' through '59'
- * - %S: the second as a decimal number, using a 24-hour clock, in the
+ * - `%%S`: the second as a decimal number, using a 24-hour clock, in the
  *   range '00' through '59'
- * - %Y: the year as a decimal number, using the Gregorian calendar
- * - %m: the month as a decimal number, in the range '1' through '12'
- * - %d: the day of the month as a decimal number, in the range '1'
+ * - `%%Y`: the year as a decimal number, using the Gregorian calendar
+ * - `%%m`: the month as a decimal number, in the range '1' through '12'
+ * - `%%d`: the day of the month as a decimal number, in the range '1'
  *   through '31'
- * - %T: alias for '%H:%M:%S'
- * - %%: a literal '%'
+ * - `%%T`: alias for `%%H:%%M:%%S`
+ * - `%%`: a literal `%`
  *
  * @return a pointer to the first character not processed in this function
  *         call. In case the input string contains more characters than
--- a/third_party/ffmpeg/libavutil/pixdesc.c
+++ b/third_party/ffmpeg/libavutil/pixdesc.c
@@ -22,12 +22,10 @@
 #include <stdio.h>
 #include <string.h>
 
-#include "avassert.h"
 #include "avstring.h"
 #include "common.h"
 #include "pixfmt.h"
 #include "pixdesc.h"
-#include "internal.h"
 #include "intreadwrite.h"
 
 void av_read_image_line2(void *dst,
@@ -2636,6 +2634,59 @@
         },
         .flags = AV_PIX_FMT_FLAG_BE,
     },
+    [AV_PIX_FMT_RGBF32BE] = {
+        .name = "rgbf32be",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 12, 0, 0, 32 },       /* R */
+            { 0, 12, 4, 0, 32 },       /* G */
+            { 0, 12, 8, 0, 32 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB |
+                 AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_RGBF32LE] = {
+        .name = "rgbf32le",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 12, 0, 0, 32 },       /* R */
+            { 0, 12, 4, 0, 32 },       /* G */
+            { 0, 12, 8, 0, 32 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_RGBAF32BE] = {
+        .name = "rgbaf32be",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 16,  0, 0, 32 },      /* R */
+            { 0, 16,  4, 0, 32 },      /* G */
+            { 0, 16,  8, 0, 32 },      /* B */
+            { 0, 16, 12, 0, 32 },      /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB |
+                 AV_PIX_FMT_FLAG_FLOAT | AV_PIX_FMT_FLAG_ALPHA,
+    },
+    [AV_PIX_FMT_RGBAF32LE] = {
+        .name = "rgbaf32le",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 16,  0, 0, 32 },      /* R */
+            { 0, 16,  4, 0, 32 },      /* G */
+            { 0, 16,  8, 0, 32 },      /* B */
+            { 0, 16, 12, 0, 32 },      /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT |
+                 AV_PIX_FMT_FLAG_ALPHA,
+    },
 };
 
 static const char * const color_range_names[] = {
@@ -2859,47 +2910,6 @@
     return ret;
 }
 
-void ff_check_pixfmt_descriptors(void){
-    int i, j;
-
-    for (i=0; i<FF_ARRAY_ELEMS(av_pix_fmt_descriptors); i++) {
-        const AVPixFmtDescriptor *d = &av_pix_fmt_descriptors[i];
-        uint8_t fill[4][8+6+3] = {{0}};
-        uint8_t *data[4] = {fill[0], fill[1], fill[2], fill[3]};
-        int linesize[4] = {0,0,0,0};
-        uint16_t tmp[2];
-
-        if (!d->name && !d->nb_components && !d->log2_chroma_w && !d->log2_chroma_h && !d->flags)
-            continue;
-        av_log(NULL, AV_LOG_INFO, "Checking: %s\n", d->name);
-        av_assert0(d->log2_chroma_w <= 3);
-        av_assert0(d->log2_chroma_h <= 3);
-        av_assert0(d->nb_components <= 4);
-        av_assert0(d->name && d->name[0]);
-        av_assert2(av_get_pix_fmt(d->name) == i);
-
-        for (j=0; j<FF_ARRAY_ELEMS(d->comp); j++) {
-            const AVComponentDescriptor *c = &d->comp[j];
-            if(j>=d->nb_components) {
-                av_assert0(!c->plane && !c->step && !c->offset && !c->shift && !c->depth);
-                continue;
-            }
-            if (d->flags & AV_PIX_FMT_FLAG_BITSTREAM) {
-                av_assert0(c->step >= c->depth);
-            } else {
-                av_assert0(8*c->step >= c->depth);
-            }
-            if (d->flags & AV_PIX_FMT_FLAG_BAYER)
-                continue;
-            av_read_image_line(tmp, (void*)data, linesize, d, 0, 0, j, 2, 0);
-            av_assert0(tmp[0] == 0 && tmp[1] == 0);
-            tmp[0] = tmp[1] = (1ULL << c->depth) - 1;
-            av_write_image_line(tmp, data, linesize, d, 0, 0, j, 2);
-        }
-    }
-}
-
-
 enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
 {
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
@@ -3262,3 +3272,26 @@
 
     return AVERROR(EINVAL);
 }
+
+int av_chroma_location_enum_to_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
+{
+    if (pos <= AVCHROMA_LOC_UNSPECIFIED || pos >= AVCHROMA_LOC_NB)
+        return AVERROR(EINVAL);
+    pos--;
+
+    *xpos = (pos&1) * 128;
+    *ypos = ((pos>>1)^(pos<4)) * 128;
+
+    return 0;
+}
+
+enum AVChromaLocation av_chroma_location_pos_to_enum(int xpos, int ypos)
+{
+    int pos, xout, yout;
+
+    for (pos = AVCHROMA_LOC_UNSPECIFIED + 1; pos < AVCHROMA_LOC_NB; pos++) {
+        if (av_chroma_location_enum_to_pos(&xout, &yout, pos) == 0 && xout == xpos && yout == ypos)
+            return pos;
+    }
+    return AVCHROMA_LOC_UNSPECIFIED;
+}
--- a/third_party/ffmpeg/libavutil/pixdesc.h
+++ b/third_party/ffmpeg/libavutil/pixdesc.h
@@ -265,6 +265,28 @@
 int av_chroma_location_from_name(const char *name);
 
 /**
+ * Converts AVChromaLocation to swscale x/y chroma position.
+ *
+ * The positions represent the chroma (0,0) position in a coordinates system
+ * with luma (0,0) representing the origin and luma(1,1) representing 256,256
+ *
+ * @param xpos  horizontal chroma sample position
+ * @param ypos  vertical   chroma sample position
+ */
+int av_chroma_location_enum_to_pos(int *xpos, int *ypos, enum AVChromaLocation pos);
+
+/**
+ * Converts swscale x/y chroma position to AVChromaLocation.
+ *
+ * The positions represent the chroma (0,0) position in a coordinates system
+ * with luma (0,0) representing the origin and luma(1,1) representing 256,256
+ *
+ * @param xpos  horizontal chroma sample position
+ * @param ypos  vertical   chroma sample position
+ */
+enum AVChromaLocation av_chroma_location_pos_to_enum(int xpos, int ypos);
+
+/**
  * Return the pixel format corresponding to name.
  *
  * If there is no pixel format with name name, then looks for a
--- a/third_party/ffmpeg/libavutil/pixfmt.h
+++ b/third_party/ffmpeg/libavutil/pixfmt.h
@@ -386,6 +386,12 @@
     AV_PIX_FMT_XV36BE,      ///< packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, big-endian, variant of Y412 where alpha channel is left undefined
     AV_PIX_FMT_XV36LE,      ///< packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, little-endian, variant of Y412 where alpha channel is left undefined
 
+    AV_PIX_FMT_RGBF32BE,    ///< IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., big-endian
+    AV_PIX_FMT_RGBF32LE,    ///< IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., little-endian
+
+    AV_PIX_FMT_RGBAF32BE,   ///< IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., big-endian
+    AV_PIX_FMT_RGBAF32LE,   ///< IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., little-endian
+
     AV_PIX_FMT_NB         ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
@@ -489,6 +495,9 @@
 
 #define AV_PIX_FMT_RGBAF16    AV_PIX_FMT_NE(RGBAF16BE, RGBAF16LE)
 
+#define AV_PIX_FMT_RGBF32     AV_PIX_FMT_NE(RGBF32BE, RGBF32LE)
+#define AV_PIX_FMT_RGBAF32    AV_PIX_FMT_NE(RGBAF32BE, RGBAF32LE)
+
 /**
   * Chromaticity coordinates of the source primaries.
   * These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.1 and ITU-T H.273.
--- a/third_party/ffmpeg/libavutil/rational.h
+++ b/third_party/ffmpeg/libavutil/rational.h
@@ -179,7 +179,8 @@
  * Find which of the two rationals is closer to another rational.
  *
  * @param q     Rational to be compared against
- * @param q1,q2 Rationals to be tested
+ * @param q1    Rational to be tested
+ * @param q2    Rational to be tested
  * @return One of the following values:
  *         - 1 if `q1` is nearer to `q` than `q2`
  *         - -1 if `q2` is nearer to `q` than `q1`
--- a/third_party/ffmpeg/libavutil/rc4.h
+++ b/third_party/ffmpeg/libavutil/rc4.h
@@ -42,6 +42,8 @@
 /**
  * @brief Initializes an AVRC4 context.
  *
+ * @param d pointer to the AVRC4 context
+ * @param key buffer containig the key
  * @param key_bits must be a multiple of 8
  * @param decrypt 0 for encryption, 1 for decryption, currently has no effect
  * @return zero on success, negative value otherwise
@@ -51,6 +53,7 @@
 /**
  * @brief Encrypts / decrypts using the RC4 algorithm.
  *
+ * @param d pointer to the AVRC4 context
  * @param count number of bytes
  * @param dst destination array, can be equal to src
  * @param src source array, can be equal to dst, may be NULL
--- /dev/null
+++ b/third_party/ffmpeg/libavutil/riscv/Makefile
@@ -0,0 +1,5 @@
+OBJS +=     riscv/float_dsp_init.o \
+            riscv/fixed_dsp_init.o \
+            riscv/cpu.o
+RVV-OBJS += riscv/float_dsp_rvv.o \
+            riscv/fixed_dsp_rvv.o
--- /dev/null
+++ b/third_party/ffmpeg/libavutil/riscv/asm.S
@@ -0,0 +1,169 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ * Loosely based on earlier work copyrighted by Mns Rullgrd, 2008.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#if defined (__riscv_float_abi_soft)
+#define NOHWF
+#define NOHWD
+#define HWF   #
+#define HWD   #
+#elif defined (__riscv_float_abi_single)
+#define NOHWF #
+#define NOHWD
+#define HWF
+#define HWD   #
+#else
+#define NOHWF #
+#define NOHWD #
+#define HWF
+#define HWD
+#endif
+
+        .macro func sym, ext=
+            .text
+            .align 2
+
+            .option push
+            .ifnb \ext
+            .option arch, +\ext
+            .endif
+
+            .global \sym
+            .hidden \sym
+            .type   \sym, %function
+            \sym:
+
+            .macro endfunc
+                .size   \sym, . - \sym
+                .option pop
+                .previous
+                .purgem endfunc
+            .endm
+        .endm
+
+        .macro const sym, align=3, relocate=0
+            .if \relocate
+                .pushsection .data.rel.ro
+            .else
+                .pushsection .rodata
+            .endif
+            .align \align
+            \sym:
+
+            .macro endconst
+                .size  \sym, . - \sym
+                .popsection
+                .purgem endconst
+            .endm
+        .endm
+
+#if !defined (__riscv_zba)
+        /* SH{1,2,3}ADD definitions for pre-Zba assemblers */
+        .macro  shnadd n, rd, rs1, rs2
+        .insn r OP, 2 * \n, 16, \rd, \rs1, \rs2
+        .endm
+
+        .macro  sh1add rd, rs1, rs2
+        shnadd  1, \rd, \rs1, \rs2
+        .endm
+
+        .macro  sh2add rd, rs1, rs2
+        shnadd  2, \rd, \rs1, \rs2
+        .endm
+
+        .macro  sh3add rd, rs1, rs2
+        shnadd  3, \rd, \rs1, \rs2
+        .endm
+#endif
+
+        /* Convenience macro to load a Vector type (vtype) as immediate */
+        .macro  lvtypei rd, e, m=m1, tp=tu, mp=mu
+
+        .ifc \e,e8
+        .equ ei, 0
+        .else
+        .ifc \e,e16
+        .equ ei, 8
+        .else
+        .ifc \e,e32
+        .equ ei, 16
+        .else
+        .ifc \e,e64
+        .equ ei, 24
+        .else
+        .error "Unknown element type"
+        .endif
+        .endif
+        .endif
+        .endif
+
+        .ifc \m,m1
+        .equ mi, 0
+        .else
+        .ifc \m,m2
+        .equ mi, 1
+        .else
+        .ifc \m,m4
+        .equ mi, 2
+        .else
+        .ifc \m,m8
+        .equ mi, 3
+        .else
+        .ifc \m,mf8
+        .equ mi, 5
+        .else
+        .ifc \m,mf4
+        .equ mi, 6
+        .else
+        .ifc \m,mf2
+        .equ mi, 7
+        .else
+        .error "Unknown multiplier"
+        .equ mi, 3
+        .endif
+        .endif
+        .endif
+        .endif
+        .endif
+        .endif
+        .endif
+
+        .ifc \tp,tu
+        .equ tpi, 0
+        .else
+        .ifc \tp,ta
+        .equ tpi, 64
+        .else
+        .error "Unknown tail policy"
+        .endif
+        .endif
+
+        .ifc \mp,mu
+        .equ mpi, 0
+        .else
+        .ifc \mp,ma
+        .equ mpi, 128
+        .else
+        .error "Unknown mask policy"
+        .endif
+        .endif
+
+        li      \rd, (ei | mi | tpi | mpi)
+        .endm
--- /dev/null
+++ b/third_party/ffmpeg/libavutil/riscv/cpu.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/cpu.h"
+#include "libavutil/cpu_internal.h"
+#include "libavutil/log.h"
+#include "config.h"
+
+#if HAVE_GETAUXVAL
+#include <sys/auxv.h>
+#define HWCAP_RV(letter) (1ul << ((letter) - 'A'))
+#endif
+
+int ff_get_cpu_flags_riscv(void)
+{
+    int ret = 0;
+#if HAVE_GETAUXVAL
+    const unsigned long hwcap = getauxval(AT_HWCAP);
+
+    if (hwcap & HWCAP_RV('I'))
+        ret |= AV_CPU_FLAG_RVI;
+    if (hwcap & HWCAP_RV('F'))
+        ret |= AV_CPU_FLAG_RVF;
+    if (hwcap & HWCAP_RV('D'))
+        ret |= AV_CPU_FLAG_RVD;
+    if (hwcap & HWCAP_RV('B'))
+        ret |= AV_CPU_FLAG_RVB_BASIC;
+
+    /* The V extension implies all Zve* functional subsets */
+    if (hwcap & HWCAP_RV('V'))
+        ret |= AV_CPU_FLAG_RVV_I32 | AV_CPU_FLAG_RVV_I64
+             | AV_CPU_FLAG_RVV_F32 | AV_CPU_FLAG_RVV_F64;
+#endif
+
+#ifdef __riscv_i
+    ret |= AV_CPU_FLAG_RVI;
+#endif
+#if defined (__riscv_flen) && (__riscv_flen >= 32)
+    ret |= AV_CPU_FLAG_RVF;
+#if (__riscv_flen >= 64)
+    ret |= AV_CPU_FLAG_RVD;
+#endif
+#endif
+
+#ifdef __riscv_zbb
+    ret |= AV_CPU_FLAG_RVB_BASIC;
+#endif
+
+    /* If RV-V is enabled statically at compile-time, check the details. */
+#ifdef __riscv_vectors
+    ret |= AV_CPU_FLAG_RVV_I32;
+#if __riscv_v_elen >= 64
+    ret |= AV_CPU_FLAG_RVV_I64;
+#endif
+#if __riscv_v_elen_fp >= 32
+    ret |= AV_CPU_FLAG_RVV_F32;
+#if __riscv_v_elen_fp >= 64
+    ret |= AV_CPU_FLAG_RVV_F64;
+#endif
+#endif
+#endif
+
+    return ret;
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavutil/riscv/cpu.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_RISCV_CPU_H
+#define AVUTIL_RISCV_CPU_H
+
+#include "config.h"
+#include <stddef.h>
+#include "libavutil/cpu.h"
+
+#if HAVE_RVV
+/**
+ * Returns the vector size in bytes (always a power of two and at least 4).
+ * This is undefined behaviour if vectors are not implemented.
+ */
+static inline size_t ff_get_rv_vlenb(void)
+{
+    size_t vlenb;
+
+    __asm__ (
+        ".option push\n"
+        ".option arch, +v\n"
+        "    csrr %0, vlenb\n"
+        ".option pop\n" : "=r" (vlenb));
+    return vlenb;
+}
+#endif
+#endif
--- /dev/null
+++ b/third_party/ffmpeg/libavutil/riscv/fixed_dsp_init.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavutil/fixed_dsp.h"
+
+void ff_butterflies_fixed_rvv(int *v1, int *v2, int len);
+
+av_cold void ff_fixed_dsp_init_riscv(AVFixedDSPContext *fdsp)
+{
+#if HAVE_RVV
+    int flags = av_get_cpu_flags();
+
+    if (flags & AV_CPU_FLAG_RVV_I32)
+        fdsp->butterflies_fixed = ff_butterflies_fixed_rvv;
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavutil/riscv/fixed_dsp_rvv.S
@@ -0,0 +1,39 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "asm.S"
+
+// (a0) = (a0) + (a1), (a1) = (a0) - (a1) [0..a2-1]
+func ff_butterflies_fixed_rvv, zve32x
+1:
+        vsetvli t0, a2, e32, m1, ta, ma
+        vle32.v v16, (a0)
+        sub     a2, a2, t0
+        vle32.v v24, (a1)
+        vadd.vv v0, v16, v24
+        vsub.vv v8, v16, v24
+        vse32.v v0, (a0)
+        sh2add  a0, t0, a0
+        vse32.v v8, (a1)
+        sh2add  a1, t0, a1
+        bnez    a2, 1b
+
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavutil/riscv/float_dsp_init.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavutil/float_dsp.h"
+
+void ff_vector_fmul_rvv(float *dst, const float *src0, const float *src1,
+                         int len);
+void ff_vector_fmac_scalar_rvv(float *dst, const float *src, float mul,
+                                int len);
+void ff_vector_fmul_scalar_rvv(float *dst, const float *src, float mul,
+                                int len);
+void ff_vector_fmul_window_rvv(float *dst, const float *src0,
+                                const float *src1, const float *win, int len);
+void ff_vector_fmul_add_rvv(float *dst, const float *src0, const float *src1,
+                             const float *src2, int len);
+void ff_vector_fmul_reverse_rvv(float *dst, const float *src0,
+                                 const float *src1, int len);
+void ff_butterflies_float_rvv(float *v1, float *v2, int len);
+float ff_scalarproduct_float_rvv(const float *v1, const float *v2, int len);
+
+void ff_vector_dmul_rvv(double *dst, const double *src0, const double *src1,
+                         int len);
+void ff_vector_dmac_scalar_rvv(double *dst, const double *src, double mul,
+                                int len);
+void ff_vector_dmul_scalar_rvv(double *dst, const double *src, double mul,
+                                int len);
+
+av_cold void ff_float_dsp_init_riscv(AVFloatDSPContext *fdsp)
+{
+#if HAVE_RVV
+    int flags = av_get_cpu_flags();
+
+    if (flags & AV_CPU_FLAG_RVV_F32) {
+        fdsp->vector_fmul = ff_vector_fmul_rvv;
+        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_rvv;
+        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_rvv;
+        fdsp->vector_fmul_window = ff_vector_fmul_window_rvv;
+        fdsp->vector_fmul_add = ff_vector_fmul_add_rvv;
+        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_rvv;
+        fdsp->butterflies_float = ff_butterflies_float_rvv;
+        fdsp->scalarproduct_float = ff_scalarproduct_float_rvv;
+    }
+
+    if (flags & AV_CPU_FLAG_RVV_F64) {
+        fdsp->vector_dmul = ff_vector_dmul_rvv;
+        fdsp->vector_dmac_scalar = ff_vector_dmac_scalar_rvv;
+        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_rvv;
+    }
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavutil/riscv/float_dsp_rvv.S
@@ -0,0 +1,237 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "asm.S"
+
+// (a0) = (a1) * (a2) [0..a3-1]
+func ff_vector_fmul_rvv, zve32f
+1:
+        vsetvli  t0, a3, e32, m1, ta, ma
+        vle32.v  v16, (a1)
+        sub      a3, a3, t0
+        vle32.v  v24, (a2)
+        sh2add   a1, t0, a1
+        vfmul.vv v16, v16, v24
+        sh2add   a2, t0, a2
+        vse32.v  v16, (a0)
+        sh2add   a0, t0, a0
+        bnez     a3, 1b
+
+        ret
+endfunc
+
+// (a0) += (a1) * fa0 [0..a2-1]
+func ff_vector_fmac_scalar_rvv, zve32f
+NOHWF   fmv.w.x   fa0, a2
+NOHWF   mv        a2, a3
+1:
+        vsetvli   t0, a2, e32, m1, ta, ma
+        slli      t1, t0, 2
+        vle32.v   v24, (a1)
+        sub       a2, a2, t0
+        vle32.v   v16, (a0)
+        sh2add    a1, t0, a1
+        vfmacc.vf v16, fa0, v24
+        vse32.v   v16, (a0)
+        sh2add    a0, t0, a0
+        bnez      a2, 1b
+
+        ret
+endfunc
+
+// (a0) = (a1) * fa0 [0..a2-1]
+func ff_vector_fmul_scalar_rvv, zve32f
+NOHWF   fmv.w.x  fa0, a2
+NOHWF   mv       a2, a3
+1:
+        vsetvli  t0, a2, e32, m1, ta, ma
+        vle32.v  v16, (a1)
+        sub      a2, a2, t0
+        vfmul.vf v16, v16, fa0
+        sh2add   a1, t0, a1
+        vse32.v  v16, (a0)
+        sh2add   a0, t0, a0
+        bnez     a2, 1b
+
+        ret
+endfunc
+
+func ff_vector_fmul_window_rvv, zve32f
+        // a0: dst, a1: src0, a2: src1, a3: window, a4: length
+        addi       t0, a4, -1
+        add        t1, t0, a4
+        sh2add     a2, t0, a2
+        sh2add     t0, t1, a0
+        sh2add     t3, t1, a3
+        li         t1, -4 // byte stride
+1:
+        vsetvli    t2, a4, e32, m1, ta, ma
+        vle32.v    v16, (a1)
+        slli       t4, t2, 2
+        vlse32.v   v20, (a2), t1
+        sub        a4, a4, t2
+        vle32.v    v24, (a3)
+        add        a1, a1, t4
+        vlse32.v   v28, (t3), t1
+        sub        a2, a2, t4
+        vfmul.vv   v0, v16, v28
+        add        a3, a3, t4
+        vfmul.vv   v8, v16, v24
+        sub        t3, t3, t4
+        vfnmsac.vv v0, v20, v24
+        vfmacc.vv  v8, v20, v28
+        vse32.v    v0, (a0)
+        add        a0, a0, t4
+        vsse32.v   v8, (t0), t1
+        sub        t0, t0, t4
+        bnez       a4, 1b
+
+        ret
+endfunc
+
+// (a0) = (a1) * (a2) + (a3) [0..a4-1]
+func ff_vector_fmul_add_rvv, zve32f
+1:
+        vsetvli   t0, a4, e32, m1, ta, ma
+        vle32.v   v8, (a1)
+        sub       a4, a4, t0
+        vle32.v   v16, (a2)
+        sh2add    a1, t0, a1
+        vle32.v   v24, (a3)
+        sh2add    a2, t0, a2
+        vfmadd.vv v8, v16, v24
+        sh2add    a3, t0, a3
+        vse32.v   v8, (a0)
+        sh2add    a0, t0, a0
+        bnez      a4, 1b
+
+        ret
+endfunc
+
+// (a0) = (a1) * reverse(a2) [0..a3-1]
+func ff_vector_fmul_reverse_rvv, zve32f
+        sh2add   a2, a3, a2
+        li       t2, -4 // byte stride
+        addi     a2, a2, -4
+1:
+        vsetvli  t0, a3, e32, m1, ta, ma
+        slli     t1, t0, 2
+        vle32.v  v16, (a1)
+        sub      a3, a3, t0
+        vlse32.v v24, (a2), t2
+        add      a1, a1, t1
+        vfmul.vv v16, v16, v24
+        sub      a2, a2, t1
+        vse32.v  v16, (a0)
+        add      a0, a0, t1
+        bnez     a3, 1b
+
+        ret
+endfunc
+
+// (a0) = (a0) + (a1), (a1) = (a0) - (a1) [0..a2-1]
+func ff_butterflies_float_rvv, zve32f
+1:
+        vsetvli  t0, a2, e32, m1, ta, ma
+        vle32.v  v16, (a0)
+        sub      a2, a2, t0
+        vle32.v  v24, (a1)
+        vfadd.vv v0, v16, v24
+        vfsub.vv v8, v16, v24
+        vse32.v  v0, (a0)
+        sh2add   a0, t0, a0
+        vse32.v  v8, (a1)
+        sh2add   a1, t0, a1
+        bnez     a2, 1b
+
+        ret
+endfunc
+
+// a0 = (a0).(a1) [0..a2-1]
+func ff_scalarproduct_float_rvv, zve32f
+        vsetivli     zero, 1, e32, m1, ta, ma
+        vmv.s.x      v8, zero
+1:
+        vsetvli      t0, a2, e32, m1, ta, ma
+        vle32.v      v16, (a0)
+        sub          a2, a2, t0
+        vle32.v      v24, (a1)
+        sh2add       a0, t0, a0
+        vfmul.vv     v16, v16, v24
+        sh2add       a1, t0, a1
+        vfredusum.vs v8, v16, v8
+        bnez         a2, 1b
+
+        vfmv.f.s fa0, v8
+NOHWF   fmv.x.w  a0, fa0
+        ret
+endfunc
+
+// (a0) = (a1) * (a2) [0..a3-1]
+func ff_vector_dmul_rvv, zve64d
+1:
+        vsetvli  t0, a3, e64, m1, ta, ma
+        vle64.v  v16, (a1)
+        sub      a3, a3, t0
+        vle64.v  v24, (a2)
+        sh3add   a1, t0, a1
+        vfmul.vv v16, v16, v24
+        sh3add   a2, t0, a2
+        vse64.v  v16, (a0)
+        sh3add   a0, t0, a0
+        bnez     a3, 1b
+
+        ret
+endfunc
+
+// (a0) += (a1) * fa0 [0..a2-1]
+func ff_vector_dmac_scalar_rvv, zve64d
+NOHWD   fmv.d.x   fa0, a2
+NOHWD   mv        a2, a3
+1:
+        vsetvli   t0, a2, e64, m1, ta, ma
+        vle64.v   v24, (a1)
+        sub       a2, a2, t0
+        vle64.v   v16, (a0)
+        sh3add    a1, t0, a1
+        vfmacc.vf v16, fa0, v24
+        vse64.v   v16, (a0)
+        sh3add    a0, t0, a0
+        bnez      a2, 1b
+
+        ret
+endfunc
+
+// (a0) = (a1) * fa0 [0..a2-1]
+func ff_vector_dmul_scalar_rvv, zve64d
+NOHWD   fmv.d.x  fa0, a2
+NOHWD   mv       a2, a3
+1:
+        vsetvli  t0, a2, e64, m1, ta, ma
+        vle64.v  v16, (a1)
+        sub      a2, a2, t0
+        vfmul.vf v16, v16, fa0
+        sh3add   a1, t0, a1
+        vse64.v  v16, (a0)
+        sh3add   a0, t0, a0
+        bnez     a2, 1b
+
+        ret
+endfunc
--- a/third_party/ffmpeg/libavutil/samplefmt.h
+++ b/third_party/ffmpeg/libavutil/samplefmt.h
@@ -213,6 +213,7 @@
  * @param[out] linesize    aligned size for audio buffer(s), may be NULL
  * @param nb_channels      number of audio channels
  * @param nb_samples       number of samples per channel
+ * @param sample_fmt       the sample format
  * @param align            buffer size alignment (0 = default, 1 = no alignment)
  * @return                 >=0 on success or a negative error code on failure
  * @todo return the size of the allocated buffer in case of success at the next bump
--- a/third_party/ffmpeg/libavutil/spherical.h
+++ b/third_party/ffmpeg/libavutil/spherical.h
@@ -20,6 +20,7 @@
 
 /**
  * @file
+ * @ingroup lavu_video_spherical
  * Spherical video
  */
 
@@ -30,19 +31,14 @@
 #include <stdint.h>
 
 /**
- * @addtogroup lavu_video
- * @{
- *
  * @defgroup lavu_video_spherical Spherical video mapping
- * @{
- */
-
-/**
- * @addtogroup lavu_video_spherical
+ * @ingroup lavu_video
+ *
  * A spherical video file contains surfaces that need to be mapped onto a
  * sphere. Depending on how the frame was converted, a different distortion
  * transformation or surface recomposition function needs to be applied before
  * the video should be mapped and displayed.
+ * @{
  */
 
 /**
@@ -226,7 +222,6 @@
 int av_spherical_from_name(const char *name);
 /**
  * @}
- * @}
  */
 
 #endif /* AVUTIL_SPHERICAL_H */
--- a/third_party/ffmpeg/libavutil/stereo3d.h
+++ b/third_party/ffmpeg/libavutil/stereo3d.h
@@ -20,6 +20,7 @@
 
 /**
  * @file
+ * @ingroup lavu_video_stereo3d
  * Stereoscopic video
  */
 
@@ -31,19 +32,15 @@
 #include "frame.h"
 
 /**
- * @addtogroup lavu_video
- * @{
- *
  * @defgroup lavu_video_stereo3d Stereo3D types and functions
- * @{
- */
-
-/**
- * @addtogroup lavu_video_stereo3d
+ * @ingroup lavu_video
+ *
  * A stereoscopic video file consists in multiple views embedded in a single
  * frame, usually describing two views of a scene. This file describes all
  * possible codec-independent view arrangements.
- * */
+ *
+ * @{
+ */
 
 /**
  * List of possible 3D Types
@@ -227,7 +224,6 @@
 
 /**
  * @}
- * @}
  */
 
 #endif /* AVUTIL_STEREO3D_H */
--- a/third_party/ffmpeg/libavutil/tests/pixelutils.c
+++ b/third_party/ffmpeg/libavutil/tests/pixelutils.c
@@ -18,15 +18,67 @@
 
 #include <stdio.h>
 
+#include "libavutil/avassert.h"
 #include "libavutil/internal.h"
+#include "libavutil/log.h"
 #include "libavutil/mem.h"
+#include "libavutil/pixdesc.h"
 #include "libavutil/pixelutils.c"
+#include "libavutil/pixfmt.h"
 
 #define W1 320
 #define H1 240
 #define W2 640
 #define H2 480
 
+static void check_pixfmt_descriptors(void)
+{
+    const AVPixFmtDescriptor *d, *last = NULL;
+    int i;
+
+    for (i = AV_PIX_FMT_NONE, d = NULL; i++, d = av_pix_fmt_desc_next(d);) {
+        uint8_t fill[4][8 + 6 + 3] = {{ 0 }};
+        uint8_t *data[4] = { fill[0], fill[1], fill[2], fill[3] };
+        int linesize[4] = { 0, 0, 0, 0 };
+        uint16_t tmp[2];
+
+        av_assert0(d->name && d->name[0]);
+        av_log(NULL, AV_LOG_INFO, "Checking: %s\n", d->name);
+        av_assert0(d->log2_chroma_w <= 3);
+        av_assert0(d->log2_chroma_h <= 3);
+        av_assert0(d->nb_components <= 4);
+        av_assert0(d->nb_components || (d->flags & AV_PIX_FMT_FLAG_HWACCEL));
+        av_assert0(av_get_pix_fmt(d->name) == av_pix_fmt_desc_get_id(d));
+
+        /* The following two checks as well as the one after the loop
+         * would need to be changed if we changed the way the descriptors
+         * are stored. */
+        av_assert0(i == av_pix_fmt_desc_get_id(d));
+        av_assert0(!last || last + 1 == d);
+
+        for (int j = 0; j < FF_ARRAY_ELEMS(d->comp); j++) {
+            const AVComponentDescriptor *c = &d->comp[j];
+            if (j >= d->nb_components) {
+                av_assert0(!c->plane && !c->step && !c->offset && !c->shift && !c->depth);
+                continue;
+            }
+            if (d->flags & AV_PIX_FMT_FLAG_BITSTREAM) {
+                av_assert0(c->step >= c->depth);
+            } else {
+                av_assert0(8*c->step >= c->depth);
+            }
+            if (d->flags & AV_PIX_FMT_FLAG_BAYER)
+                continue;
+            av_read_image_line(tmp, (void*)data, linesize, d, 0, 0, j, 2, 0);
+            av_assert0(tmp[0] == 0 && tmp[1] == 0);
+            tmp[0] = tmp[1] = (1ULL << c->depth) - 1;
+            av_write_image_line(tmp, data, linesize, d, 0, 0, j, 2);
+        }
+        last = d;
+    }
+    av_assert0(i == AV_PIX_FMT_NB);
+}
+
 static int run_single_test(const char *test,
                            const uint8_t *block1, ptrdiff_t stride1,
                            const uint8_t *block2, ptrdiff_t stride2,
@@ -87,7 +139,7 @@
         goto end;
     }
 
-    ff_check_pixfmt_descriptors();
+    check_pixfmt_descriptors();
 
 #define RANDOM_INIT(buf, size) do {             \
     int k;                                      \
--- a/third_party/ffmpeg/libavutil/thread.h
+++ b/third_party/ffmpeg/libavutil/thread.h
@@ -24,6 +24,12 @@
 
 #include "config.h"
 
+#if HAVE_PRCTL
+#include <sys/prctl.h>
+#endif
+
+#include "error.h"
+
 #if HAVE_PTHREADS || HAVE_W32THREADS || HAVE_OS2THREADS
 
 #if HAVE_PTHREADS
@@ -33,7 +39,6 @@
 
 #include <stdlib.h>
 
-#include "error.h"
 #include "log.h"
 #include "macros.h"
 
@@ -187,4 +192,13 @@
 
 #endif
 
+static inline int ff_thread_setname(const char *name)
+{
+#if HAVE_PRCTL
+    return AVERROR(prctl(PR_SET_NAME, name));
+#endif
+
+    return AVERROR(ENOSYS);
+}
+
 #endif /* AVUTIL_THREAD_H */
--- a/third_party/ffmpeg/libavutil/twofish.h
+++ b/third_party/ffmpeg/libavutil/twofish.h
@@ -59,7 +59,7 @@
   * @param dst destination array, can be equal to src
   * @param src source array, can be equal to dst
   * @param count number of 16 byte blocks
-  * @paran iv initialization vector for CBC mode, NULL for ECB mode
+  * @param iv initialization vector for CBC mode, NULL for ECB mode
   * @param decrypt 0 for encryption, 1 for decryption
  */
 void av_twofish_crypt(struct AVTWOFISH *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t* iv, int decrypt);
--- a/third_party/ffmpeg/libavutil/tx.c
+++ b/third_party/ffmpeg/libavutil/tx.c
@@ -213,7 +213,7 @@
     if (len < basis)
         return AVERROR(EINVAL);
 
-    if (!(s->map = av_mallocz((inv_lookup == -1 ? 2 : 1)*len*sizeof(*s->map))))
+    if (!(s->map = av_mallocz(len*sizeof(*s->map))))
         return AVERROR(ENOMEM);
 
     av_assert0(!dual_stride || !(dual_stride & (dual_stride - 1)));
@@ -221,9 +221,6 @@
 
     parity_revtab_generator(s->map, len, inv, 0, 0, 0, len,
                             basis, dual_stride, inv_lookup != 0);
-    if (inv_lookup == -1)
-        parity_revtab_generator(s->map + len, len, inv, 0, 0, 0, len,
-                                basis, dual_stride, 0);
 
     return 0;
 }
--- a/third_party/ffmpeg/libavutil/tx_priv.h
+++ b/third_party/ffmpeg/libavutil/tx_priv.h
@@ -290,8 +290,7 @@
  * If length is smaller than basis/2 this function will not do anything.
  *
  * If inv_lookup is set to 1, it will flip the lookup from out[map[i]] = src[i]
- * to out[i] = src[map[i]]. If set to -1, will generate 2 maps, the first one
- * flipped, the second one regular.
+ * to out[i] = src[map[i]].
  */
 int ff_tx_gen_split_radix_parity_revtab(AVTXContext *s, int len, int inv,
                                         int inv_lookup, int basis, int dual_stride);
--- a/third_party/ffmpeg/libavutil/tx_template.c
+++ b/third_party/ffmpeg/libavutil/tx_template.c
@@ -48,9 +48,9 @@
 SR_TABLE(131072);
 
 /* Other factors' tables */
-TABLE_DEF(53, 8);
-TABLE_DEF( 7, 6);
-TABLE_DEF( 9, 8);
+TABLE_DEF(53, 12);
+TABLE_DEF( 7,  6);
+TABLE_DEF( 9,  8);
 
 typedef struct FFSRTabsInitOnce {
     void (*func)(void);
@@ -104,19 +104,26 @@
     { TX_TAB(ff_tx_init_tab_131072), AV_ONCE_INIT },
 };
 
-static void TX_TAB(ff_tx_init_tab_53)(void)
+static av_cold void TX_TAB(ff_tx_init_tab_53)(void)
 {
-    TX_TAB(ff_tx_tab_53)[0] = RESCALE(cos(2 * M_PI / 12));
-    TX_TAB(ff_tx_tab_53)[1] = RESCALE(cos(2 * M_PI / 12));
-    TX_TAB(ff_tx_tab_53)[2] = RESCALE(cos(2 * M_PI /  6));
-    TX_TAB(ff_tx_tab_53)[3] = RESCALE(cos(8 * M_PI /  6));
-    TX_TAB(ff_tx_tab_53)[4] = RESCALE(cos(2 * M_PI /  5));
-    TX_TAB(ff_tx_tab_53)[5] = RESCALE(sin(8 * M_PI /  5));
-    TX_TAB(ff_tx_tab_53)[6] = RESCALE(cos(2 * M_PI / 10));
-    TX_TAB(ff_tx_tab_53)[7] = RESCALE(sin(6 * M_PI /  5));
+    /* 5pt, doubled to eliminate AVX lane shuffles */
+    TX_TAB(ff_tx_tab_53)[0] = RESCALE(cos(2 * M_PI /  5));
+    TX_TAB(ff_tx_tab_53)[1] = RESCALE(cos(2 * M_PI /  5));
+    TX_TAB(ff_tx_tab_53)[2] = RESCALE(cos(2 * M_PI / 10));
+    TX_TAB(ff_tx_tab_53)[3] = RESCALE(cos(2 * M_PI / 10));
+    TX_TAB(ff_tx_tab_53)[4] = RESCALE(sin(2 * M_PI /  5));
+    TX_TAB(ff_tx_tab_53)[5] = RESCALE(sin(2 * M_PI /  5));
+    TX_TAB(ff_tx_tab_53)[6] = RESCALE(sin(2 * M_PI / 10));
+    TX_TAB(ff_tx_tab_53)[7] = RESCALE(sin(2 * M_PI / 10));
+
+    /* 3pt */
+    TX_TAB(ff_tx_tab_53)[ 8] = RESCALE(cos(2 * M_PI / 12));
+    TX_TAB(ff_tx_tab_53)[ 9] = RESCALE(cos(2 * M_PI / 12));
+    TX_TAB(ff_tx_tab_53)[10] = RESCALE(cos(2 * M_PI /  6));
+    TX_TAB(ff_tx_tab_53)[11] = RESCALE(cos(8 * M_PI /  6));
 }
 
-static void TX_TAB(ff_tx_init_tab_7)(void)
+static av_cold void TX_TAB(ff_tx_init_tab_7)(void)
 {
     TX_TAB(ff_tx_tab_7)[0] = RESCALE(cos(2 * M_PI /  7));
     TX_TAB(ff_tx_tab_7)[1] = RESCALE(sin(2 * M_PI /  7));
@@ -126,7 +133,7 @@
     TX_TAB(ff_tx_tab_7)[5] = RESCALE(sin(2 * M_PI / 14));
 }
 
-static void TX_TAB(ff_tx_init_tab_9)(void)
+static av_cold void TX_TAB(ff_tx_init_tab_9)(void)
 {
     TX_TAB(ff_tx_tab_9)[0] = RESCALE(cos(2 * M_PI /  3));
     TX_TAB(ff_tx_tab_9)[1] = RESCALE(sin(2 * M_PI /  3));
@@ -189,19 +196,19 @@
     out[0*stride].im = in[0].im + tmp[1].im;
 
 #ifdef TX_INT32
-    mtmp[0] = (int64_t)tab[0] * tmp[0].re;
-    mtmp[1] = (int64_t)tab[1] * tmp[0].im;
-    mtmp[2] = (int64_t)tab[2] * tmp[1].re;
-    mtmp[3] = (int64_t)tab[2] * tmp[1].im;
+    mtmp[0] = (int64_t)tab[ 8] * tmp[0].re;
+    mtmp[1] = (int64_t)tab[ 9] * tmp[0].im;
+    mtmp[2] = (int64_t)tab[10] * tmp[1].re;
+    mtmp[3] = (int64_t)tab[10] * tmp[1].im;
     out[1*stride].re = in[0].re - (mtmp[2] + mtmp[0] + 0x40000000 >> 31);
     out[1*stride].im = in[0].im - (mtmp[3] - mtmp[1] + 0x40000000 >> 31);
     out[2*stride].re = in[0].re - (mtmp[2] - mtmp[0] + 0x40000000 >> 31);
     out[2*stride].im = in[0].im - (mtmp[3] + mtmp[1] + 0x40000000 >> 31);
 #else
-    tmp[0].re = tab[0] * tmp[0].re;
-    tmp[0].im = tab[1] * tmp[0].im;
-    tmp[1].re = tab[2] * tmp[1].re;
-    tmp[1].im = tab[2] * tmp[1].im;
+    tmp[0].re = tab[ 8] * tmp[0].re;
+    tmp[0].im = tab[ 9] * tmp[0].im;
+    tmp[1].re = tab[10] * tmp[1].re;
+    tmp[1].im = tab[10] * tmp[1].im;
     out[1*stride].re = in[0].re - tmp[1].re + tmp[0].re;
     out[1*stride].im = in[0].im - tmp[1].im - tmp[0].im;
     out[2*stride].re = in[0].re - tmp[1].re - tmp[0].re;
@@ -224,10 +231,10 @@
     out[D0*stride].re = in[0].re + t[0].re + t[2].re;               \
     out[D0*stride].im = in[0].im + t[0].im + t[2].im;               \
                                                                     \
-    SMUL(t[4].re, t[0].re, tab[4], tab[6], t[2].re, t[0].re);       \
-    SMUL(t[4].im, t[0].im, tab[4], tab[6], t[2].im, t[0].im);       \
-    CMUL(t[5].re, t[1].re, -tab[5], -tab[7], t[3].re, t[1].re);     \
-    CMUL(t[5].im, t[1].im, -tab[5], -tab[7], t[3].im, t[1].im);     \
+    SMUL(t[4].re, t[0].re, tab[0], tab[2], t[2].re, t[0].re);       \
+    SMUL(t[4].im, t[0].im, tab[0], tab[2], t[2].im, t[0].im);       \
+    CMUL(t[5].re, t[1].re, tab[4], tab[6], t[3].re, t[1].re);       \
+    CMUL(t[5].im, t[1].im, tab[4], tab[6], t[3].im, t[1].im);       \
                                                                     \
     BF(z0[0].re, z0[3].re, t[0].re, t[1].re);                       \
     BF(z0[0].im, z0[3].im, t[0].im, t[1].im);                       \
@@ -965,15 +972,14 @@
             return ret;
     }
 
-    /* If we need to preshuffle just steal the map from the subcontext */
+    s->map = av_malloc((len >> 1)*sizeof(*s->map));
+    if (!s->map)
+        return AVERROR(ENOMEM);
+
+    /* If we need to preshuffle copy the map from the subcontext */
     if (s->sub[0].flags & FF_TX_PRESHUFFLE) {
-        s->map = s->sub[0].map;
-        s->sub[0].map = NULL;
+        memcpy(s->map, s->sub->map, (len >> 1)*sizeof(*s->map));
     } else {
-        s->map = av_malloc((len >> 1)*sizeof(*s->map));
-        if (!s->map)
-            return AVERROR(ENOMEM);
-
         for (int i = 0; i < len >> 1; i++)
             s->map[i] = i;
     }
--- a/third_party/ffmpeg/libavutil/uuid.h
+++ b/third_party/ffmpeg/libavutil/uuid.h
@@ -106,7 +106,6 @@
  *
  * @param[in]  uu  AVUUID
  * @param[out] out Pointer to an array of no less than 37 characters.
- * @return         A non-zero value in case of an error.
  */
 void av_uuid_unparse(const AVUUID uu, char *out);
 
--- a/third_party/ffmpeg/libavutil/version.h
+++ b/third_party/ffmpeg/libavutil/version.h
@@ -79,8 +79,8 @@
  */
 
 #define LIBAVUTIL_VERSION_MAJOR  57
-#define LIBAVUTIL_VERSION_MINOR  36
-#define LIBAVUTIL_VERSION_MICRO 102
+#define LIBAVUTIL_VERSION_MINOR  39
+#define LIBAVUTIL_VERSION_MICRO 101
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
                                                LIBAVUTIL_VERSION_MINOR, \
--- a/third_party/ffmpeg/libavutil/x86/fixed_dsp_init.c
+++ b/third_party/ffmpeg/libavutil/x86/fixed_dsp_init.c
@@ -23,7 +23,7 @@
 #include "libavutil/fixed_dsp.h"
 #include "cpu.h"
 
-void ff_butterflies_fixed_sse2(int *src0, int *src1, int len);
+void ff_butterflies_fixed_sse2(int *av_restrict src0, int *av_restrict src1, int len);
 
 av_cold void ff_fixed_dsp_init_x86(AVFixedDSPContext *fdsp)
 {
--- a/third_party/ffmpeg/libavutil/x86/tx_float.asm
+++ b/third_party/ffmpeg/libavutil/x86/tx_float.asm
@@ -22,11 +22,10 @@
 ; based upon and compare.
 
 ; Intra-asm call convention:
-;       272 bytes of stack available
-;       First 10 GPRs available
+;       320 bytes of stack available
+;       14 GPRs available (last 4 must not be clobbered)
+;       Additionally, don't clobber ctx, in, out, len, lut
 ;       All vector regs available
-;       Don't clobber ctx, len, lut
-;       in and out must point to the end
 
 ; TODO:
 ;       carry over registers from smaller transforms to save on ~8 loads/stores
@@ -52,6 +51,8 @@
 %assign i (i << 1)
 %endrep
 
+cextern tab_53_float
+
 struc AVTXContext
     .len:          resd 1 ; Length
     .inv           resd 1 ; Inverse flag
@@ -88,6 +89,9 @@
 s16_mult_odd2: dd COS16_3, -COS16_3,  COS16_1, -COS16_1, -COS16_3, -COS16_3, -COS16_1, -COS16_1
 s16_perm:      dd 0, 1, 2, 3, 1, 0, 3, 2
 
+s15_perm:      dd 0, 6, 5, 3, 2, 4, 7, 1
+
+mask_mmmmmmpp: dd NEG, NEG, NEG, NEG, NEG, NEG, POS, POS
 mask_mmmmpppm: dd NEG, NEG, NEG, NEG, POS, POS, POS, NEG
 mask_ppmpmmpm: dd POS, POS, NEG, POS, NEG, NEG, POS, NEG
 mask_mppmmpmp: dd NEG, POS, POS, NEG, NEG, POS, NEG, POS
@@ -686,8 +690,6 @@
     movaps m0, [inq]
     FFT2 m0, m1
     movaps [outq], m0
-    add inq, mmsize*1
-    add outq, mmsize*1
     ret
 
 cglobal fft2_float, 4, 4, 2, ctx, out, in, stride
@@ -721,8 +723,6 @@
     movaps [outq + 1*mmsize], m0
 
 %if %3
-    add inq, mmsize*2
-    add outq, mmsize*2
     ret
 %else
     RET
@@ -764,8 +764,6 @@
     movups [outq + 3*mmsize], m1
 
 %if %1
-    add inq, mmsize*4
-    add outq, mmsize*4
     ret
 %else
     RET
@@ -806,8 +804,6 @@
     vextractf128 [outq + 16*3], m0, 1
 
 %if %1
-    add inq, mmsize*2
-    add outq, mmsize*2
     ret
 %else
     RET
@@ -857,8 +853,6 @@
     vextractf128 [outq + 16*7], m1, 1
 
 %if %2
-    add inq, mmsize*4
-    add outq, mmsize*4
     ret
 %else
     RET
@@ -943,8 +937,6 @@
     vextractf128 [outq + 16*15],  m5, 1
 
 %if %2
-    add inq, mmsize*8
-    add outq, mmsize*8
     ret
 %else
     RET
@@ -1282,12 +1274,13 @@
     add outq, 8*mmsize
     add rtabq, 4*mmsize
     sub itabq, 4*mmsize
-    sub lenq, 4*mmsize
+    sub tgtq, 4*mmsize
     jg .synth_deinterleave
 
 %if %2
-    mov lenq, tgtq
-    add outq, offq
+    sub outq, tmpq
+    neg tmpq
+    lea inq, [inq + tmpq*4]
     ret
 %else
     RET
@@ -1369,7 +1362,7 @@
     vextractf128 [outq + 15*mmsize + 16], tx2_e1, 1
 
 %if %2
-    add outq, 16*mmsize
+    sub inq, 16*mmsize
     ret
 %else
     RET
@@ -1386,6 +1379,8 @@
 %endmacro
 
 %if ARCH_X86_64
+FFT_SPLIT_RADIX_FN avx, 0
+FFT_SPLIT_RADIX_FN avx, 1
 FFT_SPLIT_RADIX_FN fma3, 0
 FFT_SPLIT_RADIX_FN fma3, 1
 %if HAVE_AVX2_EXTERNAL
@@ -1396,17 +1391,16 @@
 
 %macro IMDCT_FN 1
 INIT_YMM %1
-cglobal mdct_sr_inv_float, 4, 13, 16, 272, ctx, out, in, stride, len, lut, exp, t1, t2, t3, t4, t5, bctx
+cglobal mdct_inv_float, 4, 14, 16, 320, ctx, out, in, stride, len, lut, exp, t1, t2, t3, \
+                                        t4, t5, btmp
     movsxd lenq, dword [ctxq + AVTXContext.len]
     mov expq, [ctxq + AVTXContext.exp]
 
     lea t1d, [lend - 1]
     imul t1d, strided
 
-    mov bctxq, ctxq                    ; backup original context
-    mov t5q, [ctxq + AVTXContext.fn]   ; subtransform's jump point
-    mov ctxq, [ctxq + AVTXContext.sub] ; load subtransform's context
-    mov lutq, [ctxq + AVTXContext.map] ; load subtransform's map
+    mov btmpq, ctxq                    ; backup original context
+    mov lutq, [ctxq + AVTXContext.map] ; load map
 
     cmp strideq, 4
     je .stride4
@@ -1451,8 +1445,8 @@
     fmaddsubps m10, m12, m2, m10
     fmaddsubps m11, m13, m3, m11
 
-    mova [t2q + 0*mmsize], m10
-    mova [t2q + 1*mmsize], m11
+    movups [t2q + 0*mmsize], m10
+    movups [t2q + 1*mmsize], m11
 
     add expq, mmsize*2
     add lutq, mmsize
@@ -1469,16 +1463,16 @@
     lea t2q, [lenq*2 - mmsize/2]
 
 .stride4_pre:
-    movaps       m4, [inq]
-    movaps       m3, [t1q]
+    movups       m4, [inq]
+    movups       m3, [t1q]
 
     movsldup     m1, m4              ; im im, im im
     movshdup     m0, m3              ; re re, re re
     movshdup     m4, m4              ; re re, re re (2)
     movsldup     m3, m3              ; im im, im im (2)
 
-    movaps       m2, [expq]          ; tab
-    movaps       m5, [expq + 2*t2q]  ; tab (2)
+    movups       m2, [expq]          ; tab
+    movups       m5, [expq + 2*t2q]  ; tab (2)
 
     vpermpd      m0, m0, q0123       ; flip
     shufps       m7, m2, m2, q2301
@@ -1520,29 +1514,31 @@
     add inq, mmsize
     sub t1q, mmsize
     sub t2q, mmsize
-    jg .stride4_pre
+    jge .stride4_pre
 
 .transform:
+    mov t4q, ctxq                      ; backup original context
+    mov t5q, [ctxq + AVTXContext.fn]   ; subtransform's jump point
+    mov ctxq, [ctxq + AVTXContext.sub]
+    mov lutq, [ctxq + AVTXContext.map]
     movsxd lenq, dword [ctxq + AVTXContext.len]
+
     mov inq, outq                    ; in-place transform
     call t5q                         ; call the FFT
 
-    mov ctxq, bctxq                  ; restore original context
+    mov ctxq, t4q                    ; restore original context
     movsxd lenq, dword [ctxq + AVTXContext.len]
     mov expq, [ctxq + AVTXContext.exp]
     lea expq, [expq + lenq*4]
 
-    lea t1q, [lenq*2]                ; high
-    lea t2q, [lenq*2 - mmsize]       ; low
-
-    neg lenq
-    lea outq, [outq + lenq*4]
+    xor t1q, t1q                     ; low
+    lea t2q, [lenq*4 - mmsize]       ; high
 
 .post:
-    movaps m2, [expq + t1q]          ; tab h
-    movaps m3, [expq + t2q]          ; tab l
-    movaps m0, [outq + t1q]          ; in h
-    movaps m1, [outq + t2q]          ; in l
+    movaps m2, [expq + t2q]          ; tab h
+    movaps m3, [expq + t1q]          ; tab l
+    movups m0, [outq + t2q]          ; in h
+    movups m1, [outq + t1q]          ; in l
 
     movshdup m4, m2                  ; tab h imim
     movshdup m5, m3                  ; tab l imim
@@ -1564,12 +1560,13 @@
     blendps m1, m2, m5, 01010101b
     blendps m0, m3, m4, 01010101b
 
-    movaps [outq + t2q], m1
-    movaps [outq + t1q], m0
+    movups [outq + t2q], m0
+    movups [outq + t1q], m1
 
     add t1q, mmsize
     sub t2q, mmsize
-    jge .post
+    sub lenq, mmsize/2
+    jg .post
 
     RET
 %endmacro
@@ -1577,3 +1574,278 @@
 %if ARCH_X86_64 && HAVE_AVX2_EXTERNAL
 IMDCT_FN avx2
 %endif
+
+%macro PFA_15_FN 2
+INIT_YMM %1
+%if %2
+cglobal fft_pfa_15xM_asm_float, 0, 0, 0, ctx, out, in, stride, len, lut, buf, map, tgt, tmp, \
+                                         tgt5, stride3, stride5, btmp
+%else
+cglobal fft_pfa_15xM_float, 4, 14, 16, 320, ctx, out, in, stride, len, lut, buf, map, tgt, tmp, \
+                                            tgt5, stride3, stride5, btmp
+%endif
+
+%if %2
+    PUSH inq
+    PUSH tgt5q
+    PUSH stride3q
+    PUSH stride5q
+    PUSH btmpq
+%endif
+
+    mov btmpq, outq
+
+    mov outq, [ctxq + AVTXContext.tmp]
+%if %2 == 0
+    movsxd lenq, dword [ctxq + AVTXContext.len]
+    mov lutq, [ctxq + AVTXContext.map]
+%endif
+
+    ; Load stride (second transform's length) and second transform's LUT
+    mov tmpq, [ctxq + AVTXContext.sub]
+    movsxd strideq, dword [tmpq + AVTXContext.len]
+    mov mapq, [tmpq + AVTXContext.map]
+
+    shl strideq, 3
+    imul stride3q, strideq, 3
+    imul stride5q, strideq, 5
+
+    movaps m13, [mask_mmmmmmpp]      ; mmmmmmpp
+    vpermpd m12, m13, q0033          ; ppppmmmm
+    vextractf128 xm11, m13, 1        ; mmpp
+    movaps m10, [tab_53_float]       ; tab5
+    movaps xm9, [tab_53_float + 32]  ; tab3
+    movaps m8, [s15_perm]
+
+.dim1:
+    mov tmpd, [mapq]
+    lea tgtq, [outq + tmpq*8]
+
+%if %2
+    movups xm0, [inq]
+%else
+    LOAD64_LUT xm0, inq, lutq, 0, tmpq, m14, xm15 ; in[0,1].reim
+%endif
+
+    shufps xm1, xm0, xm0, q3223      ; in[1].imrereim
+    shufps xm0, xm0, xm0, q1001      ; in[0].imrereim
+
+    xorps xm1, xm11
+    addps xm1, xm0                   ; pc[0,1].imre
+
+%if %2
+    movddup xm14, [inq + 16]         ; in[2].reimreim
+%else
+    mov tmpd, [lutq + 8]
+    movddup xm14, [inq + tmpq*8]     ; in[2].reimreim
+%endif
+    shufps xm0, xm1, xm1, q3232      ; pc[1].reimreim
+    addps xm0, xm14                  ; dc[0].reimreim
+
+    mulps xm1, xm9                   ; tab[0123]*pc[01]
+
+    shufpd xm5, xm1, xm1, 01b        ; pc[1,0].reim
+    xorps xm1, xm11
+    addps xm1, xm1, xm5
+    addsubps xm1, xm14, xm1          ; dc[1,2].reim
+
+%if %2
+    movups m2, [inq + mmsize*0 + 24]
+    movups m3, [inq + mmsize*1 + 24]
+%else
+    LOAD64_LUT m2, inq, lutq, (mmsize/2)*0 + 12, tmpq, m14, m15
+    LOAD64_LUT m3, inq, lutq, (mmsize/2)*1 + 12, tmpq, m14, m15
+%endif
+
+    subps m7, m2, m3                 ; q[0-3].imre
+    addps m6, m2, m3                 ; q[4-7]
+    shufps m7, m7, m7, q2301         ; q[0-3].reim
+
+%if %2
+    movups m4, [inq + mmsize*2 + 24]
+%else
+    LOAD64_LUT m4, inq, lutq, (mmsize/2)*2 + 12, tmpq, m14, m15
+%endif
+
+    addps m5, m4, m6                 ; y[0-3]
+
+    vpermpd m14, m9, q1111           ; tab[23232323]
+    vbroadcastsd m15, xm9            ; tab[01010101]
+
+    mulps m6, m14
+    mulps m7, m15
+
+    subps m2, m6, m7                 ; k[0-3]
+    addps m3, m6, m7                 ; k[4-7]
+
+    addsubps m6, m4, m2              ; k[0-3]
+    addsubps m7, m4, m3              ; k[4-7]
+
+    ; 15pt from here on
+    vpermpd m2, m5, q0123            ; y[3-0]
+    vpermpd m3, m6, q0123            ; k[3-0]
+    vpermpd m4, m7, q0123            ; k[7-4]
+
+    xorps m5, m12
+    xorps m6, m12
+    xorps m7, m12
+
+    addps m2, m5                     ; t[0-3]
+    addps m3, m6                     ; t[4-7]
+    addps m4, m7                     ; t[8-11]
+
+    movlhps xm14, xm2                ; out[0]
+    unpcklpd xm7, xm3, xm4           ; out[10,5]
+    unpckhpd xm5, xm3, xm4           ; out[10,5]
+
+    addps xm14, xm2                  ; out[0]
+    addps xm7, xm5                   ; out[10,5]
+    addps xm14, xm0                  ; out[0]
+    addps xm7, xm1                   ; out[10,5]
+
+    movhps [tgtq], xm14              ; out[0]
+    movhps [tgtq + stride5q*1], xm7  ; out[5]
+    movlps [tgtq + stride5q*2], xm7  ; out[10]
+
+    shufps m14, m10, m10, q3232      ; tab5 4 5 4 5  8  9  8  9
+    shufps m15, m10, m10, q1010      ; tab5 6 7 6 7 10 11 10 11
+
+    mulps m5, m2, m14                ; t[0-3]
+    mulps m6, m3, m14                ; t[4-7]
+    mulps m7, m4, m14                ; t[8-11]
+
+    mulps m2, m15                    ; r[0-3]
+    mulps m3, m15                    ; r[4-7]
+    mulps m4, m15                    ; r[8-11]
+
+    shufps m5, m5, m5, q1032         ; t[1,0,3,2].reim
+    shufps m6, m6, m6, q1032         ; t[5,4,7,6].reim
+    shufps m7, m7, m7, q1032         ; t[9,8,11,10].reim
+
+    lea tgt5q, [tgtq + stride5q]
+    lea tmpq,  [tgtq + stride5q*2]
+
+    xorps m5, m13
+    xorps m6, m13
+    xorps m7, m13
+
+    addps m2, m5                     ; r[0,1,2,3]
+    addps m3, m6                     ; r[4,5,6,7]
+    addps m4, m7                     ; r[8,9,10,11]
+
+    shufps m5, m2, m2, q2301
+    shufps m6, m3, m3, q2301
+    shufps m7, m4, m4, q2301
+
+    xorps m2, m12
+    xorps m3, m12
+    xorps m4, m12
+
+    vpermpd m5, m5, q0123
+    vpermpd m6, m6, q0123
+    vpermpd m7, m7, q0123
+
+    addps m5, m2
+    addps m6, m3
+    addps m7, m4
+
+    vpermps m5, m8, m5
+    vpermps m6, m8, m6
+    vpermps m7, m8, m7
+
+    vbroadcastsd m0, xm0             ; dc[0]
+    vpermpd m2, m1, q1111            ; dc[2]
+    vbroadcastsd m1, xm1             ; dc[1]
+
+    addps m0, m5
+    addps m1, m6
+    addps m2, m7
+
+    vextractf128 xm3, m0, 1
+    vextractf128 xm4, m1, 1
+    vextractf128 xm5, m2, 1
+
+    movlps [tgtq  + strideq*1],  xm1
+    movhps [tgtq  + strideq*2],  xm2
+    movlps [tgtq  + stride3q*1], xm3
+    movhps [tgtq  + strideq*4],  xm4
+    movlps [tgtq  + stride3q*2], xm0
+    movlps [tgtq  + strideq*8],  xm5
+    movhps [tgtq  + stride3q*4], xm0
+    movhps [tgt5q + strideq*2],  xm1
+    movhps [tgt5q + strideq*4],  xm3
+    movlps [tmpq  + strideq*1],  xm2
+    movlps [tmpq  + stride3q*1], xm4
+    movhps [tmpq  + strideq*4],  xm5
+
+%if %2
+    add inq, mmsize*3 + 24
+%else
+    add lutq, (mmsize/2)*3 + 12
+%endif
+    add mapq, 4
+    sub lenq, 15
+    jg .dim1
+
+    ; Second transform setup
+    mov stride5q, ctxq                              ; backup original context
+    movsxd stride3q, dword [ctxq + AVTXContext.len] ; full length
+    mov tgt5q, [ctxq + AVTXContext.fn]              ; subtransform's jump point
+
+    mov inq, outq                                   ; in-place transform
+    mov ctxq, [ctxq + AVTXContext.sub]              ; load subtransform's context
+    mov lutq, [ctxq + AVTXContext.map]              ; load subtransform's map
+    movsxd lenq, dword [ctxq + AVTXContext.len]     ; load subtransform's length
+
+.dim2:
+    call tgt5q                                      ; call the FFT
+    lea inq,  [inq  + lenq*8]
+    lea outq, [outq + lenq*8]
+    sub stride3q, lenq
+    jg .dim2
+
+    mov ctxq, stride5q                              ; restore original context
+    mov lutq, [ctxq + AVTXContext.map]
+    mov inq,  [ctxq + AVTXContext.tmp]
+    movsxd lenq, dword [ctxq + AVTXContext.len]     ; full length
+
+    lea stride3q, [lutq + lenq*4]                   ; second part of the LUT
+    mov stride5q, lenq
+    mov tgt5q, btmpq
+
+.post:
+    LOAD64_LUT m0, inq, stride3q, 0, tmpq, m8, m9
+    movups [tgt5q], m0
+
+    add tgt5q, mmsize
+    add stride3q, mmsize/2
+    sub stride5q, mmsize/8
+    jg .post
+
+%if %2
+    mov outq, btmpq
+    POP btmpq
+    POP stride5q
+    POP stride3q
+    POP tgt5q
+    POP inq
+    ret
+%else
+    RET
+%endif
+
+%if %2
+cglobal fft_pfa_15xM_ns_float, 4, 14, 16, 320, ctx, out, in, stride, len, lut, buf, map, tgt, tmp, \
+                                               tgt5, stride3, stride5, btmp
+    movsxd lenq, dword [ctxq + AVTXContext.len]
+    mov lutq, [ctxq + AVTXContext.map]
+
+    call mangle(ff_tx_fft_pfa_15xM_asm_float)
+    RET
+%endif
+%endmacro
+
+%if ARCH_X86_64 && HAVE_AVX2_EXTERNAL
+PFA_15_FN avx2, 0
+PFA_15_FN avx2, 1
+%endif
--- a/third_party/ffmpeg/libavutil/x86/tx_float_init.c
+++ b/third_party/ffmpeg/libavutil/x86/tx_float_init.c
@@ -38,12 +38,17 @@
 TX_DECL_FN(fft32_ns,  avx)
 TX_DECL_FN(fft32,     fma3)
 TX_DECL_FN(fft32_ns,  fma3)
+TX_DECL_FN(fft_sr,    avx)
+TX_DECL_FN(fft_sr_ns, avx)
 TX_DECL_FN(fft_sr,    fma3)
 TX_DECL_FN(fft_sr_ns, fma3)
 TX_DECL_FN(fft_sr,    avx2)
 TX_DECL_FN(fft_sr_ns, avx2)
 
-TX_DECL_FN(mdct_sr_inv, avx2)
+TX_DECL_FN(fft_pfa_15xM, avx2)
+TX_DECL_FN(fft_pfa_15xM_ns, avx2)
+
+TX_DECL_FN(mdct_inv, avx2)
 
 TX_DECL_FN(fft2_asm, sse3)
 TX_DECL_FN(fft4_fwd_asm, sse2)
@@ -54,9 +59,12 @@
 TX_DECL_FN(fft16_asm, fma3)
 TX_DECL_FN(fft32_asm, avx)
 TX_DECL_FN(fft32_asm, fma3)
+TX_DECL_FN(fft_sr_asm, avx)
 TX_DECL_FN(fft_sr_asm, fma3)
 TX_DECL_FN(fft_sr_asm, avx2)
 
+TX_DECL_FN(fft_pfa_15xM_asm, avx2)
+
 #define DECL_INIT_FN(basis, interleave)                                        \
 static av_cold int b ##basis## _i ##interleave(AVTXContext *s,                 \
                                                const FFTXCodelet *cd,          \
@@ -82,7 +90,7 @@
                               int len, int inv, const void *scale)
 {
     int ret;
-    FFTXCodeletOptions sub_opts = { .invert_lookup = -1 };
+    FFTXCodeletOptions sub_opts = { .invert_lookup = 1 };
 
     s->scale_d = *((SCALE_TYPE *)scale);
     s->scale_f = s->scale_d;
@@ -96,9 +104,73 @@
                                 inv, scale)))
         return ret;
 
-    if ((ret = ff_tx_mdct_gen_exp_float(s, s->sub->map)))
+    s->map = av_malloc(len*sizeof(*s->map));
+    if (!s->map)
+        return AVERROR(ENOMEM);
+
+    memcpy(s->map, s->sub->map, (len >> 1)*sizeof(*s->map));
+    /* Invert lookup table for unstrided path */
+    for (int i = 0; i < (len >> 1); i++)
+       s->map[(len >> 1) + s->map[i]] = i;
+
+    if ((ret = ff_tx_mdct_gen_exp_float(s, s->map)))
+        return ret;
+
+    return 0;
+}
+
+static av_cold int fft_pfa_init(AVTXContext *s,
+                                const FFTXCodelet *cd,
+                                uint64_t flags,
+                                FFTXCodeletOptions *opts,
+                                int len, int inv,
+                                const void *scale)
+{
+    int ret;
+    int sub_len = len / cd->factors[0];
+    FFTXCodeletOptions sub_opts = { .invert_lookup = 0 };
+
+    flags &= ~FF_TX_OUT_OF_PLACE; /* We want the subtransform to be */
+    flags |=  AV_TX_INPLACE;      /* in-place */
+    flags |=  FF_TX_PRESHUFFLE;   /* This function handles the permute step */
+    flags |=  FF_TX_ASM_CALL;     /* We want an assembly function, not C */
+
+    if ((ret = ff_tx_init_subtx(s, TX_TYPE(FFT), flags, &sub_opts,
+                                sub_len, inv, scale)))
+        return ret;
+
+    if ((ret = ff_tx_gen_compound_mapping(s, cd->factors[0], sub_len)))
         return ret;
 
+    if (cd->factors[0] == 15) {
+        for (int k = 0; k < s->sub[0].len; k++) {
+            int cnt = 0;
+            int tmp[15];
+            memcpy(tmp, &s->map[k*15], 15*sizeof(*tmp));
+            for (int i = 1; i < 15; i += 3) {
+                s->map[k*15 + cnt] = tmp[i];
+                cnt++;
+            }
+            for (int i = 2; i < 15; i += 3) {
+                s->map[k*15 + cnt] = tmp[i];
+                cnt++;
+            }
+            for (int i = 0; i < 15; i += 3) {
+                s->map[k*15 + cnt] = tmp[i];
+                cnt++;
+            }
+            memmove(&s->map[k*15 + 7], &s->map[k*15 + 6], 4*sizeof(int));
+            memmove(&s->map[k*15 + 3], &s->map[k*15 + 1], 4*sizeof(int));
+            s->map[k*15 + 1] = tmp[2];
+            s->map[k*15 + 2] = tmp[0];
+        }
+    }
+
+    if (!(s->tmp = av_malloc(len*sizeof(*s->tmp))))
+        return AVERROR(ENOMEM);
+
+    TX_TAB(ff_tx_init_tabs)(len / sub_len);
+
     return 0;
 }
 
@@ -145,11 +217,17 @@
            AV_TX_INPLACE | FF_TX_PRESHUFFLE | FF_TX_ASM_CALL, AV_CPU_FLAG_AVXSLOW),
     TX_DEF(fft32_ns, FFT, 32, 32, 2, 0, 352, b8_i2, fma3, FMA3, AV_TX_INPLACE | FF_TX_PRESHUFFLE,
            AV_CPU_FLAG_AVXSLOW),
+    TX_DEF(fft_sr,    FFT, 64, 131072, 2, 0, 256, b8_i2, avx, AVX,  0, AV_CPU_FLAG_AVXSLOW),
+    TX_DEF(fft_sr_asm, FFT, 64, 131072, 2, 0, 320, b8_i2, avx, AVX,
+           AV_TX_INPLACE | FF_TX_PRESHUFFLE | FF_TX_ASM_CALL, AV_CPU_FLAG_AVXSLOW),
+    TX_DEF(fft_sr_ns, FFT, 64, 131072, 2, 0, 320, b8_i2, avx, AVX,  AV_TX_INPLACE | FF_TX_PRESHUFFLE,
+           AV_CPU_FLAG_AVXSLOW),
     TX_DEF(fft_sr,    FFT, 64, 131072, 2, 0, 288, b8_i2, fma3,  FMA3,  0, AV_CPU_FLAG_AVXSLOW),
     TX_DEF(fft_sr_asm, FFT, 64, 131072, 2, 0, 352, b8_i2, fma3,  FMA3,
            AV_TX_INPLACE | FF_TX_PRESHUFFLE | FF_TX_ASM_CALL, AV_CPU_FLAG_AVXSLOW),
     TX_DEF(fft_sr_ns, FFT, 64, 131072, 2, 0, 352, b8_i2, fma3,  FMA3,  AV_TX_INPLACE | FF_TX_PRESHUFFLE,
            AV_CPU_FLAG_AVXSLOW),
+
 #if HAVE_AVX2_EXTERNAL
     TX_DEF(fft_sr,    FFT, 64, 131072, 2, 0, 320, b8_i2, avx2, AVX2, 0,
            AV_CPU_FLAG_AVXSLOW | AV_CPU_FLAG_SLOW_GATHER),
@@ -158,7 +236,14 @@
     TX_DEF(fft_sr_ns, FFT, 64, 131072, 2, 0, 384, b8_i2, avx2, AVX2, AV_TX_INPLACE | FF_TX_PRESHUFFLE,
            AV_CPU_FLAG_AVXSLOW | AV_CPU_FLAG_SLOW_GATHER),
 
-    TX_DEF(mdct_sr_inv, MDCT, 16, TX_LEN_UNLIMITED, 2, TX_FACTOR_ANY, 384, m_inv_init, avx2, AVX2,
+    TX_DEF(fft_pfa_15xM, FFT, 60, TX_LEN_UNLIMITED, 15, TX_FACTOR_ANY, 320, fft_pfa_init, avx2, AVX2,
+           AV_TX_INPLACE, AV_CPU_FLAG_AVXSLOW | AV_CPU_FLAG_SLOW_GATHER),
+    TX_DEF(fft_pfa_15xM_asm, FFT, 60, TX_LEN_UNLIMITED, 15, TX_FACTOR_ANY, 384, fft_pfa_init, avx2, AVX2,
+           AV_TX_INPLACE | FF_TX_PRESHUFFLE | FF_TX_ASM_CALL, AV_CPU_FLAG_AVXSLOW | AV_CPU_FLAG_SLOW_GATHER),
+    TX_DEF(fft_pfa_15xM_ns, FFT, 60, TX_LEN_UNLIMITED, 15, TX_FACTOR_ANY, 384, fft_pfa_init, avx2, AVX2,
+           AV_TX_INPLACE | FF_TX_PRESHUFFLE, AV_CPU_FLAG_AVXSLOW | AV_CPU_FLAG_SLOW_GATHER),
+
+    TX_DEF(mdct_inv, MDCT, 16, TX_LEN_UNLIMITED, 2, TX_FACTOR_ANY, 384, m_inv_init, avx2, AVX2,
            FF_TX_INVERSE_ONLY, AV_CPU_FLAG_AVXSLOW | AV_CPU_FLAG_SLOW_GATHER),
 #endif
 #endif
--- a/third_party/ffmpeg/libswresample/swresample.h
+++ b/third_party/ffmpeg/libswresample/swresample.h
@@ -73,7 +73,7 @@
  *
  * Once all values have been set, it must be initialized with swr_init(). If
  * you need to change the conversion parameters, you can change the parameters
- * using @ref AVOptions, as described above in the first example; or by using
+ * using @ref avoptions, as described above in the first example; or by using
  * swr_alloc_set_opts2(), but with the first argument the allocated context.
  * You must then call swr_init() again.
  *
@@ -354,8 +354,8 @@
  *              in this case the output timestamps will match output sample numbers.
  *              See ffmpeg-resampler(1) for the two modes of compensation.
  *
- * @param s[in]     initialized Swr context
- * @param pts[in]   timestamp for the next input sample, INT64_MIN if unknown
+ * @param[in] s     initialized Swr context
+ * @param[in] pts   timestamp for the next input sample, INT64_MIN if unknown
  * @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are
  *      function used internally for timestamp compensation.
  * @return the output timestamp for the next output sample
@@ -636,8 +636,8 @@
  * @see swr_close();
  *
  * @param swr             audio resample context
- * @param output          output AVFrame
- * @param input           input AVFrame
+ * @param out             output AVFrame
+ * @param in              input AVFrame
  * @return                0 on success, AVERROR on failure.
  */
 int swr_config_frame(SwrContext *swr, const AVFrame *out, const AVFrame *in);
--- a/third_party/ffmpeg/libswscale/aarch64/yuv2rgb_neon.S
+++ b/third_party/ffmpeg/libswscale/aarch64/yuv2rgb_neon.S
@@ -118,8 +118,8 @@
 .endm
 
 .macro increment_yuv422p
-    add                 x6,  x6,  w7, UXTW                              // srcU += incU
-    add                 x13, x13, w14, UXTW                             // srcV += incV
+    add                 x6,  x6,  w7, SXTW                              // srcU += incU
+    add                 x13, x13, w14, SXTW                             // srcV += incV
 .endm
 
 .macro compute_rgba r1 g1 b1 a1 r2 g2 b2 a2
@@ -189,8 +189,8 @@
     st4                 {v16.8B,v17.8B,v18.8B,v19.8B}, [x2], #32
     subs                w8, w8, #16                                     // width -= 16
     b.gt                2b
-    add                 x2, x2, w3, UXTW                                // dst  += padding
-    add                 x4, x4, w5, UXTW                                // srcY += paddingY
+    add                 x2, x2, w3, SXTW                                // dst  += padding
+    add                 x4, x4, w5, SXTW                                // srcY += paddingY
     increment_\ifmt
     subs                w1, w1, #1                                      // height -= 1
     b.gt                1b
--- a/third_party/ffmpeg/libswscale/rgb2rgb.c
+++ b/third_party/ffmpeg/libswscale/rgb2rgb.c
@@ -139,6 +139,8 @@
     rgb2rgb_init_c();
 #if ARCH_AARCH64
     rgb2rgb_init_aarch64();
+#elif ARCH_RISCV
+    rgb2rgb_init_riscv();
 #elif ARCH_X86
     rgb2rgb_init_x86();
 #elif ARCH_LOONGARCH64
--- a/third_party/ffmpeg/libswscale/rgb2rgb.h
+++ b/third_party/ffmpeg/libswscale/rgb2rgb.h
@@ -167,6 +167,7 @@
 void ff_sws_rgb2rgb_init(void);
 
 void rgb2rgb_init_aarch64(void);
+void rgb2rgb_init_riscv(void);
 void rgb2rgb_init_x86(void);
 void rgb2rgb_init_loongarch(void);
 
--- /dev/null
+++ b/third_party/ffmpeg/libswscale/riscv/Makefile
@@ -0,0 +1,2 @@
+OBJS += riscv/rgb2rgb.o
+RVV-OBJS += riscv/rgb2rgb_rvv.o
--- /dev/null
+++ b/third_party/ffmpeg/libswscale/riscv/rgb2rgb.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libswscale/rgb2rgb.h"
+
+void ff_shuffle_bytes_0321_rvv(const uint8_t *src, uint8_t *dst, int src_len);
+void ff_shuffle_bytes_2103_rvv(const uint8_t *src, uint8_t *dst, int src_len);
+void ff_shuffle_bytes_1230_rvv(const uint8_t *src, uint8_t *dst, int src_len);
+void ff_shuffle_bytes_3012_rvv(const uint8_t *src, uint8_t *dst, int src_len);
+void ff_shuffle_bytes_3210_rvv(const uint8_t *src, uint8_t *dst, int src_len);
+void ff_interleave_bytes_rvv(const uint8_t *src1, const uint8_t *src2,
+                             uint8_t *dst, int width, int height, int s1stride,
+                             int s2stride, int dstride);
+void ff_uyvytoyuv422_rvv(uint8_t *ydst, uint8_t *udst, uint8_t *vdst,
+                         const uint8_t *src, int width, int height,
+                         int ystride, int uvstride, int src_stride);
+void ff_yuyvtoyuv422_rvv(uint8_t *ydst, uint8_t *udst, uint8_t *vdst,
+                         const uint8_t *src, int width, int height,
+                         int ystride, int uvstride, int src_stride);
+
+av_cold void rgb2rgb_init_riscv(void)
+{
+#if HAVE_RVV
+    int flags = av_get_cpu_flags();
+
+    if (flags & AV_CPU_FLAG_RVV_I32) {
+        shuffle_bytes_0321 = ff_shuffle_bytes_0321_rvv;
+        shuffle_bytes_2103 = ff_shuffle_bytes_2103_rvv;
+        shuffle_bytes_1230 = ff_shuffle_bytes_1230_rvv;
+        shuffle_bytes_3012 = ff_shuffle_bytes_3012_rvv;
+        shuffle_bytes_3210 = ff_shuffle_bytes_3210_rvv;
+        interleaveBytes = ff_interleave_bytes_rvv;
+#if (__riscv_xlen == 64)
+        uyvytoyuv422 = ff_uyvytoyuv422_rvv;
+        yuyvtoyuv422 = ff_yuyvtoyuv422_rvv;
+#endif
+    }
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libswscale/riscv/rgb2rgb_rvv.S
@@ -0,0 +1,157 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_shuffle_bytes_0321_rvv, zve32x
+        addi    t1, a0, 3
+        addi    t2, a0, 2
+        addi    t3, a0, 1
+1:
+        srai    a2, a2, 2
+        li      t4, 4
+2:
+        vsetvli    t0, a2, e8, m1, ta, ma
+        sub        a2, a2, t0
+        vlse8.v    v8, (a0), t4
+        sh2add     a0, t0, a0
+        vlse8.v    v9, (t1), t4
+        sh2add     t1, t0, t1
+        vlse8.v    v10, (t2), t4
+        sh2add     t2, t0, t2
+        vlse8.v    v11, (t3), t4
+        sh2add     t3, t0, t3
+        vsseg4e8.v v8, (a1)
+        sh2add     a1, t0, a1
+        bnez       a2, 2b
+
+        ret
+endfunc
+
+func ff_shuffle_bytes_2103_rvv, zve32x
+        addi    t1, a0, 1
+        addi    t2, a0, 0
+        addi    t3, a0, 3
+        addi    a0, a0, 2
+        j       1b
+endfunc
+
+func ff_shuffle_bytes_1230_rvv, zve32x
+        addi    t1, a0, 2
+        addi    t2, a0, 3
+        addi    t3, a0, 0
+        addi    a0, a0, 1
+        j       1b
+endfunc
+
+func ff_shuffle_bytes_3012_rvv, zve32x
+        addi    t1, a0, 0
+        addi    t2, a0, 1
+        addi    t3, a0, 2
+        addi    a0, a0, 3
+        j       1b
+endfunc
+
+func ff_shuffle_bytes_3210_rvv, zve32x
+        addi    t1, a0, 2
+        addi    t2, a0, 1
+        addi    t3, a0, 0
+        addi    a0, a0, 3
+        j       1b
+endfunc
+
+func ff_interleave_bytes_rvv, zve32x
+1:
+        mv      t0, a0
+        mv      t1, a1
+        mv      t2, a2
+        mv      t3, a3
+        addi    a4, a4, -1
+2:
+        vsetvli    t4, t3, e8, ta, ma
+        sub        t3, t3, t4
+        vle8.v     v8, (t0)
+        add        t0, t4, t0
+        vle8.v     v9, (t1)
+        add        t1, t4, t1
+        vsseg2e8.v v8, (t2)
+        sh1add     t2, t4, t2
+        bnez       t4, 2b
+
+        add     a0, a0, a5
+        add     a1, a1, a6
+        add     a2, a2, a7
+        bnez    a4, 1b
+
+        ret
+endfunc
+
+#if (__riscv_xlen == 64)
+.macro yuy2_to_i422p v_y0, v_y1, v_u, v_v
+        addi    sp, sp, -16
+        sd      s0,   (sp)
+        sd      s1,  8(sp)
+        addi    a4, a4, 1
+        lw      s0, 16(sp)
+        srai    a4, a4, 1 // pixel width -> chroma width
+        li      s1, 2
+1:
+        mv      t4, a4
+        mv      t3, a3
+        mv      t0, a0
+        addi    t6, a0, 1
+        mv      t1, a1
+        mv      t2, a2
+        addi    a5, a5, -1
+2:
+        vsetvli    t5, t4, e8, m1, ta, ma
+        sub        t4, t4, t5
+        vlseg4e8.v v8, (t3)
+        sh2add     t3, t5, t3
+        vsse8.v    \v_y0, (t0), s1
+        sh1add     t0, t5, t0
+        vsse8.v    \v_y1, (t6), s1
+        sh1add     t6, t5, t6
+        vse8.v     \v_u, (t1)
+        add        t1, t5, t1
+        vse8.v     \v_v, (t2)
+        add        t2, t5, t2
+        bnez       t4, 2b
+
+        add     a3, a3, s0
+        add     a0, a0, a6
+        add     a1, a1, a7
+        add     a2, a2, a7
+        bnez    a5, 1b
+
+        ld      s1,  8(sp)
+        ld      s0,   (sp)
+        addi    sp, sp, 16
+        ret
+.endm
+
+func ff_uyvytoyuv422_rvv, zve32x
+        yuy2_to_i422p v9, v11, v8, v10
+endfunc
+
+func ff_yuyvtoyuv422_rvv, zve32x
+        yuy2_to_i422p v8, v10, v9, v11
+endfunc
+#endif
--- a/third_party/ffmpeg/libswscale/swscale.h
+++ b/third_party/ffmpeg/libswscale/swscale.h
@@ -234,6 +234,7 @@
  * - sws_receive_slice(0, dst->height)
  * - sws_frame_end()
  *
+ * @param c   The scaling context
  * @param dst The destination frame. See documentation for sws_frame_start() for
  *            more details.
  * @param src The source frame.
@@ -249,6 +250,7 @@
  * This function will retain references to src and dst, so they must both use
  * refcounted buffers (if allocated by the caller, in case of dst).
  *
+ * @param c   The scaling context
  * @param dst The destination frame.
  *
  *            The data buffers may either be already allocated by the caller or
@@ -273,6 +275,8 @@
  * submitted with sws_frame_start(). Must be called after all sws_send_slice()
  * and sws_receive_slice() calls are done, before any new sws_frame_start()
  * calls.
+ *
+ * @param c   The scaling context
  */
 void sws_frame_end(struct SwsContext *c);
 
@@ -282,6 +286,7 @@
  * any order, but may not overlap. For vertically subsampled pixel formats, the
  * slices must be aligned according to subsampling.
  *
+ * @param c   The scaling context
  * @param slice_start first row of the slice
  * @param slice_height number of rows in the slice
  *
@@ -294,6 +299,7 @@
  * Request a horizontal slice of the output data to be written into the frame
  * previously provided to sws_frame_start().
  *
+ * @param c   The scaling context
  * @param slice_start first row of the slice; must be a multiple of
  *                    sws_receive_slice_alignment()
  * @param slice_height number of rows in the slice; must be a multiple of
@@ -310,6 +316,9 @@
                       unsigned int slice_height);
 
 /**
+ * Get the alignment required for slices
+ *
+ * @param c   The scaling context
  * @return alignment required for output slices requested with sws_receive_slice().
  *         Slice offsets and sizes passed to sws_receive_slice() must be
  *         multiples of the value returned from this function.
@@ -317,6 +326,7 @@
 unsigned int sws_receive_slice_alignment(const struct SwsContext *c);
 
 /**
+ * @param c the scaling context
  * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)
  * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)
  * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]
@@ -324,22 +334,17 @@
  * @param brightness 16.16 fixed point brightness correction
  * @param contrast 16.16 fixed point contrast correction
  * @param saturation 16.16 fixed point saturation correction
-#if LIBSWSCALE_VERSION_MAJOR > 6
- * @return negative error code on error, non negative otherwise
-#else
- * @return -1 if not supported
-#endif
+ *
+ * @return A negative error code on error, non negative otherwise.
+ *         If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported.
  */
 int sws_setColorspaceDetails(struct SwsContext *c, const int inv_table[4],
                              int srcRange, const int table[4], int dstRange,
                              int brightness, int contrast, int saturation);
 
 /**
-#if LIBSWSCALE_VERSION_MAJOR > 6
- * @return negative error code on error, non negative otherwise
-#else
- * @return -1 if not supported
-#endif
+ * @return A negative error code on error, non negative otherwise.
+ *         If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported.
  */
 int sws_getColorspaceDetails(struct SwsContext *c, int **inv_table,
                              int *srcRange, int **table, int *dstRange,
--- a/third_party/ffmpeg/libswscale/swscale_unscaled.c
+++ b/third_party/ffmpeg/libswscale/swscale_unscaled.c
@@ -2095,6 +2095,7 @@
         c->convert_unscaled = rgbToPlanarRgbWrapper;
 
     if (isBayer(srcFormat)) {
+        c->dst_slice_align = 2;
         if (dstFormat == AV_PIX_FMT_RGB24)
             c->convert_unscaled = bayer_to_rgb24_wrapper;
         else if (dstFormat == AV_PIX_FMT_RGB48)
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/apac.c
@@ -0,0 +1,269 @@
+/*
+ * APAC audio decoder
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/audio_fifo.h"
+#include "libavutil/internal.h"
+#include "libavutil/intreadwrite.h"
+#include "avcodec.h"
+#include "codec_internal.h"
+#include "decode.h"
+#include "get_bits.h"
+
+typedef struct ChContext {
+    int have_code;
+    int last_sample;
+    int last_delta;
+    int bit_length;
+    int block_length;
+    uint8_t block[32 * 2];
+    AVAudioFifo *samples;
+} ChContext;
+
+typedef struct APACContext {
+    GetBitContext gb;
+    int skip;
+
+    int cur_ch;
+    ChContext ch[2];
+
+    uint8_t *bitstream;
+    int64_t max_framesize;
+    int bitstream_size;
+    int bitstream_index;
+} APACContext;
+
+static av_cold int apac_close(AVCodecContext *avctx)
+{
+    APACContext *s = avctx->priv_data;
+
+    av_freep(&s->bitstream);
+    s->bitstream_size = 0;
+
+    for (int ch = 0; ch < 2; ch++) {
+        ChContext *c = &s->ch[ch];
+
+        av_audio_fifo_free(c->samples);
+    }
+
+    return 0;
+}
+
+static av_cold int apac_init(AVCodecContext *avctx)
+{
+    APACContext *s = avctx->priv_data;
+
+    if (avctx->bits_per_coded_sample > 8)
+        avctx->sample_fmt = AV_SAMPLE_FMT_S16P;
+    else
+        avctx->sample_fmt = AV_SAMPLE_FMT_U8P;
+
+    if (avctx->ch_layout.nb_channels < 1 ||
+        avctx->ch_layout.nb_channels > 2)
+        return AVERROR_INVALIDDATA;
+
+    for (int ch = 0; ch < avctx->ch_layout.nb_channels; ch++) {
+        ChContext *c = &s->ch[ch];
+
+        c->bit_length = avctx->bits_per_coded_sample;
+        c->block_length = 8;
+        c->have_code = 0;
+        c->samples = av_audio_fifo_alloc(avctx->sample_fmt, 1, 1024);
+        if (!c->samples)
+            return AVERROR(ENOMEM);
+    }
+
+    s->max_framesize = 1024;
+    s->bitstream = av_realloc_f(s->bitstream, s->max_framesize + AV_INPUT_BUFFER_PADDING_SIZE, sizeof(*s->bitstream));
+    if (!s->bitstream)
+        return AVERROR(ENOMEM);
+
+    return 0;
+}
+
+static int get_code(ChContext *c, GetBitContext *gb)
+{
+    if (get_bits1(gb)) {
+        int code = get_bits(gb, 2);
+
+        switch (code) {
+        case 0:
+            c->bit_length--;
+            break;
+        case 1:
+            c->bit_length++;
+            break;
+        case 2:
+            c->bit_length = get_bits(gb, 5);
+            break;
+        case 3:
+            c->block_length = get_bits(gb, 4);
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+static int apac_decode(AVCodecContext *avctx, AVFrame *frame,
+                       int *got_frame_ptr, AVPacket *pkt)
+{
+    APACContext *s = avctx->priv_data;
+    GetBitContext *gb = &s->gb;
+    int ret, n, buf_size, input_buf_size;
+    const uint8_t *buf;
+    int nb_samples;
+
+    if (!pkt->size && s->bitstream_size <= 0) {
+        *got_frame_ptr = 0;
+        return 0;
+    }
+
+    buf_size = pkt->size;
+    input_buf_size = buf_size;
+
+    if (s->bitstream_index > 0 && s->bitstream_size > 0) {
+        memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size);
+        s->bitstream_index = 0;
+    }
+
+    if (s->bitstream_index + s->bitstream_size + buf_size > s->max_framesize) {
+        s->bitstream = av_realloc_f(s->bitstream, s->bitstream_index +
+                                    s->bitstream_size +
+                                    buf_size + AV_INPUT_BUFFER_PADDING_SIZE,
+                                    sizeof(*s->bitstream));
+        if (!s->bitstream)
+            return AVERROR(ENOMEM);
+        s->max_framesize = s->bitstream_index + s->bitstream_size + buf_size;
+    }
+    if (pkt->data)
+        memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], pkt->data, buf_size);
+    buf                = &s->bitstream[s->bitstream_index];
+    buf_size          += s->bitstream_size;
+    s->bitstream_size  = buf_size;
+
+    frame->nb_samples = s->bitstream_size * 16 * 8;
+    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
+        return ret;
+
+    if ((ret = init_get_bits8(gb, buf, buf_size)) < 0)
+        return ret;
+
+    skip_bits(gb, s->skip);
+    s->skip = 0;
+
+    while (get_bits_left(gb) > 0) {
+        for (int ch = s->cur_ch; ch < avctx->ch_layout.nb_channels; ch++) {
+            ChContext *c = &s->ch[ch];
+            int16_t *dst16 = (int16_t *)c->block;
+            uint8_t *dst8 = (uint8_t *)c->block;
+            void *samples[4];
+
+            samples[0] = &c->block[0];
+            if (get_bits_left(gb) < 16 && pkt->size) {
+                s->cur_ch = ch;
+                goto end;
+            }
+
+            if (!c->have_code && get_code(c, gb))
+                get_code(c, gb);
+            c->have_code = 0;
+
+            if (c->block_length <= 0)
+                continue;
+
+            if (c->bit_length < 0 ||
+                c->bit_length > 17) {
+                c->bit_length = avctx->bits_per_coded_sample;
+                return AVERROR_INVALIDDATA;
+            }
+
+            if (get_bits_left(gb) < c->block_length * c->bit_length && pkt->size) {
+                c->have_code = 1;
+                s->cur_ch = ch;
+                goto end;
+            }
+
+            for (int i = 0; i < c->block_length; i++) {
+                int val = get_bits_long(gb, c->bit_length);
+                int delta = (val & 1) ? ~(val >> 1) : (val >> 1);
+                int sample;
+
+                delta += c->last_delta;
+                sample = c->last_sample + delta;
+                c->last_delta = delta;
+                c->last_sample = sample;
+
+                switch (avctx->sample_fmt) {
+                case AV_SAMPLE_FMT_S16P:
+                    dst16[i] = sample;
+                    break;
+                case AV_SAMPLE_FMT_U8P:
+                    dst8[i] = sample;
+                    break;
+                }
+            }
+
+            av_audio_fifo_write(c->samples, samples, c->block_length);
+        }
+
+        s->cur_ch = 0;
+    }
+end:
+    nb_samples = frame->nb_samples;
+    for (int ch = 0; ch < avctx->ch_layout.nb_channels; ch++)
+        nb_samples = FFMIN(av_audio_fifo_size(s->ch[ch].samples), nb_samples);
+
+    frame->nb_samples = nb_samples;
+    for (int ch = 0; ch < avctx->ch_layout.nb_channels; ch++) {
+        void *samples[1] = { frame->extended_data[ch] };
+        av_audio_fifo_read(s->ch[ch].samples, samples, nb_samples);
+    }
+
+    s->skip = get_bits_count(gb) - 8 * (get_bits_count(gb) / 8);
+    n = get_bits_count(gb) / 8;
+
+    if (nb_samples > 0 || pkt->size)
+        *got_frame_ptr = 1;
+
+    if (s->bitstream_size > 0) {
+        s->bitstream_index += n;
+        s->bitstream_size  -= n;
+        return input_buf_size;
+    }
+    return n;
+}
+
+const FFCodec ff_apac_decoder = {
+    .p.name           = "apac",
+    CODEC_LONG_NAME("Marian's A-pac audio"),
+    .p.type           = AVMEDIA_TYPE_AUDIO,
+    .p.id             = AV_CODEC_ID_APAC,
+    .priv_data_size   = sizeof(APACContext),
+    .init             = apac_init,
+    FF_CODEC_DECODE_CB(apac_decode),
+    .close            = apac_close,
+    .p.capabilities   = AV_CODEC_CAP_DELAY |
+                        AV_CODEC_CAP_DR1 |
+                        AV_CODEC_CAP_SUBFRAMES,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
+    .p.sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,
+                                                        AV_SAMPLE_FMT_S16P,
+                                                        AV_SAMPLE_FMT_NONE },
+};
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/dts2pts_bsf.c
@@ -0,0 +1,535 @@
+/*
+ * Copyright (c) 2022 James Almer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Derive PTS by reordering DTS from supported streams
+ */
+
+#include "libavutil/avassert.h"
+#include "libavutil/fifo.h"
+#include "libavutil/tree.h"
+
+#include "bsf.h"
+#include "bsf_internal.h"
+#include "cbs.h"
+#include "cbs_h264.h"
+#include "h264_parse.h"
+#include "h264_ps.h"
+
+typedef struct DTS2PTSNode {
+    int64_t      dts;
+    int64_t duration;
+    int          poc;
+    int          gop;
+} DTS2PTSNode;
+
+typedef struct DTS2PTSFrame {
+    AVPacket    *pkt;
+    int          poc;
+    int     poc_diff;
+    int          gop;
+} DTS2PTSFrame;
+
+typedef struct DTS2PTSH264Context {
+    H264POCContext poc;
+    SPS sps;
+    int poc_diff;
+    int last_poc;
+    int highest_poc;
+    int picture_structure;
+} DTS2PTSH264Context;
+
+typedef struct DTS2PTSContext {
+    struct AVTreeNode *root;
+    AVFifo *fifo;
+
+    // Codec specific function pointers and constants
+    int (*init)(AVBSFContext *ctx);
+    int (*filter)(AVBSFContext *ctx);
+    void (*flush)(AVBSFContext *ctx);
+    size_t fifo_size;
+
+    CodedBitstreamContext *cbc;
+    CodedBitstreamFragment au;
+
+    union {
+        DTS2PTSH264Context h264;
+    } u;
+
+    int nb_frame;
+    int gop;
+    int eof;
+} DTS2PTSContext;
+
+// AVTreeNode callbacks
+static int cmp_insert(const void *key, const void *node)
+{
+    int ret = ((const DTS2PTSNode *)key)->poc - ((const DTS2PTSNode *)node)->poc;
+    if (!ret)
+        ret = ((const DTS2PTSNode *)key)->gop - ((const DTS2PTSNode *)node)->gop;
+    return ret;
+}
+
+static int cmp_find(const void *key, const void *node)
+{
+    int ret = ((const DTS2PTSFrame *)key)->poc - ((const DTS2PTSNode *) node)->poc;
+    if (!ret)
+        ret = ((const DTS2PTSFrame *)key)->gop - ((const DTS2PTSNode *) node)->gop;
+    return ret;
+}
+
+static int dec_poc(void *opaque, void *elem)
+{
+    DTS2PTSNode *node = elem;
+    int dec = *(int *)opaque;
+    node->poc -= dec;
+    return 0;
+}
+
+static int free_node(void *opaque, void *elem)
+{
+    DTS2PTSNode *node = elem;
+    av_free(node);
+    return 0;
+}
+
+// Shared functions
+static int alloc_and_insert_node(AVBSFContext *ctx, int64_t ts, int64_t duration,
+                                 int poc, int poc_diff, int gop)
+{
+    DTS2PTSContext *s = ctx->priv_data;
+    for (int i = 0; i < poc_diff; i++) {
+        struct AVTreeNode *node = av_tree_node_alloc();
+        DTS2PTSNode *poc_node, *ret;
+        if (!node)
+            return AVERROR(ENOMEM);
+        poc_node = av_malloc(sizeof(*poc_node));
+        if (!poc_node) {
+            av_free(node);
+            return AVERROR(ENOMEM);
+        }
+        if (i && ts != AV_NOPTS_VALUE)
+            ts += duration / poc_diff;
+        *poc_node = (DTS2PTSNode) { ts, duration, poc++, gop };
+        ret = av_tree_insert(&s->root, poc_node, cmp_insert, &node);
+        if (ret && ret != poc_node) {
+            *ret = *poc_node;
+            av_free(poc_node);
+            av_free(node);
+        }
+    }
+    return 0;
+}
+
+// H.264
+static const CodedBitstreamUnitType h264_decompose_unit_types[] = {
+    H264_NAL_SPS,
+    H264_NAL_PPS,
+    H264_NAL_IDR_SLICE,
+    H264_NAL_SLICE,
+};
+
+static int h264_init(AVBSFContext *ctx)
+{
+    DTS2PTSContext *s = ctx->priv_data;
+    DTS2PTSH264Context *h264 = &s->u.h264;
+
+    s->cbc->decompose_unit_types    = h264_decompose_unit_types;
+    s->cbc->nb_decompose_unit_types = FF_ARRAY_ELEMS(h264_decompose_unit_types);
+
+    s->nb_frame = -(ctx->par_in->video_delay << 1);
+    h264->last_poc = h264->highest_poc = INT_MIN;
+
+    return 0;
+}
+
+static int get_mmco_reset(const H264RawSliceHeader *header)
+{
+    if (header->nal_unit_header.nal_ref_idc == 0 ||
+        !header->adaptive_ref_pic_marking_mode_flag)
+        return 0;
+
+    for (int i = 0; i < H264_MAX_MMCO_COUNT; i++) {
+        if (header->mmco[i].memory_management_control_operation == 0)
+            return 0;
+        else if (header->mmco[i].memory_management_control_operation == 5)
+            return 1;
+    }
+
+    return 0;
+}
+
+static int h264_queue_frame(AVBSFContext *ctx, AVPacket *pkt, int poc, int *queued)
+{
+    DTS2PTSContext *s = ctx->priv_data;
+    DTS2PTSH264Context *h264 = &s->u.h264;
+    DTS2PTSFrame frame;
+    int poc_diff, ret;
+
+    poc_diff = (h264->picture_structure == 3) + 1;
+    if (h264->sps.frame_mbs_only_flag && h264->poc_diff)
+        poc_diff = FFMIN(poc_diff, h264->poc_diff);
+    if (poc < 0) {
+        av_tree_enumerate(s->root, &poc_diff, NULL, dec_poc);
+        s->nb_frame -= poc_diff;
+    }
+    // Check if there was a POC reset (Like an IDR slice)
+    if (s->nb_frame > h264->highest_poc) {
+        s->nb_frame = 0;
+        s->gop = (s->gop + 1) % s->fifo_size;
+        h264->highest_poc = h264->last_poc;
+    }
+
+    ret = alloc_and_insert_node(ctx, pkt->dts, pkt->duration, s->nb_frame, poc_diff, s->gop);
+    if (ret < 0)
+        return ret;
+    av_log(ctx, AV_LOG_DEBUG, "Queueing frame with POC %d, GOP %d, dts %"PRId64"\n",
+           poc, s->gop, pkt->dts);
+    s->nb_frame += poc_diff;
+
+    // Add frame to output FIFO only once
+    if (*queued)
+        return 0;
+
+    frame = (DTS2PTSFrame) { pkt, poc, poc_diff, s->gop };
+    ret = av_fifo_write(s->fifo, &frame, 1);
+    av_assert2(ret >= 0);
+    *queued = 1;
+
+    return 0;
+}
+
+static int h264_filter(AVBSFContext *ctx)
+{
+    DTS2PTSContext *s = ctx->priv_data;
+    DTS2PTSH264Context *h264 = &s->u.h264;
+    CodedBitstreamFragment *au = &s->au;
+    AVPacket *in;
+    int output_picture_number = INT_MIN;
+    int field_poc[2];
+    int queued = 0, ret;
+
+    ret = ff_bsf_get_packet(ctx, &in);
+    if (ret < 0)
+        return ret;
+
+    ret = ff_cbs_read_packet(s->cbc, au, in);
+    if (ret < 0) {
+        av_log(ctx, AV_LOG_WARNING, "Failed to parse access unit.\n");
+        goto fail;
+    }
+
+    for (int i = 0; i < au->nb_units; i++) {
+        CodedBitstreamUnit *unit = &au->units[i];
+
+        switch (unit->type) {
+        case H264_NAL_IDR_SLICE:
+            h264->poc.prev_frame_num        = 0;
+            h264->poc.prev_frame_num_offset = 0;
+            h264->poc.prev_poc_msb          =
+            h264->poc.prev_poc_lsb          = 0;
+        // fall-through
+        case H264_NAL_SLICE: {
+            const H264RawSlice *slice = unit->content;
+            const H264RawSliceHeader *header = &slice->header;
+            const CodedBitstreamH264Context *cbs_h264 = s->cbc->priv_data;
+            const H264RawSPS *sps = cbs_h264->active_sps;
+            int got_reset;
+
+            if (!sps) {
+                av_log(ctx, AV_LOG_ERROR, "No active SPS for a slice\n");
+                goto fail;
+            }
+            // Initialize the SPS struct with the fields ff_h264_init_poc() cares about
+            h264->sps.frame_mbs_only_flag            = sps->frame_mbs_only_flag;
+            h264->sps.log2_max_frame_num             = sps->log2_max_frame_num_minus4 + 4;
+            h264->sps.poc_type                       = sps->pic_order_cnt_type;
+            h264->sps.log2_max_poc_lsb               = sps->log2_max_pic_order_cnt_lsb_minus4 + 4;
+            h264->sps.offset_for_non_ref_pic         = sps->offset_for_non_ref_pic;
+            h264->sps.offset_for_top_to_bottom_field = sps->offset_for_top_to_bottom_field;
+            h264->sps.poc_cycle_length               = sps->num_ref_frames_in_pic_order_cnt_cycle;
+            for (int i = 0; i < h264->sps.poc_cycle_length; i++)
+                h264->sps.offset_for_ref_frame[i] = sps->offset_for_ref_frame[i];
+
+            h264->picture_structure = sps->frame_mbs_only_flag ? 3 :
+                                      (header->field_pic_flag ?
+                                       header->field_pic_flag + header->bottom_field_flag : 3);
+
+            h264->poc.frame_num = header->frame_num;
+            h264->poc.poc_lsb = header->pic_order_cnt_lsb;
+            h264->poc.delta_poc_bottom = header->delta_pic_order_cnt_bottom;
+            h264->poc.delta_poc[0] = header->delta_pic_order_cnt[0];
+            h264->poc.delta_poc[1] = header->delta_pic_order_cnt[1];
+
+            field_poc[0] = field_poc[1] = INT_MAX;
+            ret = ff_h264_init_poc(field_poc, &output_picture_number, &h264->sps,
+                                   &h264->poc, h264->picture_structure,
+                                   header->nal_unit_header.nal_ref_idc);
+            if (ret < 0) {
+                av_log(ctx, AV_LOG_ERROR, "ff_h264_init_poc() failure\n");
+                goto fail;
+            }
+
+            got_reset = get_mmco_reset(header);
+            h264->poc.prev_frame_num        = got_reset ? 0 : h264->poc.frame_num;
+            h264->poc.prev_frame_num_offset = got_reset ? 0 : h264->poc.frame_num_offset;
+            if (header->nal_unit_header.nal_ref_idc != 0) {
+                h264->poc.prev_poc_msb      = got_reset ? 0 : h264->poc.poc_msb;
+                if (got_reset)
+                    h264->poc.prev_poc_lsb = h264->picture_structure == 2 ? 0 : field_poc[0];
+                else
+                    h264->poc.prev_poc_lsb = h264->poc.poc_lsb;
+            }
+
+            if (output_picture_number != h264->last_poc) {
+                if (h264->last_poc != INT_MIN) {
+                    int diff = FFABS(h264->last_poc - output_picture_number);
+
+                    if ((output_picture_number < 0) && !h264->last_poc)
+                        h264->poc_diff = 0;
+                    else if (FFABS(output_picture_number) < h264->poc_diff) {
+                        diff = FFABS(output_picture_number);
+                        h264->poc_diff = 0;
+                    }
+                    if (!h264->poc_diff || (h264->poc_diff > diff)) {
+                        h264->poc_diff = diff;
+                        if (h264->poc_diff == 1 && h264->sps.frame_mbs_only_flag) {
+                            av_tree_enumerate(s->root, &h264->poc_diff, NULL, dec_poc);
+                            s->nb_frame -= 2;
+                        }
+                    }
+                }
+                h264->last_poc = output_picture_number;
+                h264->highest_poc = FFMAX(h264->highest_poc, output_picture_number);
+
+                ret = h264_queue_frame(ctx, in, output_picture_number, &queued);
+                if (ret < 0)
+                    goto fail;
+            }
+            break;
+        }
+        default:
+            break;
+        }
+    }
+
+    if (output_picture_number == INT_MIN) {
+        av_log(ctx, AV_LOG_ERROR, "No slices in access unit\n");
+        ret = AVERROR_INVALIDDATA;
+        goto fail;
+    }
+
+    ret = 0;
+fail:
+    ff_cbs_fragment_reset(au);
+    if (!queued)
+        av_packet_free(&in);
+
+    return ret;
+}
+
+static void h264_flush(AVBSFContext *ctx)
+{
+    DTS2PTSContext *s = ctx->priv_data;
+    DTS2PTSH264Context *h264 = &s->u.h264;
+
+    memset(&h264->sps, 0, sizeof(h264->sps));
+    memset(&h264->poc, 0, sizeof(h264->poc));
+    s->nb_frame = -(ctx->par_in->video_delay << 1);
+    h264->last_poc = h264->highest_poc = INT_MIN;
+}
+
+// Core functions
+static const struct {
+    enum AVCodecID id;
+    int (*init)(AVBSFContext *ctx);
+    int (*filter)(AVBSFContext *ctx);
+    void (*flush)(AVBSFContext *ctx);
+    size_t fifo_size;
+} func_tab[] = {
+    { AV_CODEC_ID_H264, h264_init, h264_filter, h264_flush, H264_MAX_DPB_FRAMES * 2 * 2 },
+};
+
+static int dts2pts_init(AVBSFContext *ctx)
+{
+    DTS2PTSContext *s = ctx->priv_data;
+    CodedBitstreamFragment *au = &s->au;
+    int i, ret;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(func_tab); i++) {
+        if (func_tab[i].id == ctx->par_in->codec_id) {
+            s->init      = func_tab[i].init;
+            s->filter    = func_tab[i].filter;
+            s->flush     = func_tab[i].flush;
+            s->fifo_size = func_tab[i].fifo_size;
+            break;
+        }
+    }
+    if (i == FF_ARRAY_ELEMS(func_tab))
+        return AVERROR_BUG;
+    av_assert0(s->filter && s->fifo_size);
+
+    s->fifo = av_fifo_alloc2(s->fifo_size, sizeof(DTS2PTSFrame), 0);
+    if (!s->fifo)
+        return AVERROR(ENOMEM);
+
+    ret = ff_cbs_init(&s->cbc, ctx->par_in->codec_id, ctx);
+    if (ret < 0)
+        return ret;
+
+    if (s->init) {
+        ret = s->init(ctx);
+        if (ret < 0)
+            return ret;
+    }
+
+    if (!ctx->par_in->extradata_size)
+        return 0;
+
+    ret = ff_cbs_read_extradata(s->cbc, au, ctx->par_in);
+    if (ret < 0)
+        av_log(ctx, AV_LOG_WARNING, "Failed to parse extradata.\n");
+
+    ff_cbs_fragment_reset(au);
+
+    return 0;
+}
+
+static int dts2pts_filter(AVBSFContext *ctx, AVPacket *out)
+{
+    DTS2PTSContext *s = ctx->priv_data;
+    DTS2PTSNode *poc_node = NULL, *next[2] = { NULL, NULL };
+    DTS2PTSFrame frame;
+    int ret;
+
+    // Fill up the FIFO and POC tree
+    while (!s->eof && av_fifo_can_write(s->fifo)) {
+        ret = s->filter(ctx);
+        if (ret < 0) {
+            if (ret != AVERROR_EOF)
+                return ret;
+            s->eof = 1;
+        }
+    }
+
+    if (!av_fifo_can_read(s->fifo))
+        return AVERROR_EOF;
+
+    // Fetch a packet from the FIFO
+    ret = av_fifo_read(s->fifo, &frame, 1);
+    av_assert2(ret >= 0);
+    av_packet_move_ref(out, frame.pkt);
+    av_packet_free(&frame.pkt);
+
+    // Search the timestamp for the requested POC and set PTS
+    poc_node = av_tree_find(s->root, &frame, cmp_find, (void **)next);
+    if (!poc_node) {
+        poc_node = next[1];
+        if (!poc_node || poc_node->poc != frame.poc)
+            poc_node = next[0];
+    }
+    if (poc_node && poc_node->poc == frame.poc) {
+        out->pts = poc_node->dts;
+        if (!s->eof) {
+            // Remove the found entry from the tree
+            DTS2PTSFrame dup = (DTS2PTSFrame) { NULL, frame.poc + 1, frame.poc_diff, frame.gop };
+            for (; dup.poc_diff > 0; dup.poc++, dup.poc_diff--) {
+                struct AVTreeNode *node = NULL;
+                if (!poc_node || poc_node->dts != out->pts)
+                    continue;
+                av_tree_insert(&s->root, poc_node, cmp_insert, &node);
+                av_free(poc_node);
+                av_free(node);
+                poc_node = av_tree_find(s->root, &dup, cmp_find, NULL);
+            }
+        }
+    } else {
+        DTS2PTSFrame dup = (DTS2PTSFrame) { NULL, frame.poc - 1, frame.poc_diff, frame.gop };
+        if (s->eof && (poc_node = av_tree_find(s->root, &dup, cmp_find, NULL)) && poc_node->poc == dup.poc) {
+            out->pts = poc_node->dts;
+            if (out->pts != AV_NOPTS_VALUE)
+                out->pts += poc_node->duration;
+            ret = alloc_and_insert_node(ctx, out->pts, out->duration,
+                                        frame.poc, frame.poc_diff, frame.gop);
+            if (ret < 0) {
+                av_packet_unref(out);
+                return ret;
+            }
+            if (!ret)
+                av_log(ctx, AV_LOG_DEBUG, "Queueing frame for POC %d, GOP %d, dts %"PRId64", "
+                                          "generated from POC %d, GOP %d, dts %"PRId64", duration %"PRId64"\n",
+                       frame.poc, frame.gop, out->pts,
+                       poc_node->poc, poc_node->gop, poc_node->dts, poc_node->duration);
+        } else
+            av_log(ctx, AV_LOG_WARNING, "No timestamp for POC %d in tree\n", frame.poc);
+    }
+    av_log(ctx, AV_LOG_DEBUG, "Returning frame for POC %d, GOP %d, dts %"PRId64", pts %"PRId64"\n",
+           frame.poc, frame.gop, out->dts, out->pts);
+
+    return 0;
+}
+
+static void dts2pts_flush(AVBSFContext *ctx)
+{
+    DTS2PTSContext *s = ctx->priv_data;
+    DTS2PTSFrame frame;
+
+    if (s->flush)
+        s->flush(ctx);
+    s->eof = 0;
+    s->gop = 0;
+
+    while (s->fifo && av_fifo_read(s->fifo, &frame, 1) >= 0)
+        av_packet_free(&frame.pkt);
+
+    av_tree_enumerate(s->root, NULL, NULL, free_node);
+    av_tree_destroy(s->root);
+    s->root = NULL;
+
+    ff_cbs_fragment_reset(&s->au);
+    ff_cbs_flush(s->cbc);
+}
+
+static void dts2pts_close(AVBSFContext *ctx)
+{
+    DTS2PTSContext *s = ctx->priv_data;
+
+    dts2pts_flush(ctx);
+
+    av_fifo_freep2(&s->fifo);
+    ff_cbs_fragment_free(&s->au);
+    ff_cbs_close(&s->cbc);
+}
+
+static const enum AVCodecID dts2pts_codec_ids[] = {
+    AV_CODEC_ID_H264,
+    AV_CODEC_ID_NONE,
+};
+
+const FFBitStreamFilter ff_dts2pts_bsf = {
+    .p.name         = "dts2pts",
+    .p.codec_ids    = dts2pts_codec_ids,
+    .priv_data_size = sizeof(DTS2PTSContext),
+    .init           = dts2pts_init,
+    .flush          = dts2pts_flush,
+    .close          = dts2pts_close,
+    .filter         = dts2pts_filter,
+};
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/ftr.c
@@ -0,0 +1,208 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "adts_header.h"
+#include "avcodec.h"
+#include "codec_internal.h"
+#include "get_bits.h"
+#include "decode.h"
+
+typedef struct FTRContext {
+    AVCodecContext *aac_avctx[64];   // wrapper context for AAC
+    int nb_context;
+    AVPacket *packet;
+    AVFrame *frame;
+} FTRContext;
+
+static av_cold int ftr_init(AVCodecContext *avctx)
+{
+    FTRContext *s = avctx->priv_data;
+    const AVCodec *codec;
+    int ret;
+
+    if (avctx->ch_layout.nb_channels > 64 ||
+        avctx->ch_layout.nb_channels <= 0)
+        return AVERROR(ENOTSUP);
+
+    s->packet = av_packet_alloc();
+    if (!s->packet)
+        return AVERROR(ENOMEM);
+
+    s->frame = av_frame_alloc();
+    if (!s->frame)
+        return AVERROR(ENOMEM);
+
+    s->nb_context = avctx->ch_layout.nb_channels;
+
+    codec = avcodec_find_decoder(AV_CODEC_ID_AAC);
+    if (!codec)
+        return AVERROR_BUG;
+
+    for (int i = 0; i < s->nb_context; i++) {
+        s->aac_avctx[i] = avcodec_alloc_context3(codec);
+        if (!s->aac_avctx[i])
+            return AVERROR(ENOMEM);
+        ret = avcodec_open2(s->aac_avctx[i], codec, NULL);
+        if (ret < 0)
+            return ret;
+    }
+
+    avctx->sample_fmt = s->aac_avctx[0]->sample_fmt;
+    if (!av_sample_fmt_is_planar(avctx->sample_fmt))
+        return AVERROR(EINVAL);
+
+    return 0;
+}
+
+static int ftr_decode_frame(AVCodecContext *avctx, AVFrame *frame,
+                            int *got_frame, AVPacket *avpkt)
+{
+    FTRContext *s = avctx->priv_data;
+    GetBitContext gb;
+    int ret, ch_offset = 0;
+
+    ret = init_get_bits8(&gb, avpkt->data, avpkt->size);
+    if (ret < 0)
+        return ret;
+
+    frame->nb_samples = 0;
+
+    for (int i = 0; i < s->nb_context; i++) {
+        AVCodecContext *codec_avctx = s->aac_avctx[i];
+        GetBitContext gb2 = gb;
+        AACADTSHeaderInfo hdr_info;
+        int size;
+
+        if (get_bits_left(&gb) < 64)
+            return AVERROR_INVALIDDATA;
+
+        memset(&hdr_info, 0, sizeof(hdr_info));
+
+        size = ff_adts_header_parse(&gb2, &hdr_info);
+        if (size <= 0 || size * 8 > get_bits_left(&gb))
+            return AVERROR_INVALIDDATA;
+
+        if (size > s->packet->size) {
+            ret = av_grow_packet(s->packet, size - s->packet->size);
+            if (ret < 0)
+                return ret;
+        }
+
+        ret = av_packet_make_writable(s->packet);
+        if (ret < 0)
+            return ret;
+
+        memcpy(s->packet->data, avpkt->data + (get_bits_count(&gb) >> 3), size);
+        s->packet->size = size;
+
+        if (size > 12) {
+            uint8_t *buf = s->packet->data;
+
+            if (buf[3] & 0x20) {
+                int tmp = buf[8];
+                buf[ 9] = ~buf[9];
+                buf[11] = ~buf[11];
+                buf[12] = ~buf[12];
+                buf[ 8] = ~buf[10];
+                buf[10] = ~tmp;
+            }
+        }
+
+        ret = avcodec_send_packet(codec_avctx, s->packet);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Error submitting a packet for decoding\n");
+            return ret;
+        }
+
+        ret = avcodec_receive_frame(codec_avctx, s->frame);
+        if (ret < 0)
+            return ret;
+
+        if (!avctx->sample_rate) {
+            avctx->sample_rate = codec_avctx->sample_rate;
+        } else {
+            if (avctx->sample_rate != codec_avctx->sample_rate)
+                return AVERROR_INVALIDDATA;
+        }
+
+        if (!frame->nb_samples) {
+            frame->nb_samples = s->frame->nb_samples;
+            if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
+                return ret;
+        } else {
+            if (frame->nb_samples != s->frame->nb_samples)
+                return AVERROR_INVALIDDATA;
+        }
+
+        skip_bits_long(&gb, size * 8);
+
+        if (ch_offset + s->frame->ch_layout.nb_channels > avctx->ch_layout.nb_channels)
+            return AVERROR_INVALIDDATA;
+
+        if (avctx->sample_fmt != codec_avctx->sample_fmt)
+            return AVERROR_INVALIDDATA;
+
+        for (int ch = 0; ch < s->frame->ch_layout.nb_channels; ch++)
+            memcpy(frame->extended_data[ch_offset + ch],
+                   s->frame->extended_data[ch],
+                   av_get_bytes_per_sample(codec_avctx->sample_fmt) * s->frame->nb_samples);
+
+        ch_offset += s->frame->ch_layout.nb_channels;
+
+        if (ch_offset >= avctx->ch_layout.nb_channels)
+            break;
+    }
+
+    *got_frame = 1;
+
+    return get_bits_count(&gb) >> 3;
+}
+
+static void ftr_flush(AVCodecContext *avctx)
+{
+    FTRContext *s = avctx->priv_data;
+
+    for (int i = 0; i < s->nb_context; i++)
+        avcodec_flush_buffers(s->aac_avctx[i]);
+}
+
+static av_cold int ftr_close(AVCodecContext *avctx)
+{
+    FTRContext *s = avctx->priv_data;
+
+    for (int i = 0; i < s->nb_context; i++)
+        avcodec_free_context(&s->aac_avctx[i]);
+    av_packet_free(&s->packet);
+    av_frame_free(&s->frame);
+
+    return 0;
+}
+
+const FFCodec ff_ftr_decoder = {
+    .p.name         = "ftr",
+    .p.long_name    = NULL_IF_CONFIG_SMALL("FTR Voice"),
+    .p.type         = AVMEDIA_TYPE_AUDIO,
+    .p.id           = AV_CODEC_ID_FTR,
+    .init           = ftr_init,
+    FF_CODEC_DECODE_CB(ftr_decode_frame),
+    .close          = ftr_close,
+    .flush          = ftr_flush,
+    .priv_data_size = sizeof(FTRContext),
+    .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+};
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/ftr_parser.c
@@ -0,0 +1,107 @@
+/*
+ * FTR parser
+ * Copyright (c) 2022 Paul B Mahol
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * FTR parser
+ */
+
+#include "parser.h"
+#include "get_bits.h"
+#include "adts_header.h"
+#include "adts_parser.h"
+#include "mpeg4audio.h"
+
+typedef struct FTRParseContext {
+    ParseContext pc;
+    int skip;
+    int split;
+    int frame_index;
+} FTRParseContext;
+
+static int ftr_parse(AVCodecParserContext *s, AVCodecContext *avctx,
+                     const uint8_t **poutbuf, int *poutbuf_size,
+                     const uint8_t *buf, int buf_size)
+{
+    uint8_t tmp[8 + AV_INPUT_BUFFER_PADDING_SIZE];
+    FTRParseContext *ftr = s->priv_data;
+    uint64_t state = ftr->pc.state64;
+    int next = END_NOT_FOUND;
+    GetBitContext bits;
+    AACADTSHeaderInfo hdr;
+    int size;
+
+    *poutbuf_size = 0;
+    *poutbuf = NULL;
+
+    if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {
+        next = buf_size;
+    } else {
+        for (int i = 0; i < buf_size; i++) {
+            if (ftr->skip > 0) {
+                ftr->skip--;
+                if (ftr->skip == 0 && ftr->split) {
+                    ftr->split = 0;
+                    next = i;
+                    s->duration = 1024;
+                    s->key_frame = 1;
+                    break;
+                } else if (ftr->skip > 0) {
+                    continue;
+                }
+            }
+
+            state = (state << 8) | buf[i];
+            AV_WB64(tmp, state);
+            init_get_bits(&bits, tmp + 8 - AV_AAC_ADTS_HEADER_SIZE,
+                          AV_AAC_ADTS_HEADER_SIZE * 8);
+
+            if ((size = ff_adts_header_parse(&bits, &hdr)) > 0) {
+                ftr->skip = size - 6;
+                ftr->frame_index += ff_mpeg4audio_channels[hdr.chan_config];
+                if (ftr->frame_index >= avctx->ch_layout.nb_channels) {
+                    ftr->frame_index = 0;
+                    ftr->split = 1;
+                }
+            }
+        }
+
+        ftr->pc.state64 = state;
+
+        if (ff_combine_frame(&ftr->pc, next, &buf, &buf_size) < 0) {
+            *poutbuf = NULL;
+            *poutbuf_size = 0;
+            return buf_size;
+        }
+    }
+
+    *poutbuf      = buf;
+    *poutbuf_size = buf_size;
+
+    return next;
+}
+
+const AVCodecParser ff_ftr_parser = {
+    .codec_ids      = { AV_CODEC_ID_FTR },
+    .priv_data_size = sizeof(FTRParseContext),
+    .parser_parse   = ftr_parse,
+    .parser_close   = ff_parse_close,
+};
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/jpegquanttables.c
@@ -0,0 +1,54 @@
+/*
+ * MJPEG encoder and decoder
+ * Copyright (c) 2000, 2001 Fabrice Bellard
+ * Copyright (c) 2003 Alex Beregszaszi
+ * Copyright (c) 2003-2004 Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * MJPEG quantization tables
+ */
+
+#include "jpegquanttables.h"
+
+/* These are the sample quantization tables given in JPEG spec section K.1.
+ * The spec says that the values given produce "good" quality, and
+ * when divided by 2, "very good" quality.
+ */
+const uint8_t ff_mjpeg_std_luminance_quant_tbl[64] = {
+    16,  11,  10,  16,  24,  40,  51,  61,
+    12,  12,  14,  19,  26,  58,  60,  55,
+    14,  13,  16,  24,  40,  57,  69,  56,
+    14,  17,  22,  29,  51,  87,  80,  62,
+    18,  22,  37,  56,  68, 109, 103,  77,
+    24,  35,  55,  64,  81, 104, 113,  92,
+    49,  64,  78,  87, 103, 121, 120, 101,
+    72,  92,  95,  98, 112, 100, 103,  99
+};
+const uint8_t ff_mjpeg_std_chrominance_quant_tbl[64] = {
+    17,  18,  24,  47,  99,  99,  99,  99,
+    18,  21,  26,  66,  99,  99,  99,  99,
+    24,  26,  56,  99,  99,  99,  99,  99,
+    47,  66,  99,  99,  99,  99,  99,  99,
+    99,  99,  99,  99,  99,  99,  99,  99,
+    99,  99,  99,  99,  99,  99,  99,  99,
+    99,  99,  99,  99,  99,  99,  99,  99,
+    99,  99,  99,  99,  99,  99,  99,  99
+};
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/jpegquanttables.h
@@ -0,0 +1,32 @@
+/*
+ * MJPEG quantization tables
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_JPEGQUANTTABLES_H
+#define AVCODEC_JPEGQUANTTABLES_H
+
+#include <stdint.h>
+#include "libavutil/attributes_internal.h"
+
+FF_VISIBILITY_PUSH_HIDDEN
+extern const uint8_t ff_mjpeg_std_luminance_quant_tbl[64];
+extern const uint8_t ff_mjpeg_std_chrominance_quant_tbl[64];
+FF_VISIBILITY_POP_HIDDEN
+
+#endif /* AVCODEC_JPEGQUANTTABLES_H */
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/media100.c
@@ -0,0 +1,224 @@
+/*
+ * Media 100 decoder
+ * Copyright (c) 2022 Paul B Mahol
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Media 100 decoder.
+ */
+
+#include <inttypes.h>
+
+#include "libavutil/intreadwrite.h"
+#include "avcodec.h"
+#include "bytestream.h"
+#include "codec_internal.h"
+
+typedef struct Media100Context {
+    AVCodecContext *avctx;   // wrapper context for mjpegb
+    AVPacket *pkt;
+} Media100Context;
+
+static av_cold int media100_decode_init(AVCodecContext *avctx)
+{
+    Media100Context *ctx = avctx->priv_data;
+    const AVCodec *codec;
+    int ret;
+
+    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEGB);
+    if (!codec)
+        return AVERROR_BUG;
+    ctx->avctx = avcodec_alloc_context3(codec);
+    if (!ctx->avctx)
+        return AVERROR(ENOMEM);
+    ctx->avctx->thread_count = 1;
+    ctx->avctx->flags  = avctx->flags;
+    ctx->avctx->flags2 = avctx->flags2;
+    ctx->avctx->width  = ctx->avctx->coded_width  = avctx->width;
+    ctx->avctx->height = ctx->avctx->coded_height = avctx->height;
+
+    ret = avcodec_open2(ctx->avctx, codec, NULL);
+    if (ret < 0)
+        return ret;
+
+    ctx->pkt = av_packet_alloc();
+    if (!ctx->pkt)
+        return AVERROR(ENOMEM);
+
+    return 0;
+}
+
+static int media100_decode_frame(AVCodecContext *avctx,
+                                 AVFrame *frame, int *got_frame,
+                                 AVPacket *avpkt)
+{
+    Media100Context *ctx = avctx->priv_data;
+    unsigned second_field_offset = 0;
+    unsigned next_field = 0;
+    unsigned dht_offset[2];
+    unsigned dqt_offset[2];
+    unsigned sod_offset[2];
+    unsigned sof_offset[2];
+    unsigned sos_offset[2];
+    unsigned field = 0;
+    GetByteContext gb;
+    PutByteContext pb;
+    AVPacket *pkt;
+    int ret;
+
+    if (avpkt->size + 1024 > ctx->pkt->size) {
+        ret = av_grow_packet(ctx->pkt, avpkt->size + 1024 - ctx->pkt->size);
+        if (ret < 0)
+            return ret;
+    }
+
+    ret = av_packet_make_writable(ctx->pkt);
+    if (ret < 0)
+        return ret;
+
+    bytestream2_init(&gb, avpkt->data, avpkt->size);
+    bytestream2_init_writer(&pb, ctx->pkt->data, ctx->pkt->size);
+
+second_field:
+    bytestream2_put_be32(&pb, 0);
+    bytestream2_put_be32(&pb, AV_RB32("mjpg"));
+    bytestream2_put_be32(&pb, 0);
+    bytestream2_put_be32(&pb, 0);
+    for (int i = 0; i < 6; i++)
+        bytestream2_put_be32(&pb, 0);
+
+    sof_offset[field] = bytestream2_tell_p(&pb);
+    bytestream2_put_be16(&pb, 17);
+    bytestream2_put_byte(&pb, 8);
+    bytestream2_put_be16(&pb, avctx->height / 2);
+    bytestream2_put_be16(&pb, avctx->width);
+    bytestream2_put_byte(&pb, 3);
+    bytestream2_put_byte(&pb, 1);
+    bytestream2_put_byte(&pb, 0x21);
+    bytestream2_put_byte(&pb, 0);
+    bytestream2_put_byte(&pb, 2);
+    bytestream2_put_byte(&pb, 0x11);
+    bytestream2_put_byte(&pb, 1);
+    bytestream2_put_byte(&pb, 3);
+    bytestream2_put_byte(&pb, 0x11);
+    bytestream2_put_byte(&pb, 1);
+
+    sos_offset[field] = bytestream2_tell_p(&pb);
+    bytestream2_put_be16(&pb, 12);
+    bytestream2_put_byte(&pb, 3);
+    bytestream2_put_byte(&pb, 1);
+    bytestream2_put_byte(&pb, 0);
+    bytestream2_put_byte(&pb, 2);
+    bytestream2_put_byte(&pb, 0x11);
+    bytestream2_put_byte(&pb, 3);
+    bytestream2_put_byte(&pb, 0x11);
+    bytestream2_put_byte(&pb, 0);
+    bytestream2_put_byte(&pb, 0);
+    bytestream2_put_byte(&pb, 0);
+
+    dqt_offset[field] = bytestream2_tell_p(&pb);
+    bytestream2_put_be16(&pb, 132);
+    bytestream2_put_byte(&pb, 0);
+    bytestream2_skip(&gb, 4);
+    for (int i = 0; i < 64; i++)
+        bytestream2_put_byte(&pb, bytestream2_get_be32(&gb));
+    bytestream2_put_byte(&pb, 1);
+    for (int i = 0; i < 64; i++)
+        bytestream2_put_byte(&pb, bytestream2_get_be32(&gb));
+
+    dht_offset[field] = 0;
+    sod_offset[field] = bytestream2_tell_p(&pb);
+
+    for (int i = bytestream2_tell(&gb) + 8; next_field == 0 && i < avpkt->size - 4; i++) {
+        if (AV_RB32(avpkt->data + i) == 0x00000001) {
+            next_field = i;
+            break;
+        }
+    }
+
+    bytestream2_skip(&gb, 8);
+    bytestream2_copy_buffer(&pb, &gb, next_field - bytestream2_tell(&gb));
+    bytestream2_put_be64(&pb, 0);
+
+    if (field == 0) {
+        field = 1;
+        second_field_offset = bytestream2_tell_p(&pb);
+        next_field = avpkt->size;
+        goto second_field;
+    }
+
+    pkt = ctx->pkt;
+
+    AV_WB32(pkt->data +  8, second_field_offset);
+    AV_WB32(pkt->data + 12, second_field_offset);
+    AV_WB32(pkt->data + 16, second_field_offset);
+    AV_WB32(pkt->data + 20, dqt_offset[0]);
+    AV_WB32(pkt->data + 24, dht_offset[0]);
+    AV_WB32(pkt->data + 28, sof_offset[0]);
+    AV_WB32(pkt->data + 32, sos_offset[0]);
+    AV_WB32(pkt->data + 36, sod_offset[0]);
+
+    AV_WB32(pkt->data + second_field_offset +  8, bytestream2_tell_p(&pb) - second_field_offset);
+    AV_WB32(pkt->data + second_field_offset + 12, bytestream2_tell_p(&pb) - second_field_offset);
+    AV_WB32(pkt->data + second_field_offset + 16, 0);
+    AV_WB32(pkt->data + second_field_offset + 20, dqt_offset[1] - second_field_offset);
+    AV_WB32(pkt->data + second_field_offset + 24, dht_offset[1]);
+    AV_WB32(pkt->data + second_field_offset + 28, sof_offset[1] - second_field_offset);
+    AV_WB32(pkt->data + second_field_offset + 32, sos_offset[1] - second_field_offset);
+    AV_WB32(pkt->data + second_field_offset + 36, sod_offset[1] - second_field_offset);
+
+    pkt->size = bytestream2_tell_p(&pb);
+
+    ret = avcodec_send_packet(ctx->avctx, pkt);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Error submitting a packet for decoding\n");
+        return ret;
+    }
+
+    ret = avcodec_receive_frame(ctx->avctx, frame);
+    if (ret < 0)
+        return ret;
+
+    *got_frame = 1;
+
+    return avpkt->size;
+}
+
+static av_cold int media100_decode_end(AVCodecContext *avctx)
+{
+    Media100Context *ctx = avctx->priv_data;
+
+    avcodec_free_context(&ctx->avctx);
+    av_packet_free(&ctx->pkt);
+
+    return 0;
+}
+
+const FFCodec ff_media100_decoder = {
+    .p.name           = "media100",
+    CODEC_LONG_NAME("Media 100"),
+    .p.type           = AVMEDIA_TYPE_VIDEO,
+    .p.id             = AV_CODEC_ID_MEDIA100,
+    .priv_data_size   = sizeof(Media100Context),
+    .init             = media100_decode_init,
+    .close            = media100_decode_end,
+    FF_CODEC_DECODE_CB(media100_decode_frame),
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
+};
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/mpeg12codecs.h
@@ -0,0 +1,29 @@
+/*
+ * MPEG-1/2 codecs common code
+ * Copyright (c) 2007 Aurelien Jacobs <aurel@gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_MPEG12CODECS_H
+#define AVCODEC_MPEG12CODECS_H
+
+#include "mpegvideo.h"
+
+void ff_mpeg1_clean_buffers(MpegEncContext *s);
+
+#endif /* AVCODEC_MPEG12CODECS_H */
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/mpeg4audio_copy_pce.h
@@ -0,0 +1,69 @@
+/*
+ * MPEG-4 Audio PCE copying function
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_MPEG4AUDIO_COPY_PCE_H
+#define AVCODEC_MPEG4AUDIO_COPY_PCE_H
+
+#include "libavutil/attributes.h"
+
+#include "get_bits.h"
+#include "put_bits.h"
+
+static av_always_inline unsigned int ff_pce_copy_bits(PutBitContext *pb,
+                                                      GetBitContext *gb,
+                                                      int bits)
+{
+    unsigned int el = get_bits(gb, bits);
+    put_bits(pb, bits, el);
+    return el;
+}
+
+static inline int ff_copy_pce_data(PutBitContext *pb, GetBitContext *gb)
+{
+    int five_bit_ch, four_bit_ch, comment_size, bits;
+    int offset = put_bits_count(pb);
+
+    ff_pce_copy_bits(pb, gb, 10);               // Tag, Object Type, Frequency
+    five_bit_ch  = ff_pce_copy_bits(pb, gb, 4); // Front
+    five_bit_ch += ff_pce_copy_bits(pb, gb, 4); // Side
+    five_bit_ch += ff_pce_copy_bits(pb, gb, 4); // Back
+    four_bit_ch  = ff_pce_copy_bits(pb, gb, 2); // LFE
+    four_bit_ch += ff_pce_copy_bits(pb, gb, 3); // Data
+    five_bit_ch += ff_pce_copy_bits(pb, gb, 4); // Coupling
+    if (ff_pce_copy_bits(pb, gb, 1))            // Mono Mixdown
+        ff_pce_copy_bits(pb, gb, 4);
+    if (ff_pce_copy_bits(pb, gb, 1))            // Stereo Mixdown
+        ff_pce_copy_bits(pb, gb, 4);
+    if (ff_pce_copy_bits(pb, gb, 1))            // Matrix Mixdown
+        ff_pce_copy_bits(pb, gb, 3);
+    for (bits = five_bit_ch*5+four_bit_ch*4; bits > 16; bits -= 16)
+        ff_pce_copy_bits(pb, gb, 16);
+    if (bits)
+        ff_pce_copy_bits(pb, gb, bits);
+    align_put_bits(pb);
+    align_get_bits(gb);
+    comment_size = ff_pce_copy_bits(pb, gb, 8);
+    for (; comment_size > 0; comment_size--)
+        ff_pce_copy_bits(pb, gb, 8);
+
+    return put_bits_count(pb) - offset;
+}
+
+#endif /* AVCODEC_MPEG4AUDIO_COPY_PCE_H */
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/mpv_reconstruct_mb_template.c
@@ -0,0 +1,301 @@
+/*
+ * MPEG macroblock reconstruction
+ * Copyright (c) 2000,2001 Fabrice Bellard
+ * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#define NOT_MPEG12        0
+#define MAY_BE_MPEG12     1
+#define DEFINITELY_MPEG12 2
+
+/* put block[] to dest[] */
+static inline void put_dct(MpegEncContext *s,
+                           int16_t *block, int i, uint8_t *dest, int line_size, int qscale)
+{
+    s->dct_unquantize_intra(s, block, i, qscale);
+    s->idsp.idct_put(dest, line_size, block);
+}
+
+static inline void add_dequant_dct(MpegEncContext *s,
+                           int16_t *block, int i, uint8_t *dest, int line_size, int qscale)
+{
+    if (s->block_last_index[i] >= 0) {
+        s->dct_unquantize_inter(s, block, i, qscale);
+
+        s->idsp.idct_add(dest, line_size, block);
+    }
+}
+
+/* generic function called after a macroblock has been parsed by the
+   decoder or after it has been encoded by the encoder.
+
+   Important variables used:
+   s->mb_intra : true if intra macroblock
+   s->mv_dir   : motion vector direction
+   s->mv_type  : motion vector type
+   s->mv       : motion vector
+   s->interlaced_dct : true if interlaced dct used (mpeg2)
+ */
+static av_always_inline
+void mpv_reconstruct_mb_internal(MpegEncContext *s, int16_t block[12][64],
+                                 int lowres_flag, int is_mpeg12)
+{
+#define IS_MPEG12(s) (is_mpeg12 == MAY_BE_MPEG12 ? ((s)->out_format == FMT_MPEG1) : is_mpeg12)
+    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;
+
+    s->current_picture.qscale_table[mb_xy] = s->qscale;
+
+    /* update DC predictors for P macroblocks */
+    if (!s->mb_intra) {
+        if (is_mpeg12 != DEFINITELY_MPEG12 && (s->h263_pred || s->h263_aic)) {
+            if (s->mbintra_table[mb_xy])
+                ff_clean_intra_table_entries(s);
+        } else {
+            s->last_dc[0] =
+            s->last_dc[1] =
+            s->last_dc[2] = 128 << s->intra_dc_precision;
+        }
+    } else if (is_mpeg12 != DEFINITELY_MPEG12 && (s->h263_pred || s->h263_aic))
+        s->mbintra_table[mb_xy] = 1;
+
+#if IS_ENCODER
+    if ((s->avctx->flags & AV_CODEC_FLAG_PSNR) || s->frame_skip_threshold || s->frame_skip_factor ||
+        !((s->intra_only || s->pict_type == AV_PICTURE_TYPE_B) &&
+          s->avctx->mb_decision != FF_MB_DECISION_RD))  // FIXME precalc
+#endif /* IS_ENCODER */
+    {
+        uint8_t *dest_y, *dest_cb, *dest_cr;
+        int dct_linesize, dct_offset;
+        const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics
+        const int uvlinesize = s->current_picture.f->linesize[1];
+        const int readable   = IS_ENCODER || lowres_flag || s->pict_type != AV_PICTURE_TYPE_B;
+        const int block_size = lowres_flag ? 8 >> s->avctx->lowres : 8;
+
+        /* avoid copy if macroblock skipped in last frame too */
+        /* skip only during decoding as we might trash the buffers during encoding a bit */
+        if (!IS_ENCODER) {
+            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];
+
+            if (s->mb_skipped) {
+                s->mb_skipped = 0;
+                av_assert2(s->pict_type!=AV_PICTURE_TYPE_I);
+                *mbskip_ptr = 1;
+            } else if(!s->current_picture.reference) {
+                *mbskip_ptr = 1;
+            } else{
+                *mbskip_ptr = 0; /* not skipped */
+            }
+        }
+
+        dct_linesize = linesize << s->interlaced_dct;
+        dct_offset   = s->interlaced_dct ? linesize : linesize * block_size;
+
+        if (readable) {
+            dest_y  = s->dest[0];
+            dest_cb = s->dest[1];
+            dest_cr = s->dest[2];
+        } else {
+            dest_y  = s->sc.b_scratchpad;
+            dest_cb = s->sc.b_scratchpad + 16 * linesize;
+            dest_cr = s->sc.b_scratchpad + 32 * linesize;
+        }
+
+        if (!s->mb_intra) {
+            /* motion handling */
+            /* decoding or more than one mb_type (MC was already done otherwise) */
+
+#if !IS_ENCODER
+            if (HAVE_THREADS && is_mpeg12 != DEFINITELY_MPEG12 &&
+                s->avctx->active_thread_type & FF_THREAD_FRAME) {
+                if (s->mv_dir & MV_DIR_FORWARD) {
+                    ff_thread_await_progress(&s->last_picture_ptr->tf,
+                                             lowest_referenced_row(s, 0), 0);
+                }
+                if (s->mv_dir & MV_DIR_BACKWARD) {
+                    ff_thread_await_progress(&s->next_picture_ptr->tf,
+                                             lowest_referenced_row(s, 1), 0);
+                }
+            }
+
+            if (lowres_flag) {
+                const h264_chroma_mc_func *op_pix = s->h264chroma.put_h264_chroma_pixels_tab;
+
+                if (s->mv_dir & MV_DIR_FORWARD) {
+                    MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix);
+                    op_pix = s->h264chroma.avg_h264_chroma_pixels_tab;
+                }
+                if (s->mv_dir & MV_DIR_BACKWARD) {
+                    MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix);
+                }
+            } else {
+                op_pixels_func (*op_pix)[4];
+                qpel_mc_func (*op_qpix)[16] = s->me.qpel_put;
+
+                if ((is_mpeg12 == DEFINITELY_MPEG12 || !s->no_rounding) || s->pict_type == AV_PICTURE_TYPE_B) {
+                    op_pix = s->hdsp.put_pixels_tab;
+                } else {
+                    op_pix = s->hdsp.put_no_rnd_pixels_tab;
+                }
+                if (s->mv_dir & MV_DIR_FORWARD) {
+                    ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix, op_qpix);
+                    op_pix  = s->hdsp.avg_pixels_tab;
+                    op_qpix = s->me.qpel_avg;
+                }
+                if (s->mv_dir & MV_DIR_BACKWARD) {
+                    ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix, op_qpix);
+                }
+            }
+
+            /* skip dequant / idct if we are really late ;) */
+            if (s->avctx->skip_idct) {
+                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)
+                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)
+                   || s->avctx->skip_idct >= AVDISCARD_ALL)
+                    goto skip_idct;
+            }
+
+            /* add dct residue */
+            if (!(IS_MPEG12(s) || s->msmpeg4_version ||
+                  (s->codec_id == AV_CODEC_ID_MPEG4 && !s->mpeg_quant)))
+#endif /* !IS_ENCODER */
+            {
+                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);
+                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);
+                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);
+                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);
+
+                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+                    if (s->chroma_y_shift) {
+                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);
+                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);
+                    } else {
+                        dct_linesize >>= 1;
+                        dct_offset   >>= 1;
+                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);
+                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);
+                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);
+                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);
+                    }
+                }
+            }
+#if !IS_ENCODER
+              else if (is_mpeg12 == DEFINITELY_MPEG12 || (s->codec_id != AV_CODEC_ID_WMV2)) {
+                add_dct(s, block[0], 0, dest_y                          , dct_linesize);
+                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);
+                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);
+                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);
+
+                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+                    if (s->chroma_y_shift) {//Chroma420
+                        add_dct(s, block[4], 4, dest_cb, uvlinesize);
+                        add_dct(s, block[5], 5, dest_cr, uvlinesize);
+                    } else {
+                        //chroma422
+                        dct_linesize = uvlinesize << s->interlaced_dct;
+                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;
+
+                        add_dct(s, block[4], 4, dest_cb, dct_linesize);
+                        add_dct(s, block[5], 5, dest_cr, dct_linesize);
+                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);
+                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);
+                        if (!s->chroma_x_shift) {//Chroma444
+                            add_dct(s, block[8], 8, dest_cb+block_size, dct_linesize);
+                            add_dct(s, block[9], 9, dest_cr+block_size, dct_linesize);
+                            add_dct(s, block[10], 10, dest_cb+block_size+dct_offset, dct_linesize);
+                            add_dct(s, block[11], 11, dest_cr+block_size+dct_offset, dct_linesize);
+                        }
+                    }
+                } //fi gray
+            } else if (CONFIG_WMV2_DECODER) {
+                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);
+            }
+#endif /* !IS_ENCODER */
+        } else {
+#if !IS_ENCODER
+            /* Only MPEG-4 Simple Studio Profile is supported in > 8-bit mode.
+               TODO: Integrate 10-bit properly into mpegvideo.c so that ER works properly */
+            if (is_mpeg12 != DEFINITELY_MPEG12 && CONFIG_MPEG4_DECODER &&
+                /* s->codec_id == AV_CODEC_ID_MPEG4 && */
+                s->avctx->bits_per_raw_sample > 8) {
+                ff_mpeg4_decode_studio(s, dest_y, dest_cb, dest_cr, block_size,
+                                       uvlinesize, dct_linesize, dct_offset);
+            } else if (!IS_MPEG12(s))
+#endif /* !IS_ENCODER */
+            {
+                /* dct only in intra block */
+                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);
+                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);
+                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);
+                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);
+
+                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+                    if (s->chroma_y_shift) {
+                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);
+                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);
+                    } else {
+                        dct_offset >>=1;
+                        dct_linesize >>=1;
+                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);
+                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);
+                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);
+                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);
+                    }
+                }
+            }
+#if !IS_ENCODER
+              else {
+                s->idsp.idct_put(dest_y,                           dct_linesize, block[0]);
+                s->idsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);
+                s->idsp.idct_put(dest_y + dct_offset,              dct_linesize, block[2]);
+                s->idsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);
+
+                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+                    if (s->chroma_y_shift) {
+                        s->idsp.idct_put(dest_cb, uvlinesize, block[4]);
+                        s->idsp.idct_put(dest_cr, uvlinesize, block[5]);
+                    } else {
+                        dct_linesize = uvlinesize << s->interlaced_dct;
+                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;
+
+                        s->idsp.idct_put(dest_cb,              dct_linesize, block[4]);
+                        s->idsp.idct_put(dest_cr,              dct_linesize, block[5]);
+                        s->idsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);
+                        s->idsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);
+                        if (!s->chroma_x_shift) { //Chroma444
+                            s->idsp.idct_put(dest_cb + block_size,              dct_linesize, block[8]);
+                            s->idsp.idct_put(dest_cr + block_size,              dct_linesize, block[9]);
+                            s->idsp.idct_put(dest_cb + block_size + dct_offset, dct_linesize, block[10]);
+                            s->idsp.idct_put(dest_cr + block_size + dct_offset, dct_linesize, block[11]);
+                        }
+                    }
+                } //gray
+            }
+        }
+skip_idct:
+        if (!readable) {
+            s->hdsp.put_pixels_tab[0][0](s->dest[0], dest_y, linesize, 16);
+            if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {
+                s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize, 16 >> s->chroma_y_shift);
+                s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize, 16 >> s->chroma_y_shift);
+            }
+#endif /* !IS_ENCODER */
+        }
+    }
+}
+
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/opus_parse.c
@@ -0,0 +1,469 @@
+/*
+ * Copyright (c) 2012 Andrew D'Addesio
+ * Copyright (c) 2013-2014 Mozilla Corporation
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Opus decoder/parser shared code
+ */
+
+#include "libavutil/attributes.h"
+#include "libavutil/channel_layout.h"
+#include "libavutil/error.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/log.h"
+#include "libavutil/mem.h"
+
+#include "avcodec.h"
+#include "internal.h"
+#include "mathops.h"
+#include "opus.h"
+#include "opus_parse.h"
+#include "vorbis_data.h"
+
+static const uint16_t opus_frame_duration[32] = {
+    480, 960, 1920, 2880,
+    480, 960, 1920, 2880,
+    480, 960, 1920, 2880,
+    480, 960,
+    480, 960,
+    120, 240,  480,  960,
+    120, 240,  480,  960,
+    120, 240,  480,  960,
+    120, 240,  480,  960,
+};
+
+/**
+ * Read a 1- or 2-byte frame length
+ */
+static inline int xiph_lacing_16bit(const uint8_t **ptr, const uint8_t *end)
+{
+    int val;
+
+    if (*ptr >= end)
+        return AVERROR_INVALIDDATA;
+    val = *(*ptr)++;
+    if (val >= 252) {
+        if (*ptr >= end)
+            return AVERROR_INVALIDDATA;
+        val += 4 * *(*ptr)++;
+    }
+    return val;
+}
+
+/**
+ * Read a multi-byte length (used for code 3 packet padding size)
+ */
+static inline int xiph_lacing_full(const uint8_t **ptr, const uint8_t *end)
+{
+    int val = 0;
+    int next;
+
+    while (1) {
+        if (*ptr >= end || val > INT_MAX - 254)
+            return AVERROR_INVALIDDATA;
+        next = *(*ptr)++;
+        val += next;
+        if (next < 255)
+            break;
+        else
+            val--;
+    }
+    return val;
+}
+
+/**
+ * Parse Opus packet info from raw packet data
+ */
+int ff_opus_parse_packet(OpusPacket *pkt, const uint8_t *buf, int buf_size,
+                         int self_delimiting)
+{
+    const uint8_t *ptr = buf;
+    const uint8_t *end = buf + buf_size;
+    int padding = 0;
+    int frame_bytes, i;
+
+    if (buf_size < 1)
+        goto fail;
+
+    /* TOC byte */
+    i = *ptr++;
+    pkt->code   = (i     ) & 0x3;
+    pkt->stereo = (i >> 2) & 0x1;
+    pkt->config = (i >> 3) & 0x1F;
+
+    /* code 2 and code 3 packets have at least 1 byte after the TOC */
+    if (pkt->code >= 2 && buf_size < 2)
+        goto fail;
+
+    switch (pkt->code) {
+    case 0:
+        /* 1 frame */
+        pkt->frame_count = 1;
+        pkt->vbr         = 0;
+
+        if (self_delimiting) {
+            int len = xiph_lacing_16bit(&ptr, end);
+            if (len < 0 || len > end - ptr)
+                goto fail;
+            end      = ptr + len;
+            buf_size = end - buf;
+        }
+
+        frame_bytes = end - ptr;
+        if (frame_bytes > OPUS_MAX_FRAME_SIZE)
+            goto fail;
+        pkt->frame_offset[0] = ptr - buf;
+        pkt->frame_size[0]   = frame_bytes;
+        break;
+    case 1:
+        /* 2 frames, equal size */
+        pkt->frame_count = 2;
+        pkt->vbr         = 0;
+
+        if (self_delimiting) {
+            int len = xiph_lacing_16bit(&ptr, end);
+            if (len < 0 || 2 * len > end - ptr)
+                goto fail;
+            end      = ptr + 2 * len;
+            buf_size = end - buf;
+        }
+
+        frame_bytes = end - ptr;
+        if (frame_bytes & 1 || frame_bytes >> 1 > OPUS_MAX_FRAME_SIZE)
+            goto fail;
+        pkt->frame_offset[0] = ptr - buf;
+        pkt->frame_size[0]   = frame_bytes >> 1;
+        pkt->frame_offset[1] = pkt->frame_offset[0] + pkt->frame_size[0];
+        pkt->frame_size[1]   = frame_bytes >> 1;
+        break;
+    case 2:
+        /* 2 frames, different sizes */
+        pkt->frame_count = 2;
+        pkt->vbr         = 1;
+
+        /* read 1st frame size */
+        frame_bytes = xiph_lacing_16bit(&ptr, end);
+        if (frame_bytes < 0)
+            goto fail;
+
+        if (self_delimiting) {
+            int len = xiph_lacing_16bit(&ptr, end);
+            if (len < 0 || len + frame_bytes > end - ptr)
+                goto fail;
+            end      = ptr + frame_bytes + len;
+            buf_size = end - buf;
+        }
+
+        pkt->frame_offset[0] = ptr - buf;
+        pkt->frame_size[0]   = frame_bytes;
+
+        /* calculate 2nd frame size */
+        frame_bytes = end - ptr - pkt->frame_size[0];
+        if (frame_bytes < 0 || frame_bytes > OPUS_MAX_FRAME_SIZE)
+            goto fail;
+        pkt->frame_offset[1] = pkt->frame_offset[0] + pkt->frame_size[0];
+        pkt->frame_size[1]   = frame_bytes;
+        break;
+    case 3:
+        /* 1 to 48 frames, can be different sizes */
+        i = *ptr++;
+        pkt->frame_count = (i     ) & 0x3F;
+        padding          = (i >> 6) & 0x01;
+        pkt->vbr         = (i >> 7) & 0x01;
+
+        if (pkt->frame_count == 0 || pkt->frame_count > OPUS_MAX_FRAMES)
+            goto fail;
+
+        /* read padding size */
+        if (padding) {
+            padding = xiph_lacing_full(&ptr, end);
+            if (padding < 0)
+                goto fail;
+        }
+
+        /* read frame sizes */
+        if (pkt->vbr) {
+            /* for VBR, all frames except the final one have their size coded
+               in the bitstream. the last frame size is implicit. */
+            int total_bytes = 0;
+            for (i = 0; i < pkt->frame_count - 1; i++) {
+                frame_bytes = xiph_lacing_16bit(&ptr, end);
+                if (frame_bytes < 0)
+                    goto fail;
+                pkt->frame_size[i] = frame_bytes;
+                total_bytes += frame_bytes;
+            }
+
+            if (self_delimiting) {
+                int len = xiph_lacing_16bit(&ptr, end);
+                if (len < 0 || len + total_bytes + padding > end - ptr)
+                    goto fail;
+                end      = ptr + total_bytes + len + padding;
+                buf_size = end - buf;
+            }
+
+            frame_bytes = end - ptr - padding;
+            if (total_bytes > frame_bytes)
+                goto fail;
+            pkt->frame_offset[0] = ptr - buf;
+            for (i = 1; i < pkt->frame_count; i++)
+                pkt->frame_offset[i] = pkt->frame_offset[i-1] + pkt->frame_size[i-1];
+            pkt->frame_size[pkt->frame_count-1] = frame_bytes - total_bytes;
+        } else {
+            /* for CBR, the remaining packet bytes are divided evenly between
+               the frames */
+            if (self_delimiting) {
+                frame_bytes = xiph_lacing_16bit(&ptr, end);
+                if (frame_bytes < 0 || pkt->frame_count * frame_bytes + padding > end - ptr)
+                    goto fail;
+                end      = ptr + pkt->frame_count * frame_bytes + padding;
+                buf_size = end - buf;
+            } else {
+                frame_bytes = end - ptr - padding;
+                if (frame_bytes % pkt->frame_count ||
+                    frame_bytes / pkt->frame_count > OPUS_MAX_FRAME_SIZE)
+                    goto fail;
+                frame_bytes /= pkt->frame_count;
+            }
+
+            pkt->frame_offset[0] = ptr - buf;
+            pkt->frame_size[0]   = frame_bytes;
+            for (i = 1; i < pkt->frame_count; i++) {
+                pkt->frame_offset[i] = pkt->frame_offset[i-1] + pkt->frame_size[i-1];
+                pkt->frame_size[i]   = frame_bytes;
+            }
+        }
+    }
+
+    pkt->packet_size = buf_size;
+    pkt->data_size   = pkt->packet_size - padding;
+
+    /* total packet duration cannot be larger than 120ms */
+    pkt->frame_duration = opus_frame_duration[pkt->config];
+    if (pkt->frame_duration * pkt->frame_count > OPUS_MAX_PACKET_DUR)
+        goto fail;
+
+    /* set mode and bandwidth */
+    if (pkt->config < 12) {
+        pkt->mode = OPUS_MODE_SILK;
+        pkt->bandwidth = pkt->config >> 2;
+    } else if (pkt->config < 16) {
+        pkt->mode = OPUS_MODE_HYBRID;
+        pkt->bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND + (pkt->config >= 14);
+    } else {
+        pkt->mode = OPUS_MODE_CELT;
+        pkt->bandwidth = (pkt->config - 16) >> 2;
+        /* skip medium band */
+        if (pkt->bandwidth)
+            pkt->bandwidth++;
+    }
+
+    return 0;
+
+fail:
+    memset(pkt, 0, sizeof(*pkt));
+    return AVERROR_INVALIDDATA;
+}
+
+static int channel_reorder_vorbis(int nb_channels, int channel_idx)
+{
+    return ff_vorbis_channel_layout_offsets[nb_channels - 1][channel_idx];
+}
+
+static int channel_reorder_unknown(int nb_channels, int channel_idx)
+{
+    return channel_idx;
+}
+
+av_cold int ff_opus_parse_extradata(AVCodecContext *avctx,
+                                    OpusParseContext *s)
+{
+    static const uint8_t default_channel_map[2] = { 0, 1 };
+
+    int (*channel_reorder)(int, int) = channel_reorder_unknown;
+    int channels = avctx->ch_layout.nb_channels;
+
+    const uint8_t *extradata, *channel_map;
+    int extradata_size;
+    int version, map_type, streams, stereo_streams, i, j, ret;
+    AVChannelLayout layout = { 0 };
+
+    if (!avctx->extradata) {
+        if (channels > 2) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Multichannel configuration without extradata.\n");
+            return AVERROR(EINVAL);
+        }
+        extradata      = opus_default_extradata;
+        extradata_size = sizeof(opus_default_extradata);
+    } else {
+        extradata = avctx->extradata;
+        extradata_size = avctx->extradata_size;
+    }
+
+    if (extradata_size < 19) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid extradata size: %d\n",
+               extradata_size);
+        return AVERROR_INVALIDDATA;
+    }
+
+    version = extradata[8];
+    if (version > 15) {
+        avpriv_request_sample(avctx, "Extradata version %d", version);
+        return AVERROR_PATCHWELCOME;
+    }
+
+    avctx->delay = AV_RL16(extradata + 10);
+    if (avctx->internal)
+        avctx->internal->skip_samples = avctx->delay;
+
+    channels = avctx->extradata ? extradata[9] : (channels == 1) ? 1 : 2;
+    if (!channels) {
+        av_log(avctx, AV_LOG_ERROR, "Zero channel count specified in the extradata\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    s->gain_i = AV_RL16(extradata + 16);
+
+    map_type = extradata[18];
+    if (!map_type) {
+        if (channels > 2) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Channel mapping 0 is only specified for up to 2 channels\n");
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+        layout         = (channels == 1) ? (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO :
+                                           (AVChannelLayout)AV_CHANNEL_LAYOUT_STEREO;
+        streams        = 1;
+        stereo_streams = channels - 1;
+        channel_map    = default_channel_map;
+    } else if (map_type == 1 || map_type == 2 || map_type == 255) {
+        if (extradata_size < 21 + channels) {
+            av_log(avctx, AV_LOG_ERROR, "Invalid extradata size: %d\n",
+                   extradata_size);
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+
+        streams        = extradata[19];
+        stereo_streams = extradata[20];
+        if (!streams || stereo_streams > streams ||
+            streams + stereo_streams > 255) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Invalid stream/stereo stream count: %d/%d\n", streams, stereo_streams);
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+
+        if (map_type == 1) {
+            if (channels > 8) {
+                av_log(avctx, AV_LOG_ERROR,
+                       "Channel mapping 1 is only specified for up to 8 channels\n");
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+            av_channel_layout_copy(&layout, &ff_vorbis_ch_layouts[channels - 1]);
+            channel_reorder = channel_reorder_vorbis;
+        } else if (map_type == 2) {
+            int ambisonic_order = ff_sqrt(channels) - 1;
+            if (channels != ((ambisonic_order + 1) * (ambisonic_order + 1)) &&
+                channels != ((ambisonic_order + 1) * (ambisonic_order + 1) + 2)) {
+                av_log(avctx, AV_LOG_ERROR,
+                       "Channel mapping 2 is only specified for channel counts"
+                       " which can be written as (n + 1)^2 or (n + 1)^2 + 2"
+                       " for nonnegative integer n\n");
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+            if (channels > 227) {
+                av_log(avctx, AV_LOG_ERROR, "Too many channels\n");
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+
+            layout.order = AV_CHANNEL_ORDER_AMBISONIC;
+            layout.nb_channels = channels;
+            if (channels != ((ambisonic_order + 1) * (ambisonic_order + 1)))
+                layout.u.mask = AV_CH_LAYOUT_STEREO;
+        } else {
+            layout.order       = AV_CHANNEL_ORDER_UNSPEC;
+            layout.nb_channels = channels;
+        }
+
+        channel_map = extradata + 21;
+    } else {
+        avpriv_request_sample(avctx, "Mapping type %d", map_type);
+        return AVERROR_PATCHWELCOME;
+    }
+
+    s->channel_maps = av_calloc(channels, sizeof(*s->channel_maps));
+    if (!s->channel_maps) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    for (i = 0; i < channels; i++) {
+        ChannelMap *map = &s->channel_maps[i];
+        uint8_t     idx = channel_map[channel_reorder(channels, i)];
+
+        if (idx == 255) {
+            map->silence = 1;
+            continue;
+        } else if (idx >= streams + stereo_streams) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Invalid channel map for output channel %d: %d\n", i, idx);
+            av_freep(&s->channel_maps);
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+
+        /* check that we did not see this index yet */
+        map->copy = 0;
+        for (j = 0; j < i; j++)
+            if (channel_map[channel_reorder(channels, j)] == idx) {
+                map->copy     = 1;
+                map->copy_idx = j;
+                break;
+            }
+
+        if (idx < 2 * stereo_streams) {
+            map->stream_idx  = idx / 2;
+            map->channel_idx = idx & 1;
+        } else {
+            map->stream_idx  = idx - stereo_streams;
+            map->channel_idx = 0;
+        }
+    }
+
+    ret = av_channel_layout_copy(&avctx->ch_layout, &layout);
+    if (ret < 0)
+        goto fail;
+
+    s->nb_streams         = streams;
+    s->nb_stereo_streams  = stereo_streams;
+
+    return 0;
+fail:
+    av_channel_layout_uninit(&layout);
+    return ret;
+}
+
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/opus_parse.h
@@ -0,0 +1,77 @@
+/*
+ * Opus decoder/parser common functions and structures
+ * Copyright (c) 2012 Andrew D'Addesio
+ * Copyright (c) 2013-2014 Mozilla Corporation
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_OPUS_PARSE_H
+#define AVCODEC_OPUS_PARSE_H
+
+#include <stdint.h>
+
+#include "avcodec.h"
+#include "opus.h"
+
+typedef struct OpusPacket {
+    int packet_size;                /**< packet size */
+    int data_size;                  /**< size of the useful data -- packet size - padding */
+    int code;                       /**< packet code: specifies the frame layout */
+    int stereo;                     /**< whether this packet is mono or stereo */
+    int vbr;                        /**< vbr flag */
+    int config;                     /**< configuration: tells the audio mode,
+                                     **                bandwidth, and frame duration */
+    int frame_count;                /**< frame count */
+    int frame_offset[OPUS_MAX_FRAMES]; /**< frame offsets */
+    int frame_size[OPUS_MAX_FRAMES]; /**< frame sizes */
+    int frame_duration;             /**< frame duration, in samples @ 48kHz */
+    enum OpusMode mode;             /**< mode */
+    enum OpusBandwidth bandwidth;   /**< bandwidth */
+} OpusPacket;
+
+// a mapping between an opus stream and an output channel
+typedef struct ChannelMap {
+    int stream_idx;
+    int channel_idx;
+
+    // when a single decoded channel is mapped to multiple output channels, we
+    // write to the first output directly and copy from it to the others
+    // this field is set to 1 for those copied output channels
+    int copy;
+    // this is the index of the output channel to copy from
+    int copy_idx;
+
+    // this channel is silent
+    int silence;
+} ChannelMap;
+
+typedef struct OpusParseContext {
+    int             nb_streams;
+    int      nb_stereo_streams;
+
+    int16_t gain_i;
+
+    ChannelMap *channel_maps;
+} OpusParseContext;
+
+int ff_opus_parse_packet(OpusPacket *pkt, const uint8_t *buf, int buf_size,
+                         int self_delimited);
+
+int ff_opus_parse_extradata(AVCodecContext *avctx, OpusParseContext *s);
+
+#endif /* AVCODEC_OPUS_PARSE_H */
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/opus_silk.h
@@ -0,0 +1,48 @@
+/*
+ * Opus Silk functions/definitions
+ * Copyright (c) 2012 Andrew D'Addesio
+ * Copyright (c) 2013-2014 Mozilla Corporation
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_OPUS_SILK_H
+#define AVCODEC_OPUS_SILK_H
+
+#include "avcodec.h"
+#include "opus.h"
+#include "opus_rc.h"
+
+#define SILK_HISTORY                 322
+#define SILK_MAX_LPC                 16
+
+typedef struct SilkContext SilkContext;
+
+int ff_silk_init(AVCodecContext *avctx, SilkContext **ps, int output_channels);
+void ff_silk_free(SilkContext **ps);
+void ff_silk_flush(SilkContext *s);
+
+/**
+ * Decode the LP layer of one Opus frame (which may correspond to several SILK
+ * frames).
+ */
+int ff_silk_decode_superframe(SilkContext *s, OpusRangeCoder *rc,
+                              float *output[2],
+                              enum OpusBandwidth bandwidth, int coded_channels,
+                              int duration_ms);
+
+#endif /* AVCODEC_OPUS_SILK_H */
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/opusdec_celt.c
@@ -0,0 +1,586 @@
+/*
+ * Copyright (c) 2012 Andrew D'Addesio
+ * Copyright (c) 2013-2014 Mozilla Corporation
+ * Copyright (c) 2016 Rostislav Pehlivanov <atomnuker@gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Opus CELT decoder
+ */
+
+#include <float.h>
+
+#include "opus_celt.h"
+#include "opustab.h"
+#include "opus_pvq.h"
+
+/* Use the 2D z-transform to apply prediction in both the time domain (alpha)
+ * and the frequency domain (beta) */
+static void celt_decode_coarse_energy(CeltFrame *f, OpusRangeCoder *rc)
+{
+    int i, j;
+    float prev[2] = { 0 };
+    float alpha = ff_celt_alpha_coef[f->size];
+    float beta  = ff_celt_beta_coef[f->size];
+    const uint8_t *model = ff_celt_coarse_energy_dist[f->size][0];
+
+    /* intra frame */
+    if (opus_rc_tell(rc) + 3 <= f->framebits && ff_opus_rc_dec_log(rc, 3)) {
+        alpha = 0.0f;
+        beta  = 1.0f - (4915.0f/32768.0f);
+        model = ff_celt_coarse_energy_dist[f->size][1];
+    }
+
+    for (i = 0; i < CELT_MAX_BANDS; i++) {
+        for (j = 0; j < f->channels; j++) {
+            CeltBlock *block = &f->block[j];
+            float value;
+            int available;
+
+            if (i < f->start_band || i >= f->end_band) {
+                block->energy[i] = 0.0;
+                continue;
+            }
+
+            available = f->framebits - opus_rc_tell(rc);
+            if (available >= 15) {
+                /* decode using a Laplace distribution */
+                int k = FFMIN(i, 20) << 1;
+                value = ff_opus_rc_dec_laplace(rc, model[k] << 7, model[k+1] << 6);
+            } else if (available >= 2) {
+                int x = ff_opus_rc_dec_cdf(rc, ff_celt_model_energy_small);
+                value = (x>>1) ^ -(x&1);
+            } else if (available >= 1) {
+                value = -(float)ff_opus_rc_dec_log(rc, 1);
+            } else value = -1;
+
+            block->energy[i] = FFMAX(-9.0f, block->energy[i]) * alpha + prev[j] + value;
+            prev[j] += beta * value;
+        }
+    }
+}
+
+static void celt_decode_fine_energy(CeltFrame *f, OpusRangeCoder *rc)
+{
+    int i;
+    for (i = f->start_band; i < f->end_band; i++) {
+        int j;
+        if (!f->fine_bits[i])
+            continue;
+
+        for (j = 0; j < f->channels; j++) {
+            CeltBlock *block = &f->block[j];
+            int q2;
+            float offset;
+            q2 = ff_opus_rc_get_raw(rc, f->fine_bits[i]);
+            offset = (q2 + 0.5f) * (1 << (14 - f->fine_bits[i])) / 16384.0f - 0.5f;
+            block->energy[i] += offset;
+        }
+    }
+}
+
+static void celt_decode_final_energy(CeltFrame *f, OpusRangeCoder *rc)
+{
+    int priority, i, j;
+    int bits_left = f->framebits - opus_rc_tell(rc);
+
+    for (priority = 0; priority < 2; priority++) {
+        for (i = f->start_band; i < f->end_band && bits_left >= f->channels; i++) {
+            if (f->fine_priority[i] != priority || f->fine_bits[i] >= CELT_MAX_FINE_BITS)
+                continue;
+
+            for (j = 0; j < f->channels; j++) {
+                int q2;
+                float offset;
+                q2 = ff_opus_rc_get_raw(rc, 1);
+                offset = (q2 - 0.5f) * (1 << (14 - f->fine_bits[i] - 1)) / 16384.0f;
+                f->block[j].energy[i] += offset;
+                bits_left--;
+            }
+        }
+    }
+}
+
+static void celt_decode_tf_changes(CeltFrame *f, OpusRangeCoder *rc)
+{
+    int i, diff = 0, tf_select = 0, tf_changed = 0, tf_select_bit;
+    int consumed, bits = f->transient ? 2 : 4;
+
+    consumed = opus_rc_tell(rc);
+    tf_select_bit = (f->size != 0 && consumed+bits+1 <= f->framebits);
+
+    for (i = f->start_band; i < f->end_band; i++) {
+        if (consumed+bits+tf_select_bit <= f->framebits) {
+            diff ^= ff_opus_rc_dec_log(rc, bits);
+            consumed = opus_rc_tell(rc);
+            tf_changed |= diff;
+        }
+        f->tf_change[i] = diff;
+        bits = f->transient ? 4 : 5;
+    }
+
+    if (tf_select_bit && ff_celt_tf_select[f->size][f->transient][0][tf_changed] !=
+                         ff_celt_tf_select[f->size][f->transient][1][tf_changed])
+        tf_select = ff_opus_rc_dec_log(rc, 1);
+
+    for (i = f->start_band; i < f->end_band; i++) {
+        f->tf_change[i] = ff_celt_tf_select[f->size][f->transient][tf_select][f->tf_change[i]];
+    }
+}
+
+static void celt_denormalize(CeltFrame *f, CeltBlock *block, float *data)
+{
+    int i, j;
+
+    for (i = f->start_band; i < f->end_band; i++) {
+        float *dst = data + (ff_celt_freq_bands[i] << f->size);
+        float log_norm = block->energy[i] + ff_celt_mean_energy[i];
+        float norm = exp2f(FFMIN(log_norm, 32.0f));
+
+        for (j = 0; j < ff_celt_freq_range[i] << f->size; j++)
+            dst[j] *= norm;
+    }
+}
+
+static void celt_postfilter_apply_transition(CeltBlock *block, float *data)
+{
+    const int T0 = block->pf_period_old;
+    const int T1 = block->pf_period;
+
+    float g00, g01, g02;
+    float g10, g11, g12;
+
+    float x0, x1, x2, x3, x4;
+
+    int i;
+
+    if (block->pf_gains[0]     == 0.0 &&
+        block->pf_gains_old[0] == 0.0)
+        return;
+
+    g00 = block->pf_gains_old[0];
+    g01 = block->pf_gains_old[1];
+    g02 = block->pf_gains_old[2];
+    g10 = block->pf_gains[0];
+    g11 = block->pf_gains[1];
+    g12 = block->pf_gains[2];
+
+    x1 = data[-T1 + 1];
+    x2 = data[-T1];
+    x3 = data[-T1 - 1];
+    x4 = data[-T1 - 2];
+
+    for (i = 0; i < CELT_OVERLAP; i++) {
+        float w = ff_celt_window2[i];
+        x0 = data[i - T1 + 2];
+
+        data[i] +=  (1.0 - w) * g00 * data[i - T0]                          +
+                    (1.0 - w) * g01 * (data[i - T0 - 1] + data[i - T0 + 1]) +
+                    (1.0 - w) * g02 * (data[i - T0 - 2] + data[i - T0 + 2]) +
+                    w         * g10 * x2                                    +
+                    w         * g11 * (x1 + x3)                             +
+                    w         * g12 * (x0 + x4);
+        x4 = x3;
+        x3 = x2;
+        x2 = x1;
+        x1 = x0;
+    }
+}
+
+static void celt_postfilter(CeltFrame *f, CeltBlock *block)
+{
+    int len = f->blocksize * f->blocks;
+    const int filter_len = len - 2 * CELT_OVERLAP;
+
+    celt_postfilter_apply_transition(block, block->buf + 1024);
+
+    block->pf_period_old = block->pf_period;
+    memcpy(block->pf_gains_old, block->pf_gains, sizeof(block->pf_gains));
+
+    block->pf_period = block->pf_period_new;
+    memcpy(block->pf_gains, block->pf_gains_new, sizeof(block->pf_gains));
+
+    if (len > CELT_OVERLAP) {
+        celt_postfilter_apply_transition(block, block->buf + 1024 + CELT_OVERLAP);
+
+        if (block->pf_gains[0] > FLT_EPSILON && filter_len > 0)
+            f->opusdsp.postfilter(block->buf + 1024 + 2 * CELT_OVERLAP,
+                                  block->pf_period, block->pf_gains,
+                                  filter_len);
+
+        block->pf_period_old = block->pf_period;
+        memcpy(block->pf_gains_old, block->pf_gains, sizeof(block->pf_gains));
+    }
+
+    memmove(block->buf, block->buf + len, (1024 + CELT_OVERLAP / 2) * sizeof(float));
+}
+
+static int parse_postfilter(CeltFrame *f, OpusRangeCoder *rc, int consumed)
+{
+    int i;
+
+    memset(f->block[0].pf_gains_new, 0, sizeof(f->block[0].pf_gains_new));
+    memset(f->block[1].pf_gains_new, 0, sizeof(f->block[1].pf_gains_new));
+
+    if (f->start_band == 0 && consumed + 16 <= f->framebits) {
+        int has_postfilter = ff_opus_rc_dec_log(rc, 1);
+        if (has_postfilter) {
+            float gain;
+            int tapset, octave, period;
+
+            octave = ff_opus_rc_dec_uint(rc, 6);
+            period = (16 << octave) + ff_opus_rc_get_raw(rc, 4 + octave) - 1;
+            gain   = 0.09375f * (ff_opus_rc_get_raw(rc, 3) + 1);
+            tapset = (opus_rc_tell(rc) + 2 <= f->framebits) ?
+                     ff_opus_rc_dec_cdf(rc, ff_celt_model_tapset) : 0;
+
+            for (i = 0; i < 2; i++) {
+                CeltBlock *block = &f->block[i];
+
+                block->pf_period_new = FFMAX(period, CELT_POSTFILTER_MINPERIOD);
+                block->pf_gains_new[0] = gain * ff_celt_postfilter_taps[tapset][0];
+                block->pf_gains_new[1] = gain * ff_celt_postfilter_taps[tapset][1];
+                block->pf_gains_new[2] = gain * ff_celt_postfilter_taps[tapset][2];
+            }
+        }
+
+        consumed = opus_rc_tell(rc);
+    }
+
+    return consumed;
+}
+
+static void process_anticollapse(CeltFrame *f, CeltBlock *block, float *X)
+{
+    int i, j, k;
+
+    for (i = f->start_band; i < f->end_band; i++) {
+        int renormalize = 0;
+        float *xptr;
+        float prev[2];
+        float Ediff, r;
+        float thresh, sqrt_1;
+        int depth;
+
+        /* depth in 1/8 bits */
+        depth = (1 + f->pulses[i]) / (ff_celt_freq_range[i] << f->size);
+        thresh = exp2f(-1.0 - 0.125f * depth);
+        sqrt_1 = 1.0f / sqrtf(ff_celt_freq_range[i] << f->size);
+
+        xptr = X + (ff_celt_freq_bands[i] << f->size);
+
+        prev[0] = block->prev_energy[0][i];
+        prev[1] = block->prev_energy[1][i];
+        if (f->channels == 1) {
+            CeltBlock *block1 = &f->block[1];
+
+            prev[0] = FFMAX(prev[0], block1->prev_energy[0][i]);
+            prev[1] = FFMAX(prev[1], block1->prev_energy[1][i]);
+        }
+        Ediff = block->energy[i] - FFMIN(prev[0], prev[1]);
+        Ediff = FFMAX(0, Ediff);
+
+        /* r needs to be multiplied by 2 or 2*sqrt(2) depending on LM because
+        short blocks don't have the same energy as long */
+        r = exp2f(1 - Ediff);
+        if (f->size == 3)
+            r *= M_SQRT2;
+        r = FFMIN(thresh, r) * sqrt_1;
+        for (k = 0; k < 1 << f->size; k++) {
+            /* Detect collapse */
+            if (!(block->collapse_masks[i] & 1 << k)) {
+                /* Fill with noise */
+                for (j = 0; j < ff_celt_freq_range[i]; j++)
+                    xptr[(j << f->size) + k] = (celt_rng(f) & 0x8000) ? r : -r;
+                renormalize = 1;
+            }
+        }
+
+        /* We just added some energy, so we need to renormalize */
+        if (renormalize)
+            celt_renormalize_vector(xptr, ff_celt_freq_range[i] << f->size, 1.0f);
+    }
+}
+
+int ff_celt_decode_frame(CeltFrame *f, OpusRangeCoder *rc,
+                         float **output, int channels, int frame_size,
+                         int start_band,  int end_band)
+{
+    int i, j, downmix = 0;
+    int consumed;           // bits of entropy consumed thus far for this frame
+    AVTXContext *imdct;
+    av_tx_fn imdct_fn;
+
+    if (channels != 1 && channels != 2) {
+        av_log(f->avctx, AV_LOG_ERROR, "Invalid number of coded channels: %d\n",
+               channels);
+        return AVERROR_INVALIDDATA;
+    }
+    if (start_band < 0 || start_band > end_band || end_band > CELT_MAX_BANDS) {
+        av_log(f->avctx, AV_LOG_ERROR, "Invalid start/end band: %d %d\n",
+               start_band, end_band);
+        return AVERROR_INVALIDDATA;
+    }
+
+    f->silence        = 0;
+    f->transient      = 0;
+    f->anticollapse   = 0;
+    f->flushed        = 0;
+    f->channels       = channels;
+    f->start_band     = start_band;
+    f->end_band       = end_band;
+    f->framebits      = rc->rb.bytes * 8;
+
+    f->size = av_log2(frame_size / CELT_SHORT_BLOCKSIZE);
+    if (f->size > CELT_MAX_LOG_BLOCKS ||
+        frame_size != CELT_SHORT_BLOCKSIZE * (1 << f->size)) {
+        av_log(f->avctx, AV_LOG_ERROR, "Invalid CELT frame size: %d\n",
+               frame_size);
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (!f->output_channels)
+        f->output_channels = channels;
+
+    for (i = 0; i < f->channels; i++) {
+        memset(f->block[i].coeffs,         0, sizeof(f->block[i].coeffs));
+        memset(f->block[i].collapse_masks, 0, sizeof(f->block[i].collapse_masks));
+    }
+
+    consumed = opus_rc_tell(rc);
+
+    /* obtain silence flag */
+    if (consumed >= f->framebits)
+        f->silence = 1;
+    else if (consumed == 1)
+        f->silence = ff_opus_rc_dec_log(rc, 15);
+
+
+    if (f->silence) {
+        consumed = f->framebits;
+        rc->total_bits += f->framebits - opus_rc_tell(rc);
+    }
+
+    /* obtain post-filter options */
+    consumed = parse_postfilter(f, rc, consumed);
+
+    /* obtain transient flag */
+    if (f->size != 0 && consumed+3 <= f->framebits)
+        f->transient = ff_opus_rc_dec_log(rc, 3);
+
+    f->blocks    = f->transient ? 1 << f->size : 1;
+    f->blocksize = frame_size / f->blocks;
+
+    imdct = f->tx[f->transient ? 0 : f->size];
+    imdct_fn = f->tx_fn[f->transient ? 0 : f->size];
+
+    if (channels == 1) {
+        for (i = 0; i < CELT_MAX_BANDS; i++)
+            f->block[0].energy[i] = FFMAX(f->block[0].energy[i], f->block[1].energy[i]);
+    }
+
+    celt_decode_coarse_energy(f, rc);
+    celt_decode_tf_changes   (f, rc);
+    ff_celt_bitalloc         (f, rc, 0);
+    celt_decode_fine_energy  (f, rc);
+    ff_celt_quant_bands      (f, rc);
+
+    if (f->anticollapse_needed)
+        f->anticollapse = ff_opus_rc_get_raw(rc, 1);
+
+    celt_decode_final_energy(f, rc);
+
+    /* apply anti-collapse processing and denormalization to
+     * each coded channel */
+    for (i = 0; i < f->channels; i++) {
+        CeltBlock *block = &f->block[i];
+
+        if (f->anticollapse)
+            process_anticollapse(f, block, f->block[i].coeffs);
+
+        celt_denormalize(f, block, f->block[i].coeffs);
+    }
+
+    /* stereo -> mono downmix */
+    if (f->output_channels < f->channels) {
+        f->dsp->vector_fmac_scalar(f->block[0].coeffs, f->block[1].coeffs, 1.0, FFALIGN(frame_size, 16));
+        downmix = 1;
+    } else if (f->output_channels > f->channels)
+        memcpy(f->block[1].coeffs, f->block[0].coeffs, frame_size * sizeof(float));
+
+    if (f->silence) {
+        for (i = 0; i < 2; i++) {
+            CeltBlock *block = &f->block[i];
+
+            for (j = 0; j < FF_ARRAY_ELEMS(block->energy); j++)
+                block->energy[j] = CELT_ENERGY_SILENCE;
+        }
+        memset(f->block[0].coeffs, 0, sizeof(f->block[0].coeffs));
+        memset(f->block[1].coeffs, 0, sizeof(f->block[1].coeffs));
+    }
+
+    /* transform and output for each output channel */
+    for (i = 0; i < f->output_channels; i++) {
+        CeltBlock *block = &f->block[i];
+
+        /* iMDCT and overlap-add */
+        for (j = 0; j < f->blocks; j++) {
+            float *dst  = block->buf + 1024 + j * f->blocksize;
+
+            imdct_fn(imdct, dst + CELT_OVERLAP / 2, f->block[i].coeffs + j,
+                     sizeof(float)*f->blocks);
+            f->dsp->vector_fmul_window(dst, dst, dst + CELT_OVERLAP / 2,
+                                       ff_celt_window, CELT_OVERLAP / 2);
+        }
+
+        if (downmix)
+            f->dsp->vector_fmul_scalar(&block->buf[1024], &block->buf[1024], 0.5f, frame_size);
+
+        /* postfilter */
+        celt_postfilter(f, block);
+
+        /* deemphasis */
+        block->emph_coeff = f->opusdsp.deemphasis(output[i],
+                                                  &block->buf[1024 - frame_size],
+                                                  block->emph_coeff, frame_size);
+    }
+
+    if (channels == 1)
+        memcpy(f->block[1].energy, f->block[0].energy, sizeof(f->block[0].energy));
+
+    for (i = 0; i < 2; i++ ) {
+        CeltBlock *block = &f->block[i];
+
+        if (!f->transient) {
+            memcpy(block->prev_energy[1], block->prev_energy[0], sizeof(block->prev_energy[0]));
+            memcpy(block->prev_energy[0], block->energy,         sizeof(block->prev_energy[0]));
+        } else {
+            for (j = 0; j < CELT_MAX_BANDS; j++)
+                block->prev_energy[0][j] = FFMIN(block->prev_energy[0][j], block->energy[j]);
+        }
+
+        for (j = 0; j < f->start_band; j++) {
+            block->prev_energy[0][j] = CELT_ENERGY_SILENCE;
+            block->energy[j]         = 0.0;
+        }
+        for (j = f->end_band; j < CELT_MAX_BANDS; j++) {
+            block->prev_energy[0][j] = CELT_ENERGY_SILENCE;
+            block->energy[j]         = 0.0;
+        }
+    }
+
+    f->seed = rc->range;
+
+    return 0;
+}
+
+void ff_celt_flush(CeltFrame *f)
+{
+    int i, j;
+
+    if (f->flushed)
+        return;
+
+    for (i = 0; i < 2; i++) {
+        CeltBlock *block = &f->block[i];
+
+        for (j = 0; j < CELT_MAX_BANDS; j++)
+            block->prev_energy[0][j] = block->prev_energy[1][j] = CELT_ENERGY_SILENCE;
+
+        memset(block->energy, 0, sizeof(block->energy));
+        memset(block->buf,    0, sizeof(block->buf));
+
+        memset(block->pf_gains,     0, sizeof(block->pf_gains));
+        memset(block->pf_gains_old, 0, sizeof(block->pf_gains_old));
+        memset(block->pf_gains_new, 0, sizeof(block->pf_gains_new));
+
+        /* libopus uses CELT_EMPH_COEFF on init, but 0 is better since there's
+         * a lesser discontinuity when seeking.
+         * The deemphasis functions differ from libopus in that they require
+         * an initial state divided by the coefficient. */
+        block->emph_coeff = 0.0f / CELT_EMPH_COEFF;
+    }
+    f->seed = 0;
+
+    f->flushed = 1;
+}
+
+void ff_celt_free(CeltFrame **f)
+{
+    CeltFrame *frm = *f;
+    int i;
+
+    if (!frm)
+        return;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(frm->tx); i++)
+        av_tx_uninit(&frm->tx[i]);
+
+    ff_celt_pvq_uninit(&frm->pvq);
+
+    av_freep(&frm->dsp);
+    av_freep(f);
+}
+
+int ff_celt_init(AVCodecContext *avctx, CeltFrame **f, int output_channels,
+                 int apply_phase_inv)
+{
+    CeltFrame *frm;
+    int i, ret;
+
+    if (output_channels != 1 && output_channels != 2) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid number of output channels: %d\n",
+               output_channels);
+        return AVERROR(EINVAL);
+    }
+
+    frm = av_mallocz(sizeof(*frm));
+    if (!frm)
+        return AVERROR(ENOMEM);
+
+    frm->avctx           = avctx;
+    frm->output_channels = output_channels;
+    frm->apply_phase_inv = apply_phase_inv;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(frm->tx); i++) {
+        const float scale = -1.0f/32768;
+        if ((ret = av_tx_init(&frm->tx[i], &frm->tx_fn[i], AV_TX_FLOAT_MDCT, 1, 15 << (i + 3), &scale, 0)) < 0)
+            goto fail;
+    }
+
+    if ((ret = ff_celt_pvq_init(&frm->pvq, 0)) < 0)
+        goto fail;
+
+    frm->dsp = avpriv_float_dsp_alloc(avctx->flags & AV_CODEC_FLAG_BITEXACT);
+    if (!frm->dsp) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    ff_opus_dsp_init(&frm->opusdsp);
+    ff_celt_flush(frm);
+
+    *f = frm;
+
+    return 0;
+fail:
+    ff_celt_free(&frm);
+    return ret;
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/qsvenc_av1.c
@@ -0,0 +1,156 @@
+/*
+ * Intel MediaSDK QSV based AV1 encoder
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <mfxvideo.h>
+
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+
+#include "avcodec.h"
+#include "codec_internal.h"
+#include "bsf.h"
+#include "qsv.h"
+#include "qsvenc.h"
+
+typedef struct QSVAV1EncContext {
+    AVClass *class;
+    AVBSFContext *extra_data_bsf;
+    QSVEncContext qsv;
+} QSVAV1EncContext;
+
+static av_cold int qsv_enc_init(AVCodecContext *avctx)
+{
+    QSVAV1EncContext *q = avctx->priv_data;
+    int ret;
+
+    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+        const AVBitStreamFilter *filter = av_bsf_get_by_name("extract_extradata");
+        if (!filter) {
+            av_log(avctx, AV_LOG_ERROR, "Cannot get extract_extradata bitstream filter\n");
+            return AVERROR_BUG;
+        }
+        ret = av_bsf_alloc(filter, &q->extra_data_bsf);
+        if (ret < 0)
+            return ret;
+        ret = avcodec_parameters_from_context(q->extra_data_bsf->par_in, avctx);
+        if (ret < 0)
+           return ret;
+        ret = av_bsf_init(q->extra_data_bsf);
+        if (ret < 0)
+           return ret;
+    }
+
+    return ff_qsv_enc_init(avctx, &q->qsv);
+}
+
+static int qsv_enc_frame(AVCodecContext *avctx, AVPacket *pkt,
+                         const AVFrame *frame, int *got_packet)
+{
+    QSVAV1EncContext *q = avctx->priv_data;
+    int ret;
+
+    ret = ff_qsv_encode(avctx, &q->qsv, pkt, frame, got_packet);
+    if (ret < 0)
+        return ret;
+
+    if (*got_packet && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+        ret = av_bsf_send_packet(q->extra_data_bsf, pkt);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
+                "failed to send input packet\n");
+            return ret;
+        }
+
+        ret = av_bsf_receive_packet(q->extra_data_bsf, pkt);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
+                "failed to receive output packet\n");
+            return ret;
+        }
+    }
+
+    return ret;
+}
+
+static av_cold int qsv_enc_close(AVCodecContext *avctx)
+{
+    QSVAV1EncContext *q = avctx->priv_data;
+
+    av_bsf_free(&q->extra_data_bsf);
+
+    return ff_qsv_enc_close(avctx, &q->qsv);
+}
+
+#define OFFSET(x) offsetof(QSVAV1EncContext, x)
+#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+static const AVOption options[] = {
+    QSV_COMMON_OPTS
+    QSV_OPTION_B_STRATEGY
+    QSV_OPTION_ADAPTIVE_I
+    QSV_OPTION_ADAPTIVE_B
+    QSV_OPTION_EXTBRC
+    { "profile", NULL, OFFSET(qsv.profile), AV_OPT_TYPE_INT, { .i64 = MFX_PROFILE_UNKNOWN }, 0, INT_MAX, VE, "profile" },
+        { "unknown" , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MFX_PROFILE_UNKNOWN      }, INT_MIN, INT_MAX,     VE, "profile" },
+        { "main"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MFX_PROFILE_AV1_MAIN     }, INT_MIN, INT_MAX,     VE, "profile" },
+    { "tile_cols",  "Number of columns for tiled encoding",   OFFSET(qsv.tile_cols),    AV_OPT_TYPE_INT, { .i64 = 0 }, 0, UINT16_MAX, VE },
+    { "tile_rows",  "Number of rows for tiled encoding",      OFFSET(qsv.tile_rows),    AV_OPT_TYPE_INT, { .i64 = 0 }, 0, UINT16_MAX, VE },
+    { "look_ahead_depth", "Depth of look ahead in number frames, available when extbrc option is enabled", OFFSET(qsv.look_ahead_depth), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 100, VE },
+    { NULL },
+};
+
+static const AVClass class = {
+    .class_name = "av1_qsv encoder",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+static const FFCodecDefault qsv_enc_defaults[] = {
+    { "b",         "1M"   },
+    { "g",         "-1"   },
+    { "bf",        "-1"   },
+    { "refs",      "0"    },
+    { NULL },
+};
+
+FFCodec ff_av1_qsv_encoder = {
+    .p.name           = "av1_qsv",
+    .p.long_name      = NULL_IF_CONFIG_SMALL("AV1 (Intel Quick Sync Video acceleration)"),
+    .priv_data_size = sizeof(QSVAV1EncContext),
+    .p.type           = AVMEDIA_TYPE_VIDEO,
+    .p.id             = AV_CODEC_ID_AV1,
+    .init             = qsv_enc_init,
+    FF_CODEC_ENCODE_CB(qsv_enc_frame),
+    .close            = qsv_enc_close,
+    .p.capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HYBRID,
+    .p.pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_NV12,
+                                                    AV_PIX_FMT_P010,
+                                                    AV_PIX_FMT_QSV,
+                                                    AV_PIX_FMT_NONE },
+    .p.priv_class     = &class,
+    .defaults       = qsv_enc_defaults,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .p.wrapper_name   = "qsv",
+    .hw_configs     = ff_qsv_enc_hw_configs,
+};
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/Makefile
@@ -0,0 +1,21 @@
+OBJS-$(CONFIG_AAC_DECODER) += riscv/aacpsdsp_init.o
+RVV-OBJS-$(CONFIG_AAC_DECODER) += riscv/aacpsdsp_rvv.o
+OBJS-$(CONFIG_ALAC_DECODER) += riscv/alacdsp_init.o
+RVV-OBJS-$(CONFIG_ALAC_DECODER) += riscv/alacdsp_rvv.o
+OBJS-$(CONFIG_AUDIODSP) += riscv/audiodsp_init.o \
+                           riscv/audiodsp_rvf.o
+RVV-OBJS-$(CONFIG_AUDIODSP) += riscv/audiodsp_rvv.o
+OBJS-$(CONFIG_BSWAPDSP) += riscv/bswapdsp_init.o \
+                           riscv/bswapdsp_rvb.o
+RVV-OBJS-$(CONFIG_BSWAPDSP) += riscv/bswapdsp_rvv.o
+OBJS-$(CONFIG_FMTCONVERT) += riscv/fmtconvert_init.o
+RVV-OBJS-$(CONFIG_FMTCONVERT) += riscv/fmtconvert_rvv.o
+OBJS-$(CONFIG_IDCTDSP) += riscv/idctdsp_init.o
+RVV-OBJS-$(CONFIG_IDCTDSP) += riscv/idctdsp_rvv.o
+OBJS-$(CONFIG_OPUS_DECODER) += riscv/opusdsp_init.o
+RVV-OBJS-$(CONFIG_OPUS_DECODER) += riscv/opusdsp_rvv.o
+OBJS-$(CONFIG_PIXBLOCKDSP) += riscv/pixblockdsp_init.o \
+                              riscv/pixblockdsp_rvi.o
+RVV-OBJS-$(CONFIG_PIXBLOCKDSP) += riscv/pixblockdsp_rvv.o
+OBJS-$(CONFIG_VORBIS_DECODER) += riscv/vorbisdsp_init.o
+RVV-OBJS-$(CONFIG_VORBIS_DECODER) += riscv/vorbisdsp_rvv.o
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/aacpsdsp_init.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavcodec/aacpsdsp.h"
+
+void ff_ps_add_squares_rvv(float *dst, const float (*src)[2], int n);
+void ff_ps_mul_pair_single_rvv(float (*dst)[2], float (*src0)[2], float *src1,
+                               int n);
+void ff_ps_hybrid_analysis_rvv(float (*out)[2], float (*in)[2],
+                               const float (*filter)[8][2], ptrdiff_t, int n);
+void ff_ps_hybrid_analysis_ileave_rvv(float (*out)[32][2], float L[2][38][64],
+                                      int i, int len);
+void ff_ps_hybrid_synthesis_deint_rvv(float out[2][38][64], float (*in)[32][2],
+                                      int i, int len);
+
+void ff_ps_stereo_interpolate_rvv(float (*l)[2], float (*r)[2],
+                                  float h[2][4], float h_step[2][4], int len);
+
+av_cold void ff_psdsp_init_riscv(PSDSPContext *c)
+{
+#if HAVE_RVV
+    int flags = av_get_cpu_flags();
+
+    if (flags & AV_CPU_FLAG_RVV_F32) {
+        c->add_squares = ff_ps_add_squares_rvv;
+        c->mul_pair_single = ff_ps_mul_pair_single_rvv;
+        c->hybrid_analysis = ff_ps_hybrid_analysis_rvv;
+        c->stereo_interpolate[0] = ff_ps_stereo_interpolate_rvv;
+    }
+
+    if (flags & AV_CPU_FLAG_RVV_I32) {
+        c->hybrid_analysis_ileave = ff_ps_hybrid_analysis_ileave_rvv;
+        c->hybrid_synthesis_deint = ff_ps_hybrid_synthesis_deint_rvv;
+    }
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/aacpsdsp_rvv.S
@@ -0,0 +1,279 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_ps_add_squares_rvv, zve32f
+1:
+        vsetvli     t0, a2, e32, m1, ta, ma
+        vlseg2e32.v v24, (a1)
+        sub         a2, a2, t0
+        vle32.v     v16, (a0)
+        sh3add      a1, t0, a1
+        vfmacc.vv   v16, v24, v24
+        vfmacc.vv   v16, v25, v25
+        vse32.v     v16, (a0)
+        sh2add      a0, t0, a0
+        bnez        a2, 1b
+
+        ret
+endfunc
+
+func ff_ps_mul_pair_single_rvv, zve32f
+1:
+        vsetvli     t0, a3, e32, m1, ta, ma
+        vlseg2e32.v v24, (a1)
+        sub         a3, a3, t0
+        vle32.v     v16, (a2)
+        sh3add      a1, t0, a1
+        vfmul.vv    v24, v24, v16
+        sh2add      a2, t0, a2
+        vfmul.vv    v25, v25, v16
+        vsseg2e32.v v24, (a0)
+        sh3add      a0, t0, a0
+        bnez        a3, 1b
+
+        ret
+endfunc
+
+func ff_ps_hybrid_analysis_rvv, zve32f
+        /* We need 26 FP registers, for 20 scratch ones. Spill fs0-fs5. */
+        addi    sp, sp, -48
+        .irp n, 0, 1, 2, 3, 4, 5
+HWD     fsd     fs\n, (8 * \n)(sp)
+NOHWD   fsw     fs\n, (4 * \n)(sp)
+        .endr
+
+        .macro input, j, fd0, fd1, fd2, fd3
+        flw     \fd0, (4 * ((\j * 2) + 0))(a1)
+        flw     fs4, (4 * (((12 - \j) * 2) + 0))(a1)
+        flw     \fd1, (4 * ((\j * 2) + 1))(a1)
+        fsub.s  \fd3, \fd0, fs4
+        flw     fs5, (4 * (((12 - \j) * 2) + 1))(a1)
+        fadd.s  \fd2, \fd1, fs5
+        fadd.s  \fd0, \fd0, fs4
+        fsub.s  \fd1, \fd1, fs5
+        .endm
+
+        //         re0, re1, im0, im1
+        input   0, ft0, ft1, ft2, ft3
+        input   1, ft4, ft5, ft6, ft7
+        input   2, ft8, ft9, ft10, ft11
+        input   3, fa0, fa1, fa2, fa3
+        input   4, fa4, fa5, fa6, fa7
+        input   5, fs0, fs1, fs2, fs3
+        flw     fs4, (4 * ((6 * 2) + 0))(a1)
+        flw     fs5, (4 * ((6 * 2) + 1))(a1)
+
+        add        a2, a2, 6 * 2 * 4 // point to filter[i][6][0]
+        li         t4, 8 * 2 * 4 // filter byte stride
+        slli       a3, a3, 3 // output byte stride
+1:
+        .macro filter, vs0, vs1, fo0, fo1, fo2, fo3
+        vfmacc.vf  v8, \fo0, \vs0
+        vfmacc.vf  v9, \fo2, \vs0
+        vfnmsac.vf v8, \fo1, \vs1
+        vfmacc.vf  v9, \fo3, \vs1
+        .endm
+
+        vsetvli    t0, a4, e32, m1, ta, ma
+        /*
+         * The filter (a2) has 16 segments, of which 13 need to be extracted.
+         * R-V V supports only up to 8 segments, so unrolling is unavoidable.
+         */
+        addi       t1, a2, -48
+        vlse32.v   v22, (a2), t4
+        addi       t2, a2, -44
+        vlse32.v   v16, (t1), t4
+        addi       t1, a2, -40
+        vfmul.vf   v8, v22, fs4
+        vlse32.v   v24, (t2), t4
+        addi       t2, a2, -36
+        vfmul.vf   v9, v22, fs5
+        vlse32.v   v17, (t1), t4
+        addi       t1, a2, -32
+        vlse32.v   v25, (t2), t4
+        addi       t2, a2, -28
+        filter     v16, v24, ft0, ft1, ft2, ft3
+        vlse32.v   v18, (t1), t4
+        addi       t1, a2, -24
+        vlse32.v   v26, (t2), t4
+        addi       t2, a2, -20
+        filter     v17, v25, ft4, ft5, ft6, ft7
+        vlse32.v   v19, (t1), t4
+        addi       t1, a2, -16
+        vlse32.v   v27, (t2), t4
+        addi       t2, a2, -12
+        filter     v18, v26, ft8, ft9, ft10, ft11
+        vlse32.v   v20, (t1), t4
+        addi       t1, a2, -8
+        vlse32.v   v28, (t2), t4
+        addi       t2, a2, -4
+        filter     v19, v27, fa0, fa1, fa2, fa3
+        vlse32.v   v21, (t1), t4
+        sub        a4, a4, t0
+        vlse32.v   v29, (t2), t4
+        slli       t1, t0, 3 + 1 + 2 // ctz(8 * 2 * 4)
+        add        a2, a2, t1
+        filter     v20, v28, fa4, fa5, fa6, fa7
+        filter     v21, v29, fs0, fs1, fs2, fs3
+
+        add        t2, a0, 4
+        vsse32.v   v8, (a0), a3
+        mul        t0, t0, a3
+        vsse32.v   v9, (t2), a3
+        add        a0, a0, t0
+        bnez       a4, 1b
+
+        .irp n, 5, 4, 3, 2, 1, 0
+HWD     fld     fs\n, (8 * \n)(sp)
+NOHWD   flw     fs\n, (4 * \n)(sp)
+        .endr
+        addi    sp, sp, 48
+        ret
+        .purgem input
+        .purgem filter
+endfunc
+
+func ff_ps_hybrid_analysis_ileave_rvv, zve32x /* no needs for zve32f here */
+        slli        t0, a2, 5 + 1 + 2 // ctz(32 * 2 * 4)
+        sh2add      a1, a2, a1
+        add         a0, a0, t0
+        addi        a2, a2, -64
+        li          t1, 38 * 64 * 4
+        li          t6, 64 * 4 // (uint8_t *)L[x][j+1][i] - L[x][j][i]
+        add         a4, a1, t1 // &L[1]
+        beqz        a2, 3f
+1:
+        mv          t0, a0
+        mv          t1, a1
+        mv          t3, a3
+        mv          t4, a4
+        addi        a2, a2, 1
+2:
+        vsetvli     t5, t3, e32, m1, ta, ma
+        vlse32.v    v16, (t1), t6
+        sub         t3, t3, t5
+        vlse32.v    v17, (t4), t6
+        mul         t2, t5, t6
+        vsseg2e32.v v16, (t0)
+        sh3add      t0, t5, t0
+        add         t1, t1, t2
+        add         t4, t4, t2
+        bnez        t3, 2b
+
+        add         a0, a0, 32 * 2 * 4
+        add         a1, a1, 4
+        add         a4, a4, 4
+        bnez        a2, 1b
+3:
+        ret
+endfunc
+
+func ff_ps_hybrid_synthesis_deint_rvv, zve32x
+        slli        t1, a2, 5 + 1 + 2
+        sh2add      a0, a2, a0
+        add         a1, a1, t1
+        addi        a2, a2, -64
+        li          t1, 38 * 64 * 4
+        li          t6, 64 * 4
+        add         a4, a0, t1
+        beqz        a2, 3f
+1:
+        mv          t0, a0
+        mv          t1, a1
+        mv          t3, a3
+        mv          t4, a4
+        addi        a2, a2, 1
+2:
+        vsetvli     t5, t3, e32, m1, ta, ma
+        vlseg2e32.v v16, (t1)
+        sub         t3, t3, t5
+        vsse32.v    v16, (t0), t6
+        mul         t2, t5, t6
+        vsse32.v    v17, (t4), t6
+        sh3add      t1, t5, t1
+        add         t0, t0, t2
+        add         t4, t4, t2
+        bnez        t3, 2b
+
+        add         a0, a0, 4
+        add         a1, a1, 32 * 2 * 4
+        add         a4, a4, 4
+        bnez        a2, 1b
+3:
+        ret
+endfunc
+
+func ff_ps_stereo_interpolate_rvv, zve32f
+        vsetvli      t0, zero, e32, m1, ta, ma
+        vid.v        v24
+        flw          ft0,   (a2)
+        vadd.vi      v24, v24, 1   // v24[i] = i + 1
+        flw          ft1,  4(a2)
+        vfcvt.f.xu.v v24, v24
+        flw          ft2,  8(a2)
+        vfmv.v.f     v16, ft0
+        flw          ft3, 12(a2)
+        vfmv.v.f     v17, ft1
+        flw          ft0,   (a3)
+        vfmv.v.f     v18, ft2
+        flw          ft1,  4(a3)
+        vfmv.v.f     v19, ft3
+        flw          ft2,  8(a3)
+        vfmv.v.f     v20, ft0
+        flw          ft3, 12(a3)
+        vfmv.v.f     v21, ft1
+        fcvt.s.wu    ft4, t0       // (float)(vlenb / sizeof (float))
+        vfmv.v.f     v22, ft2
+        fmul.s       ft0, ft0, ft4
+        vfmv.v.f     v23, ft3
+        fmul.s       ft1, ft1, ft4
+        vfmacc.vv    v16, v24, v20 // h0 += (i + 1) * h0_step
+        fmul.s       ft2, ft2, ft4
+        vfmacc.vv    v17, v24, v21
+        fmul.s       ft3, ft3, ft4
+        vfmacc.vv    v18, v24, v22
+        vfmacc.vv    v19, v24, v23
+1:
+        vsetvli   t0, a4, e32, m1, ta, ma
+        vlseg2e32.v v8, (a0)     // v8:l_re, v9:l_im
+        sub       a4, a4, t0
+        vlseg2e32.v v10, (a1)    // v10:r_re, v11:r_im
+        vfmul.vv  v12, v8, v16
+        vfmul.vv  v13, v9, v16
+        vfmul.vv  v14, v8, v17
+        vfmul.vv  v15, v9, v17
+        vfmacc.vv v12, v10, v18
+        vfmacc.vv v13, v11, v18
+        vfmacc.vv v14, v10, v19
+        vfmacc.vv v15, v11, v19
+        vsseg2e32.v v12, (a0)
+        sh3add    a0, t0, a0
+        vsseg2e32.v v14, (a1)
+        sh3add    a1, t0, a1
+        vfadd.vf  v16, v16, ft0 // h0 += (vlenb / sizeof (float)) * h0_step
+        vfadd.vf  v17, v17, ft1
+        vfadd.vf  v18, v18, ft2
+        vfadd.vf  v19, v19, ft3
+        bnez      a4, 1b
+
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/alacdsp_init.c
@@ -0,0 +1,50 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavcodec/avcodec.h"
+#include "libavcodec/alacdsp.h"
+
+void ff_alac_decorrelate_stereo_rvv(int32_t *buffer[2], int nb_samples,
+                                    int decorr_shift, int decorr_left_weight);
+void ff_alac_append_extra_bits_mono_rvv(int32_t *buffer[2],
+                                        int32_t *extra_bits_buf[2],
+                                        int extra_bits, int channels,
+                                        int nb_samples);
+void ff_alac_append_extra_bits_stereo_rvv(int32_t *buffer[2],
+                                          int32_t *extra_bits_buf[2],
+                                          int extra_bits, int channels,
+                                          int nb_samples);
+
+av_cold void ff_alacdsp_init_riscv(ALACDSPContext *c)
+{
+#if HAVE_RVV && (__riscv_xlen == 64)
+    int flags = av_get_cpu_flags();
+
+    if (flags & AV_CPU_FLAG_RVV_I32) {
+        c->decorrelate_stereo = ff_alac_decorrelate_stereo_rvv;
+        c->append_extra_bits[0] = ff_alac_append_extra_bits_mono_rvv;
+        c->append_extra_bits[1] = ff_alac_append_extra_bits_stereo_rvv;
+    }
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/alacdsp_rvv.S
@@ -0,0 +1,90 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+#if (__riscv_xlen == 64)
+func ff_alac_decorrelate_stereo_rvv, zve32x
+        ld          a4, 8(a0)
+        ld          a0, 0(a0)
+1:
+        vsetvli     t0, a1, e32, m1, ta, ma
+        vle32.v     v24, (a4)
+        sub         a1, a1, t0
+        vle32.v     v16, (a0)
+        vmul.vx     v8, v24, a3
+        vadd.vv     v24, v24, v16
+        vsra.vx     v8, v8, a2
+        vsub.vv     v16, v16, v8
+        vsub.vv     v24, v24, v8
+        vse32.v     v16, (a4)
+        sh2add      a4, t0, a4
+        vse32.v     v24, (a0)
+        sh2add      a0, t0, a0
+        bnez        a1, 1b
+
+        ret
+endfunc
+
+func ff_alac_append_extra_bits_mono_rvv, zve32x
+        ld      a0, (a0)
+        ld      a1, (a1)
+1:
+        vsetvli t0, a4, e32, m1, ta, ma
+        vle32.v v16, (a0)
+        sub     a4, a4, t0
+        vle32.v v24, (a1)
+        sh2add  a1, t0, a1
+        vsll.vx v16, v16, a2
+        vor.vv  v16, v24, v16
+        vse32.v v16, (a0)
+        sh2add  a0, t0, a0
+        bnez    a4, 1b
+
+        ret
+endfunc
+
+func ff_alac_append_extra_bits_stereo_rvv, zve32x
+        ld      a6, 8(a0)
+        ld      a0,  (a0)
+        ld      a7, 8(a1)
+        ld      a1,  (a1)
+1:
+        vsetvli t0, a4, e32, m1, ta, ma
+        vle32.v v16, (a0)
+        sub     a4, a4, t0
+        vle32.v v0, (a6)
+        vsll.vx v16, v16, a2
+        vsll.vx v0, v0, a2
+        vle32.v v24, (a1)
+        sh2add  a1, t0, a1
+        vle32.v v8, (a7)
+        sh2add  a7, t0, a7
+        vor.vv  v16, v24, v16
+        vor.vv  v0, v8, v0
+        vse32.v v16, (a0)
+        sh2add  a0, t0, a0
+        vse32.v v0, (a6)
+        sh2add  a6, t0, a6
+        bnez    a4, 1b
+
+        ret
+endfunc
+#endif
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/audiodsp_init.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavcodec/audiodsp.h"
+
+void ff_vector_clipf_rvf(float *dst, const float *src, int len, float min, float max);
+
+int32_t ff_scalarproduct_int16_rvv(const int16_t *v1, const int16_t *v2, int len);
+void ff_vector_clip_int32_rvv(int32_t *dst, const int32_t *src, int32_t min,
+                              int32_t max, unsigned int len);
+void ff_vector_clipf_rvv(float *dst, const float *src, int len, float min, float max);
+
+av_cold void ff_audiodsp_init_riscv(AudioDSPContext *c)
+{
+    int flags = av_get_cpu_flags();
+
+    if (flags & AV_CPU_FLAG_RVF)
+        c->vector_clipf = ff_vector_clipf_rvf;
+#if HAVE_RVV
+    if (flags & AV_CPU_FLAG_RVV_I32) {
+        c->scalarproduct_int16 = ff_scalarproduct_int16_rvv;
+        c->vector_clip_int32 = ff_vector_clip_int32_rvv;
+    }
+    if (flags & AV_CPU_FLAG_RVV_F32)
+        c->vector_clipf = ff_vector_clipf_rvv;
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/audiodsp_rvf.S
@@ -0,0 +1,49 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_vector_clipf_rvf, f
+NOHWF   fmv.w.x fa0, a3
+NOHWF   fmv.w.x fa1, a4
+1:
+        flw     ft0,   (a1)
+        flw     ft1,  4(a1)
+        fmax.s  ft0, ft0, fa0
+        flw     ft2,  8(a1)
+        fmax.s  ft1, ft1, fa0
+        flw     ft3, 12(a1)
+        fmax.s  ft2, ft2, fa0
+        addi    a2, a2, -4
+        fmax.s  ft3, ft3, fa0
+        addi    a1, a1, 16
+        fmin.s  ft0, ft0, fa1
+        fmin.s  ft1, ft1, fa1
+        fsw     ft0,   (a0)
+        fmin.s  ft2, ft2, fa1
+        fsw     ft1,  4(a0)
+        fmin.s  ft3, ft3, fa1
+        fsw     ft2,  8(a0)
+        fsw     ft3, 12(a0)
+        addi    a0, a0, 16
+        bnez    a2, 1b
+
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/audiodsp_rvv.S
@@ -0,0 +1,72 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_scalarproduct_int16_rvv, zve32x
+        vsetivli    zero, 1, e32, m1, ta, ma
+        vmv.s.x     v8, zero
+1:
+        vsetvli     t0, a2, e16, m1, ta, ma
+        vle16.v     v16, (a0)
+        sub         a2, a2, t0
+        vle16.v     v24, (a1)
+        sh1add      a0, t0, a0
+        vwmul.vv    v0, v16, v24
+        sh1add      a1, t0, a1
+        vsetvli     zero, t0, e32, m2, ta, ma
+        vredsum.vs  v8, v0, v8
+        bnez        a2, 1b
+
+        vmv.x.s     a0, v8
+        ret
+endfunc
+
+func ff_vector_clip_int32_rvv, zve32x
+1:
+        vsetvli t0, a4, e32, m1, ta, ma
+        vle32.v v8, (a1)
+        sub     a4, a4, t0
+        vmax.vx v8, v8, a2
+        sh2add  a1, t0, a1
+        vmin.vx v8, v8, a3
+        vse32.v v8, (a0)
+        sh2add  a0, t0, a0
+        bnez    a4, 1b
+
+        ret
+endfunc
+
+func ff_vector_clipf_rvv, zve32f
+NOHWF   fmv.w.x  fa0, a3
+NOHWF   fmv.w.x  fa1, a4
+1:
+        vsetvli  t0, a2, e32, m1, ta, ma
+        vle32.v  v8, (a1)
+        sub      a2, a2, t0
+        vfmax.vf v8, v8, fa0
+        sh2add   a1, t0, a1
+        vfmin.vf v8, v8, fa1
+        vse32.v  v8, (a0)
+        sh2add   a0, t0, a0
+        bnez     a2, 1b
+
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/bswapdsp_init.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavcodec/bswapdsp.h"
+
+void ff_bswap32_buf_rvb(uint32_t *dst, const uint32_t *src, int len);
+void ff_bswap32_buf_rvv(uint32_t *dst, const uint32_t *src, int len);
+void ff_bswap16_buf_rvv(uint16_t *dst, const uint16_t *src, int len);
+
+av_cold void ff_bswapdsp_init_riscv(BswapDSPContext *c)
+{
+    int cpu_flags = av_get_cpu_flags();
+
+#if (__riscv_xlen >= 64)
+    if (cpu_flags & AV_CPU_FLAG_RVB_BASIC)
+        c->bswap_buf = ff_bswap32_buf_rvb;
+#endif
+#if HAVE_RVV
+    if (cpu_flags & AV_CPU_FLAG_RVV_I32) {
+        c->bswap_buf = ff_bswap32_buf_rvv;
+        c->bswap16_buf = ff_bswap16_buf_rvv;
+    }
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/bswapdsp_rvb.S
@@ -0,0 +1,68 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+#include "libavutil/riscv/asm.S"
+
+#if (__riscv_xlen >= 64)
+func ff_bswap32_buf_rvb, zbb
+        andi    t0, a1, 4
+        beqz    t0, 1f
+        /* Align a1 (input) to 64-bit */
+        lwu     t0, (a1)
+        addi    a0, a0, 4
+        rev8    t0, t0
+        addi    a2, a2, -1
+        srli    t0, t0, __riscv_xlen - 32
+        addi    a1, a1, 4
+        sw      t0, -4(a0)
+1:
+        andi    a3, a2, -2
+        sh2add  a2, a2, a0
+        beqz    a3, 3f
+        sh2add  a3, a3, a0
+2:      /* 2 elements (64 bits) at a time on a 64-bit boundary */
+        ld      t0,  (a1)
+        addi    a0, a0, 8
+        rev8    t0, t0
+#if (__riscv_xlen == 64)
+        srli    t2, t0, 32
+        sw      t0, -4(a0)
+#else
+        srli    t1, t0, __riscv_xlen - 64
+        srli    t2, t0, __riscv_xlen - 32
+        sw      t1, -4(a0)
+#endif
+        addi    a1, a1, 8
+        sw      t2, -8(a0)
+        bne     a0, a3, 2b
+3:
+        beq     a0, a2, 5f
+4:      /* Process last element */
+        lwu     t0, (a1)
+        addi    a0, a0, 4
+        rev8    t0, t0
+        addi    a1, a1, 4
+        srli    t0, t0, __riscv_xlen - 32
+        sw      t0, -4(a0)
+5:
+        ret
+endfunc
+#endif
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/bswapdsp_rvv.S
@@ -0,0 +1,62 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+#include "libavutil/riscv/asm.S"
+
+func ff_bswap32_buf_rvv, zve32x
+        li      t4, 4
+        addi    t1, a0, 1
+        addi    t2, a0, 2
+        addi    t3, a0, 3
+1:
+        vsetvli    t0, a2, e8, m1, ta, ma
+        vlseg4e8.v v8, (a1)
+        sub        a2, a2, t0
+        sh2add     a1, t0, a1
+        vsse8.v    v8, (t3), t4
+        sh2add     t3, t0, t3
+        vsse8.v    v9, (t2), t4
+        sh2add     t2, t0, t2
+        vsse8.v    v10, (t1), t4
+        sh2add     t1, t0, t1
+        vsse8.v    v11, (a0), t4
+        sh2add     a0, t0, a0
+        bnez       a2, 1b
+
+        ret
+endfunc
+
+func ff_bswap16_buf_rvv, zve32x
+        li      t2, 2
+        addi    t1, a0, 1
+1:
+        vsetvli    t0, a2, e8, m1, ta, ma
+        vlseg2e8.v v8, (a1)
+        sub        a2, a2, t0
+        sh1add     a1, t0, a1
+        vsse8.v    v8, (t1), t2
+        sh1add     t1, t0, t1
+        vsse8.v    v9, (a0), t2
+        sh1add     a0, t0, a0
+        bnez       a2, 1b
+
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/fmtconvert_init.c
@@ -0,0 +1,44 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavcodec/fmtconvert.h"
+
+void ff_int32_to_float_fmul_scalar_rvv(float *dst, const int32_t *src,
+                                       float mul, int len);
+void ff_int32_to_float_fmul_array8_rvv(FmtConvertContext *c, float *dst,
+                                       const int32_t *src, const float *mul,
+                                       int len);
+
+av_cold void ff_fmt_convert_init_riscv(FmtConvertContext *c)
+{
+#if HAVE_RVV
+    int flags = av_get_cpu_flags();
+
+    if (flags & AV_CPU_FLAG_RVV_F32) {
+        c->int32_to_float_fmul_scalar = ff_int32_to_float_fmul_scalar_rvv;
+        c->int32_to_float_fmul_array8 = ff_int32_to_float_fmul_array8_rvv;
+    }
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/fmtconvert_rvv.S
@@ -0,0 +1,66 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_int32_to_float_fmul_scalar_rvv, zve32f
+NOHWF   fmv.w.x     fa0, a2
+NOHWF   mv          a2, a3
+1:
+        vsetvli     t0, a2, e32, m1, ta, ma
+        vle32.v     v24, (a1)
+        sub         a2, a2, t0
+        vfcvt.f.x.v v24, v24
+        sh2add      a1, t0, a1
+        vfmul.vf    v24, v24, fa0
+        vse32.v     v24, (a0)
+        sh2add      a0, t0, a0
+        bnez        a2, 1b
+
+        ret
+endfunc
+
+func ff_int32_to_float_fmul_array8_rvv, zve32f
+        srai        a4, a4, 3
+
+1:      vsetvli     t0, a4, e32, m1, ta, ma
+        vle32.v     v24, (a3)
+        slli        t2, t0, 2 + 3
+        vlseg8e32.v v16, (a2)
+        vsetvli     t3, zero, e32, m8, ta, ma
+        vfcvt.f.x.v v16, v16
+        vsetvli     zero, a4, e32, m1, ta, ma
+        vfmul.vv    v16, v16, v24
+        sub         a4, a4, t0
+        vfmul.vv    v17, v17, v24
+        sh2add      a3, t0, a3
+        vfmul.vv    v18, v18, v24
+        add         a2, a2, t2
+        vfmul.vv    v19, v19, v24
+        vfmul.vv    v20, v20, v24
+        vfmul.vv    v21, v21, v24
+        vfmul.vv    v22, v22, v24
+        vfmul.vv    v23, v23, v24
+        vsseg8e32.v v16, (a1)
+        add         a1, a1, t2
+        bnez        a4, 1b
+
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/idctdsp_init.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavutil/riscv/cpu.h"
+#include "libavcodec/avcodec.h"
+#include "libavcodec/idctdsp.h"
+
+void ff_put_pixels_clamped_rvv(const int16_t *block, uint8_t *pixels,
+                               ptrdiff_t stride);
+void ff_put_signed_pixels_clamped_rvv(const int16_t *block, uint8_t *pixels,
+                                      ptrdiff_t stride);
+void ff_add_pixels_clamped_rvv(const int16_t *block, uint8_t *pixels,
+                               ptrdiff_t stride);
+
+av_cold void ff_idctdsp_init_riscv(IDCTDSPContext *c, AVCodecContext *avctx,
+                                   unsigned high_bit_depth)
+{
+#if HAVE_RVV
+    int flags = av_get_cpu_flags();
+
+    if ((flags & AV_CPU_FLAG_RVV_I32) && ff_get_rv_vlenb() >= 16) {
+        c->put_pixels_clamped = ff_put_pixels_clamped_rvv;
+        c->put_signed_pixels_clamped = ff_put_signed_pixels_clamped_rvv;
+        c->add_pixels_clamped = ff_add_pixels_clamped_rvv;
+    }
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/idctdsp_rvv.S
@@ -0,0 +1,79 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_put_pixels_clamped_rvv, zve32x
+        vsetivli    zero, 8, e16, m1, ta, ma
+        vlseg8e16.v v24, (a0)
+1:
+        /* RVV only has signed-signed and unsigned-unsigned clipping.
+         * We need two steps for signed-to-unsigned clipping. */
+        vsetvli     t0, zero, e16, m8, ta, ma
+        vmax.vx     v24, v24, zero
+
+        vsetivli    zero, 8, e8, mf2, ta, ma
+        vnclipu.wi  v16, v24, 0
+        vnclipu.wi  v17, v25, 0
+        vnclipu.wi  v18, v26, 0
+        vnclipu.wi  v19, v27, 0
+        vnclipu.wi  v20, v28, 0
+        vnclipu.wi  v21, v29, 0
+        vnclipu.wi  v22, v30, 0
+        vnclipu.wi  v23, v31, 0
+        vssseg8e8.v v16, (a1), a2
+        ret
+endfunc
+
+func ff_put_signed_pixels_clamped_rvv, zve32x
+        vsetivli    zero, 8, e16, m1, ta, ma
+        vlseg8e16.v v24, (a0)
+
+        li          t1, 128
+        vsetivli    zero, 8, e8, mf2, ta, ma
+        vnclip.wi   v16, v24, 0
+        vnclip.wi   v17, v25, 0
+        vnclip.wi   v18, v26, 0
+        vnclip.wi   v19, v27, 0
+        vnclip.wi   v20, v28, 0
+        vnclip.wi   v21, v29, 0
+        vnclip.wi   v22, v30, 0
+        vnclip.wi   v23, v31, 0
+        vsetvli     t0, zero, e8, m8, ta, ma
+        vadd.vx     v16, v16, t1
+        vsetivli    zero, 8, e8, mf2, ta, ma
+        vssseg8e8.v v16, (a1), a2
+        ret
+endfunc
+
+func ff_add_pixels_clamped_rvv, zve32x
+        vsetivli    zero, 8, e8, mf2, ta, ma
+        vlseg8e16.v v24, (a0)
+        vlsseg8e8.v v16, (a1), a2
+        vwaddu.wv   v24, v24, v16
+        vwaddu.wv   v25, v25, v17
+        vwaddu.wv   v26, v26, v18
+        vwaddu.wv   v27, v27, v19
+        vwaddu.wv   v28, v28, v20
+        vwaddu.wv   v29, v29, v21
+        vwaddu.wv   v30, v30, v22
+        vwaddu.wv   v31, v31, v23
+        j           1b
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/opusdsp_init.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavutil/riscv/cpu.h"
+#include "libavcodec/opusdsp.h"
+
+void ff_opus_postfilter_rvv_128(float *data, int period, float *g, int len);
+void ff_opus_postfilter_rvv_256(float *data, int period, float *g, int len);
+void ff_opus_postfilter_rvv_512(float *data, int period, float *g, int len);
+void ff_opus_postfilter_rvv_1024(float *data, int period, float *g, int len);
+
+av_cold void ff_opus_dsp_init_riscv(OpusDSP *d)
+{
+#if HAVE_RVV
+    int flags = av_get_cpu_flags();
+
+    if (flags & AV_CPU_FLAG_RVV_F32)
+        switch (ff_get_rv_vlenb()) {
+        case 16:
+            d->postfilter = ff_opus_postfilter_rvv_128;
+            break;
+        case 32:
+            d->postfilter = ff_opus_postfilter_rvv_256;
+            break;
+        case 64:
+            d->postfilter = ff_opus_postfilter_rvv_512;
+            break;
+        case 128:
+            d->postfilter = ff_opus_postfilter_rvv_512;
+            break;
+        }
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/opusdsp_rvv.S
@@ -0,0 +1,75 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_opus_postfilter_rvv_128, zve32f
+        lvtypei a5, e32, m2, ta, ma
+        j       1f
+endfunc
+
+func ff_opus_postfilter_rvv_512, zve32f
+        lvtypei a5, e32, mf2, ta, ma
+        j       1f
+endfunc
+
+func ff_opus_postfilter_rvv_1024, zve32f
+        lvtypei a5, e32, mf4, ta, ma
+        j       1f
+endfunc
+
+func ff_opus_postfilter_rvv_256, zve32f
+        lvtypei a5, e32, m1, ta, ma
+1:
+        li           a4, 5
+        addi         a1, a1, 2
+        slli         a1, a1, 2
+        lw           t1, 4(a2)
+        vsetivli     zero, 3, e32, m1, ta, ma
+        vle32.v      v24, (a2)
+        sub          a1, a0, a1      // a1 = &x4 = &data[-(period + 2)]
+        vsetvl       zero, a4, a5
+        vslide1up.vx v8, v24, t1
+        lw           t2, 8(a2)
+        vle32.v      v16, (a1)
+        vslide1up.vx v24, v8, t2     // v24 = { g[2], g[1], g[0], g[1], g[2] }
+2:
+        vsetvl  t0, a3, a5
+        vle32.v v0, (a0)
+        sub     a3, a3, t0
+3:
+        vsetvl         zero, a4, a5
+        lw             t2, 20(a1)
+        vfmul.vv       v8, v24, v16
+        addi           a0, a0, 4
+        vslide1down.vx v16, v16, t2
+        addi           a1, a1, 4
+        vfredusum.vs   v0, v8, v0
+        vsetvl         zero, t0, a5
+        vmv.x.s        t1, v0
+        addi           t0, t0, -1
+        vslide1down.vx v0, v0, zero
+        sw             t1, -4(a0)
+        bnez           t0, 3b
+
+        bnez    a3, 2b
+
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/pixblockdsp_init.c
@@ -0,0 +1,65 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavutil/riscv/cpu.h"
+#include "libavcodec/avcodec.h"
+#include "libavcodec/pixblockdsp.h"
+
+void ff_get_pixels_8_rvi(int16_t *block, const uint8_t *pixels,
+                         ptrdiff_t stride);
+void ff_get_pixels_16_rvi(int16_t *block, const uint8_t *pixels,
+                          ptrdiff_t stride);
+
+void ff_get_pixels_8_rvv(int16_t *block, const uint8_t *pixels,
+                         ptrdiff_t stride);
+void ff_get_pixels_16_rvv(int16_t *block, const uint8_t *pixels,
+                          ptrdiff_t stride);
+void ff_diff_pixels_rvv(int16_t *block, const uint8_t *s1, const uint8_t *s2,
+                        ptrdiff_t stride);
+
+av_cold void ff_pixblockdsp_init_riscv(PixblockDSPContext *c,
+                                       AVCodecContext *avctx,
+                                       unsigned high_bit_depth)
+{
+    int cpu_flags = av_get_cpu_flags();
+
+    if (cpu_flags & AV_CPU_FLAG_RVI) {
+        if (high_bit_depth)
+            c->get_pixels = ff_get_pixels_16_rvi;
+        else
+            c->get_pixels = ff_get_pixels_8_rvi;
+    }
+
+#if HAVE_RVV
+    if ((cpu_flags & AV_CPU_FLAG_RVV_I32) && ff_get_rv_vlenb() >= 16) {
+        if (high_bit_depth)
+            c->get_pixels_unaligned = c->get_pixels = ff_get_pixels_16_rvv;
+        else
+            c->get_pixels_unaligned = c->get_pixels = ff_get_pixels_8_rvv;
+
+        c->diff_pixels_unaligned = c->diff_pixels = ff_diff_pixels_rvv;
+    }
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/pixblockdsp_rvi.S
@@ -0,0 +1,58 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_get_pixels_8_rvi
+.irp row, 0, 1, 2, 3, 4, 5, 6, 7
+        ld      t0,    (a1)
+        add     a1, a1, a2
+        sd      zero, ((\row * 16) + 0)(a0)
+        addi    t6, t6, -1
+        sd      zero, ((\row * 16) + 8)(a0)
+        srli    t1, t0, 8
+        sb      t0, ((\row * 16) + 0)(a0)
+        srli    t2, t0, 16
+        sb      t1, ((\row * 16) + 2)(a0)
+        srli    t3, t0, 24
+        sb      t2, ((\row * 16) + 4)(a0)
+        srli    t4, t0, 32
+        sb      t3, ((\row * 16) + 6)(a0)
+        srli    t1, t0, 40
+        sb      t4, ((\row * 16) + 8)(a0)
+        srli    t2, t0, 48
+        sb      t1, ((\row * 16) + 10)(a0)
+        srli    t3, t0, 56
+        sb      t2, ((\row * 16) + 12)(a0)
+        sb      t3, ((\row * 16) + 14)(a0)
+.endr
+        ret
+endfunc
+
+func ff_get_pixels_16_rvi
+.irp row, 0, 1, 2, 3, 4, 5, 6, 7
+        ld      t0, 0(a1)
+        ld      t1, 8(a1)
+        add     a1, a1, a2
+        sd      t0, ((\row * 16) + 0)(a0)
+        sd      t1, ((\row * 16) + 8)(a0)
+.endr
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/pixblockdsp_rvv.S
@@ -0,0 +1,59 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_get_pixels_8_rvv, zve32x
+        vsetivli     zero, 8, e8, mf2, ta, ma
+        vlsseg8e8.v  v16, (a1), a2
+        vwcvtu.x.x.v v8, v16
+        vwcvtu.x.x.v v9, v17
+        vwcvtu.x.x.v v10, v18
+        vwcvtu.x.x.v v11, v19
+        vwcvtu.x.x.v v12, v20
+        vwcvtu.x.x.v v13, v21
+        vwcvtu.x.x.v v14, v22
+        vwcvtu.x.x.v v15, v23
+        vsseg8e16.v  v8, (a0)
+        ret
+endfunc
+
+func ff_get_pixels_16_rvv, zve32x
+        vsetivli     zero, 8, e16, m1, ta, ma
+        vlsseg8e16.v v0, (a1), a2
+        vsseg8e16.v  v0, (a0)
+        ret
+endfunc
+
+func ff_diff_pixels_rvv, zve32x
+        vsetivli    zero, 8, e8, mf2, ta, ma
+        vlsseg8e8.v v16, (a1), a3
+        vlsseg8e8.v v24, (a2), a3
+        vwsubu.vv   v8, v16, v24
+        vwsubu.vv   v9, v17, v25
+        vwsubu.vv   v10, v18, v26
+        vwsubu.vv   v11, v19, v27
+        vwsubu.vv   v12, v20, v28
+        vwsubu.vv   v13, v21, v29
+        vwsubu.vv   v14, v22, v30
+        vwsubu.vv   v15, v23, v31
+        vsseg8e16.v v8, (a0)
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/vorbisdsp_init.c
@@ -0,0 +1,37 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/cpu.h"
+#include "libavcodec/vorbisdsp.h"
+
+void ff_vorbis_inverse_coupling_rvv(float *mag, float *ang,
+                                    ptrdiff_t blocksize);
+
+av_cold void ff_vorbisdsp_init_riscv(VorbisDSPContext *c)
+{
+#if HAVE_RVV
+    int flags = av_get_cpu_flags();
+
+    if (flags & AV_CPU_FLAG_RVV_I32)
+        c->vorbis_inverse_coupling = ff_vorbis_inverse_coupling_rvv;
+#endif
+}
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/riscv/vorbisdsp_rvv.S
@@ -0,0 +1,43 @@
+/*
+ * Copyright  2022 Rmi Denis-Courmont.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/riscv/asm.S"
+
+func ff_vorbis_inverse_coupling_rvv, zve32f
+        fmv.w.x   ft0, zero
+1:
+        vsetvli   t0, a2, e32, m1, ta, ma
+        vle32.v   v16, (a1)
+        sub       a2, a2, t0
+        vle32.v   v24, (a0)
+        vfmax.vf  v8, v16, ft0
+        vfmin.vf  v16, v16, ft0
+        vfsgnj.vv v8, v8, v24
+        vfsgnj.vv v16, v16, v24
+        vfsub.vv  v8, v24, v8
+        vfsub.vv  v24, v24, v16
+        vse32.v   v8, (a1)
+        sh2add    a1, t0, a1
+        vse32.v   v24, (a0)
+        sh2add    a0, t0, a0
+        bnez      a2, 1b
+
+        ret
+endfunc
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/speedhq.h
@@ -0,0 +1,35 @@
+/*
+ * NewTek SpeedHQ common header
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_SPEEDHQ_H
+#define AVCODEC_SPEEDHQ_H
+
+#include <stdint.h>
+#include "libavutil/attributes_internal.h"
+
+#define SPEEDHQ_RL_NB_ELEMS 121
+
+FF_VISIBILITY_PUSH_HIDDEN
+extern const uint8_t ff_speedhq_run[SPEEDHQ_RL_NB_ELEMS];
+extern const uint8_t ff_speedhq_level[SPEEDHQ_RL_NB_ELEMS];
+extern const uint16_t ff_speedhq_vlc_table[SPEEDHQ_RL_NB_ELEMS + 2][2];
+FF_VISIBILITY_POP_HIDDEN
+
+#endif /* AVCODEC_SPEEDHQ_H */
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/speedhqdec.c
@@ -0,0 +1,653 @@
+/*
+ * NewTek SpeedHQ codec
+ * Copyright 2017 Steinar H. Gunderson
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * NewTek SpeedHQ decoder.
+ */
+
+#define BITSTREAM_READER_LE
+
+#include "libavutil/attributes.h"
+#include "libavutil/mem_internal.h"
+
+#include "avcodec.h"
+#include "blockdsp.h"
+#include "codec_internal.h"
+#include "decode.h"
+#include "get_bits.h"
+#include "idctdsp.h"
+#include "libavutil/thread.h"
+#include "mathops.h"
+#include "mpeg12data.h"
+#include "mpeg12vlc.h"
+#include "speedhq.h"
+
+#define MAX_INDEX (64 - 1)
+
+/*
+ * 5 bits makes for very small tables, with no more than two lookups needed
+ * for the longest (10-bit) codes.
+ */
+#define ALPHA_VLC_BITS 5
+
+typedef struct SHQContext {
+    BlockDSPContext bdsp;
+    IDCTDSPContext idsp;
+    uint8_t permutated_intra_scantable[64];
+    int quant_matrix[64];
+    enum { SHQ_SUBSAMPLING_420, SHQ_SUBSAMPLING_422, SHQ_SUBSAMPLING_444 }
+        subsampling;
+    enum { SHQ_NO_ALPHA, SHQ_RLE_ALPHA, SHQ_DCT_ALPHA } alpha_type;
+} SHQContext;
+
+/* NOTE: The first element is always 16, unscaled. */
+static const uint8_t unscaled_quant_matrix[64] = {
+    16, 16, 19, 22, 26, 27, 29, 34,
+    16, 16, 22, 24, 27, 29, 34, 37,
+    19, 22, 26, 27, 29, 34, 34, 38,
+    22, 22, 26, 27, 29, 34, 37, 40,
+    22, 26, 27, 29, 32, 35, 40, 48,
+    26, 27, 29, 32, 35, 40, 48, 58,
+    26, 27, 29, 34, 38, 46, 56, 69,
+    27, 29, 35, 38, 46, 56, 69, 83
+};
+
+static VLC dc_lum_vlc_le;
+static VLC dc_chroma_vlc_le;
+static VLC dc_alpha_run_vlc_le;
+static VLC dc_alpha_level_vlc_le;
+
+static RL_VLC_ELEM speedhq_rl_vlc[674];
+
+static inline int decode_dc_le(GetBitContext *gb, int component)
+{
+    int code, diff;
+
+    if (component == 0 || component == 3) {
+        code = get_vlc2(gb, dc_lum_vlc_le.table, DC_VLC_BITS, 2);
+    } else {
+        code = get_vlc2(gb, dc_chroma_vlc_le.table, DC_VLC_BITS, 2);
+    }
+    if (!code) {
+        diff = 0;
+    } else {
+        diff = get_xbits_le(gb, code);
+    }
+    return diff;
+}
+
+static inline int decode_alpha_block(const SHQContext *s, GetBitContext *gb, uint8_t last_alpha[16], uint8_t *dest, int linesize)
+{
+    uint8_t block[128];
+    int i = 0, x, y;
+
+    memset(block, 0, sizeof(block));
+
+    {
+        OPEN_READER(re, gb);
+
+        for ( ;; ) {
+            int run, level;
+
+            UPDATE_CACHE_LE(re, gb);
+            GET_VLC(run, re, gb, dc_alpha_run_vlc_le.table, ALPHA_VLC_BITS, 2);
+
+            if (run < 0) break;
+            i += run;
+            if (i >= 128)
+                return AVERROR_INVALIDDATA;
+
+            UPDATE_CACHE_LE(re, gb);
+            GET_VLC(level, re, gb, dc_alpha_level_vlc_le.table, ALPHA_VLC_BITS, 2);
+            block[i++] = level;
+        }
+
+        CLOSE_READER(re, gb);
+    }
+
+    for (y = 0; y < 8; y++) {
+        for (x = 0; x < 16; x++) {
+            last_alpha[x] -= block[y * 16 + x];
+        }
+        memcpy(dest, last_alpha, 16);
+        dest += linesize;
+    }
+
+    return 0;
+}
+
+static inline int decode_dct_block(const SHQContext *s, GetBitContext *gb, int last_dc[4], int component, uint8_t *dest, int linesize)
+{
+    const int *quant_matrix = s->quant_matrix;
+    const uint8_t *scantable = s->permutated_intra_scantable;
+    LOCAL_ALIGNED_32(int16_t, block, [64]);
+    int dc_offset;
+
+    s->bdsp.clear_block(block);
+
+    dc_offset = decode_dc_le(gb, component);
+    last_dc[component] -= dc_offset;  /* Note: Opposite of most codecs. */
+    block[scantable[0]] = last_dc[component];  /* quant_matrix[0] is always 16. */
+
+    /* Read AC coefficients. */
+    {
+        int i = 0;
+        OPEN_READER(re, gb);
+        for ( ;; ) {
+            int level, run;
+            UPDATE_CACHE_LE(re, gb);
+            GET_RL_VLC(level, run, re, gb, speedhq_rl_vlc,
+                       TEX_VLC_BITS, 2, 0);
+            if (level == 127) {
+                break;
+            } else if (level) {
+                i += run;
+                if (i > MAX_INDEX)
+                    return AVERROR_INVALIDDATA;
+                /* If next bit is 1, level = -level */
+                level = (level ^ SHOW_SBITS(re, gb, 1)) -
+                        SHOW_SBITS(re, gb, 1);
+                LAST_SKIP_BITS(re, gb, 1);
+            } else {
+                /* Escape. */
+#if MIN_CACHE_BITS < 6 + 6 + 12
+#error MIN_CACHE_BITS is too small for the escape code, add UPDATE_CACHE
+#endif
+                run = SHOW_UBITS(re, gb, 6) + 1;
+                SKIP_BITS(re, gb, 6);
+                level = SHOW_UBITS(re, gb, 12) - 2048;
+                LAST_SKIP_BITS(re, gb, 12);
+
+                i += run;
+                if (i > MAX_INDEX)
+                    return AVERROR_INVALIDDATA;
+            }
+
+            block[scantable[i]] = (level * quant_matrix[i]) >> 4;
+        }
+        CLOSE_READER(re, gb);
+    }
+
+    s->idsp.idct_put(dest, linesize, block);
+
+    return 0;
+}
+
+static int decode_speedhq_border(const SHQContext *s, GetBitContext *gb, AVFrame *frame, int field_number, int line_stride)
+{
+    int linesize_y  = frame->linesize[0] * line_stride;
+    int linesize_cb = frame->linesize[1] * line_stride;
+    int linesize_cr = frame->linesize[2] * line_stride;
+    int linesize_a;
+    int ret;
+
+    if (s->alpha_type != SHQ_NO_ALPHA)
+        linesize_a = frame->linesize[3] * line_stride;
+
+    for (int y = 0; y < frame->height; y += 16 * line_stride) {
+        int last_dc[4] = { 1024, 1024, 1024, 1024 };
+        uint8_t *dest_y, *dest_cb, *dest_cr, *dest_a;
+        uint8_t last_alpha[16];
+        int x = frame->width - 8;
+
+        dest_y = frame->data[0] + frame->linesize[0] * (y + field_number) + x;
+        if (s->subsampling == SHQ_SUBSAMPLING_420) {
+            dest_cb = frame->data[1] + frame->linesize[1] * (y/2 + field_number) + x / 2;
+            dest_cr = frame->data[2] + frame->linesize[2] * (y/2 + field_number) + x / 2;
+        } else {
+            av_assert2(s->subsampling == SHQ_SUBSAMPLING_422);
+            dest_cb = frame->data[1] + frame->linesize[1] * (y + field_number) + x / 2;
+            dest_cr = frame->data[2] + frame->linesize[2] * (y + field_number) + x / 2;
+        }
+        if (s->alpha_type != SHQ_NO_ALPHA) {
+            memset(last_alpha, 255, sizeof(last_alpha));
+            dest_a = frame->data[3] + frame->linesize[3] * (y + field_number) + x;
+        }
+
+        if ((ret = decode_dct_block(s, gb, last_dc, 0, dest_y, linesize_y)) < 0)
+            return ret;
+        if ((ret = decode_dct_block(s, gb, last_dc, 0, dest_y + 8, linesize_y)) < 0)
+            return ret;
+        if ((ret = decode_dct_block(s, gb, last_dc, 0, dest_y + 8 * linesize_y, linesize_y)) < 0)
+            return ret;
+        if ((ret = decode_dct_block(s, gb, last_dc, 0, dest_y + 8 * linesize_y + 8, linesize_y)) < 0)
+            return ret;
+        if ((ret = decode_dct_block(s, gb, last_dc, 1, dest_cb, linesize_cb)) < 0)
+            return ret;
+        if ((ret = decode_dct_block(s, gb, last_dc, 2, dest_cr, linesize_cr)) < 0)
+            return ret;
+
+        if (s->subsampling != SHQ_SUBSAMPLING_420) {
+            if ((ret = decode_dct_block(s, gb, last_dc, 1, dest_cb + 8 * linesize_cb, linesize_cb)) < 0)
+                return ret;
+            if ((ret = decode_dct_block(s, gb, last_dc, 2, dest_cr + 8 * linesize_cr, linesize_cr)) < 0)
+                return ret;
+        }
+
+        if (s->alpha_type == SHQ_RLE_ALPHA) {
+            /* Alpha coded using 16x8 RLE blocks. */
+            if ((ret = decode_alpha_block(s, gb, last_alpha, dest_a, linesize_a)) < 0)
+                return ret;
+            if ((ret = decode_alpha_block(s, gb, last_alpha, dest_a + 8 * linesize_a, linesize_a)) < 0)
+                return ret;
+        } else if (s->alpha_type == SHQ_DCT_ALPHA) {
+            /* Alpha encoded exactly like luma. */
+            if ((ret = decode_dct_block(s, gb, last_dc, 3, dest_a, linesize_a)) < 0)
+                return ret;
+            if ((ret = decode_dct_block(s, gb, last_dc, 3, dest_a + 8, linesize_a)) < 0)
+                return ret;
+            if ((ret = decode_dct_block(s, gb, last_dc, 3, dest_a + 8 * linesize_a, linesize_a)) < 0)
+                return ret;
+            if ((ret = decode_dct_block(s, gb, last_dc, 3, dest_a + 8 * linesize_a + 8, linesize_a)) < 0)
+                return ret;
+        }
+    }
+
+    return 0;
+}
+
+static int decode_speedhq_field(const SHQContext *s, const uint8_t *buf, int buf_size, AVFrame *frame, int field_number, int start, int end, int line_stride)
+{
+    int ret, slice_number, slice_offsets[5];
+    int linesize_y  = frame->linesize[0] * line_stride;
+    int linesize_cb = frame->linesize[1] * line_stride;
+    int linesize_cr = frame->linesize[2] * line_stride;
+    int linesize_a;
+    GetBitContext gb;
+
+    if (s->alpha_type != SHQ_NO_ALPHA)
+        linesize_a = frame->linesize[3] * line_stride;
+
+    if (end < start || end - start < 3 || end > buf_size)
+        return AVERROR_INVALIDDATA;
+
+    slice_offsets[0] = start;
+    slice_offsets[4] = end;
+    for (slice_number = 1; slice_number < 4; slice_number++) {
+        uint32_t last_offset, slice_len;
+
+        last_offset = slice_offsets[slice_number - 1];
+        slice_len = AV_RL24(buf + last_offset);
+        slice_offsets[slice_number] = last_offset + slice_len;
+
+        if (slice_len < 3 || slice_offsets[slice_number] > end - 3)
+            return AVERROR_INVALIDDATA;
+    }
+
+    for (slice_number = 0; slice_number < 4; slice_number++) {
+        uint32_t slice_begin, slice_end;
+        int x, y;
+
+        slice_begin = slice_offsets[slice_number];
+        slice_end = slice_offsets[slice_number + 1];
+
+        if ((ret = init_get_bits8(&gb, buf + slice_begin + 3, slice_end - slice_begin - 3)) < 0)
+            return ret;
+
+        for (y = slice_number * 16 * line_stride; y < frame->height; y += line_stride * 64) {
+            uint8_t *dest_y, *dest_cb, *dest_cr, *dest_a;
+            int last_dc[4] = { 1024, 1024, 1024, 1024 };
+            uint8_t last_alpha[16];
+
+            memset(last_alpha, 255, sizeof(last_alpha));
+
+            dest_y = frame->data[0] + frame->linesize[0] * (y + field_number);
+            if (s->subsampling == SHQ_SUBSAMPLING_420) {
+                dest_cb = frame->data[1] + frame->linesize[1] * (y/2 + field_number);
+                dest_cr = frame->data[2] + frame->linesize[2] * (y/2 + field_number);
+            } else {
+                dest_cb = frame->data[1] + frame->linesize[1] * (y + field_number);
+                dest_cr = frame->data[2] + frame->linesize[2] * (y + field_number);
+            }
+            if (s->alpha_type != SHQ_NO_ALPHA) {
+                dest_a = frame->data[3] + frame->linesize[3] * (y + field_number);
+            }
+
+            for (x = 0; x < frame->width - 8 * (s->subsampling != SHQ_SUBSAMPLING_444); x += 16) {
+                /* Decode the four luma blocks. */
+                if ((ret = decode_dct_block(s, &gb, last_dc, 0, dest_y, linesize_y)) < 0)
+                    return ret;
+                if ((ret = decode_dct_block(s, &gb, last_dc, 0, dest_y + 8, linesize_y)) < 0)
+                    return ret;
+                if ((ret = decode_dct_block(s, &gb, last_dc, 0, dest_y + 8 * linesize_y, linesize_y)) < 0)
+                    return ret;
+                if ((ret = decode_dct_block(s, &gb, last_dc, 0, dest_y + 8 * linesize_y + 8, linesize_y)) < 0)
+                    return ret;
+
+                /*
+                 * Decode the first chroma block. For 4:2:0, this is the only one;
+                 * for 4:2:2, it's the top block; for 4:4:4, it's the top-left block.
+                 */
+                if ((ret = decode_dct_block(s, &gb, last_dc, 1, dest_cb, linesize_cb)) < 0)
+                    return ret;
+                if ((ret = decode_dct_block(s, &gb, last_dc, 2, dest_cr, linesize_cr)) < 0)
+                    return ret;
+
+                if (s->subsampling != SHQ_SUBSAMPLING_420) {
+                    /* For 4:2:2, this is the bottom block; for 4:4:4, it's the bottom-left block. */
+                    if ((ret = decode_dct_block(s, &gb, last_dc, 1, dest_cb + 8 * linesize_cb, linesize_cb)) < 0)
+                        return ret;
+                    if ((ret = decode_dct_block(s, &gb, last_dc, 2, dest_cr + 8 * linesize_cr, linesize_cr)) < 0)
+                        return ret;
+
+                    if (s->subsampling == SHQ_SUBSAMPLING_444) {
+                        /* Top-right and bottom-right blocks. */
+                        if ((ret = decode_dct_block(s, &gb, last_dc, 1, dest_cb + 8, linesize_cb)) < 0)
+                            return ret;
+                        if ((ret = decode_dct_block(s, &gb, last_dc, 2, dest_cr + 8, linesize_cr)) < 0)
+                            return ret;
+                        if ((ret = decode_dct_block(s, &gb, last_dc, 1, dest_cb + 8 * linesize_cb + 8, linesize_cb)) < 0)
+                            return ret;
+                        if ((ret = decode_dct_block(s, &gb, last_dc, 2, dest_cr + 8 * linesize_cr + 8, linesize_cr)) < 0)
+                            return ret;
+
+                        dest_cb += 8;
+                        dest_cr += 8;
+                    }
+                }
+                dest_y += 16;
+                dest_cb += 8;
+                dest_cr += 8;
+
+                if (s->alpha_type == SHQ_RLE_ALPHA) {
+                    /* Alpha coded using 16x8 RLE blocks. */
+                    if ((ret = decode_alpha_block(s, &gb, last_alpha, dest_a, linesize_a)) < 0)
+                        return ret;
+                    if ((ret = decode_alpha_block(s, &gb, last_alpha, dest_a + 8 * linesize_a, linesize_a)) < 0)
+                        return ret;
+                    dest_a += 16;
+                } else if (s->alpha_type == SHQ_DCT_ALPHA) {
+                    /* Alpha encoded exactly like luma. */
+                    if ((ret = decode_dct_block(s, &gb, last_dc, 3, dest_a, linesize_a)) < 0)
+                        return ret;
+                    if ((ret = decode_dct_block(s, &gb, last_dc, 3, dest_a + 8, linesize_a)) < 0)
+                        return ret;
+                    if ((ret = decode_dct_block(s, &gb, last_dc, 3, dest_a + 8 * linesize_a, linesize_a)) < 0)
+                        return ret;
+                    if ((ret = decode_dct_block(s, &gb, last_dc, 3, dest_a + 8 * linesize_a + 8, linesize_a)) < 0)
+                        return ret;
+                    dest_a += 16;
+                }
+            }
+        }
+    }
+
+    if (s->subsampling != SHQ_SUBSAMPLING_444 && (frame->width & 15))
+        return decode_speedhq_border(s, &gb, frame, field_number, line_stride);
+
+    return 0;
+}
+
+static void compute_quant_matrix(int *output, int qscale)
+{
+    int i;
+    for (i = 0; i < 64; i++) output[i] = unscaled_quant_matrix[ff_zigzag_direct[i]] * qscale;
+}
+
+static int speedhq_decode_frame(AVCodecContext *avctx, AVFrame *frame,
+                                int *got_frame, AVPacket *avpkt)
+{
+    SHQContext * const s = avctx->priv_data;
+    const uint8_t *buf   = avpkt->data;
+    int buf_size         = avpkt->size;
+    uint8_t quality;
+    uint32_t second_field_offset;
+    int ret;
+
+    if (buf_size < 4 || avctx->width < 8 || avctx->width % 8 != 0)
+        return AVERROR_INVALIDDATA;
+    if (buf_size < avctx->width*avctx->height / 64 / 4)
+        return AVERROR_INVALIDDATA;
+
+    quality = buf[0];
+    if (quality >= 100) {
+        return AVERROR_INVALIDDATA;
+    }
+
+    compute_quant_matrix(s->quant_matrix, 100 - quality);
+
+    second_field_offset = AV_RL24(buf + 1);
+    if (second_field_offset >= buf_size - 3) {
+        return AVERROR_INVALIDDATA;
+    }
+
+    avctx->coded_width = FFALIGN(avctx->width, 16);
+    avctx->coded_height = FFALIGN(avctx->height, 16);
+
+    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
+        return ret;
+    }
+    frame->key_frame = 1;
+
+    if (second_field_offset == 4 || second_field_offset == (buf_size-4)) {
+        /*
+         * Overlapping first and second fields is used to signal
+         * encoding only a single field. In this case, "height"
+         * is ambiguous; it could mean either the height of the
+         * frame as a whole, or of the field. The former would make
+         * more sense for compatibility with legacy decoders,
+         * but this matches the convention used in NDI, which is
+         * the primary user of this trick.
+         */
+        if ((ret = decode_speedhq_field(s, buf, buf_size, frame, 0, 4, buf_size, 1)) < 0)
+            return ret;
+    } else {
+        if ((ret = decode_speedhq_field(s, buf, buf_size, frame, 0, 4, second_field_offset, 2)) < 0)
+            return ret;
+        if ((ret = decode_speedhq_field(s, buf, buf_size, frame, 1, second_field_offset, buf_size, 2)) < 0)
+            return ret;
+    }
+
+    *got_frame = 1;
+    return buf_size;
+}
+
+/*
+ * Alpha VLC. Run and level are independently coded, and would be
+ * outside the default limits for MAX_RUN/MAX_LEVEL, so we don't
+ * bother with combining them into one table.
+ */
+static av_cold void compute_alpha_vlcs(void)
+{
+    uint16_t run_code[134], level_code[266];
+    uint8_t run_bits[134], level_bits[266];
+    int16_t run_symbols[134], level_symbols[266];
+    int entry, i, sign;
+
+    /* Initialize VLC for alpha run. */
+    entry = 0;
+
+    /* 0 -> 0. */
+    run_code[entry] = 0;
+    run_bits[entry] = 1;
+    run_symbols[entry] = 0;
+    ++entry;
+
+    /* 10xx -> xx plus 1. */
+    for (i = 0; i < 4; ++i) {
+        run_code[entry] = (i << 2) | 1;
+        run_bits[entry] = 4;
+        run_symbols[entry] = i + 1;
+        ++entry;
+    }
+
+    /* 111xxxxxxx -> xxxxxxx. */
+    for (i = 0; i < 128; ++i) {
+        run_code[entry] = (i << 3) | 7;
+        run_bits[entry] = 10;
+        run_symbols[entry] = i;
+        ++entry;
+    }
+
+    /* 110 -> EOB. */
+    run_code[entry] = 3;
+    run_bits[entry] = 3;
+    run_symbols[entry] = -1;
+    ++entry;
+
+    av_assert0(entry == FF_ARRAY_ELEMS(run_code));
+
+    INIT_LE_VLC_SPARSE_STATIC(&dc_alpha_run_vlc_le, ALPHA_VLC_BITS,
+                              FF_ARRAY_ELEMS(run_code),
+                              run_bits, 1, 1,
+                              run_code, 2, 2,
+                              run_symbols, 2, 2, 160);
+
+    /* Initialize VLC for alpha level. */
+    entry = 0;
+
+    for (sign = 0; sign <= 1; ++sign) {
+        /* 1s -> -1 or +1 (depending on sign bit). */
+        level_code[entry] = (sign << 1) | 1;
+        level_bits[entry] = 2;
+        level_symbols[entry] = sign ? -1 : 1;
+        ++entry;
+
+        /* 01sxx -> xx plus 2 (2..5 or -2..-5, depending on sign bit). */
+        for (i = 0; i < 4; ++i) {
+            level_code[entry] = (i << 3) | (sign << 2) | 2;
+            level_bits[entry] = 5;
+            level_symbols[entry] = sign ? -(i + 2) : (i + 2);
+            ++entry;
+        }
+    }
+
+    /*
+     * 00xxxxxxxx -> xxxxxxxx, in two's complement. There are many codes
+     * here that would better be encoded in other ways (e.g. 0 would be
+     * encoded by increasing run, and +/- 1 would be encoded with a
+     * shorter code), but it doesn't hurt to allow everything.
+     */
+    for (i = 0; i < 256; ++i) {
+        level_code[entry] = i << 2;
+        level_bits[entry] = 10;
+        level_symbols[entry] = i;
+        ++entry;
+    }
+
+    av_assert0(entry == FF_ARRAY_ELEMS(level_code));
+
+    INIT_LE_VLC_SPARSE_STATIC(&dc_alpha_level_vlc_le, ALPHA_VLC_BITS,
+                              FF_ARRAY_ELEMS(level_code),
+                              level_bits, 1, 1,
+                              level_code, 2, 2,
+                              level_symbols, 2, 2, 288);
+}
+
+static av_cold void speedhq_static_init(void)
+{
+    /* Exactly the same as MPEG-2, except for a little-endian reader. */
+    INIT_CUSTOM_VLC_STATIC(&dc_lum_vlc_le, DC_VLC_BITS, 12,
+                           ff_mpeg12_vlc_dc_lum_bits, 1, 1,
+                           ff_mpeg12_vlc_dc_lum_code, 2, 2,
+                           INIT_VLC_OUTPUT_LE, 512);
+    INIT_CUSTOM_VLC_STATIC(&dc_chroma_vlc_le, DC_VLC_BITS, 12,
+                           ff_mpeg12_vlc_dc_chroma_bits, 1, 1,
+                           ff_mpeg12_vlc_dc_chroma_code, 2, 2,
+                           INIT_VLC_OUTPUT_LE, 514);
+
+    ff_init_2d_vlc_rl(ff_speedhq_vlc_table, speedhq_rl_vlc, ff_speedhq_run,
+                      ff_speedhq_level, SPEEDHQ_RL_NB_ELEMS,
+                      FF_ARRAY_ELEMS(speedhq_rl_vlc), INIT_VLC_LE);
+
+    compute_alpha_vlcs();
+}
+
+static av_cold int speedhq_decode_init(AVCodecContext *avctx)
+{
+    int ret;
+    static AVOnce init_once = AV_ONCE_INIT;
+    SHQContext * const s = avctx->priv_data;
+
+    ret = ff_thread_once(&init_once, speedhq_static_init);
+    if (ret)
+        return AVERROR_UNKNOWN;
+
+    ff_blockdsp_init(&s->bdsp);
+    ff_idctdsp_init(&s->idsp, avctx);
+    ff_permute_scantable(s->permutated_intra_scantable, ff_zigzag_direct,
+                         s->idsp.idct_permutation);
+
+    switch (avctx->codec_tag) {
+    case MKTAG('S', 'H', 'Q', '0'):
+        s->subsampling = SHQ_SUBSAMPLING_420;
+        s->alpha_type = SHQ_NO_ALPHA;
+        avctx->pix_fmt = AV_PIX_FMT_YUV420P;
+        break;
+    case MKTAG('S', 'H', 'Q', '1'):
+        s->subsampling = SHQ_SUBSAMPLING_420;
+        s->alpha_type = SHQ_RLE_ALPHA;
+        avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
+        break;
+    case MKTAG('S', 'H', 'Q', '2'):
+        s->subsampling = SHQ_SUBSAMPLING_422;
+        s->alpha_type = SHQ_NO_ALPHA;
+        avctx->pix_fmt = AV_PIX_FMT_YUV422P;
+        break;
+    case MKTAG('S', 'H', 'Q', '3'):
+        s->subsampling = SHQ_SUBSAMPLING_422;
+        s->alpha_type = SHQ_RLE_ALPHA;
+        avctx->pix_fmt = AV_PIX_FMT_YUVA422P;
+        break;
+    case MKTAG('S', 'H', 'Q', '4'):
+        s->subsampling = SHQ_SUBSAMPLING_444;
+        s->alpha_type = SHQ_NO_ALPHA;
+        avctx->pix_fmt = AV_PIX_FMT_YUV444P;
+        break;
+    case MKTAG('S', 'H', 'Q', '5'):
+        s->subsampling = SHQ_SUBSAMPLING_444;
+        s->alpha_type = SHQ_RLE_ALPHA;
+        avctx->pix_fmt = AV_PIX_FMT_YUVA444P;
+        break;
+    case MKTAG('S', 'H', 'Q', '7'):
+        s->subsampling = SHQ_SUBSAMPLING_422;
+        s->alpha_type = SHQ_DCT_ALPHA;
+        avctx->pix_fmt = AV_PIX_FMT_YUVA422P;
+        break;
+    case MKTAG('S', 'H', 'Q', '9'):
+        s->subsampling = SHQ_SUBSAMPLING_444;
+        s->alpha_type = SHQ_DCT_ALPHA;
+        avctx->pix_fmt = AV_PIX_FMT_YUVA444P;
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "Unknown NewTek SpeedHQ FOURCC provided (%08X)\n",
+               avctx->codec_tag);
+        return AVERROR_INVALIDDATA;
+    }
+
+    /* This matches what NDI's RGB -> Y'CbCr 4:2:2 converter uses. */
+    avctx->colorspace = AVCOL_SPC_BT470BG;
+    avctx->chroma_sample_location = AVCHROMA_LOC_CENTER;
+
+    return 0;
+}
+
+const FFCodec ff_speedhq_decoder = {
+    .p.name         = "speedhq",
+    CODEC_LONG_NAME("NewTek SpeedHQ"),
+    .p.type         = AVMEDIA_TYPE_VIDEO,
+    .p.id           = AV_CODEC_ID_SPEEDHQ,
+    .priv_data_size = sizeof(SHQContext),
+    .init           = speedhq_decode_init,
+    FF_CODEC_DECODE_CB(speedhq_decode_frame),
+    .p.capabilities = AV_CODEC_CAP_DR1,
+};
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/svq1encdsp.h
@@ -0,0 +1,34 @@
+/*
+ * SVQ1 encoder DSP
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_SVQ1ENCDSP_H
+#define AVCODEC_SVQ1ENCDSP_H
+
+#include <stdint.h>
+
+typedef struct SVQ1EncDSPContext {
+    int (*ssd_int8_vs_int16)(const int8_t *pix1, const int16_t *pix2,
+                             intptr_t size);
+} SVQ1EncDSPContext;
+
+void ff_svq1enc_init_ppc(SVQ1EncDSPContext *c);
+void ff_svq1enc_init_x86(SVQ1EncDSPContext *c);
+
+#endif /* AVCODEC_SVQ1ENCDSP_H */
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/vorbis_data.h
@@ -0,0 +1,34 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VORBIS_DATA_H
+#define AVCODEC_VORBIS_DATA_H
+
+#include <stdint.h>
+
+#include "libavutil/channel_layout.h"
+
+extern const float ff_vorbis_floor1_inverse_db_table[256];
+extern const float * const ff_vorbis_vwin[8];
+extern const uint8_t ff_vorbis_channel_layout_offsets[8][8];
+#if FF_API_OLD_CHANNEL_LAYOUT
+extern const uint64_t ff_vorbis_channel_layouts[9];
+#endif
+extern const AVChannelLayout ff_vorbis_ch_layouts[9];
+
+#endif /* AVCODEC_VORBIS_DATA_H */
--- /dev/null
+++ b/third_party/ffmpeg/libavcodec/vqcdec.c
@@ -0,0 +1,430 @@
+/*
+ * ViewQuest VQC decoder
+ * Copyright (C) 2022 Peter Ross
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avcodec.h"
+#include "get_bits.h"
+#include "codec_internal.h"
+#include "decode.h"
+#include "libavutil/thread.h"
+
+#define VECTOR_VLC_BITS 6
+
+static const uint8_t vector_nbits[] = {
+    2, 4, 4, 4, 4, 2, 4, 4,
+    6, 6, 6, 6, 6, 6, 6, 6
+};
+
+enum {
+    SKIP_3 = 0x10,
+    SKIP_4,
+    SKIP_5,
+    SKIP_6,
+    STOP_RUN,
+    SIGNED_8BIT,
+    SIGNED_6BIT
+};
+
+/* vector symbols are signed, but returned unsigned by get_vlc2()
+   codebook indexes are cast as uint8_t in seed_codebook() to compensate */
+static const int8_t vector_symbols[] = {
+    0, SKIP_3, SKIP_4, SKIP_5, SKIP_6, STOP_RUN, 1, -1,
+    2, 3, 4, SIGNED_8BIT, -2, -3, -4, SIGNED_6BIT
+};
+
+static VLC vector_vlc;
+
+static av_cold void vqc_init_static_data(void)
+{
+    INIT_VLC_STATIC_FROM_LENGTHS(&vector_vlc, VECTOR_VLC_BITS, FF_ARRAY_ELEMS(vector_nbits),
+                             vector_nbits, 1,
+                             vector_symbols, 1, 1,
+                             0, 0, 1 << VECTOR_VLC_BITS);
+}
+
+typedef struct VqcContext {
+    AVFrame *frame;
+    uint8_t * vectors;
+    int16_t * coeff, *tmp1, *tmp2;
+    int16_t codebook[4][256];
+} VqcContext;
+
+static av_cold int vqc_decode_init(AVCodecContext * avctx)
+{
+    static AVOnce init_static_once = AV_ONCE_INIT;
+    VqcContext *s = avctx->priv_data;
+
+    s->vectors = av_malloc((avctx->width * avctx->height * 3) / 2);
+    if (!s->vectors)
+        return AVERROR(ENOMEM);
+
+    s->coeff = av_malloc_array(2 * avctx->width, sizeof(s->coeff[0]));
+    if (!s->coeff)
+        return AVERROR(ENOMEM);
+
+    s->tmp1 = av_malloc_array(avctx->width / 2, sizeof(s->tmp1[0]));
+    if (!s->tmp1)
+        return AVERROR(ENOMEM);
+
+    s->tmp2 = av_malloc_array(avctx->width / 2, sizeof(s->tmp2[0]));
+    if (!s->tmp2)
+        return AVERROR(ENOMEM);
+
+    avctx->pix_fmt = AV_PIX_FMT_YUV420P;
+    s->frame = av_frame_alloc();
+    if (!s->frame)
+        return AVERROR(ENOMEM);
+
+    ff_thread_once(&init_static_once, vqc_init_static_data);
+
+    return 0;
+}
+
+static int seed_pow1(int x)
+{
+    return x >= 1 && x <= 5 ? 1 << x : 0;
+}
+
+static int seed_pow2(int x)
+{
+    return x >= 1 && x <= 4 ? 1 << x : 1;
+}
+
+static int bias(int x, int c)
+{
+    if (x < 0)
+        return x - c;
+    else if (x > 0)
+        return x + c;
+    else
+        return 0;
+}
+
+static void seed_codebooks(VqcContext * s, const int * seed)
+{
+    int book1 = -256 * seed[3];
+    int book2 = -128 * seed[4];
+    int book3 = -128 * seed[5];
+    int book4 = -128 * seed[6];
+
+    for (int i = -128; i < 128; i++) {
+        s->codebook[0][(uint8_t)i] = book1;
+        s->codebook[1][(uint8_t)i] = bias(book2, seed[0]);
+        s->codebook[2][(uint8_t)i] = bias(book3, seed[1]);
+        s->codebook[3][(uint8_t)i] = bias(book4, seed[2]);
+
+        book1 += 2 * seed[3];
+        book2 += seed[4];
+        book3 += seed[5];
+        book4 += seed[6];
+    }
+}
+
+static void decode_vectors(VqcContext * s, const uint8_t * buf, int size, int width, int height)
+{
+    GetBitContext gb;
+    uint8_t * vectors = s->vectors;
+    uint8_t * vectors_end = s->vectors + (width * height * 3) / 2;
+
+    memset(vectors, 0, 3 * width * height / 2);
+
+    init_get_bits8(&gb, buf, size);
+
+    for (int i = 0; i < 3 * width * height / 2 / 32; i++) {
+        uint8_t * dst = vectors;
+        int symbol;
+
+        *dst++ = get_bits(&gb, 8);
+        *dst++ = get_bits(&gb, 8);
+
+        while (show_bits(&gb, 2) != 2) {
+
+            if (dst >= vectors_end - 1)
+                return;
+
+            if (!show_bits(&gb, 4)) {
+                *dst++ = 0;
+                *dst++ = 0;
+                skip_bits(&gb, 4);
+                continue;
+            }
+
+            symbol = get_vlc2(&gb, vector_vlc.table, VECTOR_VLC_BITS, 1);
+            switch(symbol) {
+            case SKIP_3: dst += 3; break;
+            case SKIP_4: dst += 4; break;
+            case SKIP_5: dst += 5; break;
+            case SKIP_6: dst += 6; break;
+            case SIGNED_8BIT: *dst++ = get_sbits(&gb, 8); break;
+            case SIGNED_6BIT: *dst++ = get_sbits(&gb, 6); break;
+            default:
+                *dst++ = symbol;
+            }
+        }
+
+        skip_bits(&gb, 2);
+        vectors += 32;
+    }
+}
+
+static void load_coeffs(VqcContext * s, const uint8_t * v, int width, int coeff_width)
+{
+    int16_t * c0     = s->coeff;
+    int16_t * c1     = s->coeff + coeff_width;
+    int16_t * c0_125 = s->coeff + (coeff_width >> 3);
+    int16_t * c1_125 = s->coeff + coeff_width + (coeff_width >> 3);
+    int16_t * c0_25  = s->coeff + (coeff_width >> 2);
+    int16_t * c1_25 =  s->coeff + coeff_width + (coeff_width >> 2);
+    int16_t * c0_5  =  s->coeff + (coeff_width >> 1);
+    int16_t * c1_5  =  s->coeff + coeff_width + (coeff_width >> 1);
+
+    for (int i = 0; i < width; i++) {
+        c0[0] = s->codebook[0][v[0]];
+        c0[1] = s->codebook[0][v[1]];
+        c0 += 2;
+
+        c1[0] = s->codebook[0][v[2]];
+        c1[1] = s->codebook[0][v[3]];
+        c1 += 2;
+
+        c0_125[0] = s->codebook[1][v[4]];
+        c0_125[1] = s->codebook[1][v[5]];
+        c0_125 += 2;
+
+        c1_125[0] = s->codebook[1][v[6]];
+        c1_125[1] = s->codebook[1][v[7]];
+        c1_125 += 2;
+
+        c0_25[0] = s->codebook[2][v[8]];
+        c0_25[1] = s->codebook[2][v[9]];
+        c0_25[2] = s->codebook[2][v[10]];
+        c0_25[3] = s->codebook[2][v[11]];
+        c0_25 += 4;
+
+        c1_25[0] = s->codebook[2][v[12]];
+        c1_25[1] = s->codebook[2][v[13]];
+        c1_25[2] = s->codebook[2][v[14]];
+        c1_25[3] = s->codebook[2][v[15]];
+        c1_25 += 4;
+
+        if (v[16] | v[17] | v[18] | v[19]) {
+            c0_5[0] = s->codebook[3][v[16]];
+            c0_5[1] = s->codebook[3][v[17]];
+            c0_5[2] = s->codebook[3][v[18]];
+            c0_5[3] = s->codebook[3][v[19]];
+        } else {
+            c0_5[0] = c0_5[1] = c0_5[2] = c0_5[3] = 0;
+        }
+
+        if (v[20] | v[21] | v[22] | v[23]) {
+            c0_5[4] = s->codebook[3][v[20]];
+            c0_5[5] = s->codebook[3][v[21]];
+            c0_5[6] = s->codebook[3][v[22]];
+            c0_5[7] = s->codebook[3][v[23]];
+        } else {
+            c0_5[4] = c0_5[5] = c0_5[6] = c0_5[7] = 0;
+        }
+        c0_5 += 8;
+
+        if (v[24] | v[25] | v[26] | v[27]) {
+            c1_5[0] = s->codebook[3][v[24]];
+            c1_5[1] = s->codebook[3][v[25]];
+            c1_5[2] = s->codebook[3][v[26]];
+            c1_5[3] = s->codebook[3][v[27]];
+        } else {
+            c1_5[0] = c1_5[1] = c1_5[2] = c1_5[3] = 0;
+        }
+
+        if (v[28] | v[29] | v[30] | v[31]) {
+            c1_5[4] = s->codebook[3][v[28]];
+            c1_5[5] = s->codebook[3][v[29]];
+            c1_5[6] = s->codebook[3][v[30]];
+            c1_5[7] = s->codebook[3][v[31]];
+        } else {
+            c1_5[4] = c1_5[5] = c1_5[6] = c1_5[7] = 0;
+        }
+        c1_5 += 8;
+
+        v += 32;
+    }
+}
+
+static void transform1(const int16_t * a, const int16_t * b, int16_t * dst, int width)
+{
+    int s0 = a[0] + (b[0] >> 1);
+
+    for (int i = 0; i < width / 2 - 1; i++) {
+        dst[i * 2] = s0;
+        s0 = a[i + 1] + ((b[i] + b[i + 1]) >> 1);
+        dst[i * 2 + 1] = ((dst[i * 2] + s0) >> 1) - 2 * b[i];
+    }
+
+    dst[width - 2] = s0;
+    dst[width - 1] = a[width / 2 - 1] + ((b[width / 2 - 2] - 2 * b[width / 2 - 1]) >> 2) - b[width / 2 - 1];
+}
+
+static uint8_t clip(int x)
+{
+    return x >= -128 ? x <= 127 ? x + 0x80 : 0x00 : 0xFF;
+}
+
+static void transform2(const int16_t * a, const int16_t * b, uint8_t * dst, int width)
+{
+    int s0 = a[0] + (b[0] >> 1);
+    int tmp;
+
+    for (int i = 0; i < width / 2 - 1; i++) {
+        dst[i * 2] = av_clip_uint8(s0 + 0x80);
+        tmp = a[i + 1] + ((b[i] + b[i + 1]) >> 1);
+        dst[i * 2 + 1] = av_clip_uint8(((tmp + s0) >> 1) - 2 * b[i] + 0x80);
+        s0 = tmp;
+    }
+
+    dst[width - 2] = clip(s0);
+    dst[width - 1] = clip(a[width / 2 - 1] + ((b[width / 2 - 2] - 2 * b[width / 2 - 1]) >> 2) - b[width / 2 - 1]);
+}
+
+static void decode_strip(VqcContext * s, uint8_t * dst, int stride, int width)
+{
+    const int16_t * coeff;
+
+    for (int i = 0; i < width; i++) {
+        int v0 = s->coeff[i];
+        int v1 = s->coeff[width + i];
+        s->coeff[i] = v0 - v1;
+        s->coeff[width + i] = v0 + v1;
+    }
+
+    coeff = s->coeff;
+
+    transform1(coeff, coeff + width / 8, s->tmp1, width / 4);
+    transform1(s->tmp1, coeff + width / 4, s->tmp2, width / 2);
+    transform2(s->tmp2, coeff + width / 2, dst, width);
+
+    coeff += width;
+    dst += stride;
+
+    transform1(coeff, coeff + width / 8, s->tmp1, width / 4);
+    transform1(s->tmp1, coeff + width / 4, s->tmp2, width / 2);
+    transform2(s->tmp2, coeff + width / 2, dst, width);
+}
+
+static void decode_frame(VqcContext * s, int width, int height)
+{
+    uint8_t * vectors = s->vectors;
+    uint8_t * y = s->frame->data[0];
+    uint8_t * u = s->frame->data[1];
+    uint8_t * v = s->frame->data[2];
+
+    for (int j = 0; j < height / 4; j++) {
+        load_coeffs(s, vectors, width / 16, width);
+        decode_strip(s, y, s->frame->linesize[0], width);
+        vectors += 2 * width;
+        y += 2 * s->frame->linesize[0];
+
+        load_coeffs(s, vectors, width / 32, width / 2);
+        decode_strip(s, u, s->frame->linesize[1], width / 2);
+        vectors += width;
+        u += 2 * s->frame->linesize[1];
+
+        load_coeffs(s, vectors, width / 16, width);
+        decode_strip(s, y, s->frame->linesize[0], width);
+        vectors += 2 * width;
+        y += 2 * s->frame->linesize[0];
+
+        load_coeffs(s, vectors, width / 32, width / 2);
+        decode_strip(s, v, s->frame->linesize[2], width / 2);
+        vectors += width;
+        v += 2 * s->frame->linesize[2];
+    }
+}
+
+static int vqc_decode_frame(AVCodecContext *avctx, AVFrame * rframe,
+                            int * got_frame, AVPacket * avpkt)
+{
+    VqcContext *s = avctx->priv_data;
+    int ret;
+    const uint8_t * buf = avpkt->data;
+    int cache, seed[7], gamma, contrast;
+
+    if (avpkt->size < 7)
+        return AVERROR_INVALIDDATA;
+
+    if ((ret = ff_reget_buffer(avctx, s->frame, 0)) < 0)
+        return ret;
+
+    av_log(avctx, AV_LOG_DEBUG, "VQC%d format\n", (buf[2] & 1) + 1);
+
+    if (((buf[0] >> 1) & 7) != 5) {
+        avpriv_request_sample(avctx, "subversion != 5\n");
+        return AVERROR_PATCHWELCOME;
+    }
+
+    cache = AV_RL24(buf + 4);
+    seed[2] = seed_pow1((cache >> 1) & 7);
+    seed[1] = seed_pow1((cache >> 4) & 7);
+    seed[0] = seed_pow1((cache >> 7) & 7);
+    seed[6] = seed_pow2((cache >> 10) & 7);
+    seed[5] = seed_pow2((cache >> 13) & 7);
+    seed[4] = seed_pow2((cache >> 16) & 7);
+    seed[3] = seed_pow2((cache >> 19) & 7);
+
+    gamma = buf[0] >> 4;
+    contrast = AV_RL16(buf + 2) >> 1;
+    if (gamma || contrast)
+        avpriv_request_sample(avctx, "gamma=0x%x, contrast=0x%x\n", gamma, contrast);
+
+    seed_codebooks(s, seed);
+    decode_vectors(s, buf + 7, avpkt->size - 7, avctx->width, avctx->height);
+    decode_frame(s, avctx->width, avctx->height);
+
+    if ((ret = av_frame_ref(rframe, s->frame)) < 0)
+        return ret;
+
+    *got_frame = 1;
+
+    return avpkt->size;
+}
+
+static av_cold int vqc_decode_end(AVCodecContext * avctx)
+{
+    VqcContext *s = avctx->priv_data;
+
+    av_freep(&s->vectors);
+    av_freep(&s->coeff);
+    av_freep(&s->tmp1);
+    av_freep(&s->tmp2);
+    av_frame_free(&s->frame);
+
+    return 0;
+}
+
+const FFCodec ff_vqc_decoder = {
+    .p.name         = "vqc",
+    CODEC_LONG_NAME("ViewQuest VQC"),
+    .p.type         = AVMEDIA_TYPE_VIDEO,
+    .p.id           = AV_CODEC_ID_VQC,
+    .priv_data_size = sizeof(VqcContext),
+    .init           = vqc_decode_init,
+    .close          = vqc_decode_end,
+    FF_CODEC_DECODE_CB(vqc_decode_frame),
+    .p.capabilities = AV_CODEC_CAP_DR1,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+};
